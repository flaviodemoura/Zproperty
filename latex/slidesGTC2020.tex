\documentclass[10pt]{beamer}

% \usetheme[progressbar=frametitle]{metropolis}

% \usepackage{booktabs}
% \usepackage[scale=2]{ccicons}

% \usepackage{pgfplots}
% \usepgfplotslibrary{dateplot}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage[color]{coqdoc}
\usepackage[all]{xy}
\usepackage{pdfsync}

\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}
\newcommand{\term}{{\mathcal{T}}}
\newcommand{\fv}[1]{{\tt fv}(#1)}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\db}[1]{{\bf \underline{#1}}}
\newcommand{\tto}{\twoheadrightarrow}

\title{Extending the Locally Nameless Representation with an Explicit Substitution Operator}
\date{\today}
\author{Flávio L. C. de Moura and Leandro Oliveira Rezende}
\institute{Seminário GTC/UnB}
\titlegraphic{\hfill\includegraphics[height=1.5cm]{unb-logo.png}}

\begin{document}

\maketitle

\begin{frame}[fragile]{Confluence of ARS}
    \begin{itemize}
    \item An Abstract Rewriting System (ARS) is a pair $(A,R)$ where
      $A$ is a set and $R$ is a binary relation over $A$.
  \end{itemize}
    \[
      \xymatrix{
        & \bullet \ar@{->>}[dl] \ar@{->>}[dr] & \\
        \bullet \ar@{.>>}[dr] &  & \bullet \ar@{.>>}[dl] \\
        & \bullet & }
    \]
\end{frame}

\begin{frame}[fragile]{The Z Property implies Confluence}
  \begin{itemize}
  \item  {\bf Z Property}: Let $(A,\to)$ be an ARS. If $a\to b$ then there exists a mapping $f:A \to A$ such that the following diagram holds:
    \[
      \xymatrix{
        a \ar[r] &  b \ar@{->>}[dl]\\
        f(a) \ar@{->>}[r] & f(b) \\ 
      }
    \]
    \item Z-property implies confluence~\cite{ZPropertyDraft}: We showed the formalization of this result in the previous GTC seminar.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Weak Z Property}
  \begin{definition}
  Let $(A,\to)$ be an ARS and $\to_x$ another relation on $A$. A
  mapping $f$ satisfies the {\it weak Z property} for $\to$ by $\to_x$
  if $a\to b$ implies $b \tto_x f(a)$ and $f(a) \tto_x
  f(b)$. % Therefore, a mapping $f$ satisfies the Z property for $\to$,
  % if it satisfies the weak Z property by itself. When $f$ satisfies
  % the (weak) Z property, we also say that $f$ is (weakly) Z.
    \[
      \xymatrix{
        a \ar[r] &  b \ar@{->>}[dl]^x\\
        f(a) \ar@{->>}[r]_x & f(b) \\ 
      }
    \]

\end{definition}
\end{frame}

\begin{frame}[fragile]{Compositional Z Property}
  \begin{definition}\label{def:zcomp}
  Let $(A,\to)$ be an ARS such that $\to = \to_1 \cup \to_2$. If there exists mappings $f_1,f_2: A \to A$ such that: \\[.05in]
  \begin{tabular}{ll}
  {\color{blue} 1.} $f_1$ is Z for $\to_1$ & {\color{blue} 2.} $a \to_1 b$ implies $f_2(a) \tto f_2(b)$ \\[.05in]
  {\color{blue} 3.} $a \tto f_2(a)$, for any $a\in Im(f_1)$ & {\color{blue} 4.} $f_2 \circ f_1$ is weakly Z for $\to_2$ by $\to$ \\[.05in]
  \end{tabular}
  then $f_2 \circ f_1$ is Z for $(A,\to)$, and hence $(A,\to)$
  is confluent.
  \begin{tabular}{l@{\hskip 1cm}l}
  \xymatrix{
    a \ar@{->}[rr]^1 && b \ar@{.>>}[dll]_1\\
    f_1(a)\ar@{.>>}[d] \ar@{.>>}[rr]^1 && f_1(b) \\
    f_2(f_1(a)) \ar@{.>>}[rr] && f_2(f_1(b))
                                 } &
                                     \xymatrix{
    a \ar@{->}[rr]^2 && b \ar@{.>>}[ddll]\\
                     & & \\
    f_2(f_1(a)) \ar@{.>>}[rr] && f_2(f_1(b))
                                 }   
\end{tabular}
\end{definition}
  \begin{itemize}
  \item Compositional Z implies Confluence~\cite{Nakazawa-Fujita2016}
    \begin{itemize}
    \item We formalized this result in Coq ({\color{blue} Coq session}).
      % Leandro, minha sugestão é que você explique esta prova em uma
      % sessão de Coq. Como a prova é relativamente simples, acredito
      % que possa ser interessante para a plateia.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{The $\lambda$-calculus (with Explicit Substitutions)}
   \begin{itemize}
  \item Starting point: $\lambda$-calculus
    $$\term ::= x \mid \lambda x.\term \mid \term\term $$
    $$(\lambda x.t)\ u \to_\beta t\{x/u\}$$
    \pause
    \item Extending the $\lambda$-calculus with an explicit substitution operator: {\color{red} calculi with explicit substitutions} 
    $$\term ::= x \mid \lambda x.\term \mid \term\term\; {\color{red} \mid \term[x/\term]}$$ \pause
    $$\begin{array}{llll}
        (\lambda x.t)\ u &  \to &  {\color{red} t[x/u]} & \\ \pause
        {\color{red} x[x/u]} & {\color{red}\to} & {\color{red}u} & \\
        {\color{red} y[x/u]} & {\color{red}\to} & {\color{red}y} & {\color{red} x\neq y} \\
        {\color{red}(\lambda y.t')[x/u]} &  {\color{red} \to} &  {\color{red} \lambda y. t'[x/u]} & {\color{red} x\neq y} \\
        {\color{red} (t'\ t'')[x/u]} & {\color{red}\to} & {\color{red} t'[x/u]\ t''[x/u]} & \\
      \end{array}$$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{The Formalization in Coq}

    \begin{itemize}
    \item Bound variables are De Bruijn indexes, and
    \item Free variables are named variables.
      \begin{itemize}
      \item This framework was built in Coq for $\lambda$-calculi
        without explicit substitutions by Charguéraud~\cite{Ch11}.
      \end{itemize}
    \end{itemize}

  \begin{coqdoccode}
    \coqdocnoindent \coqdockw{Inductive} \coqdocvar{pterm} :
    \coqdockw{Set} :=\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_bvar} : \coqdocvar{nat} \ensuremath{\rightarrow}
    \coqdocvar{pterm}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_fvar} : \coqdocvar{var} \ensuremath{\rightarrow}
    \coqdocvar{pterm}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_app} : \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{pterm\_abs} :
    \coqdocvar{pterm} \ensuremath{\rightarrow}
    \coqdocvar{pterm}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_sub} : \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}.\coqdoceol
  \end{coqdoccode}

  \begin{itemize}
  \item The expressions generated by this grammar are called pre-terms.
  \item But just a proper subset of the pre-terms are important: terms.
  \item We formalized three different notions of terms (with an
    explicit substitution operator) and their equivalence.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The notion of terms}

  \begin{coqdoccode}
    \coqdocemptyline \coqdocnoindent \coqdockw{Inductive}
    \coqdocvar{term} : \coqdocvar{pterm} \ensuremath{\rightarrow}
    \coqdockw{Prop} :=\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{term\_var} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{x}, \coqdocvar{term} (\coqdocvar{pterm\_fvar}
    \coqdocvar{x})\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{term\_app} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{t1} \coqdocvar{t2},\coqdocvar{term} \coqdocvar{t1}
    \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{t2}
    \ensuremath{\rightarrow} \coqdoceol \coqdocindent{9.00em}
    \coqdocvar{term} (\coqdocvar{pterm\_app} \coqdocvar{t1}
    \coqdocvar{t2})\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{term\_abs} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{L} \coqdocvar{t1},(\coqdockw{\ensuremath{\forall}}
    \coqdocvar{x}, \coqdocvar{x} $\backslash$\coqdocvar{notin}
    \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{term}
    (\coqdocvar{t1} \^{} \coqdocvar{x}))
    \ensuremath{\rightarrow}\coqdoceol \coqdocindent{18.00em}
    \coqdocvar{term} (\coqdocvar{pterm\_abs} \coqdocvar{t1})\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{term\_sub} :
    \coqdockw{\ensuremath{\forall}} \coqdocvar{L} \coqdocvar{t1}
    \coqdocvar{t2}, (\coqdockw{\ensuremath{\forall}} \coqdocvar{x},
    \coqdocvar{x} $\backslash$\coqdocvar{notin} \coqdocvar{L}
    \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{t1} \^{}
    \coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
    \coqdocindent{12.00em} \coqdocvar{term} \coqdocvar{t2}
    \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{pterm\_sub}
    \coqdocvar{t1} \coqdocvar{t2}).\coqdoceol
  \end{coqdoccode}

  \begin{itemize}
  \item where (\coqdocvar{t1} \^{} \coqdocvar{x}) is obtained from
    \coqdocvar{t1} by replacing all its occurrences of the index 0 for
    \coqdocvar{x}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Alternative notion of term}
  \begin{itemize}
  \item The local closure of an expression indicates the value of the
    indices that may appear in it.
  \end{itemize}
  \begin{coqdoccode}
    \coqdockw{Fixpoint} \coqdocvar{lc\_at}
    (\coqdocvar{k}:\coqdocvar{nat}) (\coqdocvar{t}:\coqdocvar{pterm})
    : \coqdockw{Prop} :=\coqdoceol \coqdocindent{1.00em}
    \coqdockw{match} \coqdocvar{t} \coqdockw{with}\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{pterm\_bvar}
    \coqdocvar{i} \ensuremath{\Rightarrow} \coqdocvar{i}  \ensuremath{<}
    \coqdocvar{k}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_fvar} \coqdocvar{x} \ensuremath{\Rightarrow}
    \coqdocvar{True}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_app} \coqdocvar{t1} \coqdocvar{t2}
    \ensuremath{\Rightarrow} \coqdocvar{lc\_at} \coqdocvar{k}
    \coqdocvar{t1} \ensuremath{\land} \coqdocvar{lc\_at} \coqdocvar{k}
    \coqdocvar{t2}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_abs} \coqdocvar{t1} \ensuremath{\Rightarrow}
    \coqdocvar{lc\_at} (\coqdocvar{S} \coqdocvar{k})
    \coqdocvar{t1}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_sub} \coqdocvar{t1} \coqdocvar{t2}
    \ensuremath{\Rightarrow} (\coqdocvar{lc\_at} (\coqdocvar{S}
    \coqdocvar{k}) \coqdocvar{t1}) \ensuremath{\land}
    \coqdocvar{lc\_at} \coqdocvar{k} \coqdocvar{t2}\coqdoceol
    \coqdocindent{1.00em} \coqdockw{end}.\coqdoceol
  \end{coqdoccode}

  \begin{coqdoccode}
  \coqdockw{Theorem} \coqdocvar{term\_equiv\_lc\_at}:
  \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvar{term}
  \coqdocvar{t} \ensuremath{\leftrightarrow} \coqdocvar{lc\_at} 0
  \coqdocvar{t}.\coqdoceol
\end{coqdoccode}
% Aqui tem muita coisa interessante para mostrar, mas precisa
% selecionar bem por conta do tempo.
\end{frame}

\begin{frame}[fragile]{Another alternative notion of term}

  \begin{coqdoccode}
    \coqdockw{Inductive} \coqdocvar{lc}: \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdockw{Prop} :=\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{lc\_var}:
    \coqdockw{\ensuremath{\forall}} \coqdocvar{x}, \coqdocvar{lc}
    (\coqdocvar{pterm\_fvar} \coqdocvar{x})\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{lc\_app}:
    \coqdockw{\ensuremath{\forall}} \coqdocvar{t1} \coqdocvar{t2},
    \coqdocvar{lc} \coqdocvar{t1} \ensuremath{\rightarrow}
    \coqdocvar{lc} \coqdocvar{t2} \ensuremath{\rightarrow}
    \coqdocvar{lc} (\coqdocvar{pterm\_app} \coqdocvar{t1}
    \coqdocvar{t2})\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{lc\_abs}: \coqdockw{\ensuremath{\forall}}
    \coqdocvar{t1} \coqdocvar{L}, (\coqdockw{\ensuremath{\forall}}
    \coqdocvar{x}, \coqdocvar{x} \symbol{92}\coqdocvar{notin}
    \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{lc}
    (\coqdocvar{t1}\^{}\coqdocvar{x})) \ensuremath{\rightarrow}
    \coqdocvar{lc} (\coqdocvar{pterm\_abs} \coqdocvar{t1})\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{lc\_sub}:
    \coqdockw{\ensuremath{\forall}} \coqdocvar{t1} \coqdocvar{t2}
    \coqdocvar{L}, (\coqdockw{\ensuremath{\forall}} \coqdocvar{x},
    \coqdocvar{x} \symbol{92}\coqdocvar{notin} \coqdocvar{L}
    \ensuremath{\rightarrow} \coqdocvar{lc}
    (\coqdocvar{t1}\^{}\coqdocvar{x})) \ensuremath{\rightarrow}
    \coqdocvar{lc} \coqdocvar{t2} \ensuremath{\rightarrow} \coqdoceol
    \coqdocindent{5.00em} \coqdocvar{lc} (\coqdocvar{pterm\_sub} \coqdocvar{t1}
    \coqdocvar{t2}).\coqdoceol
  \end{coqdoccode}\vspace{1cm}

  \begin{coqdoccode}
    \coqdockw{Lemma} \coqdocvar{lc\_equiv\_lc\_at}:
    \coqdockw{\ensuremath{\forall}} \coqdocvar{t}, \coqdocvar{lc}
    \coqdocvar{t} \ensuremath{\leftrightarrow} \coqdocvar{lc\_at} 0
    \coqdocvar{t}.\coqdoceol
  \end{coqdoccode}
  % Leandro, aqui também temos várias coisas interessantes para falar,
  % mas precisamos selecionar alguns pontos interessantes viáveis no
  % tempo disponível. Vou deixar para você pensar nisto e me dar um
  % retorno por email amanhã ou no sábado, ok?
\end{frame}

\begin{frame}[fragile]{Future work}
  \begin{itemize}
  \item Complete the proof that the formalized calculus satisfies the
    Z property.
  \item Merge this formalization with the one that has the other properties (PSN and one-step $\beta$-simulation).
  \item Extract the code of the corresponding calculus with explicit substitutions.
  \end{itemize}
\end{frame}

% Leandro, acredito que não vai dar tempo nem mesmo de citar o lex. Eu
% deixaria de fora.
% \begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
%   $$\term ::= x \mid \lambda x.\term \mid \term\term \mid \term[x/\term]$$

%   $$\begin{array}{llll}
%       t[x/u][y/v] & =_C & t[y/v][x/u], & \mbox{ if } y \notin\fv{u} \mbox{ and } x \notin \fv{v} \\[.3cm]
%       (\lambda x. t)\ u & \to_{\tt B} & t[x/u] & \\      
%       x[x/u] & \to_{\tt Var} & u & \\      
%       t[x/u] & \to_{\tt Gc} & t, & \mbox{ if } x \notin\fv{t} \\      
%       (t\ v)[x/u] & \to_{\tt App} & t[x/u]\ v[x/u] & \\
%       (\lambda y. t)[x/u] & \to_{\tt Lamb} & \lambda y.t[x/u] & \\
%       t[x/u][y/v] & \to_{\tt Comp} & t[y/v][x/u[y/v]], & \mbox{ if } y \in\fv{u} \\            
%       \end{array}$$
% \end{frame}

\bibliographystyle{alpha}
\bibliography{references}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
