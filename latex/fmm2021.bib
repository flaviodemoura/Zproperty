@book{10.5555/1717258,
  title = {Lambda-Calculus, Combinators and Functional Programming},
  author = {Revesz, G. E.},
  year = {2009},
  edition = {1st},
  publisher = {Cambridge University Press},
  address = {USA},
  abstract = {Originally published in 1988, this book presents an introduction to lambda-calculus and combinators without getting lost in the details of mathematical aspects of their theory. Lambda-calculus is treated here as a functional language and its relevance to computer science is clearly demonstrated. The main purpose of the book is to provide computer science students and researchers with a firm background in lambda-calculus and combinators and show the applicabillity of these theories to functional programming. The presentation of the material is self-contained. It can be used as a primary text for a course on functional programming. It can also be used as a supplementary text for courses on the structure and implementation of programming languages, theory of computing, or semantics of programming languages.},
  isbn = {0-521-11429-2},
  file = {/home/flaviomoura/Zotero/storage/H8ANJ85X/Revesz - 2009 - Lambda-calculus, combinators and functional progra.pdf}
}

@book{10.5555/7517,
  title = {Introduction to Higher Order Categorical Logic},
  author = {Lambek, J. and Scott, P. J.},
  year = {1986},
  publisher = {Cambridge University Press},
  address = {USA},
  isbn = {0-521-24665-2},
  file = {/home/flaviomoura/Zotero/storage/ZZ33AA7B/Lambek e Scott - 1986 - Introduction to higher order categorical logic.pdf}
}

@book{15thAnnualIEEE2000,
  title = {15th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{Santa Barbara}}, {{California}}, {{USA}}, {{June}} 26-29, 2000},
  year = {2000},
  publisher = {IEEE Computer Society},
  isbn = {0-7695-0725-5}
}

@misc{2021LICSAccattoli,
  title = {2021 - {{LICS}} - {{Accattoli}}, {{Condoluci}}, {{Sacerdoti Coen}} - {{Strong Call-by-Value}} Is {{Reasonable}}, {{Implosively}}.Pdf},
  journal = {Google Docs},
  urldate = {2021-06-10},
  howpublished = {https://drive.google.com/file/d/1IMPe6LO1dVZhLxSTW96aARy3PHbHWxYC/view?usp=sharing\&usp=embed\_facebook},
  file = {/home/flaviomoura/Zotero/storage/5C8FA8EV/view.html}
}

@article{abadiExplicitSubstitutions1991,
  title = {Explicit {{Substitutions}}},
  author = {Abadi, M. and Cardelli, L. and Curien, P.-L. and L{\'e}vy, J.-J.},
  year = {1991},
  journal = {Journal of Functional Programming},
  volume = {1},
  number = {4},
  pages = {375--416},
  doi = {10.1017/S0956796800000186},
  file = {/home/flaviomoura/Zotero/storage/IJC7WG6W/abadiExplicitSubstitutions1991.pdf;/home/flaviomoura/Zotero/storage/YVC8QPUU/Abadi et al. - 1991 - Explicit substitutions.pdf}
}

@article{abadiSmartChoicesSelection2020,
  ids = {abadiSmartChoicesSelection2021},
  title = {Smart {{Choices}} and the {{Selection Monad}}},
  author = {Abadi, Martin and Plotkin, Gordon},
  year = {2020},
  month = jul,
  journal = {arXiv:2007.08926 [cs]},
  eprint = {2007.08926},
  primaryclass = {cs},
  urldate = {2020-07-20},
  abstract = {Describing systems in terms of choices and of the resulting costs and rewards offers the promise of freeing algorithm designers and programmers from specifying how those choices should be made; in implementations, the choices can be realized by optimization techniques and, increasingly, by machine learning methods. We study this approach from a programming-language perspective. We define two small languages that support decision-making abstractions: one with choices and rewards, and the other additionally with probabilities. We give both operational and denotational semantics. The operational semantics combine the usual semantics of standard constructs with optimization over a space of possible executions. The denotational semantics, which are compositional and can also be viewed as an implementation by translation to a simpler language, rely on the selection monad. We establish that the two semantics coincide in both cases.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Machine Learning,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/A2HPSJ8L/Abadi e Plotkin - 2020 - Smart Choices and the Selection Monad.pdf;/home/flaviomoura/Zotero/storage/A3YRPA8E/Abadi e Plotkin - 2021 - Smart Choices and the Selection Monad.pdf;/home/flaviomoura/Zotero/storage/CQZN7FEQ/Abadi e Plotkin - 2021 - Smart Choices and the Selection Monad.pdf;/home/flaviomoura/Zotero/storage/2RKXB376/2007.html;/home/flaviomoura/Zotero/storage/HUG3HJRJ/2007.html;/home/flaviomoura/Zotero/storage/KGS4KKSA/2007.html;/home/flaviomoura/Zotero/storage/XLD9WE5G/2007.html}
}

@book{abadiTheoreticalAspectsComputer1997,
  title = {Theoretical {{Aspects}} of {{Computer Software}}, {{Third International Symposium}}, {{TACS}} '97, {{Sendai}}, {{Japan}}, {{September}} 23-26, 1997, {{Proceedings}}},
  editor = {Abadi, Mart{\'i}n and Ito, Takayasu},
  year = {1997},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1281},
  publisher = {Springer},
  doi = {10.1007/BFb0014544},
  isbn = {3-540-63388-X}
}

@book{abbottUnderstandingAnalysis2015,
  title = {Understanding {{Analysis}}},
  author = {Abbott, Stephen},
  year = {2015},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4939-2712-8}
}

@article{abelFailureNormalizationImpredicative2020,
  ids = {abelFailureNormalizationImpredicative2020a},
  title = {Failure of {{Normalization}} in {{Impredicative Type Theory}} with {{Proof-Irrelevant Propositional Equality}}},
  author = {Abel, Andreas and Coquand, Thierry},
  year = {2020},
  month = jun,
  journal = {arXiv:1911.08174 [cs, math]},
  eprint = {1911.08174},
  primaryclass = {cs, math},
  urldate = {2020-06-30},
  abstract = {Normalization fails in type theory with an impredicative universe of propositions and a proof-irrelevant propositional equality. The counterexample to normalization is adapted from Girard's counterexample against normalization of System F equipped with a decider for type equality. It refutes Werner's normalization conjecture [LMCS 2008].},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/JUBWX8KL/Abel e Coquand - 2020 - Failure of Normalization in Impredicative Type The.pdf;/home/flaviomoura/Zotero/storage/KDJIBSTU/Abel e Coquand - 2020 - Failure of Normalization in Impredicative Type The.pdf;/home/flaviomoura/Zotero/storage/CS8VEILP/1911.html;/home/flaviomoura/Zotero/storage/FTWCS5KY/1911.html}
}

@article{abelLeibnizEqualityIsomorphic2020,
  title = {Leibniz Equality Is Isomorphic to {{Martin-L{\"o}f}} Identity, Parametrically},
  author = {Abel, Andreas and Cockx, Jesper and Devriese, Dominique and Timany, Amin and Wadler, Philip},
  year = {2020},
  journal = {Journal of Functional Programming},
  volume = {30},
  pages = {e17},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796820000155},
  urldate = {2023-10-10},
  abstract = {Consider two widely used definitions of equality. That of Leibniz: one value equals another if any predicate that holds of the first holds of the second. And that of Martin-L{\"o}f: the type identifying one value with another is occupied if the two values are identical. The former dates back several centuries, while the latter is widely used in proof systems such as Agda and Coq. Here we show that the two definitions are isomorphic: we can convert any proof of Leibniz equality to one of Martin-L{\"o}f identity and vice versa, and each conversion followed by the other is the identity. One direction of the isomorphism depends crucially on values of the type corresponding to Leibniz equality satisfying functional extensionality and Reynolds' notion of parametricity. The existence of the conversions is widely known (meaning that if one can prove one equality then one can prove the other), but that the two conversions form an isomorphism (internally) in the presence of parametricity and functional extensionality is, we believe, new. Our result is a special case of a more general relation that holds between inductive families and their Church encodings. Our proofs are given inside type theory, rather than meta-theoretically. Our paper is a literate Agda script.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AWL8CF2J/Abel et al. - 2020 - Leibniz equality is isomorphic to Martin-LÃ¶f ident.pdf}
}

@article{abelPOPLMarkReloadedMechanizing2019,
  title = {{{POPLMark}} Reloaded: {{Mechanizing}} Proofs by Logical Relations},
  shorttitle = {{{POPLMark}} Reloaded},
  author = {Abel, Andreas and Allais, Guillaume and Hameer, Aliya and Pientka, Brigitte and Momigliano, Alberto and Sch{\"a}fer, Steven and Stark, Kathrin},
  year = {2019},
  journal = {Journal of Functional Programming},
  volume = {29},
  pages = {e19},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796819000170},
  urldate = {2022-07-31},
  abstract = {Abstract             We propose a new collection of benchmark problems in mechanizing the metatheory of programming languages, in order to compare and push the state of the art of proof assistants. In particular, we focus on proofs using logical relations (LRs) and propose establishing strong normalization of a simply typed calculus with a proof by Kripke-style LRs as a benchmark. We give a modern view of this well-understood problem by formulating our LR on well-typed terms. Using this case study, we share some of the lessons learned tackling this problem in different dependently typed proof environments. In particular, we consider the mechanization in Beluga, a proof environment that supports higher-order abstract syntax encodings and contrast it to the development and strategies used in general-purpose proof assistants such as Coq and Agda. The goal of this paper is to engage the community in discussions on what support in proof environments is needed to truly bring mechanized metatheory to the masses and engage said community in the crafting of future benchmarks.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/75CY58EV/Abel et al. - 2019 - POPLMark reloaded Mechanizing proofs by logical r.pdf}
}

@article{abeSymmetricLambdaCalculusCorresponding2021,
  title = {A {{Symmetric Lambda-Calculus Corresponding}} to the {{Negation-Free Bilateral Natural Deduction}}},
  author = {Abe, Tatsuya and Kimura, Daisuke},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.12607 [cs]},
  eprint = {2101.12607},
  primaryclass = {cs},
  urldate = {2021-02-01},
  abstract = {Filinski constructed a symmetric lambda-calculus consisting of expressions and continuations which are symmetric, and functions which have duality. In his calculus, functions can be encoded to expressions and continuations using primitive operators. That is, the duality of functions is not derived in the calculus but adopted as a principle of the calculus. In this paper, we propose a simple symmetric lambda-calculus corresponding to the negation-free natural deduction based bilateralism in proof-theoretic semantics. In our calculus, continuation types are represented as not negations of formulae but formulae with negative polarity. Function types are represented as the implication and but-not connectives in intuitionistic and paraconsistent logics, respectively. Our calculus is not only simple but also powerful as it includes a call-value calculus corresponding to the call-by-value dual calculus invented by Wadler. We show that mutual transformations between expressions and continuations are definable in our calculus to justify the duality of functions. We also show that every typable function has dual types. Thus, the duality of function is derived from bilateralism.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/5RXHY764/Abe e Kimura - 2021 - A Symmetric Lambda-Calculus Corresponding to the N.pdf;/home/flaviomoura/Zotero/storage/6H6K97A3/2101.html}
}

@book{abilioUnBDali2016,
  title = {{{UnB-Dali}}},
  author = {{Abilio}},
  year = {2016}
}

@article{accattoliAbstractFactorizationTheorem2012,
  title = {An {{Abstract Factorization Theorem}} for {{Explicit Substitutions}}},
  author = {Accattoli, Beniamino},
  year = {2012},
  pages = {16 pages},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany},
  doi = {10.4230/LIPICS.RTA.2012.6},
  urldate = {2023-09-07},
  collaborator = {Herbstritt, Marc},
  langid = {english},
  keywords = {000 Computer science knowledge general works,Computer Science},
  file = {/home/flaviomoura/Zotero/storage/7ZBVJK55/Accattoli - 2012 - An Abstract Factorization Theorem for Explicit Sub.pdf}
}

@article{accattoliAbstractMachineryInteraction2020,
  title = {The {{Abstract Machinery}} of {{Interaction}} ({{Long Version}})},
  author = {Accattoli, Beniamino and Lago, Ugo Dal and Vanoni, Gabriele},
  year = {2020},
  month = jul,
  journal = {arXiv:2002.05649 [cs]},
  eprint = {2002.05649},
  primaryclass = {cs},
  urldate = {2020-07-10},
  abstract = {This paper revisits the Interaction Abstract Machine (IAM), a machine based on Girard's Geometry of Interaction, introduced by Mackie and Danos \& Regnier. It is an unusual machine, not relying on environments, presented on linear logic proof nets, and whose soundness proof is convoluted and passes through various other formalisms. Here we provide a new direct proof of its correctness, based on a variant of Sands's improvements, a natural notion of bisimulation. Moreover, our proof is carried out on a new presentation of the IAM, defined as a machine acting directly on \${\textbackslash}lambda\$-terms, rather than on linear logic proof nets.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/I5JJH3S8/Accattoli et al. - 2020 - The Abstract Machinery of Interaction (Long Versio.pdf;/home/flaviomoura/Zotero/storage/KZPQF7Q2/2002.html}
}

@article{accattoliAbstractMachinesOpen2019,
  title = {Abstract Machines for {{Open Call-by-Value}}},
  author = {Accattoli, Beniamino and Guerrieri, Giulio},
  year = {2019},
  month = oct,
  journal = {Science of Computer Programming},
  volume = {184},
  pages = {102275},
  issn = {01676423},
  doi = {10.1016/j.scico.2019.03.002},
  urldate = {2023-03-20},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/8G5PITVG/Accattoli e Guerrieri - 2019 - Abstract machines for Open Call-by-Value.pdf}
}

@inproceedings{accattoliBetaReductionInvariant2014,
  title = {Beta Reduction Is Invariant, Indeed},
  booktitle = {Joint {{Meeting}} of the {{Twenty-Third EACSL Annual Conference}} on {{Computer Science Logic}} ({{CSL}}) and the {{Twenty-Ninth Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}}), {{CSL-LICS}} '14, {{Vienna}}, {{Austria}}, {{July}} 14 - 18, 2014},
  author = {Accattoli, B. and Lago, U. Dal},
  year = {2014},
  pages = {8:1--8:10},
  doi = {10.1145/2603088.2603105}
}

@inproceedings{accattoliDistillingAbstractMachines2014,
  title = {Distilling Abstract Machines},
  booktitle = {Proceedings of the 19th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming, {{Gothenburg}}, {{Sweden}}, {{September}} 1-3, 2014},
  author = {Accattoli, B. and Barenbaum, P. and Mazza, D.},
  year = {2014},
  pages = {363--376},
  doi = {10.1145/2628136.2628154}
}

@article{accattoliEfficiencyInteraction2020,
  title = {The ({{In}}){{Efficiency}} of {{Interaction}}},
  author = {Accattoli, Beniamino and Lago, Ugo Dal and Vanoni, Gabriele},
  year = {2020},
  month = oct,
  journal = {arXiv:2010.12988 [cs]},
  eprint = {2010.12988},
  primaryclass = {cs},
  urldate = {2020-10-27},
  abstract = {Evaluating higher-order functional programs through abstract machines inspired by the geometry of the interaction is known to induce \${\textbackslash}textit\{space\}\$ efficiencies, the price being \${\textbackslash}textit\{time\}\$ performances often poorer than those obtainable with traditional, environment-based, abstract machines. Although families of lambda-terms for which the former is exponentially less efficient than the latter do exist, it is currently unknown how {\textbackslash}emph\{general\} this phenomenon is, and how far the inefficiencies can go, in the worst case. We answer these questions formulating four different well-known abstract machines inside a common definitional framework, this way being able to give sharp results about the relative time efficiencies. We also prove that non-idempotent intersection type theories are able to precisely reflect the time performances of the interactive abstract machine, this way showing that its time-inefficiency ultimately descends from the presence of higher-order types.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/QKGSSDYS/Accattoli et al. - 2020 - The (In)Efficiency of Interaction.pdf;/home/flaviomoura/Zotero/storage/8WUA78KH/2010.html}
}

@article{accattoliFactorizationNormalizationEssentially2019,
  title = {Factorization and {{Normalization}}, {{Essentially}}},
  author = {Accattoli, Beniamino and Faggian, Claudia and Guerrieri, Giulio},
  year = {2019},
  journal = {CoRR},
  abstract = {Lambda-calculi come with no fixed evaluation strategy. Different strategies may then be considered, and it is important that they satisfy some abstract rewriting property, such as factorization or normalization theorems. In this paper we provide simple proof techniques for these theorems. Our starting point is a revisitation of Takahashi's technique to prove factorization for head reduction. Our technique is both simpler and more powerful, as it works in cases where Takahishi's does not. We then pair factorization with two other abstract properties, defining {\textbackslash}emphessential systems, and show that normalization follows. Concretely, we apply the technique to four case studies, two classic ones, head and the leftmost-outermost reductions, and two less classic ones, non-deterministic weak call-by-value and least-level reductions.}
}

@article{accattoliFactorizeFactorization2020,
  ids = {accattoliFactorizeFactorization2020a},
  title = {Factorize {{Factorization}}},
  author = {Accattoli, Beniamino and Faggian, Claudia and Guerrieri, Giulio},
  year = {2020},
  journal = {CoRR},
  eprint = {2005.01808},
  abstract = {We present a new technique for proving factorization theorems for compound rewriting systems in a modular way, which is inspired by Hindley-Rosen result for confluence. Factorization -- a simple form of standardization -- is concerned with reduction strategies, i.e. how a result is computed. The technique is first developed abstractly. In particular, we isolate a simple sufficient condition (called linear swap) for lifting factorization from components to the compound system. We then closely analyze some common factorization schemas for the lambda-calculus, and show that the technique simplifies even more, reducing to the test of elementary local commutations. Concretely, we apply our technique to diverse extensions of the {$\lambda$}-calculus, among which de' Liguoro and Piperno's non-deterministic lambda-calculus and -- for call-by-value -- Carraro and Guerrieri's shuffling calculus. For both calculi the literature contains factorization theorems. For each, we obtain a novel proof which is neat and strikingly short.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/GGHCSYV8/Accattoli et al. - 2020 - Factorize Factorization.pdf;/home/flaviomoura/Zotero/storage/TR5MVRKL/2005.html}
}

@article{accattoliFormalizingFunctionsProcesses2023,
  title = {Formalizing {{Functions}} as {{Processes}}},
  author = {Accattoli, Beniamino and Blanc, Horace and Sacerdoti Coen, Claudio},
  year = {2023},
  pages = {21 pages, 834960 bytes},
  publisher = {[object Object]},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.ITP.2023.5},
  urldate = {2024-04-17},
  abstract = {We present the first formalization of Milner's classic translation of the {$\lambda$}-calculus into the {$\pi$}-calculus. It is a challenging result with respect to variables, names, and binders, as it requires one to relate variables and binders of the {$\lambda$}-calculus with names and binders in the {$\pi$}-calculus. We formalize it in Abella, merging the set of variables and the set of names, thus circumventing the challenge and obtaining a neat formalization.},
  collaborator = {Naumowicz, Adam and Thiemann, Ren{\'e}},
  copyright = {Creative Commons Attribution 4.0 International license, info:eu-repo/semantics/openAccess},
  isbn = {9783959772846},
  langid = {english},
  keywords = {Abella,binders,Lambda calculus,pi calculus,proof assistants,Theory of computation  Automated reasoning,Theory of computation  Lambda calculus,Theory of computation  Operational semantics,Theory of computation  Process calculi},
  file = {/home/flaviomoura/Zotero/storage/LRUHZTQ5/Accattoli et al. - 2023 - Formalizing Functions as Processes.pdf}
}

@inproceedings{accattoliFreshLookLambdaCalculus2019,
  title = {A {{Fresh Look}} at the Lambda-{{Calculus}} ({{Invited Talk}})},
  booktitle = {4th {{International Conference}} on {{Formal Structures}} for {{Computation}} and {{Deduction}} ({{FSCD}} 2019)},
  author = {Accattoli, Beniamino},
  editor = {Geuvers, Herman},
  year = {2019},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  volume = {131},
  pages = {1:1--1:20},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address = {Dagstuhl, Germany},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.FSCD.2019.1},
  isbn = {978-3-95977-107-8}
}

@article{accattoliFunctionalPearlDistributive2020,
  title = {Functional {{Pearl}}: {{The Distributive}} \${\textbackslash}lambda\$-{{Calculus}}},
  shorttitle = {Functional {{Pearl}}},
  author = {Accattoli, Beniamino and {D{\'i}az-Caro}, Alejandro},
  year = {2020},
  month = jul,
  journal = {arXiv:2002.07944 [cs]},
  eprint = {2002.07944},
  primaryclass = {cs},
  urldate = {2020-07-30},
  abstract = {We introduce a simple extension of the \${\textbackslash}lambda\$-calculus with pairs---called the distributive \${\textbackslash}lambda\$-calculus---obtained by adding a computational interpretation of the valid distributivity isomorphism \$A {\textbackslash}Rightarrow (B{\textbackslash}wedge C){\textbackslash} {\textbackslash} {\textbackslash}equiv{\textbackslash} {\textbackslash} (A{\textbackslash}Rightarrow B) {\textbackslash}wedge (A{\textbackslash}Rightarrow C)\$ of simple types. We study the calculus both as an untyped and as a simply typed setting. Key features of the untyped calculus are confluence, the absence of clashes of constructs, that is, evaluation never gets stuck, and a leftmost-outermost normalization theorem, obtained with straightforward proofs. With respect to simple types, we show that the new rules satisfy subject reduction if types are considered up to the distributivity isomorphism. The main result is strong normalization for simple types up to distributivity. The proof is a smooth variation over the one for the \${\textbackslash}lambda\$-calculus with pairs and simple types.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/KA6CEKTA/Accattoli e DÃ­az-Caro - 2020 - Functional Pearl The Distributive $lambda$-Calcu.pdf;/home/flaviomoura/Zotero/storage/NH9GSHAW/2002.html}
}

@misc{accattoliIMELLCutElimination2024,
  title = {{{IMELL Cut Elimination}} with {{Linear Overhead}}},
  author = {Accattoli, Beniamino and Coen, Claudio Sacerdoti},
  year = {2024},
  month = may,
  number = {arXiv:2405.03669},
  eprint = {2405.03669},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.03669},
  urldate = {2024-05-07},
  abstract = {Recently, Accattoli introduced the Exponential Substitution Calculus (ESC) given by untyped proof terms for Intuitionistic Multiplicative Exponential Linear Logic (IMELL), endowed with rewriting rules at-a-distance for cut elimination. He also introduced a new cut elimination strategy, dubbed the good strategy, and showed that its number of steps is a time cost model with polynomial overhead for the ESC/IMELL, and the first such one. Here, we refine Accattoli's result by introducing an abstract machine for ESC and proving that it implements the good strategy and computes cut-free terms/proofs within a linear overhead.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/TZNXMM45/Accattoli and Coen - 2024 - IMELL Cut Elimination with Linear Overhead.pdf;/home/flaviomoura/Zotero/storage/IBWI45EN/2405.html}
}

@article{accattoliImplementingOpenCallbyValue2017,
  title = {Implementing {{Open Call-by-Value}} ({{Extended Version}})},
  author = {Accattoli, Beniamino and Guerrieri, Giulio},
  year = {2017},
  month = feb,
  journal = {arXiv:1701.08186 [cs]},
  eprint = {1701.08186},
  primaryclass = {cs},
  urldate = {2021-04-06},
  abstract = {The theory of the call-by-value lambda-calculus relies on weak evaluation and closed terms, that are natural hypotheses in the study of programming languages. To model proof assistants, however, strong evaluation and open terms are required. Open call-by-value is the intermediate setting of weak evaluation with open terms, on top of which Gr{\textbackslash}'egoire and Leroy designed the abstract machine of Coq. This paper provides a theory of abstract machines for open call-by-value. The literature contains machines that are either simple but inefficient, as they have an exponential overhead, or efficient but heavy, as they rely on a labelling of environments and a technical optimization. We introduce a machine that is simple and efficient: it does not use labels and it implements open call-by-value within a bilinear overhead. Moreover, we provide a new fine understanding of how different optimizations impact on the complexity of the overhead.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,D.3.1,F.1.1,F.3.1,F.3.2,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/Y8I8BI53/Accattoli e Guerrieri - 2017 - Implementing Open Call-by-Value (Extended Version).pdf;/home/flaviomoura/Zotero/storage/89UTXDAL/1701.html;/home/flaviomoura/Zotero/storage/RZLHZR36/1701.html}
}

@misc{accattoliInteractionEquivalence2024,
  title = {Interaction {{Equivalence}}},
  author = {Accattoli, Beniamino and Lancelot, Adrienne and Manzonetto, Giulio and Vanoni, Gabriele},
  year = {2024},
  month = sep,
  number = {arXiv:2409.18709},
  eprint = {2409.18709},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2409.18709},
  urldate = {2024-09-30},
  abstract = {Contextual equivalence is the de facto standard notion of program equivalence. A key theorem is that contextual equivalence is an equational theory. Making contextual equivalence more intensional, for example taking into account the time cost of the computation, seems a natural refinement. Such a change, however, does not induce an equational theory, for an apparently essential reason: cost is not invariant under reduction. In the paradigmatic case of the untyped \${\textbackslash}lambda\$-calculus, we introduce interaction equivalence. Inspired by game semantics, we observe the number of interaction steps between terms and contexts but -- crucially -- ignore their own internal steps. We prove that interaction equivalence is an equational theory and we characterize it as \$B\$, the well-known theory induced by B{\textbackslash}"ohm tree equality. Ours is the first observational characterization of \$B\$ obtained without enriching the discriminating power of contexts with extra features such as non-determinism. To prove our results, we develop interaction-based refinements of the B{\textbackslash}"ohm-out technique and of intersection types.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/BV54TBER/Accattoli et al. - 2024 - Interaction Equivalence.pdf;/home/flaviomoura/Zotero/storage/GAB6BCKZ/Accattoli et al. - 2024 - Interaction Equivalence.pdf;/home/flaviomoura/Zotero/storage/EE5QRI4T/2409.html;/home/flaviomoura/Zotero/storage/T7YE5Z2Q/2409.html}
}

@inproceedings{accattoliInvarianceUnitaryCost2012,
  title = {On the {{Invariance}} of the {{Unitary Cost Model}} for {{Head Reduction}}},
  booktitle = {{{RTA}}},
  author = {Accattoli, B. and Lago, U. Dal},
  year = {2012},
  pages = {22--37}
}

@misc{accattoliLogSensitiveEncodingTuring2023,
  title = {A {{Log-Sensitive Encoding}} of {{Turing Machines}} in the \${\textbackslash}lambda\$-{{Calculus}}},
  author = {Accattoli, Beniamino and Lago, Ugo Dal and Vanoni, Gabriele},
  year = {2023},
  month = jan,
  number = {arXiv:2301.12556},
  eprint = {2301.12556},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-02-02},
  abstract = {This note modifies the reference encoding of Turing machines in the {$\lambda$}-calculus by Dal Lago and Accattoli [DLA17], which is tuned for time efficiency, as to accommodate logarithmic space. There are two main changes: Turing machines now have two tapes, an input tape and a work tape, and the input tape is encoded differently, because the reference encoding comes with a linear space overhead for managing tapes, which is excessive for studying logarithmic space.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/TLS2Y3US/Accattoli et al. - 2023 - A Log-Sensitive Encoding of Turing Machines in the.pdf}
}

@misc{accattoliMirroringCallbyNeedValues2024,
  title = {Mirroring {{Call-by-Need}}, or {{Values Acting Silly}}},
  author = {Accattoli, Beniamino and Lancelot, Adrienne},
  year = {2024},
  month = feb,
  number = {arXiv:2402.12078},
  eprint = {2402.12078},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-02-20},
  abstract = {Call-by-need evaluation for the lambda-calculus can be seen as merging the best of call-by-name and call-by-value, namely the wise erasing behaviour of the former and the wise duplicating behaviour of the latter. To better understand how duplication and erasure can be combined, we design a degenerated calculus, dubbed call-by-silly, that is symmetric to call-by-need in that it merges the worst of call-by-name and call-by-value, namely silly duplications by-name and silly erasures by-value. We validate the design of the call-by-silly calculus via rewriting properties and multi types. In particular, we mirror the main theorem about call-by-need -- that is, its operational equivalence with call-by-name -- showing that call-by-silly and call-by-value induce the same contextual equivalence. This fact shows the blindness with respect to efficiency of call-by-value contextual equivalence. We also define a call-by-silly strategy and measure its length via tight multi types. Lastly, we prove that the call-by-silly strategy computes evaluation sequences of maximal length in the calculus.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/X544PHM5/Accattoli and Lancelot - 2024 - Mirroring Call-by-Need, or Values Acting Silly.pdf;/home/flaviomoura/Zotero/storage/Y4TYRKJI/Accattoli and Lancelot - 2024 - Mirroring Call-by-Need, or Values Acting Silly.pdf;/home/flaviomoura/Zotero/storage/PCQDQE32/2402.html}
}

@article{accattoliMPRICourseLogique,
  title = {{{MPRI}} Course {{Logique Lin}}{\textasciiacute}eaire et {{Paradigmes Logiques}} Du {{Calcul Year}} 2022-23, {{Part}} 3, {{Lecture}} 6},
  author = {Accattoli, Beniamino},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/A9PTPDFW/Accattoli - MPRI course Logique LinÂ´eaire et Paradigmes Logiqu.pdf}
}

@misc{accattoliMultiTypesReasonable2022,
  title = {Multi {{Types}} and {{Reasonable Space}} ({{Long Version}})},
  author = {Accattoli, Beniamino and Lago, Ugo Dal and Vanoni, Gabriele},
  year = {2022},
  month = jul,
  number = {arXiv:2207.08795},
  eprint = {2207.08795},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {Accattoli, Dal Lago, and Vanoni have recently proved that the space used by the Space KAM, a variant of the Krivine abstract machine, is a reasonable space cost model for the lambda-calculus accounting for logarithmic space, solving a longstanding open problem. In this paper, we provide a new system of multi types (a variant of intersection types) and extract from multi type derivations the space used by the Space KAM, capturing into a type system the space complexity of the abstract machine. Additionally, we show how to capture also the time of the Space KAM, which is a reasonable time cost model, via minor changes to the type system.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/TMXIGZLY/Accattoli et al. - 2022 - Multi Types and Reasonable Space (Long Version).pdf;/home/flaviomoura/Zotero/storage/6U6X9IVJ/2207.html}
}

@inproceedings{accattoliNonstandardStandardizationTheorem2014,
  title = {A Nonstandard Standardization Theorem},
  booktitle = {{{POPL}}},
  author = {Accattoli, B. and Bonelli, E. and Kesner, D. and Lombardi, C.},
  year = {2014},
  pages = {659--670}
}

@misc{accattoliNormalFormBisimulations2023,
  title = {Normal {{Form Bisimulations By Value}}},
  author = {Accattoli, Beniamino and Lancelot, Adrienne and Faggian, Claudia},
  year = {2023},
  month = sep,
  number = {arXiv:2303.08161},
  eprint = {2303.08161},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-09-06},
  abstract = {Normal form bisimilarities are a natural form of program equivalence resting on open terms, first introduced by Sangiorgi in call-by-name. The literature contains a normal form bisimilarity for Plotkin's call-by-value \${\textbackslash}lambda\$-calculus, Lassen's {\textbackslash}emph\{enf bisimilarity\}, which validates all of Moggi's monadic laws and can be extended to validate \${\textbackslash}eta\$. It does not validate, however, other relevant principles, such as the identification of meaningless terms -- validated instead by Sangiorgi's bisimilarity -- or the commutation of \${\textbackslash}letexp\$s. These shortcomings are due to issues with open terms of Plotkin's calculus. We introduce a new call-by-value normal form bisimilarity, deemed {\textbackslash}emph\{net bisimilarity\}, closer in spirit to Sangiorgi's and satisfying the additional principles. We develop it on top of an existing formalism designed for dealing with open terms in call-by-value. It turns out that enf and net bisimilarities are {\textbackslash}emph\{incomparable\}, as net bisimilarity does not validate Moggi's laws nor \${\textbackslash}eta\$. Moreover, there is no easy way to merge them. To better understand the situation, we provide an analysis of the rich range of possible call-by-value normal form bisimilarities, relating them to Ehrhard's relational model.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/72N2Z5J4/Accattoli et al. - 2023 - Normal Form Bisimulations By Value.pdf;/home/flaviomoura/Zotero/storage/DNEBDIL8/2303.html}
}

@unpublished{accattoliOpenCallbyValue2016,
  title = {Open {{Call-by-Value}}},
  author = {Accattoli, B. and Guerrieri, G.},
  year = {2016}
}

@inproceedings{accattoliOpenCallbyValue2016a,
  title = {Open {{Call-by-Value}}},
  booktitle = {Programming {{Languages}} and {{Systems}} - 14th {{Asian Symposium}}, {{APLAS}} 2016, {{Hanoi}}, {{Vietnam}}, {{November}} 21-23, 2016, {{Proceedings}}},
  author = {Accattoli, B. and Guerrieri, G.},
  year = {2016},
  pages = {206--226},
  doi = {10.1007/978-3-319-47958-3_12}
}

@article{accattoliOpenCallbyValueExtended2016,
  title = {Open {{Call-by-Value}} ({{Extended Version}})},
  author = {Accattoli, Beniamino and Guerrieri, Giulio},
  year = {2016},
  month = sep,
  journal = {arXiv:1609.00322 [cs]},
  eprint = {1609.00322},
  primaryclass = {cs},
  urldate = {2021-04-06},
  abstract = {The elegant theory of the call-by-value lambda-calculus relies on weak evaluation and closed terms, that are natural hypotheses in the study of programming languages. To model proof assistants, however, strong evaluation and open terms are required, and it is well known that the operational semantics of call-by-value becomes problematic in this case. Here we study the intermediate setting -- that we call Open Call-by-Value -- of weak evaluation with open terms, on top of which Gr{\textbackslash}'egoire and Leroy designed the abstract machine of Coq. Various calculi for Open Call-by-Value already exist, each one with its pros and cons. This paper presents a detailed comparative study of the operational semantics of four of them, coming from different areas such as the study of abstract machines, denotational semantics, linear logic proof nets, and sequent calculus. We show that these calculi are all equivalent from a termination point of view, justifying the slogan Open Call-by-Value.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,D.3.1,F.3.2,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/L9WZGVMI/Accattoli e Guerrieri - 2016 - Open Call-by-Value (Extended Version).pdf;/home/flaviomoura/Zotero/storage/H34PACIN/1609.html;/home/flaviomoura/Zotero/storage/SAKX8MXF/1609.html}
}

@inproceedings{accattoliPermutativeLambdaCalculus2012,
  title = {The {{Permutative Lambda Calculus}}},
  booktitle = {{{LPAR}}},
  author = {Accattoli, B. and Kesner, D.},
  year = {2012},
  pages = {23--36},
  file = {/home/flaviomoura/Zotero/storage/AJWK7ZHR/Accattoli e Kesner - 2012 - The Permutative Lambda Calculus.pdf}
}

@misc{accattoliPositiveFocusingDirectly2024,
  title = {Positive {{Focusing}} Is {{Directly Useful}}},
  author = {Accattoli, Beniamino and Wu, Jui-Hsuan},
  year = {2024},
  month = nov,
  number = {arXiv:2411.09489},
  eprint = {2411.09489},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2411.09489},
  urldate = {2024-11-15},
  abstract = {Recently, Miller and Wu introduced the positive \${\textbackslash}lambda\$-calculus, a call-by-value \${\textbackslash}lambda\$-calculus with sharing obtained by assigning proof terms to the positively polarized focused proofs for minimal intuitionistic logic. The positive \${\textbackslash}lambda\$-calculus stands out among \${\textbackslash}lambda\$-calculi with sharing for a compactness property related to the sharing of variables. We show that -- thanks to compactness -- the positive calculus neatly captures the core of useful sharing, a technique for the study of reasonable time cost models.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/RN2NCQ2X/Accattoli e Wu - 2024 - Positive Focusing is Directly Useful.pdf;/home/flaviomoura/Zotero/storage/WHZAN8YP/2411.html}
}

@article{accattoliPreservationStrongNormalisation2012,
  title = {Preservation of {{Strong Normalisation}} modulo Permutations for the Structural Lambda-Calculus},
  author = {Accattoli, B. and Kesner, D.},
  year = {2012},
  journal = {Logical Methods in Computer Science},
  volume = {8},
  number = {1},
  file = {/home/flaviomoura/Zotero/storage/2L4SHKSU/Accattoli e Kesner - 2012 - Preservation of Strong Normalisation modulo permut.pdf}
}

@misc{accattoliReasonableSpaceLambda2024,
  title = {Reasonable {{Space}} for the \${\textbackslash}lambda\$-{{Calculus}}, {{Logarithmically}}},
  author = {Accattoli, Beniamino and Lago, Ugo Dal and Vanoni, Gabriele},
  year = {2024},
  month = may,
  number = {arXiv:2203.00362},
  eprint = {2203.00362},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2203.00362},
  urldate = {2024-05-09},
  abstract = {Can the \${\textbackslash}lambda\$-calculus be considered a reasonable computational model? Can we use it for measuring the time \${\textbackslash}textit\{and\}\$ space consumption of algorithms? While the literature contains positive answers about time, much less is known about space. This paper presents a new reasonable space cost model for the \${\textbackslash}lambda\$-calculus, based on a variant over the Krivine abstract machine. For the first time, this cost model is able to accommodate logarithmic space. Moreover, we study the time behavior of our machine and show how to transport our results to the call-by-value \${\textbackslash}lambda\$-calculus.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/YACY5F8E/Accattoli et al. - 2024 - Reasonable Space for the $lambda$-Calculus, Logar.pdf;/home/flaviomoura/Zotero/storage/DTZ4MGUB/2203.html}
}

@inproceedings{accattoliReasonableSpaceLCalculus2022,
  title = {Reasonable {{Space}} for the {$\lambda$}-{{Calculus}}, {{Logarithmically}}},
  booktitle = {Proceedings of the 37th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Accattoli, Beniamino and Dal Lago, Ugo and Vanoni, Gabriele},
  year = {2022},
  month = aug,
  pages = {1--13},
  publisher = {ACM},
  address = {Haifa Israel},
  doi = {10.1145/3531130.3533362},
  urldate = {2023-09-17},
  isbn = {978-1-4503-9351-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/LUUKUNGA/Accattoli et al. - 2022 - Reasonable Space for the Î»-Calculus, Logarithmical.pdf}
}

@misc{accattoliSemanticBoundMulti2023,
  title = {Semantic {{Bound}} and {{Multi Types}}, {{Revisited}}},
  author = {Accattoli, Beniamino},
  year = {2023},
  month = dec,
  number = {arXiv:2311.18233},
  eprint = {2311.18233},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-12-05},
  abstract = {Intersection types are a standard tool in operational and semantical studies of the lambda calculus. De Carvalho showed how multi types, a quantitative variant of intersection types providing a handy presentation of the relational denotational model, allows one to extract precise bounds on the number of \${\textbackslash}beta\$-steps and the size of normal forms. In the last few years, de Carvalho's work has been extended and adapted to a number of lambda calculi, evaluation strategies, and abstract machines. These works, however, only adapt the first part of his work, that extracts bounds from multi type derivations, while never consider the second part, which deals with extracting bounds from the multi types themselves. The reason is that this second part is more technical, and requires to reason up to type substitutions. It is however also the most interesting, because it shows that the bounding power is inherent to the relational model (which is induced by the types, without the derivations), independently of its presentation as a type system. Here we dissect and clarify the second part of de Carvalho's work, establishing a link with principal multi types, and isolating a key property independent of type substitutions.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/HCUSPN6Y/Accattoli - 2023 - Semantic Bound and Multi Types, Revisited.pdf;/home/flaviomoura/Zotero/storage/78CQHW5N/2311.html}
}

@article{accattoliSemanticBoundsStrong2021,
  title = {Semantic {{Bounds}} and {{Strong Call-by-Value Normalization}}},
  author = {Accattoli, Beniamino and Guerrieri, Giulio and Leberle, Maico},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.13979 [cs]},
  eprint = {2104.13979},
  primaryclass = {cs},
  urldate = {2021-04-30},
  abstract = {This paper explores two topics at once: the use of denotational semantics to bound the evaluation length of functional programs, and the semantics of strong (that is, possibly under abstractions) call-by-value evaluation. About the first, we analyze de Carvalho's seminal use of relational semantics for bounding the evaluation length of lambda-terms, starting from the presentation of the semantics as an intersection types system. We focus on the part of his work which is usually neglected in its many recent adaptations, despite being probably the conceptually deeper one: how to transfer the bounding power from the type system to the relational semantics itself. We dissect this result and re-understand it via the isolation of a simpler size representation property. About the second, we use relational semantics to develop a semantical study of strong call-by-value evaluation, which is both a delicate and neglected topic. We give a semantic characterization of terms normalizable with respect to strong evaluation, providing in particular the first result of adequacy with respect to strong call-by-value. Moreover, we extract bounds about strong evaluation from both the type systems and the relational semantics. Essentially, we use strong call-by-value to revisit de Carvalho's semantic bounds, and de Carvalho's technique to provide semantical foundations for strong call-by-value.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/QRM32X7Y/Accattoli et al. - 2021 - Semantic Bounds and Strong Call-by-Value Normaliza.pdf;/home/flaviomoura/Zotero/storage/YFQH9W2B/Accattoli et al. - 2021 - Semantic Bounds and Strong Call-by-Value Normaliza.pdf;/home/flaviomoura/Zotero/storage/5QDACE6C/2104.html;/home/flaviomoura/Zotero/storage/K28RUDUR/2104.html}
}

@misc{accattoliSemanticBoundsStrong2023,
  title = {Semantic {{Bounds}} and {{Strong Call-by-Value Normalization}}},
  author = {Accattoli, Beniamino and Guerrieri, Giulio and Leberle, Maico},
  year = {2023},
  month = jul,
  number = {arXiv:2104.13979},
  eprint = {2104.13979},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-07-04},
  abstract = {This paper explores two topics at once: the use of denotational semantics to bound the evaluation length of functional programs, and the semantics of strong (that is, possibly under abstractions) call-by-value evaluation. About the first, we analyze de Carvalho's seminal use of relational semantics for bounding the evaluation length of {$\lambda$}-terms, starting from the presentation of the semantics as an intersection types system. We focus on the part of his work which is usually neglected in its many recent adaptations, despite being probably the conceptually deeper one: how to transfer the bounding power from the type system to the relational semantics itself. We dissect this result and re-understand it via the isolation of a simpler size representation property.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/9QUQXCVL/Accattoli et al. - 2023 - Semantic Bounds and Strong Call-by-Value Normaliza.pdf}
}

@inproceedings{accattoliSharingPerspectiveCalculus2023,
  title = {Sharing a {{Perspective}} on the {$\lambda$}-{{Calculus}}},
  booktitle = {Proceedings of the 2023 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}},
  author = {Accattoli, Beniamino},
  year = {2023},
  month = oct,
  pages = {179--190},
  publisher = {ACM},
  address = {Cascais Portugal},
  doi = {10.1145/3622758.3622884},
  urldate = {2023-10-27},
  isbn = {9798400703881},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/55J34AKL/Accattoli - 2023 - Sharing a Perspective on the -Calculus.pdf}
}

@misc{accattoliStrongCallbyValueMulti2023,
  title = {Strong {{Call-by-Value}} and {{Multi Types}}},
  author = {Accattoli, Beniamino and Guerrieri, Giulio and Leberle, Maico},
  year = {2023},
  month = sep,
  number = {arXiv:2309.12261},
  eprint = {2309.12261},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-09-22},
  abstract = {This paper provides foundations for strong (that is, possibly under abstraction) call-by-value evaluation for the lambda-calculus. Recently, Accattoli et al. proposed a form of call-by-value strong evaluation for the lambda-calculus, the external strategy, and proved it reasonable for time. Here, we study the external strategy using a semantical tool, namely Ehrhard's call-by-value multi types, a variant of intersection types. We show that the external strategy terminates exactly when a term is typable with so-called shrinking multi types, mimicking similar results for strong call-by-name. Additionally, the external strategy is normalizing in the untyped setting, that is, it reaches the normal form whenever it exists. We also consider the call-by-extended-value approach to strong evaluation shown reasonable for time by Biernacka et al. The two approaches turn out to not be equivalent: terms may be externally divergent but terminating for call-by-extended-value.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,D.3.1,F.3.2},
  file = {/home/flaviomoura/Zotero/storage/S5NLDNSL/Accattoli et al. - 2023 - Strong Call-by-Value and Multi Types.pdf;/home/flaviomoura/Zotero/storage/MREDSJUT/2309.html}
}

@article{accattoliStrongCallbyValueReasonable2021,
  ids = {accattoliStrongCallbyValueReasonable2021a},
  title = {Strong {{Call-by-Value}} Is {{Reasonable}}, {{Implosively}}},
  author = {Accattoli, Beniamino and Condoluci, Andrea and Coen, Claudio Sacerdoti},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.06928 [cs]},
  eprint = {2102.06928},
  primaryclass = {cs},
  urldate = {2021-02-16},
  abstract = {Whether the number of beta-steps in the lambda-calculus can be taken as a reasonable cost model (that is, polynomially related to the one of Turing machines) is a delicate problem, which depends on the notion of evaluation strategy. Since the nineties, it is known that weak (that is, out of abstractions) call-by-value evaluation is a reasonable strategy while L{\textbackslash}'evy's optimal parallel strategy, which is strong (that is, it reduces everywhere), is not. The strong case turned out to be subtler than the weak one. In 2014 Accattoli and Dal Lago have shown that strong call-by-name is reasonable, by introducing a new form of useful sharing and, later, an abstract machine with an overhead quadratic in the number of beta-steps. Here we show that strong call-by-value evaluation is also reasonable, via a new abstract machine realizing useful sharing and having a linear overhead. Moreover, our machine uses a new mix of sharing techniques, adding on top of useful sharing a form of implosive sharing, which on some terms brings an exponential speed-up. We give an example of family that the machine executes in time logarithmic in the number of beta-steps.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/RNA3C86C/Accattoli et al. - 2021 - Strong Call-by-Value is Reasonable, Implosively.pdf;/home/flaviomoura/Zotero/storage/W8SX3D6M/Accattoli et al. - 2021 - Strong Call-by-Value is Reasonable, Implosively.pdf;/home/flaviomoura/Zotero/storage/9CLQGWH2/2102.html;/home/flaviomoura/Zotero/storage/WY7PWUQZ/2102.html}
}

@article{accattoliStrongDistillery2015,
  title = {A {{Strong Distillery}}},
  author = {Accattoli, B. and Barenbaum, P. and Mazza, D.},
  year = {2015},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages}
}

@techreport{accattoliStructuralLambdacalculus2010,
  title = {The Structural Lambda-Calculus},
  author = {Accattoli, B. and Kesner, D.},
  year = {2010},
  institution = {Universit{\'e} Paris Diderot}
}

@inproceedings{accattoliStructuralLambdacalculus2010a,
  title = {The Structural Lambda-Calculus},
  booktitle = {19th {{EACSL Annual Conference}} on {{Computer Science}} and {{Logic}} ({{CSL}})},
  author = {Accattoli, B. and Kesner, D.},
  year = {2010},
  series = {{{LNCS}}},
  volume = {6247},
  pages = {381--395},
  publisher = {Springer-Verlag}
}

@misc{accattoliTheoryCallbyValueSolvability2022,
  title = {The {{Theory}} of {{Call-by-Value Solvability}} (Long Version)},
  author = {Accattoli, Beniamino and Guerrieri, Giulio},
  year = {2022},
  month = jul,
  number = {arXiv:2207.08697},
  eprint = {2207.08697},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {The denotational semantics of the untyped lambda-calculus is a well developed field built around the concept of solvable terms, which are elegantly characterized in many different ways. In particular, unsolvable terms provide a consistent notion of meaningless term. The semantics of the untyped call-by-value lambda-calculus (CbV) is instead still in its infancy, because of some inherent difficulties but also because CbV solvable terms are less studied and understood than in call-by-name. On the one hand, we show that a carefully crafted presentation of CbV allows us to recover many of the properties that solvability has in call-by-name, in particular qualitative and quantitative characterizations via multi types. On the other hand, we stress that, in CbV, solvability plays a different role: identifying unsolvable terms as meaningless induces an inconsistent theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,D.3.1,F.3.2,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/8DII98DK/Accattoli and Guerrieri - 2022 - The Theory of Call-by-Value Solvability (long vers.pdf;/home/flaviomoura/Zotero/storage/XKZ5K7NI/2207.html}
}

@article{accattoliUsefulOpenCallbyNeed2021,
  title = {Useful {{Open Call-by-Need}}},
  author = {Accattoli, Beniamino and Leberle, Maico},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.06591 [cs]},
  eprint = {2107.06591},
  primaryclass = {cs},
  urldate = {2021-07-15},
  abstract = {This paper studies useful sharing, which is a sophisticated optimization for lambda-calculi, in the context of call-by-need evaluation in presence of open terms. Useful sharing turns out to be harder to manipulate in call-by-need than in call-by-name or call-by-value, because call-by-need evaluates inside environments, making it harder to specify when a substitution step is useful. We isolate the key involved concepts and prove the correctness of useful sharing in this setting.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/TUPE9TT7/Accattoli e Leberle - 2021 - Useful Open Call-by-Need.pdf;/home/flaviomoura/Zotero/storage/2JYSS9DW/2107.html}
}

@misc{accattoliVanillaSequentCalculus2024,
  title = {The {{Vanilla Sequent Calculus}} Is {{Call-by-Value}}},
  author = {Accattoli, Beniamino},
  year = {2024},
  month = sep,
  number = {arXiv:2409.19722},
  eprint = {2409.19722},
  publisher = {arXiv},
  urldate = {2024-10-10},
  abstract = {Existing Curry-Howard interpretations of call-by-value evaluation for the \${\textbackslash}lambda\$-calculus involve classical logic or linear logic, despite the fact that call-by-value was introduced in an intuitionistic setting without linear features. This paper shows that the most basic sequent calculus for minimal intuitionistic logic -- dubbed here vanilla -- can naturally be seen as a logical interpretation of call-by-value evaluation. This is obtained by establishing mutual simulations with a well-known formalism for call-by-value evaluation.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/WGG7HIZG/Accattoli - 2024 - The Vanilla Sequent Calculus is Call-by-Value.pdf;/home/flaviomoura/Zotero/storage/9MJBQQV7/2409.html}
}

@misc{accattoliVanillaSequentCalculus2024a,
  title = {The {{Vanilla Sequent Calculus}} Is {{Call-by-Value}} ({{Fresh Perspective}})},
  author = {Accattoli, Beniamino},
  year = {2024},
  month = nov,
  number = {arXiv:2409.19722},
  eprint = {2409.19722},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2409.19722},
  urldate = {2024-11-06},
  abstract = {Existing Curry-Howard interpretations of call-by-value evaluation for the \${\textbackslash}lambda\$-calculus are either based on ad-hoc modifications of intuitionistic proof systems or involve additional logical concepts such as classical logic or linear logic, despite the fact that call-by-value was introduced in an intuitionistic setting without linear features. This paper shows that the most basic sequent calculus for minimal intuitionistic logic -- dubbed here vanilla -- can naturally be seen as a logical interpretation of call-by-value evaluation. This is obtained by establishing mutual simulations with a well-known formalism for call-by-value evaluation.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/E826TMFW/Accattoli - 2024 - The Vanilla Sequent Calculus is Call-by-Value (Fre.pdf;/home/flaviomoura/Zotero/storage/JQBCTEAR/2409.html}
}

@article{acclavioCanonicityProofsConstructive,
  title = {Canonicity of {{Proofs}} in {{Constructive Modal Logic}} {$\star$}},
  author = {Acclavio, Matteo and Catta, Davide and Olimpieri, Federico},
  abstract = {In this paper we investigate the Curry-Howard correspondence for constructive modal logic in light of the gap between the proof equivalences enforced by the lambda calculi from the literature and by the recently defined winning strategies for this logic.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XG95L4B9/Acclavio et al. - Canonicity of Proofs in Constructive Modal Logic â.pdf}
}

@misc{acclavioCanonicityProofsConstructive2023,
  title = {Canonicity of {{Proofs}} in {{Constructive Modal Logic}}},
  author = {Acclavio, Matteo and Catta, Davide and Olimpieri, Federico},
  year = {2023},
  month = jul,
  number = {arXiv:2304.05465},
  eprint = {2304.05465},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-08-01},
  abstract = {In this paper we investigate the Curry-Howard correspondence for constructive modal logic in light of the gap between the proof equivalences enforced by the lambda calculi from the literature and by the recently defined winning strategies for this logic.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/JBNCLA9U/Acclavio et al. - 2023 - Canonicity of Proofs in Constructive Modal Logic.pdf}
}

@misc{acclavioInfinitaryCuteliminationFinite2024,
  title = {Infinitary Cut-Elimination via Finite Approximations (Extended Version)},
  author = {Acclavio, Matteo and Curzi, Gianluca and Guerrieri, Giulio},
  year = {2024},
  month = may,
  number = {arXiv:2308.07789},
  eprint = {2308.07789},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2308.07789},
  urldate = {2024-05-29},
  abstract = {We investigate non-wellfounded proof systems based on parsimonious logic, a weaker variant of linear logic where the exponential modality ! is interpreted as a constructor for streams over finite data. Logical consistency is maintained at a global level by adapting a standard progressing criterion. We present an infinitary version of cut-elimination based on finite approximations, and we prove that, in presence of the progressing criterion, it returns well-defined non-wellfounded proofs at its limit. Furthermore, we show that cut-elimination preserves the progressive criterion and various regularity conditions internalizing degrees of proof-theoretical uniformity. Finally, we provide a denotational semantics for our systems based on the relational model.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/3INAXC3W/Acclavio et al. - 2024 - Infinitary cut-elimination via finite approximatio.pdf;/home/flaviomoura/Zotero/storage/D5JR9R4Z/2308.html}
}

@book{acetoAutomataLanguagesProgramming2008,
  title = {Automata, {{Languages}} and {{Programming}}, 35th {{International Colloquium}}, {{ICALP}} 2008, {{Reykjavik}}, {{Iceland}}, {{July}} 7-11, 2008, {{Proceedings}}, {{Part II}} - {{Track B}}: {{Logic}}, {{Semantics}}, and {{Theory}} of {{Programming}} \& {{Track C}}: {{Security}} and {{Cryptography Foundations}}},
  editor = {Aceto, Luca and Damg{\textbackslash}aard, Ivan and Goldberg, Leslie Ann and Halld{\'o}rsson, Magn{\'u}s M. and Ing{\'o}lfsd{\'o}ttir, Anna and Walukiewicz, Igor},
  year = {2008},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {5126},
  publisher = {Springer},
  doi = {10.1007/978-3-540-70583-3},
  isbn = {978-3-540-70582-6}
}

@misc{acetoComplexityResultsModal2023,
  title = {Complexity Results for Modal Logic with Recursion via Translations and Tableaux},
  author = {Aceto, Luca and Achilleos, Antonis and Anastasiadi, Elli and Francalanza, Adrian and Ing{\'o}lfsd{\'o}ttir, Anna},
  year = {2023},
  month = jun,
  number = {arXiv:2306.16881},
  eprint = {2306.16881},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-07-11},
  abstract = {This paper studies the complexity of classical modal logics and of their extension with fixed-point operators, using translations to transfer results across logics. In particular, we show several complexity results for multi-agent logics via translations to and from the {\textmu}-calculus and modal logic, which allow us to transfer known upper and lower bounds. We also use these translations to introduce a terminating tableau system for the logics we study, based on Kozen's tableau for the {\textmu}-calculus, and the one of Fitting and Massacci for modal logic. Finally, we show how to encode the tableaux we introduced into {\textmu}-calculus formulas. This encoding provides upper bounds for the satisfiability checking of the few logics we previously did not have algorithms for.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/I2RDFUQZ/Aceto et al. - 2023 - Complexity results for modal logic with recursion .pdf}
}

@misc{achilleosProceedingsFifteenthInternational2024,
  title = {Proceedings {{Fifteenth International Symposium}} on {{Games}}, {{Automata}}, {{Logics}}, and {{Formal Verification}}},
  author = {Achilleos, Antonis and Francalanza, Adrian},
  year = {2024},
  month = oct,
  number = {arXiv:2410.21884},
  eprint = {2410.21884},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2410.21884},
  urldate = {2024-10-30},
  abstract = {This volume contains the proceedings of GandALF 2024, the Fifteenth International Symposium on Games, Automata, Logics, and Formal Verification. GandALF 2024 took place on 19-21 June 2024, in Reykjavik, Iceland. The aim of GandALF 2024 is to bring together researchers from academia and industry who are actively working in the fields of Games, Automata, Logics, and Formal Verification. The idea is to cover an ample spectrum of themes, ranging from theory to applications, and stimulate cross-fertilization.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/TWNSM67Y/2410.html}
}

@techreport{aczelGeneralChurchRosserTheorem1978,
  title = {A General {{Church-Rosser}} Theorem},
  author = {Aczel, P.},
  year = {1978},
  institution = {University of Manchester}
}

@article{aczelUsingComputersLearn1999,
  title = {Using Computers to Learn Logic: Undergraduates' Experiences},
  author = {Aczel, J. and Fung, P. and Bornat, R. and Oliver, M. and O'Shea, T. and Sufrin, B.},
  year = {1999},
  journal = {Advanced Research in Computers and Communications in Education},
  pages = {875--882},
  publisher = {Amsterdam, IOS Press}
}

@article{adamsPureTypeSystems2005,
  title = {Pure {{Type Systems With Judgemental Equality}}},
  author = {ADAMS, R.},
  year = {2005},
  journal = {Journal of Functional Programming},
  volume = {16},
  number = {02},
  pages = {219},
  doi = {10.1017/s0956796805005770}
}

@article{adamsStronglyNormalizingComputation2016,
  title = {A {{Strongly Normalizing Computation Rule}} for {{Univalence}} in {{Higher-Order Minimal Logic}}},
  author = {Adams, R. and Bezem, M. and Coquand, T.},
  year = {2016},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@article{adiAcUnificationRaceSystem1992,
  title = {Ac-{{Unification Race}}: {{The System Solving Approach}}, {{Implementation}} and {{Benchmarks}}},
  author = {Adi, M. and Kirchner, C.},
  year = {1992},
  journal = {Journal of Symbolic Computation},
  volume = {14},
  number = {1},
  pages = {51--70},
  doi = {10.1016/0747-7171(92)90025-y}
}

@inproceedings{adjedjMartinLofCoq2024,
  title = {Martin-{{L{\"o}f}} {\`a} La {{Coq}}},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Adjedj, Arthur and {Lennon-Bertrand}, Meven and Maillard, Kenji and P{\'e}drot, Pierre-Marie and Pujet, Lo{\"i}c},
  year = {2024},
  month = jan,
  series = {{{CPP}} 2024},
  pages = {230--245},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3636501.3636951},
  urldate = {2024-05-29},
  abstract = {We present an extensive mechanization of the metatheory of Martin-L{\"o}f Type Theory (MLTT) in the Coq proof assistant. Our development builds on pre-existing work in Agda to show not only the decidability of conversion, but also the decidability of type checking, using an approach guided by bidirectional type checking. From our proof of decidability, we obtain a certified and executable type checker for a full-fledged version of MLTT with support for {$\Pi$}, {$\Sigma$}, {$\mathbb{N}$}, and Id types, and one universe. Our development does not rely on impredicativity, induction-recursion or any axiom beyond MLTT extended with indexed inductive types and a handful of predicative universes, thus narrowing the gap between the object theory and the metatheory to a mere difference in universes. Furthermore, our formalization choices are geared towards a modular development that relies on Coq's features, e.g. universe polymorphism and metaprogramming with tactics.},
  isbn = {9798400704888},
  keywords = {Bidirectional typing,Dependent type systems,Logical relations},
  file = {/home/flaviomoura/Zotero/storage/9CQAIA95/Adjedj et al. - 2024 - Martin-LÃ¶f Ã  la Coq.pdf}
}

@article{adlemanDistinguishingPrimeNumbers1983,
  title = {On Distinguishing Prime Numbers from Composite Numbers},
  author = {Adleman, L. M. and Pomerance, C. and Rumely, R. S.},
  year = {1983},
  journal = {Annals of Mathematics},
  number = {117},
  pages = {173--206}
}

@article{adlemanPrimalityTestingAbelian1992,
  title = {Primality {{Testing}} and {{Abelian Varieties}} over {{Finite Fields}}},
  author = {Adleman, L. M. and Huang, M.-D.},
  year = {1992},
  journal = {Lecture notes in Mathematics},
  number = {1512}
}

@inbook{adusei-pokuBibliographicInformationPublished2021,
  title = {Bibliographic Information Published by the {{Deutsche Nationalbibliothek}}},
  booktitle = {Taking {{Stakes}} in the {{Unknown}}},
  year = {2021},
  month = dec,
  pages = {4--4},
  publisher = {transcript Verlag},
  doi = {10.14361/9783839452943-001},
  urldate = {2021-07-13},
  collaborator = {{Adusei-Poku}, Nana},
  isbn = {978-3-8394-5294-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/RP54SB6T/2021 - Bibliographic information published by the Deutsch.pdf}
}

@article{adzicBackslashOdelNotre2016,
  title = {G\${\textbackslash}backslash\$''odel's {{Notre Dame Course}}},
  author = {Adzic, M. and Dosen, K.},
  year = {2016},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {01A60 (History of mathematics and mathematicians,03-03 (Mathematical logic and foundations,20th century),historical),Mathematics - History and Overview,Mathematics - Logic}
}

@misc{affeldtComprehensiveOverviewLebesgue2024,
  title = {A {{Comprehensive Overview}} of the {{Lebesgue Differentiation Theorem}} in {{Coq}}},
  author = {Affeldt, Reynald and Stone, Zachary},
  year = {2024},
  month = mar,
  number = {arXiv:2403.18229},
  eprint = {2403.18229},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-28},
  abstract = {Formalization of real analysis offers a chance to rebuild traditional proofs of important theorems as unambiguous theories that can be interactively explored. This paper provides a comprehensive overview of the Lebesgue Differentiation Theorem formalized in the Coq proof assistant, from which the first Fundamental Theorem of Calculus (FTC) for the Lebesgue integral is obtained as a corollary. Proving the first FTC in this way has the advantage of decomposing into loosely-coupled theories of moderate size and of independent interest that lend themselves well to incremental and collaborative development. We explain how we formalize all the topological constructs and all the standard lemmas needed to eventually relate the definitions of derivability and of Lebesgue integration of MathComp-Analysis, a formalization of analysis developed on top of the Mathematical Components library. In the course of this experiment, we substantially enrich MathComp-Analysis and even devise a new proof for Urysohn's lemma.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/CJLXRDXR/Affeldt e Stone - 2024 - A Comprehensive Overview of the Lebesgue Different.pdf;/home/flaviomoura/Zotero/storage/5I8HCZYE/2403.html}
}

@book{aggarwalNeuralNetworksDeep2018,
  title = {Neural {{Networks}} and {{Deep Learning}}},
  author = {Aggarwal, Charu C.},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-94463-0}
}

@article{agrawalPrimalityIdentityTesting2003,
  title = {Primality and {{Identity Testing}} via {{Chinese Remaindering}}},
  author = {Agrawal, Manindra and Biswas, Somenath},
  year = {2003},
  journal = {journal of the ACM},
  volume = {50},
  number = {3},
  pages = {429--443}
}

@article{agrawalPRIMES2004,
  title = {{{PRIMES}} Is in {{P}}},
  author = {Agrawal, Manindra and Kayal, Neeraj and Saxena, Nitin},
  year = {2004},
  month = sep,
  journal = {Annals of Mathematics},
  volume = {160},
  number = {2},
  pages = {781--793},
  issn = {0003-486X},
  doi = {10.4007/annals.2004.160.781},
  urldate = {2023-04-12},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ME8R7VFE/primality_journal.pdf}
}

@article{aguileraLowenheimSkolemTheoremGodel2023,
  title = {The {{L{\"o}wenheim-Skolem}} Theorem for {{G{\"o}del}} Logic},
  author = {Aguilera, J. P.},
  year = {2023},
  month = apr,
  journal = {Annals of Pure and Applied Logic},
  volume = {174},
  number = {4},
  pages = {103235},
  issn = {0168-0072},
  doi = {10.1016/j.apal.2022.103235},
  urldate = {2024-08-07},
  abstract = {We prove the following L{\"o}wenheim-Skolem theorems for first-order G{\"o}del logic:(1)For the G{\"o}del logic G[0,1], a sentence {$\phi$} has models of every infinite cardinality if and only if it has a model of cardinality â¶{$\omega$}(=supâ¡\{{$\aleph$}0,2{$\aleph$}0,{\dots}\}).(2)For an arbitrary G{\"o}del logic GT, a sentence {$\phi$} has models of every infinite cardinality if and only if it has a model of cardinality â¶{$\omega$}1. Moreover, (1) becomes false if â¶{$\omega$} is replaced by a smaller cardinality, and (2) becomes false if â¶{$\omega$}1 is replaced by a smaller cardinality.},
  keywords = {Fuzzy logic,Godel logic,Hanf number,Lowenheim-Skolem theorem},
  file = {/home/flaviomoura/Zotero/storage/BY9ZFEM4/Aguilera - 2023 - The LÃ¶wenheim-Skolem theorem for GÃ¶del logic.pdf;/home/flaviomoura/Zotero/storage/GV6PT4XN/S0168007222001506.html}
}

@book{aherLogicLanguageComputation2015,
  title = {Logic, {{Language}}, and {{Computation}} - 10th {{International Tbilisi Symposium}} on {{Logic}}, {{Language}}, and {{Computation}}, {{TbiLLC}} 2013, {{Gudauri}}, {{Georgia}}, {{September}} 23-27, 2013. {{Revised Selected Papers}}},
  editor = {Aher, M. and Hole, D. and Jer{\'a}bek, E. and Kupke, C.},
  year = {2015},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {8984},
  publisher = {Springer},
  doi = {10.1007/978-3-662-46906-4},
  isbn = {978-3-662-46905-7}
}

@book{ahoDataStructuresAlgorithms1983,
  title = {Data {{Structures}} and {{Algorithms}}},
  author = {Aho, A. V. and Hopcroft, J. E. and Ullman, J.},
  year = {1983},
  edition = {1st},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {Boston, MA, USA},
  isbn = {0-201-00023-7}
}

@inproceedings{ahrensDisplayedMonoidalCategories2024,
  title = {Displayed {{Monoidal Categories}} for the {{Semantics}} of {{Linear Logic}}},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Ahrens, Benedikt and Matthes, Ralph and {van der Weide}, Niels and Wullaert, Kobe},
  year = {2024},
  month = jan,
  series = {{{CPP}} 2024},
  pages = {260--273},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3636501.3636956},
  urldate = {2024-08-20},
  abstract = {We present a formalization of different categorical structures used to interpret linear logic. Our formalization takes place in UniMath, a library of univalent mathematics based on the Coq proof assistant.   All the categorical structures we formalize are based on monoidal categories. As such, one of our contributions is a practical, usable library of formalized results on monoidal categories. Monoidal categories carry a lot of structure, and instances of monoidal categories are often built from complicated mathematical objects. This can cause challenges of scalability, regarding both the vast amount of data to be managed by the user of the library, as well as the time the proof assistant spends on checking code. To enable scalability, and to avoid duplication of computer code in the formalization, we develop "displayed monoidal categories". These gadgets allow for the modular construction of complicated monoidal categories by building them in layers; we demonstrate their use in many examples. Specifically, we define linear-non-linear categories and construct instances of them via Lafont categories and linear categories.},
  isbn = {9798400704888},
  file = {/home/flaviomoura/Zotero/storage/NEFUR8ZN/Ahrens et al. - 2024 - Displayed Monoidal Categories for the Semantics of.pdf}
}

@book{ahrensHowTakeSmart,
  title = {{How to Take Smart Notes: One Simple Technique to Boost Writing, Learning and Thinking -- for Students, Academics and Nonfiction Book Writers}},
  shorttitle = {{How to Take Smart Notes}},
  author = {Ahrens, S{\"o}nke},
  abstract = {The key to good and efficient writing lies in the intelligent organisation of ideas and notes. This book helps students, academics and nonfiction writers to get more done, write intelligent texts and learn for the long run. It teaches you how to take smart notes and ensure they bring you and your projects forward. The Take Smart Notes principle is based on established psychological insight and draws from a tried and tested note-taking-technique. This is the first comprehensive guide and description of this system in English, and not only does it explain how it works, but also why. It suits students and academics in the social sciences and humanities, nonfiction writers and others who are in the business of reading, thinking and writing. Instead of wasting your time searching for notes, quotes or references, you can focus on what really counts: thinking, understanding and developing new ideas in writing. It does not matter if you prefer taking notes with pen and paper or on a computer, be it Windows, Mac or Linux. And you can start right away.},
  langid = {Ingl{\^e}s}
}

@article{ahrensUnivalencePrinciple2021,
  ids = {ahrensUnivalencePrinciple2021a},
  title = {The {{Univalence Principle}}},
  author = {Ahrens, Benedikt and North, Paige Randall and Shulman, Michael and Tsementzis, Dimitris},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.06275 [cs, math]},
  eprint = {2102.06275},
  primaryclass = {cs, math},
  urldate = {2021-02-15},
  abstract = {The Univalence Principle is the statement that equivalent mathematical structures are indistinguishable. We prove a general version of this principle that applies to all set-based, categorical, and higher-categorical structures defined in a non-algebraic and space-based style, as well as models of higher-order theories such as topological spaces. In particular, we formulate a general definition of indiscernibility for objects of any such structure, and a corresponding univalence condition that generalizes Rezk's completeness condition for Segal spaces and ensures that all equivalences of structures are levelwise equivalences. Our work builds on Makkai's First-Order Logic with Dependent Sorts, but is expressed in Voevodsky's Univalent Foundations (UF), extending previous work on the Structure Identity Principle and univalent categories in UF. This enables indistinguishability to be expressed simply as identification, and yields a formal theory that is interpretable in classical homotopy theory, but also in other higher topos models. It follows that Univalent Foundations is a fully equivalence-invariant foundation for higher-categorical mathematics, as intended by Voevodsky.},
  archiveprefix = {arXiv},
  keywords = {18N99 03B38 03G30 55U35,Computer Science - Logic in Computer Science,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/MI7FXERV/Ahrens et al. - 2021 - The Univalence Principle.pdf;/home/flaviomoura/Zotero/storage/SD745NNA/Ahrens et al. - 2021 - The Univalence Principle.pdf;/home/flaviomoura/Zotero/storage/3X87WXAH/2102.html;/home/flaviomoura/Zotero/storage/B8T2YAZ8/2102.html}
}

@misc{ahrensUnivalencePrinciple2022,
  title = {The {{Univalence Principle}}},
  author = {Ahrens, Benedikt and North, Paige Randall and Shulman, Michael and Tsementzis, Dimitris},
  year = {2022},
  month = aug,
  number = {arXiv:2102.06275},
  eprint = {2102.06275},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-08-31},
  abstract = {The Univalence Principle is the statement that equivalent mathematical structures are indistinguishable. We prove a general version of this principle that applies to all set-based, categorical, and higher-categorical structures defined in a non-algebraic and space-based style, as well as models of higher-order theories such as topological spaces. In particular, we formulate a general definition of indiscernibility for objects of any such structure, and a corresponding univalence condition that generalizes Rezk's completeness condition for Segal spaces and ensures that all equivalences of structures are levelwise equivalences. Our work builds on Makkai's First-Order Logic with Dependent Sorts, but is expressed in Voevodsky's Univalent Foundations (UF), extending previous work on the Structure Identity Principle and univalent categories in UF. This enables indistinguishability to be expressed simply as identification, and yields a formal theory that is interpretable in classical homotopy theory, but also in other higher topos models. It follows that Univalent Foundations is a fully equivalence-invariant foundation for higher-categorical mathematics, as intended by Voevodsky.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {18N99 03B38 03G30 55U35,Computer Science - Logic in Computer Science,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/JW6DQDPY/Ahrens et al. - 2022 - The Univalence Principle.pdf}
}

@book{aignerProofsBook2010,
  title = {Proofs from the {{Book}}},
  author = {Aigner, Martin and Ziegler, G{\"u}nter M and Hofmann, Karl H and Erdos, Paul},
  year = {2010},
  volume = {274},
  publisher = {Springer}
}

@article{akcamProblemsDualUnification2021,
  title = {On {{Problems Dual}} to {{Unification}}: {{The String-Rewriting Case}}},
  shorttitle = {On {{Problems Dual}} to {{Unification}}},
  author = {Ak{\c c}am, Z{\"u}mr{\"u}t and Hono II, Daniel S. and Narendran, Paliath and Pulver, Andrew},
  year = {2021},
  month = feb,
  journal = {arXiv:2103.00386 [cs]},
  eprint = {2103.00386},
  primaryclass = {cs},
  urldate = {2021-03-06},
  abstract = {In this paper, we investigate problems which are dual to the unification problem, namely the Fixed Point (FP) problem, Common Term (CT) problem and the Common Equation (CE) problem for string rewriting systems. Our main motivation is computing fixed points in systems, such as loop invariants in programming languages. We show that the fixed point (FP) problem is reducible to the common term problem. Our new results are: (i) the fixed point problem is undecidable for finite convergent string rewriting systems whereas it is decidable in polynomial time for finite, convergent and dwindling string rewriting systems, (ii) the common term problem is undecidable for the class of dwindling string rewriting systems, and (iii) for the class of finite, monadic and convergent systems, the common equation problem is decidable in polynomial time but for the class of dwindling string rewriting systems, common equation problem is undecidable.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/J2S5ZHU6/AkÃ§am et al. - 2021 - On Problems Dual to Unification The String-Rewrit.pdf;/home/flaviomoura/Zotero/storage/PPCZQVSF/2103.html}
}

@article{akhmedkhodjaevIntroducingTypeProperties2021,
  title = {Introducing {{Type Properties}}},
  author = {Akhmedkhodjaev, Aziz},
  year = {2021},
  month = jun,
  journal = {arXiv:2106.08470 [cs]},
  eprint = {2106.08470},
  primaryclass = {cs},
  urldate = {2021-06-17},
  abstract = {In type theory, we can express many practical ideas by attributing some additional data to expressions we operate on during compilation. For instance, some substructural type theories augment variables' typing judgments with the information of their usage. That is, they allow one to explicitly state how many times - 0, 1, or many - a variable can be used. This solves the problem of resource usage control and allows us to treat variables as resources. What's more, it often happens that this attributed information is interpreted (used) during the same compilation and erased before we run a program. A case in the point is that in the same substructural type theories, their type checkers use these 0, 1, or many, to ensure that all variables are used as many times as these attributions say them to be. Yet, there wasn't any programming language concept whose concern would be to allow a programmer to express these attributions in the language itself. That is, to let the programmer express which data the one wants to attribute to what expressions and, most importantly, the meaning of the attributed data in their program. As it turned out, the presence of such a concept allows us to express many practical ideas in the language itself. For instance, with appropriate means for assigning the meaning of these attributions, this concept would allow one to express linear types as functionality in a separate program module, without the need to refine the whole type system to add them. In this paper, we present such a concept - we propose type properties. It allows a programmer to express these attributions while fulfilling the requirement of being fully on the static level. That is, it allows one to express how to interpret these attributions during compilation and erases them before a program is passed to the runtime.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/ADKKUYJK/2106.html}
}

@article{albertTwoFirstorderLogics2020,
  title = {Two First-Order Logics of Permutations},
  author = {Albert, Michael and Bouvel, Mathilde and F{\'e}ray, Valentin},
  year = {2020},
  month = apr,
  journal = {Journal of Combinatorial Theory, Series A},
  volume = {171},
  pages = {105158},
  issn = {00973165},
  doi = {10.1016/j.jcta.2019.105158},
  urldate = {2021-02-19},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SYK9NSJL/Albert et al. - 2020 - Two first-order logics of permutations.pdf}
}

@article{allaisTypeScopeSafe2018,
  title = {A Type and Scope Safe Universe of Syntaxes with Binding: Their Semantics and Proofs},
  shorttitle = {A Type and Scope Safe Universe of Syntaxes with Binding},
  author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
  year = {2018},
  month = jul,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {ICFP},
  pages = {1--30},
  issn = {2475-1421},
  doi = {10.1145/3236785},
  urldate = {2024-04-05},
  abstract = {Almost every programming language's syntax includes a notion of binder and corresponding bound occurrences, along with the accompanying notions of {$\alpha$}-equivalence, capture avoiding substitution, typing contexts, runtime environments, and so on. In the past, implementing and reasoning about programming languages required careful handling to maintain the correct behaviour of bound variables. Modern programming languages include features that enable constraints like scope safety to be expressed in types. Nevertheless, the programmer is still forced to write the same boilerplate over again for each new implementation of a scope safe operation (e.g., renaming, substitution, desugaring, printing, etc.), and then again for correctness proofs.             We present an expressive universe of syntaxes with binding and demonstrate how to (1) implement scope safe traversals once and for all by generic programming; and (2) how to derive properties of these traversals by generic proving. Our universe description, generic traversals and proofs, and our examples have all been formalised in Agda and are available in the accompanying material.             NB. we recommend printing the paper in colour to benefit from syntax highlighting in code fragments.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/KIQB9JXP/Allais et al. - 2018 - A type and scope safe universe of syntaxes with bi.pdf}
}

@book{alleyCraftScientificPresentations2013,
  title = {The {{Craft}} of {{Scientific Presentations}}: {{Critical Steps}} to {{Succeed}} and {{Critical Errors}} to {{Avoid}}},
  author = {Alley, M.},
  year = {2013},
  edition = {2},
  publisher = {Springer-Verlag New York},
  isbn = {978-1-4419-8278-0 978-1-4419-8279-7}
}

@article{allioux2021types,
  title = {Types Are Internal Infinity-Groupoids},
  author = {Allioux, Antoine and Finster, Eric and Sozeau, Matthieu},
  year = {2021},
  file = {/home/flaviomoura/Zotero/storage/ICSV3DRQ/Allioux et al. - Types are internal infinity-groupoids.pdf}
}

@article{alliouxTypesAreInternal,
  title = {Types Are {{Internal}} {$\infty$}-Groupoids},
  author = {Allioux, Antoine and Finster, Eric and Sozeau, Matthieu},
  pages = {16},
  abstract = {By extending type theory with a universe of definitionally associative and unital polynomial monads, we show how to arrive at a definition of opetopic type which is able to encode a number of fully coherent algebraic structures. In particular, our approach leads to a definition of {$\infty$}-groupoid internal to type theory and we prove that the type of such {$\infty$}-groupoids is equivalent to the universe of types. That is, every type admits the structure of an {$\infty$}-groupoid internally, and this structure is unique.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/I2GLXI9N/Allioux et al. - Types are Internal â-groupoids.pdf}
}

@article{alliouxTypesAreInternal2021,
  title = {Types Are {{Internal}} \${\textbackslash}infty\$-{{Groupoids}}},
  author = {Allioux, Antoine and Finster, Eric and Sozeau, Matthieu},
  year = {2021},
  month = apr,
  journal = {arXiv:2105.00024 [cs, math]},
  eprint = {2105.00024},
  primaryclass = {cs, math},
  urldate = {2021-05-04},
  abstract = {By extending type theory with a universe of definitionally associative and unital polynomial monads, we show how to arrive at a definition of opetopic type which is able to encode a number of fully coherent algebraic structures. In particular, our approach leads to a definition of \${\textbackslash}infty\$-groupoid internal to type theory and we prove that the type of such \${\textbackslash}infty\$-groupoids is equivalent to the universe of types. That is, every type admits the structure of an \${\textbackslash}infty\$-groupoid internally, and this structure is unique.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/GKWHCTFY/Allioux et al. - 2021 - Types are Internal $infty$-Groupoids.pdf;/home/flaviomoura/Zotero/storage/L8HACB9D/2105.html}
}

@incollection{almeidaComputationalRelevanceFormal2019,
  title = {The {{Computational Relevance}} of {{Formal Logic Through Formal Proofs}}},
  booktitle = {Formal {{Methods Teaching}}},
  author = {Almeida, Ariane A. and {Rocha-Oliveira}, Ana Cristina and Ramos, Thiago M. Ferreira and de Moura, Fl{\'a}vio L. C. and {Ayala-Rinc{\'o}n}, Mauricio},
  year = {2019},
  series = {Formal {{Methods Teaching}}},
  pages = {81--96},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-32441-4_6}
}

@unpublished{almeidaFormalizacaoEquivalenciaEntre2016,
  ids = {almeidaFormalizacaoEquivalenciaEntre2016a},
  title = {Formaliza{\c c}{\~a}o Da {{Equival{\^e}ncia}} Entre {{Crit{\'e}rios}} de {{Termina{\c c}{\~a}o}}},
  author = {Almeida, A. A.},
  year = {2016}
}

@book{almeidaRigorousSoftwareDevelopment2011,
  title = {Rigorous {{Software Development}}},
  author = {Almeida, Jos{\'e} Bacelar and Frade, Maria Jo{\~a}o and Pinto, Jorge Sousa and de Sousa, Sim{\~a}o Melo},
  year = {2011},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  doi = {10.1007/978-0-85729-018-2}
}

@book{almeidaTtSortingPVS2016,
  title = {{\textbackslash}tt Sorting: A {{PVS}} {\textbackslash}{{emphTheory}} for {{Sorting Algorithms}}},
  author = {Almeida, A. A. and {Rocha-Oliveira}, A. C. and Ramos, T. M. F. and {de Moura}, F. L. C. and {Ayala-Rinc{\'o}n}, M.},
  year = {Last visited: September, 2016},
  publisher = {Universidade de Bras{\'i}lia},
  annotation = {Published: Available at {\textbackslash}scriptsize{\textbackslash}tt http://shemesh.larc.nasa.gov/fm/ftp/larc/PVS-library/library.html - NASA Langley Research Center PVS libraries}
}

@misc{aloupisClassicNintendoGames2015,
  title = {Classic {{Nintendo Games}} Are ({{Computationally}}) {{Hard}}},
  author = {Aloupis, Greg and Demaine, Erik D. and Guo, Alan and Viglietta, Giovanni},
  year = {2015},
  month = feb,
  number = {arXiv:1203.1895},
  eprint = {1203.1895},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1203.1895},
  urldate = {2024-08-27},
  abstract = {We prove NP-hardness results for five of Nintendo's largest video game franchises: Mario, Donkey Kong, Legend of Zelda, Metroid, and Pokemon. Our results apply to generalized versions of Super Mario Bros. 1-3, The Lost Levels, and Super Mario World; Donkey Kong Country 1-3; all Legend of Zelda games; all Metroid games; and all Pokemon role-playing games. In addition, we prove PSPACE-completeness of the Donkey Kong Country games and several Legend of Zelda games.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Computer Science and Game Theory},
  file = {/home/flaviomoura/Zotero/storage/M3RS7MHR/Aloupis et al. - 2015 - Classic Nintendo Games are (Computationally) Hard.pdf;/home/flaviomoura/Zotero/storage/UPSEFQV2/1203.html}
}

@unpublished{altenkirchAconversionEasy2002,
  title = {{$\alpha$}-Conversion Is Easy},
  author = {Altenkirch, T.},
  year = {2002},
  file = {/home/flaviomoura/Zotero/storage/XEASVDRL/Altenkirch - 2002 - Î±-conversion is easy.pdf}
}

@article{altenkirchCategoryInterpretationDirected2017,
  title = {The {{Category Interpretation}} of {{Directed Type Theory}}},
  author = {Altenkirch, Thorsten and Neumann, Jacob},
  year = {2017},
  abstract = {The field of directed type theory seeks to design type theories capable of reasoning synthetically about (higher) categories, by generalizing the symmetric identity types of Martin-L{\"o}f Type Theory to asymmetric Hom-types. So far, the main approaches to directed type theory proceed in a ``somewhat indirect'' manner: axiomatizing the directed interval type and defining the machinery of directed type theory in terms of it. In this paper, we take the first step towards a `directed homotopy type theory without the directed interval' by developing a directed analogue of Hofmann and Streicher's groupoid model---the category model. The directed type theory this models is adequate for synthetic 1-category theory; the extent to which this approach extends to higher dimensions is the subject of ongoing investigation. Moreover, since the semantics of this theory are expressed in terms of categories with families, these results promise to interface elegantly with current research into generalized algebraic theories and (higher) observational type theory.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9FXVSYP5/Altenkirch e Neumann - 2017 - The Category Interpretation of Directed Type Theor.pdf}
}

@inproceedings{altenkirchExtensionalEqualityIntensional1999,
  title = {Extensional Equality in Intensional Type Theory},
  booktitle = {Proceedings. 14th {{Symposium}} on {{Logic}} in {{Computer Science}} ({{Cat}}. {{No}}. {{PR00158}})},
  author = {Altenkirch, T.},
  year = {1999},
  month = jul,
  pages = {412--420},
  issn = {1043-6871},
  doi = {10.1109/LICS.1999.782636},
  urldate = {2024-08-22},
  abstract = {We present a new approach to introducing an extensional propositional equality in Intensional Type Theory. Our construction is based on the observation that there is a sound, intensional setoid model in Intensional Type theory with a proof-irrelevant universe of propositions and /spl eta/-rules for /spl Pi/and /spl Sigma/-types. The Type Theory corresponding to this model is decidable, has no irreducible constants and permits large eliminations, which are essential for universes.},
  keywords = {Electrical capacitance tomography,Informatics,Network address translation,Tin},
  file = {/home/flaviomoura/Zotero/storage/4NEDG7UE/Altenkirch - 1999 - Extensional equality in intensional type theory.pdf;/home/flaviomoura/Zotero/storage/QAZ3N2HW/782636.html}
}

@article{altenkirchIntroductionFormalReasoning,
  title = {Introduction to {{Formal Reasoning}} ({{COMP2065}})},
  author = {Altenkirch, Thorsten},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/EAZYIDU4/Altenkirch - Introduction to Formal Reasoning (COMP2065).pdf}
}

@article{altenkirchNormalisationEvaluationType2016,
  title = {Normalisation by {{Evaluation}} for {{Type Theory}}, in {{Type Theory}}},
  author = {Altenkirch, T. and Kaposi, A.},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,F.4.1}
}

@inproceedings{altenkirchObservationalEqualityNow2007,
  title = {Observational Equality, Now!},
  booktitle = {Proceedings of the 2007 Workshop on {{Programming}} Languages Meets Program Verification},
  author = {Altenkirch, Thorsten and McBride, Conor and Swierstra, Wouter},
  year = {2007},
  month = oct,
  pages = {57--68},
  publisher = {ACM},
  address = {Freiburg Germany},
  doi = {10.1145/1292597.1292608},
  urldate = {2023-06-23},
  abstract = {This paper has something new and positive to say about propositional equality in programming and proof systems based on the Curry-Howard correspondence between propositions and types. We have found a way to present a propositional equality type {$\bullet$} which is substitutive, allowing us to reason by replacing equal for equal in propositions; {$\bullet$} which reflects the observable behaviour of values rather than their construction: in particular, we have extensionality---functions are equal if they take equal inputs to equal outputs; {$\bullet$} which retains strong normalisation, decidable typechecking and canonicity---the property that closed normal forms inhabiting datatypes have canonical constructors; {$\bullet$} which allows inductive data structures to be expressed in terms of a standard characterisation of well-founded trees; {$\bullet$} which is presented syntactically---you can implement it directly, and we are doing so---this approach stands at the core of Epigram 2; {$\bullet$} which you can play with now: we have simulated our system by a shallow embedding in Agda 2, shipping as part of the standard examples package for that system [21].},
  isbn = {978-1-59593-677-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BAVMU3E2/Altenkirch et al. - 2007 - Observational equality, now!.pdf}
}

@article{altenkirchQuotientInductiveinductiveTypes2016,
  title = {Quotient Inductive-Inductive Types},
  author = {Altenkirch, T. and Capriotti, P. and Dijkstra, G. and Forsberg, F. Nordvall},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@misc{altenkirchShouldTypeTheory2022,
  title = {Should {{Type Theory}} Replace {{Set Theory}} as the {{Foundation}} of {{Mathematics}}},
  author = {Altenkirch, Thorsten},
  year = {2022},
  month = jun,
  number = {arXiv:2111.06368},
  eprint = {2111.06368},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-06-28},
  abstract = {We discuss why Type Theory is preferable as foundation of Mathematics compared to set theory.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/6H7VZJKV/Altenkirch - 2022 - Should Type Theory replace Set Theory as the Found.pdf;/home/flaviomoura/Zotero/storage/VAGGX3GH/Altenkirch - 2023 - Should Type Theory replace Set Theory as the Found.pdf;/home/flaviomoura/Zotero/storage/AEPWIS6X/2111.html}
}

@book{altenkirchTypesProofsPrograms2007,
  title = {Types for {{Proofs}} and {{Programs}}, {{International Workshop}}, {{TYPES}} 2006, {{Nottingham}}, {{UK}}, {{April}} 18-21, 2006, {{Revised Selected Papers}}},
  editor = {Altenkirch, Thorsten and McBride, Conor},
  year = {2007},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {4502},
  publisher = {Springer},
  isbn = {978-3-540-74463-4}
}

@unpublished{altenkirchTypeTheoryType2016,
  title = {Type {{Theory}} in {{Type Theory}}},
  author = {Altenkirch, T. and Kaposi, A.},
  year = {2016}
}

@misc{alvesExtendingQuantitativePatternMatching2024,
  title = {Extending the {{Quantitative Pattern-Matching Paradigm}}},
  author = {Alves, Sandra and Kesner, Delia and Ramos, Miguel},
  year = {2024},
  month = aug,
  number = {arXiv:2408.11007},
  eprint = {2408.11007},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2408.11007},
  urldate = {2024-08-21},
  abstract = {We show how (well-established) type systems based on non-idempotent intersection types can be extended to characterize termination properties of functional programming languages with pattern matching features. To model such programming languages, we use a (weak and closed) \${\textbackslash}lambda\$-calculus integrating a pattern matching mechanism on algebraic data types (ADTs). Remarkably, we also show that this language not only encodes Plotkin's CBV and CBN \${\textbackslash}lambda\$-calculus as well as other subsuming frameworks, such as the bang-calculus, but can also be used to interpret the semantics of effectful languages with exceptions. After a thorough study of the untyped language, we introduce a type system based on intersection types, and we show through purely logical methods that the set of terminating terms of the language corresponds exactly to that of well-typed terms. Moreover, by considering non-idempotent intersection types, this characterization turns out to be quantitative, i.e. the size of the type derivation of a term t gives an upper bound for the number of evaluation steps from t to its normal form.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.3.1,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/93QXLKKW/Alves et al. - 2024 - Extending the Quantitative Pattern-Matching Paradi.pdf;/home/flaviomoura/Zotero/storage/PIFNZ4CY/2408.html}
}

@article{alvesLinearityRoadmap2012,
  title = {Linearity: {{A Roadmap}}},
  author = {Alves, S. and Fernandez, M. and Florido, M. and Mackie, I.},
  year = {2012},
  journal = {Journal of Logic and Computation},
  volume = {24},
  number = {3},
  pages = {513--529},
  doi = {10.1093/logcom/exs020}
}

@article{alvesLinearRecursion2010,
  title = {Linear {{Recursion}}},
  author = {Alves, S. and Fern{\'a}ndez, M. and Florido, M. and Mackie, I.},
  year = {2010},
  month = jan,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.3.3,F.4.1}
}

@article{alvesMLstyleRecordCalculus2021,
  title = {An {{ML-style}} Record Calculus with Extensible Records},
  author = {Alves, Sandra and Ramos, Miguel},
  year = {2021},
  month = aug,
  journal = {arXiv:2108.06296 [cs]},
  eprint = {2108.06296},
  primaryclass = {cs},
  urldate = {2021-08-16},
  abstract = {In this work, we develop a polymorphic record calculus with extensible records. Extensible records are records that can have new fields added to them, or preexisting fields removed from them. We also develop a static type system for this calculus and a sound and complete type inference algorithm. Most ML-style polymorphic record calculi that support extensible records are based on row variables. We present an alternative construction based on the polymorphic record calculus developed by Ohori. Ohori based his polymorphic record calculus on the idea of kind restrictions. This allowed him to express polymorphic operations on records such as field selection and modification. With the addition of extensible types, we were able to extend Ohori's original calculus with other powerful operations on records such as field addition and removal.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,D.3.1,F.3.1},
  file = {/home/flaviomoura/Zotero/storage/5PJ6CC5D/Alves e Ramos - 2021 - An ML-style record calculus with extensible record.pdf}
}

@misc{alvesQuantitativeGlobalMemory2023,
  title = {Quantitative {{Global Memory}}},
  author = {Alves, Sandra and Kesner, Delia and Ramos, Miguel},
  year = {2023},
  month = mar,
  number = {arXiv:2303.08940},
  eprint = {2303.08940},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-03-20},
  abstract = {We show that recent approaches of static analysis based on quantitative typing systems can be extended to programming languages with global state. More precisely, we define a call-by-value language equipped with operations to access a global memory, together with a semantic model based on a (tight) multi-type system that captures exact measures of time and space related to evaluation of programs. We show that the type system is quantitatively sound and complete with respect to the original operational semantics of the language.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.3.1,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/BLCHMJJC/Alves et al. - 2023 - Quantitative Global Memory.pdf;/home/flaviomoura/Zotero/storage/VLFEWFWU/Alves et al. - 2023 - Quantitative Global Memory.pdf}
}

@article{amoresComplexityDecidingSyntactic2021,
  title = {Complexity of {{Deciding Syntactic Equivalence}} up to {{Renaming}} for {{Term Rewriting Systems}} ({{Extended Version}})},
  author = {Amores, Michael Christian Fink and Sabel, David},
  year = {2021},
  month = jun,
  journal = {arXiv:2106.13520 [cs]},
  eprint = {2106.13520},
  primaryclass = {cs},
  urldate = {2021-06-28},
  abstract = {Inspired by questions from program transformations, eight notions of isomorphisms between term rewriting systems are defined, analysed and classified. The notions include global isomorphisms where the renaming of variables and / or function symbols is the same for all term rewriting rules of the system, and local ones where a single renaming for every rule is used. The complexity of the underlying decision problems are analysed and either shown to be efficiently solvable or proved to be complete for the graph isomorphism complexity class.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/42VK5KUT/Amores e Sabel - 2021 - Complexity of Deciding Syntactic Equivalence up to.pdf;/home/flaviomoura/Zotero/storage/37F8EXRU/2106.html}
}

@article{amorimBindingOperatorsNominal2016,
  title = {Binding {{Operators}} for {{Nominal Sets}}},
  author = {de Amorim, Arthur Azevedo},
  year = {2016},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {325},
  number = {nil},
  pages = {3--27},
  doi = {10.1016/j.entcs.2016.09.029}
}

@article{andou2003church,
  title = {Church--{{Rosser}} Property of a Simple Reduction for Full First-Order Classical Natural Deduction},
  author = {Andou, Y},
  year = {2003},
  journal = {Annals of Pure and Applied logic},
  volume = {119},
  number = {1-3},
  pages = {225--237},
  publisher = {Elsevier}
}

@article{andouChurchRosserPropertySimple2003,
  title = {Church-{{Rosser}} Property of a Simple Reduction for Full First-Order Classical Natural Deduction},
  author = {Andou, Y.},
  year = {2003},
  journal = {Ann. Pure Appl. Logic},
  volume = {119},
  number = {1-3},
  pages = {225--237},
  doi = {10.1016/S0168-0072(02)00051-9}
}

@article{andradeguzmanNaturalDeductionSemantic2020,
  title = {Natural Deduction and Semantic Models of Justification Logic in the Proof Assistant {{Coq}}},
  author = {Andrade Guzm{\'a}n, Jes{\'u}s Mauricio and Hern{\'a}ndez Quiroz, Francisco},
  year = {2020},
  month = jun,
  journal = {Logic Journal of the IGPL},
  pages = {jzaa007},
  issn = {1367-0751, 1368-9894},
  doi = {10.1093/jigpal/jzaa007},
  urldate = {2020-07-22},
  abstract = {Abstract             The purpose of this paper is to present a formalization of the language, semantics and axiomatization of justification logic in Coq. We present proofs in a natural deduction style derived from the axiomatic approach of justification logic. Additionally, we present possible world semantics in Coq based on Fitting models to formalize the semantic satisfaction of formulas. As an important result, with this implementation, it is possible to give a proof of soundness for \${\textbackslash}mathsf\{L\}{\textbackslash}mathsf\{P\}\$ with respect to Fitting models.},
  langid = {english}
}

@article{andrettaelements,
  title = {Elements of Mathematical Logic Version of January 5, 2021},
  author = {Andretta, Alessandro}
}

@article{andrewsAutomatingHigherOrderLogic1984,
  title = {Automating {{Higher-Order Logic}}},
  author = {Andrews, P. B. and Miller, D. A. and Cohen, E. L. and Pfenning, F.},
  year = {1984},
  journal = {Contemporary Mathematics},
  volume = {29}
}

@book{andrewsIntroductionMathematicalLogic2002,
  title = {An {{Introduction}} to {{Mathematical Logic}} and {{Type Theory}}: {{To Truth Through Proof}}},
  author = {Andrews, P. B.},
  year = {2002},
  series = {Applied {{Logic Series}}},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-015-9934-4}
}

@article{andronick13thInternationalConference,
  title = {13th {{International Conference}} on {{Interactive Theorem Proving}} ({{ITP}} 2022)},
  author = {Andronick, June},
  pages = {602},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WDFHRKEJ/Andronick - 13th International Conference on Interactive Theor.pdf}
}

@article{andronickLIPIcsVolume2372022,
  title = {{{LIPIcs}}, {{Volume}} 237, {{ITP}} 2022, {{Complete Volume}}},
  author = {Andronick, June and {de Moura}, Leonardo},
  year = {2022},
  pages = {602 pages, 8195227 bytes},
  publisher = {[object Object]},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.ITP.2022},
  urldate = {2024-04-17},
  abstract = {LIPIcs, Volume 237, ITP 2022, Complete Volume},
  collaborator = {Andronick, June and {de Moura}, Leonardo},
  copyright = {Creative Commons Attribution 4.0 International license, info:eu-repo/semantics/openAccess},
  langid = {english},
  keywords = {Computing methodologies  Theorem proving algorithms,LIPIcs Volume 237 ITP 2022 Complete Volume,Software and its engineering  Formal methods,Theory of computation  Higher order logic,Theory of computation  Interactive proof systems,Theory of computation  Program reasoning},
  file = {/home/flaviomoura/Zotero/storage/4TDPBJ2R/Andronick e de Moura - 2022 - LIPIcs, Volume 237, ITP 2022, Complete Volume.pdf}
}

@article{annenkovExtractingFunctionalPrograms2021,
  title = {Extracting Functional Programs from {{Coq}}, in {{Coq}}},
  author = {Annenkov, Danil and Milo, Mikkel and Nielsen, Jakob Botsch and Spitters, Bas},
  year = {2021},
  month = aug,
  journal = {arXiv:2108.02995 [cs]},
  eprint = {2108.02995},
  primaryclass = {cs},
  urldate = {2021-08-09},
  abstract = {We implement extraction of Coq programs to functional languages based on MetaCoq's certified erasure. We extend the MetaCoq erasure output language with typing information and use it as an intermediate representation, which we call \${\textbackslash}lambda{\textasciicircum}T\_{\textbackslash}square\$. We complement the extraction functionality with a full pipeline that includes several standard transformations (eta-expansion, inlining, etc) implemented in a proof-generating manner along with a verified optimisation pass removing unused arguments. We prove the pass correct wrt. a conventional call-by-value operational semantics of functional languages. From the optimised \${\textbackslash}lambda{\textasciicircum}T\_{\textbackslash}square\$ representation, we obtain code in two functional smart contract languages (Liquidity and CameLIGO), the functional language Elm, and a subset of the multi-paradigm language for systems programming Rust. Rust is currently gaining popularity as a language for smart contracts, and we demonstrate how our extraction can be used to extract smart contract code for the Concordium network. The development is done in the context of the ConCert framework that enables smart contract verification. We contribute with two verified real-world smart contracts (boardroom voting and escrow), which we use, among other examples, to exemplify the applicability of the pipeline. In addition, we develop a verified web application and extract it to fully functional Elm code. In total, this gives us a way to write dependently typed programs in Coq, verify, and then extract them to several target languages while retaining a small trusted computing base of only MetaCoq and the pretty-printers into these languages.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/M94UVFEI/Annenkov et al. - 2021 - Extracting functional programs from Coq, in Coq.pdf;/home/flaviomoura/Zotero/storage/Q285CAT7/2108.html}
}

@article{antonelliCountingPropositionalLogic2021,
  title = {On {{Counting Propositional Logic}}},
  author = {Antonelli, Melissa and Lago, Ugo Dal and Pistone, Paolo},
  year = {2021},
  month = mar,
  journal = {arXiv:2103.12862 [cs]},
  eprint = {2103.12862},
  primaryclass = {cs},
  urldate = {2021-04-06},
  abstract = {We study counting propositional logic as an extension of propositional logic with counting quantifiers. We prove that the complexity of the underlying decision problem perfectly matches the appropriate level of Wagner's counting hierarchy, but also that the resulting logic admits a satisfactory proof-theoretical treatment. From the latter, a type system for a probabilistic lambda-calculus is derived in the spirit of the Curry-Howard correspondence, showing the potential of counting propositional logic as a useful tool in several fields of theoretical computer science.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.3.1,F.1.3,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/9GKE2G4X/Antonelli et al. - 2021 - On Counting Propositional Logic.pdf;/home/flaviomoura/Zotero/storage/5W6FNCNI/2103.html;/home/flaviomoura/Zotero/storage/65SIAXRC/2103.html}
}

@misc{antonelliRemarksCountingPropositional2022,
  title = {Some {{Remarks}} on {{Counting Propositional Logic}}},
  author = {Antonelli, Melissa},
  year = {2022},
  month = oct,
  number = {arXiv:2210.16160},
  eprint = {2210.16160},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-10-31},
  abstract = {Counting propositional logic was recently introduced in relation to randomized computation and shown able to logically characterize the full counting hierarchy [1]. In this paper we aim to clarify the intuitive meaning and expressive power of its univariate fragment. On the one hand, we provide an effective procedure to measure the probability of counting formulas. On the other, we make the connection between this logic and stochastic experiments explicit, proving that the counting language can simulate any (and only) event associated with dyadic distributions.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/9M8DRV25/Antonelli - 2022 - Some Remarks on Counting Propositional Logic.pdf}
}

@inproceedings{aotoRulebasedProcedureEquivariant2016,
  title = {A Rule-Based Procedure for Equivariant Nominal Unification},
  booktitle = {8th {{International Workshop}} on {{Higher-Order Rewriting}} - {{HOR}} 2016},
  author = {Aoto, T. and Kikuchi, K.},
  year = {2016}
}

@article{aperyConstructiveMathematics2017,
  title = {Constructive Mathematics},
  author = {Ap{\'e}ry, R.},
  year = {2017},
  month = may,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - History and Overview,Mathematics - Logic}
}

@article{apostolicoParallelDetectionAll1995,
  title = {Parallel {{Detection}} of {{All Palindromes}} in a {{String}}},
  author = {Apostolico, Alberto and Breslauer, Dany and Galil, Zvi},
  year = {1995},
  journal = {Theoretical Computer Science},
  volume = {141},
  number = {1-2},
  pages = {163--173},
  doi = {10.1016/0304-3975(94)00083-u}
}

@misc{appelEfficientExtensionalBinary2022,
  title = {Efficient {{Extensional Binary Tries}}},
  author = {Appel, Andrew W. and Leroy, Xavier},
  year = {2022},
  month = sep,
  number = {arXiv:2110.05063},
  eprint = {2110.05063},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-12-19},
  abstract = {Lookup tables (finite maps) are a ubiquitous data structure. In pure functional languages they are best represented using trees instead of hash tables. In pure functional languages within constructive logic, without a primitive integer type, they are well represented using binary tries instead of search trees.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/M7R32HVE/Appel e Leroy - 2022 - Efficient Extensional Binary Tries.pdf}
}

@article{appelEfficientVerifiedRedBlack,
  title = {Efficient {{Verified Red-Black Trees}}},
  author = {Appel, Andrew W},
  abstract = {I present a new implementation of balanced binary search trees, compatible with the MSets interface of the Coq Standard Library. Like the current Library implementation, mine is formally verified (in Coq) to be correct with respect to the MSets specification, and to be balanced (which implies asymptotic efficiency guarantees). Benchmarks show that my implementation runs significantly faster than the library implementation, because (1) Red-Black trees avoid the significant overhead of arithmetic incurred by AVL trees for balancing computations; (2) a specialized delete-min operation makes priority-queue operations much faster; and (3) dynamically choosing between three algorithms for set union/intersection leads to better asymptotic efficiency.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AN636FY4/Appel - Efï¬cient Veriï¬ed Red-Black Trees.pdf}
}

@book{AppliedProofTheory2008,
  title = {Applied {{Proof Theory}}: {{Proof Interpretations}} and {{Their Use}} in {{Mathematics}}},
  shorttitle = {Applied {{Proof Theory}}},
  year = {2008},
  series = {Springer {{Monographs}} in {{Mathematics}}},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-77533-1},
  urldate = {2023-05-29},
  isbn = {978-3-540-77532-4 978-3-540-77533-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/V59FZ8R3/2008 - Applied Proof Theory Proof Interpretations and Th.pdf}
}

@article{araiResultsCutEliminationProvable1998,
  title = {Some {{Results}} on {{Cut-Elimination}}, {{Provable Well-Orderings}}, {{Induction}} and {{Reflection}}},
  author = {Arai, Toshiyasu},
  year = {1998},
  journal = {Annals of Pure and Applied Logic},
  volume = {95},
  number = {1-3},
  pages = {93--184},
  doi = {10.1016/s0168-0072(98)00020-7}
}

@article{aravantinosDecidabilityUndecidabilityResults2011,
  title = {Decidability and {{Undecidability Results}} for {{Propositional Schemata}}},
  author = {Aravantinos, V. and Caferra, R. and Peltier, N.},
  year = {2011},
  month = mar,
  journal = {Journal of Artificial Intelligence Research},
  volume = {40},
  pages = {599--656},
  issn = {1076-9757},
  doi = {10.1613/jair.3351},
  urldate = {2024-07-29},
  abstract = {We define a logic of propositional formula schemata adding to the syntax of propositional logic indexed propositions and iterated connectives ranging over intervals parameterized by arithmetic variables.  The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable.  This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure.  This schemata calculus allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability.},
  copyright = {Copyright (c)},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IW2K86XW/Aravantinos et al. - 2011 - Decidability and Undecidability Results for Propos.pdf}
}

@inproceedings{aravantinosSchemataCalculusPropositional2009,
  title = {A {{Schemata Calculus}} for {{Propositional Logic}}},
  booktitle = {Automated {{Reasoning}} with {{Analytic Tableaux}} and {{Related Methods}}},
  author = {Aravantinos, Vincent and Caferra, Ricardo and Peltier, Nicolas},
  editor = {Giese, Martin and Waaler, Arild},
  year = {2009},
  pages = {32--46},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-02716-1_4},
  abstract = {We define a notion of formula schema handling arithmetic parameters, indexed propositional variables (e.g. Pi) and iterated conjunctions/disjunctions (e.g. \${\textbackslash}bigwedge\_\{i=1\}{\textasciicircum}n P\_i\$, where n is a parameter). Iterated conjunctions or disjunctions are part of their syntax. We define a sound and complete (w.r.t. satisfiability) tableaux-based proof procedure for this language. This schemata calculus (called stab) allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. Although the satisfiability problem is undecidable for unrestricted schemata, we identify a class of them for which stab always terminates. An example shows evidence that the approach is applicable to non-trivial practical problems. We give some precise technical hints to pursue the present work.},
  isbn = {978-3-642-02716-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/UN8UAX2R/hal-00940671.html}
}

@phdthesis{arbiserExplicitSubstitutionSystems2005,
  title = {Explicit {{Substitution Systems}} and {{Subsystems}}},
  author = {Arbiser, A.},
  year = {2005},
  school = {Universidad de Buenos Aires}
}

@inproceedings{arbiserLambdaCalculusConstructors2006,
  title = {A {{Lambda-Calculus}} with {{Constructors}}},
  booktitle = {Term {{Rewriting}} and {{Applications}}},
  author = {Arbiser, Ariel and Miquel, Alexandre and R{\'i}os, Alejandro},
  editor = {Pfenning, Frank},
  year = {2006},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {181--196},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/11805618_14},
  abstract = {We present an extension of the {$\lambda$}({$\eta$})-calculus with a case construct that propagates through functions like a head linear substitution, and show that this construction permits to recover the expressiveness of ML-style pattern matching. We then prove that this system enjoys the Church-Rosser property using a semi-automatic `divide and conquer' technique by which we determine all the pairs of commuting subsystems of the formalism (considering all the possible combinations of the nine primitive reduction rules). Finally, we prove a separation theorem similar to B{\"o}hm's theorem for the whole formalism.},
  isbn = {978-3-540-36835-9},
  langid = {english},
  keywords = {Critical Pair,Normal Form,Operational Semantic,Reduction Rule,Separation Theorem},
  file = {/home/flaviomoura/Zotero/storage/PLARPPWE/Arbiser et al. - 2006 - A Lambda-Calculus with Constructors.pdf}
}

@article{archambault-bouffardImplementationExplicitSubstitutions,
  title = {Implementation of {{Explicit Substitutions}}: From {$\Lambda\sigma$} to the {{Suspension Calculus}}},
  author = {{Archambault-Bouffard}, Vincent and Monnier, Stefan},
  abstract = {Explicit substitutions are an important tool for the efficient implementation of the normalization of terms in programs that manipulate data with binders, such as theorem provers or type checkers. We explore here the design space between the {$\lambda\sigma$}-calculus [Abadi et al. 1991] and the suspension-calculus [Nadathur and Wilson 1998] by showing how to go from one to the other, in various small steps. This gives an intuition about the performance advantages of the suspension-calculus as well as provides various alternatives.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DZ58F2R3/Archambault-Bouffard e Monnier - Implementation of Explicit Substitutions from Î»Ï .pdf}
}

@article{ariasJsCoqHybridTheorem2017,
  title = {{{jsCoq}}: {{Towards Hybrid Theorem Proving Interfaces}}},
  shorttitle = {{{jsCoq}}},
  author = {Arias, Emilio Jes{\'u}s Gallego and Pin, Beno{\^i}t and Jouvelot, Pierre},
  year = {2017},
  month = jan,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {239},
  eprint = {1701.07125},
  pages = {15--27},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.239.2},
  urldate = {2020-08-23},
  abstract = {We describe jsCcoq, a new platform and user environment for the Coq interactive proof assistant. The jsCoq system targets the HTML5-ECMAScript 2015 specification, and it is typically run inside a standards-compliant browser, without the need of external servers or services. Targeting educational use, jsCoq allows the user to start interaction with proof scripts right away, thanks to its self-contained nature. Indeed, a full Coq environment is packed along the proof scripts, easing distribution and installation. Starting to use jsCoq is as easy as clicking on a link. The current release ships more than 10 popular Coq libraries, and supports popular books such as Software Foundations or Certified Programming with Dependent Types. The new target platform has opened up new interaction and display possibilities. It has also fostered the development of some new Coq-related technology. In particular, we have implemented a new serialization-based protocol for interaction with the proof assistant, as well as a new package format for library distribution.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Human-Computer Interaction,Computer Science - Logic in Computer Science,Computer Science - Machine Learning,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/HYVNW435/Arias et al. - 2017 - jsCoq Towards Hybrid Theorem Proving Interfaces.pdf;/home/flaviomoura/Zotero/storage/DT676HAZ/1701.html}
}

@inproceedings{ariolaMinimalClassicalLogic2003,
  title = {Minimal {{Classical Logic}} and {{Control Operators}}},
  booktitle = {Thirtieth {{International Colloquium}} on {{Automata}}, {{Languages}} and {{Programming}}, {{ICALP}} '03, {{Eindhoven}}, {{The Netherlands}}, {{June}} 30 - {{July}} 4, 2003},
  author = {Ariola, Z. M. and Herbelin, H.},
  year = {2003},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {2719},
  pages = {871--885},
  publisher = {Springer},
  isbn = {3-540-40493-7}
}

@article{ariolaSequentCalculiAbstract2009,
  title = {Sequent Calculi and Abstract Machines},
  author = {Ariola, Zena M. and Bohannon, Aaron and Sabry, Amr},
  year = {2009},
  month = may,
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {31},
  number = {4},
  pages = {13:1--13:48},
  issn = {0164-0925},
  doi = {10.1145/1516507.1516508},
  urldate = {2024-06-10},
  abstract = {We propose a sequent calculus derived from the {$\lambda$}{\texthorizontalbar}{$\mu\mu$}{\texttildelow}-calculus of Curien and Herbelin that is expressive enough to directly represent the fine details of program evaluation using typical abstract machines. Not only does the calculus easily encode the usual components of abstract machines such as environments and stacks, but it can also simulate the transition steps of the abstract machine with just a constant overhead. Technically this is achieved by ensuring that reduction in the calculus always happens at a bounded depth from the root of the term. We illustrate these properties by providing shallow encodings of the Krivine (call-by-name) and the CEK (call-by-value) abstract machines in the calculus.},
  keywords = {Curry-Howard isomorphism,duality,explicit substitutions,Krivine machine,natural deduction},
  file = {/home/flaviomoura/Zotero/storage/4NHN2YPL/Ariola et al. - 2009 - Sequent calculi and abstract machines.pdf}
}

@incollection{arndtEmptinessDischargeSequent2014,
  title = {Emptiness and {{Discharge}} in {{Sequent Calculus}} and {{Natural Deduction}}},
  booktitle = {Recent {{Trends}} in {{Philosophical Logic}}},
  author = {Arndt, Michael and Tranchini, Luca},
  editor = {Ciuni, Roberto and Wansing, Heinrich and Willkommen, Caroline},
  year = {2014},
  volume = {41},
  pages = {13--29},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-06080-4_2},
  urldate = {2023-06-07},
  isbn = {978-3-319-06079-8 978-3-319-06080-4},
  langid = {english}
}

@book{aroraComputationalComplexityModern2009,
  title = {Computational {{Complexity}}: {{A Modern Approach}}},
  author = {Arora, S. and Barak, B.},
  year = {2009},
  edition = {1st},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {0-521-42426-7 978-0-521-42426-4},
  file = {/home/flaviomoura/Zotero/storage/D5WNE3S9/Arora e Barak - 2009 - Computational Complexity A Modern Approach.pdf}
}

@inproceedings{arrialGenericityStratification2024,
  title = {Genericity {{Through Stratification}}},
  booktitle = {Proceedings of the 39th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Arrial, Victor and Guerrieri, Giulio and Kesner, Delia},
  year = {2024},
  month = jul,
  pages = {1--15},
  publisher = {ACM},
  address = {Tallinn Estonia},
  doi = {10.1145/3661814.3662113},
  urldate = {2024-09-04},
  isbn = {9798400706608},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/H3SNY449/Arrial et al. - 2024 - Genericity Through Stratification.pdf}
}

@article{artsTerminationTermRewriting2000,
  title = {Termination of {{Term Rewriting Using Dependency Pairs}}},
  author = {Arts, T. and Giesl, J.},
  year = {2000},
  journal = {Theoretical Computer Science},
  volume = {236},
  number = {1-2},
  pages = {133--178},
  doi = {10.1016/s0304-3975(99)00207-8}
}

@article{asadaAlmostEverySimply2018,
  title = {Almost {{Every Simply Typed Lambda-Term Has}} a {{Long Beta-Reduction Sequence}}},
  author = {Asada, Kazuyuki and Kobayashi, Naoki and Sin'ya, Ryoma and Tsukada, Takeshi},
  year = {2018},
  journal = {CoRR},
  abstract = {It is well known that the length of a beta-reduction sequence of a simply typed lambda-term of order k can be huge; it is as large as k-fold exponential in the size of the lambda-term in the worst case. We consider the following relevant question about quantitative properties, instead of the worst case: how many simply typed lambda-terms have very long reduction sequences? We provide a partial answer to this question, by showing that asymptotically almost every simply typed lambda-term of order k has a reduction sequence as long as (k-1)-fold exponential in the term size, under the assumption that the arity of functions and the number of variables that may occur in every subterm are bounded above by a constant. To prove it, we have extended the infinite monkey theorem for strings to a parametrized one for regular tree languages, which may be of independent interest. The work has been motivated by quantitative analysis of the complexity of higher-order model checking.}
}

@misc{aschenbrennerNormalizationTheoremAsymptotic2024,
  title = {A {{Normalization Theorem}} in {{Asymptotic Differential Algebra}}},
  author = {Aschenbrenner, Matthias and van den Dries, Lou and {van der Hoeven}, Joris},
  year = {2024},
  month = mar,
  number = {arXiv:2403.19732},
  eprint = {2403.19732},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2024-04-04},
  abstract = {We define the universal exponential extension of an algebraically closed differential field and investigate its properties in the presence of a nice valuation and in connection with linear differential equations. Next we prove normalization theorems for algebraic differential equations over \$H\$-fields, as a tool in solving such equations in suitable extensions. The results in this monograph are essential in our work on Hardy fields in [6].},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Classical Analysis and ODEs,Mathematics - Commutative Algebra,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/63TXHVH5/Aschenbrenner et al. - 2024 - A Normalization Theorem in Asymptotic Differential.pdf;/home/flaviomoura/Zotero/storage/PBGQKEX3/2403.html}
}

@article{aschieriBackslashOdelLogic2016,
  title = {G\${\textbackslash}backslash\$``odel {{Logic}}: From {{Natural Deduction}} to {{Parallel Computation}}},
  author = {Aschieri, F. and Ciabattoni, A. and Genco, F. A.},
  year = {2016},
  month = jul,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@article{aschieriNaturalDeductionHerbrand2016,
  title = {On {{Natural Deduction}} for {{Herbrand Constructive Logics I}}: {{Curry-Howard Correspondence}} for {{Dummett}}'s {{Logic LC}}},
  author = {Aschieri, F.},
  year = {2016},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@article{aschieriNaturalDeductionHerbrand2016a,
  title = {On {{Natural Deduction}} for {{Herbrand Constructive Logics II}}: {{Curry-Howard Correspondence}} for {{Markov}}'s {{Principle}} in {{First-Order Logic}} and {{Arithmetic}}},
  author = {Aschieri, F. and Manighetti, M.},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic}
}

@article{aspertiCostUsageLcalculus,
  title = {The Cost of Usage in the {$\lambda$}-Calculus},
  author = {Asperti, Andrea and Levy, Jean-Jacques and {Paris-Rocquencourt}, {\relax INRIA} and Chesnay, Le},
  pages = {8},
  abstract = {A new ``inductive'' approach to standardization for the {$\lambda$}-calculus has been recently introduced by Xi, allowing him to establish a double-exponential upper bound {\textbar}M {\textbar}2{\textbar}{$\sigma\vert$} for the length of the standard reduction relative to an arbitrary reduction {$\sigma$} originated in M . In this paper we refine Xi's analysis, obtaining much better bounds, especially for computations producing small normal forms. For instance, for terms reducing to a boolean, we are able to prove that the length of the standard reduction is at most a mere factorial of the length of the shortest reduction sequence. The methodological innovation of our approach is that instead to try to count the cost for producing something, as customary, we count the cost of consuming things. The key observation is that the part of a {$\lambda$}-term that is needed to produce the normal form (or an arbitrary rigid prefix) may rapidly augment along a computation, but can only decrease very slowly (actually, linearly).},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BCR9IIXF/Asperti et al. - The cost of usage in the Î»-calculus.pdf}
}

@inproceedings{aspertiTypeSystemsDummies2012,
  title = {Type Systems for Dummies},
  booktitle = {Proceedings of {{TLDI}} 2012: {{The Seventh ACM SIGPLAN Workshop}} on {{Types}} in {{Languages Design}} and {{Implementation}}, {{Philadelphia}}, {{PA}}, {{USA}}, {{Saturday}}, {{January}} 28, 2012},
  author = {Asperti, Andrea and Guidi, Ferruccio},
  year = {2012},
  pages = {79--90},
  doi = {10.1145/2103786.2103797}
}

@article{aspertiZenArtFormalisation2011,
  title = {Zen and the Art of Formalisation},
  author = {Asperti, Andrea and Avigad, Jeremy},
  year = {2011},
  month = aug,
  journal = {Mathematical Structures in Computer Science},
  volume = {21},
  number = {4},
  pages = {679--682},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129511000065},
  urldate = {2023-10-04},
  abstract = {N. G. de Bruijn, now professor emeritus of the Eindhoven University of Technology, was a pioneer in the field of interactive theorem proving. From 1967 to the end of the 1970's, his work on the Automath system introduced the architecture that is common to most of today's proof assistants, and much of the basic technology. But de Bruijn was a mathematician first and foremost, as evidenced by the many mathematical notions and results that bear his name, among them de Bruijn sequences, de Bruijn graphs, the de Bruijn--Newman constant, and the de Bruijn--Erd{\"o}s theorem. The quotation above is thus interesting not because it is a reflection on his expertise in formal verification, but, rather, of his convictions as a working mathematician.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IN95CA6U/Asperti e Avigad - 2011 - Zen and the art of formalisation.pdf}
}

@unpublished{assafUntypedConfluenceDependent2017,
  title = {Untyped {{Confluence In Dependent Type Theories}}},
  author = {Assaf, A. and Dowek, G. and Jouannaud, J. and Liu, J.},
  year = {2017},
  month = apr,
  keywords = {confluence,critical pairs,decreasing diagrams.,Higher-order rewriting modulo,Patterns,polymorphic universes,Type theory}
}

@article{atseriasAutomatingResolutionNpHard2019,
  title = {Automating {{Resolution Is Np-Hard}}},
  author = {Atserias, Albert and M{\"u}ller, Moritz},
  year = {2019},
  journal = {CoRR},
  abstract = {We show that the problem of finding a Resolution refutation that is at most polynomially longer than a shortest one is NP-hard. In the parlance of proof complexity, Resolution is not automatizable unless P = NP. Indeed, we show it is NP-hard to distinguish between formulas that have Resolution refutations of polynomial length and those that do not have subexponential length refutations. This also implies that Resolution is not automatizable in subexponential time or quasi-polynomial time unless NP is included in SUBEXP or QP, respectively.}
}

@article{audebaudProofsRandomizedAlgorithms2009,
  title = {Proofs of {{Randomized Algorithms}} in {{Coq}}},
  author = {Audebaud, P. and {Paulin-Mohring}, C.},
  year = {2009},
  journal = {Science of Computer Programming},
  volume = {74},
  number = {8},
  pages = {568--589},
  doi = {10.1016/j.scico.2007.09.002}
}

@article{augustssonVerseCalculusCore2023,
  title = {The {{Verse Calculus}}: {{A Core Calculus}} for {{Deterministic Functional Logic Programming}}},
  shorttitle = {The {{Verse Calculus}}},
  author = {Augustsson, Lennart and Breitner, Joachim and Claessen, Koen and Jhala, Ranjit and Peyton Jones, Simon and Shivers, Olin and Steele Jr., Guy L. and Sweeney, Tim},
  year = {2023},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {ICFP},
  pages = {417--447},
  issn = {2475-1421},
  doi = {10.1145/3607845},
  urldate = {2024-09-06},
  abstract = {Functional logic languages have a rich literature, but it is tricky    to give them a satisfying semantics. In this paper we describe the    Verse calculus, VC, a new core calculus for deterministic functional    logic programming. Our main contribution is to equip VC with a    small-step rewrite semantics, so that we can reason    about a VC program in the same way as one does with lambda    calculus; that is, by applying successive rewrites to it.    We also show that the rewrite system is confluent for well-behaved terms.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NQ36UWRD/Augustsson et al. - 2023 - The Verse Calculus A Core Calculus for Determinis.pdf}
}

@article{avelarFirstorderUnificationPVS2014,
  title = {First-Order Unification in the {{PVS}} Proof Assistant},
  author = {Avelar, A. B. and Galdino, A. L. and de Moura, F. L. C. and {Ayala-Rinc{\'o}n}, Mauricio},
  year = {2014},
  journal = {Logic Journal of the IGPL},
  volume = {22},
  number = {5},
  pages = {758--789},
  doi = {10.1093/jigpal/jzu012}
}

@inproceedings{avelarFormalizationTheoremExistence2011,
  title = {A {{Formalization}} of the {{Theorem}} of {{Existence}} of {{First-Order Most General Unifiers}}},
  booktitle = {Proceedings 6th {{Workshop}} on {{Logical}} and {{Semantic Frameworks}} with {{Applications}}, {{LSFA}} 2011, {{Belo Horizonte}}, {{Brazil}}, 27 {{August}} 2011.},
  author = {Avelar, A. B. and Galdino, A. L. and de Moura, F. L. C. and {Ayala-Rinc{\'o}n}, M.},
  year = {2011},
  pages = {63--78},
  doi = {10.4204/EPTCS.81.5}
}

@inproceedings{avelarVerificationCompletenessUnification2010,
  title = {Verification of the {{Completeness}} of {{Unification Algorithms}} {\`a} La {{Robinson}}},
  booktitle = {Proc. 17th {{Workshop}} on {{Logic}}, {{Language}}, {{Information}} and {{Computation}} ({{WoLLIC}} 2010)},
  author = {Avelar, A. B. and de Moura, F. L. C. and Galdino, A. L. and {Ayala-Rinc{\'o}n}, M.},
  year = {2010},
  series = {{{LNAI}}},
  volume = {6188},
  pages = {110--124}
}

@misc{avigadAnatomyFormalProof2024,
  title = {Anatomy of a {{Formal Proof}}},
  author = {Avigad, Jeremy and Commelin, Johan and Macbeth, Heather and Topaz, Adam},
  year = {2024},
  month = nov,
  number = {arXiv:2411.11885},
  eprint = {2411.11885},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2411.11885},
  urldate = {2024-11-21},
  abstract = {Interactive proof assistants make it possible for ordinary mathematicians to write definitions and theorems in a formal proof language, like a programming language, so that a computer can parse them and check them against the rules of a formal axiomatic foundation. This article describes the experience of working with a proof assistant and considers the impact the technology will have on mathematics.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - History and Overview},
  file = {/home/flaviomoura/Zotero/storage/UCSV9TE3/Avigad et al. - 2024 - Anatomy of a Formal Proof.pdf;/home/flaviomoura/Zotero/storage/FMGJIT9L/2411.html}
}

@book{avigadClassicalConstructiveLogic2000,
  title = {Classical and Constructive Logic},
  author = {Avigad, J.},
  year = {2000},
  annotation = {Published: {\textbackslash}tt https://www.andrew.cmu.edu/user/avigad/Teaching/classical.pdf},
  file = {/home/flaviomoura/Zotero/storage/GYR56XH2/Avigad - 2000 - Classical and constructive logic.pdf}
}

@article{avigadFormallyVerifiedMathematics2014,
  title = {Formally Verified Mathematics},
  author = {Avigad, Jeremy and Harrison, John},
  year = {2014},
  month = apr,
  journal = {Communications of the ACM},
  volume = {57},
  number = {4},
  pages = {66--75},
  issn = {0001-0782},
  doi = {10.1145/2591012},
  urldate = {2021-12-27},
  abstract = {With the help of computational proof assistants, formal verification could become the new standard for rigor in mathematics.},
  file = {/home/flaviomoura/Zotero/storage/8MQ9ZBEQ/Avigad e Harrison - 2014 - Formally verified mathematics.pdf}
}

@article{avigadFormallyVerifiedProof2007,
  title = {A Formally Verified Proof of the Prime Number Theorem},
  author = {Avigad, Jeremy and Donnelly, Kevin and Gray, David and Raff, Paul},
  year = {2007},
  month = dec,
  journal = {ACM Transactions on Computational Logic},
  volume = {9},
  number = {1},
  pages = {2--es},
  issn = {1529-3785},
  doi = {10.1145/1297658.1297660},
  urldate = {2021-12-27},
  abstract = {The prime number theorem, established by Hadamard and de la Vall{\'e}e Poussin independently in 1896, asserts that the density of primes in the positive integers is asymptotic to 1/ln x. Whereas their proofs made serious use of the methods of complex analysis, elementary proofs were provided by Selberg and Erd{\"o}s in 1948. We describe a formally verified version of Selberg's proof, obtained using the Isabelle proof assistant.},
  keywords = {formal verification,Prime number theorem},
  file = {/home/flaviomoura/Zotero/storage/6FGUJVWA/Avigad et al. - 2007 - A formally verified proof of the prime number theo.pdf}
}

@article{avigadFoundations2020,
  ids = {avigadFoundations2021},
  title = {Foundations},
  author = {Avigad, Jeremy},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.09541 [cs, math]},
  eprint = {2009.09541},
  primaryclass = {cs, math},
  urldate = {2020-09-24},
  abstract = {This is a draft of a chapter on mathematical logic and foundations for an upcoming handbook of computational proof assistants.},
  archiveprefix = {arXiv},
  keywords = {68V15 (Primary) 03-01 03B35 (Secondary),Computer Science - Logic in Computer Science,F.4.1,I.2.3,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/8HYNJH7T/Avigad - 2021 - Foundations.pdf;/home/flaviomoura/Zotero/storage/DK3EB832/Avigad - 2020 - Foundations.pdf;/home/flaviomoura/Zotero/storage/F3DAT6EV/2009.html;/home/flaviomoura/Zotero/storage/PFRYC85H/2009.html}
}

@book{avigadInteractiveTheoremProving2018,
  title = {Interactive {{Theorem Proving}} - 9th {{International Conference}}, {{ITP}} 2018, {{Held}} as {{Part}} of the {{Federated Logic Conference}}, {{FloC}} 2018, {{Oxford}}, {{UK}}, {{July}} 9-12, 2018, {{Proceedings}}},
  editor = {Avigad, Jeremy and Mahboubi, Assia},
  year = {2018},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {10895},
  publisher = {Springer},
  doi = {10.1007/978-3-319-94821-8},
  isbn = {978-3-319-94820-1}
}

@book{avigadLogicComputation2002,
  title = {Logic and {{Computation}}},
  author = {Avigad, J.},
  year = {2002},
  annotation = {Published: {\textbackslash}tt https://www.andrew.cmu.edu/user/avigad/Teaching/landc\_notes.pdf},
  file = {/home/flaviomoura/Zotero/storage/L6EALXYB/Avigad - 2002 - Logic and Computation.pdf}
}

@book{avigadMathematicalLogicComputation2022,
  title = {Mathematical {{Logic}} and {{Computation}}},
  author = {Avigad, Jeremy},
  year = {2022},
  month = sep,
  edition = {1},
  publisher = {Cambridge University Press},
  doi = {10.1017/9781108778756},
  urldate = {2023-11-21},
  abstract = {This new book on mathematical logic by Jeremy Avigad gives a thorough introduction to the fundamental results and methods of the subject from the syntactic point of view, emphasizing logic as the study of formal languages and systems and their proper use. Topics include proof theory, model theory, the theory of computability, and axiomatic foundations, with special emphasis given to aspects of mathematical logic that are fundamental to computer science, including deductive systems, constructive logic, the simply typed lambda calculus, and type-theoretic foundations. Clear and engaging, with plentiful examples and exercises, it is an excellent introduction to the subject for graduate students and advanced undergraduates who are interested in logic in mathematics, computer science, and philosophy, and an invaluable reference for any practicing logician's bookshelf.},
  isbn = {978-1-108-77875-6 978-1-108-47875-5 978-1-108-72084-7}
}

@misc{avigadMathematicsFormalTurn2023,
  title = {Mathematics and the Formal Turn},
  author = {Avigad, Jeremy},
  year = {2023},
  month = nov,
  number = {arXiv:2311.00007},
  eprint = {2311.00007},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2023-11-07},
  abstract = {Since the early twentieth century, it has been understood that mathematical definitions and proofs can be represented in formal systems systems with precise grammars and rules of use. Building on such foundations, computational proof assistants now make it possible to encode mathematical knowledge in digital form. This article enumerates some of the ways that these and related technologies can help us do mathematics.},
  archiveprefix = {arXiv},
  keywords = {03B35 68V20 (Primary) 68Q60 68V15 68V25 68V35 68T01 97U50 (Secondary),Mathematics - History and Overview,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/IGBAMDT6/Avigad - 2023 - Mathematics and the formal turn.pdf;/home/flaviomoura/Zotero/storage/JUSP95SI/2311.html}
}

@article{awodeyInductiveTypesHomotopy2012,
  title = {Inductive Types in Homotopy Type Theory},
  author = {Awodey, S. and Gambino, N. and Sojakova, K.},
  year = {2012},
  month = jan,
  journal = {ArXiv e-prints},
  keywords = {03B15,03B70,03F50,Computer Science - Logic in Computer Science,Mathematics - Logic}
}

@article{awodeyNaturalModelsHomotopy2014,
  title = {Natural Models of Homotopy Type Theory},
  author = {Awodey, S.},
  year = {2014},
  month = jun,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Category Theory,Mathematics - Logic}
}

@article{awodeyPropositionHomotopyType2017,
  title = {A Proposition Is the (Homotopy) Type of Its Proofs},
  author = {Awodey, S.},
  year = {2017},
  month = jan,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Logic}
}

@book{axlerLinearAlgebraDone2014,
  title = {Linear {{Algebra Done Right}}},
  author = {Axler, Sheldon},
  year = {2014},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-11080-6}
}

@unpublished{ayala-rinconAppliedLogicComputer2016,
  title = {Applied {{Logic}} for {{Computer Scientists}} - Computational Deduction and Formal Proofs},
  author = {{Ayala-Rinc{\'o}n}, M. and de Moura, F. L. C.},
  year = {2016},
  file = {/home/flaviomoura/Zotero/storage/G7G2M8Q7/Ayala-RincÃ³n e Moura - 2016 - Applied Logic for Computer Scientists - computatio.pdf}
}

@book{ayala-rinconAppliedLogicComputer2017,
  title = {Applied {{Logic}} for {{Computer Scientists}} - {{Computational Deduction}} and {{Formal Proofs}}},
  author = {{Ayala-Rinc{\'o}n}, M. and de Moura, F. L. C.},
  year = {2017},
  series = {{{UTCS}}},
  publisher = {Springer},
  isbn = {978-3-319-51653-0},
  file = {/home/flaviomoura/Zotero/storage/2MR9XDE8/Ayala-RincÃ³n e Moura - 2017 - Applied Logic for Computer Scientists - Computatio.pdf;/home/flaviomoura/Zotero/storage/W8BTKQXZ/alcs-authorcopy.pdf}
}

@article{ayala-rinconApplyingLambdaS_e2003,
  ids = {ayala-rinconApplyingLambdaStyle2003a},
  title = {On {{Applying}} the \${\textbackslash}lambda S\_e\$-{{Style}} of {{Unification}} for {{Simply-Typed Higher Order Unification}} in the {{Pure}} Lambda {{Calculus}}.},
  author = {{Ayala-Rinc{\'o}n}, M. and Kamareddine, F.},
  year = {2003},
  journal = {Matem{\'a}tica Contempor{\^a}nea},
  volume = {24},
  pages = {1--22}
}

@article{ayala-rinconCertifiedFirstOrderACUnification,
  title = {Certified {{First-Order AC-Unification}} and {{Applications}}},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and Fern{\'a}ndez, Maribel and Silva, Gabriel Ferreira and Kutsia, Temur and {Nantes-Sobrinho}, Daniele},
  abstract = {AC-unification, i.e., unification modulo Associativity and Commutativity axioms is a key component in rewrite-based programming languages and theorem provers. We have used the PVS proof assistant to specify Stickel's pioneering AC-unification algorithm and proved it to be terminating (using an elaborate lexicographic measure based on Fages' termination proof), sound, and complete. We give a detailed account of the formalisation, including descriptions of the main steps in the proofs of termination, soundness, and completeness; the files that were created along with their hierarchy and size; and a discussion about our design choices, including the consequences of our choice for the grammar of terms. We also discuss applications of the certified AC-unification algorithm, showing how the formalisation could be used as a starting point to formalise more efficient ACunification algorithms or to test implementations of AC-unification algorithms. This formalisation has been used to obtain a certified nominal AC-matching algorithm. Also, it could serve as a basis to specify a nominal AC-unification algorithm once this open theoretical problem is solved.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7Q29CARS/Ayala-RincÃ³n et al. - Certified First-Order AC-Unification and Applicati.pdf}
}

@article{ayala-rinconCheckingOverlapsNominal2016,
  title = {Checking {{Overlaps}} of {{Nominal Rewriting Rules}}},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and Fern{\'a}ndez, Maribel and Gabbay, Murdoch James and {Rocha-Oliveira}, Ana Cristina},
  year = {2016},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {323},
  pages = {39--56},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2016.06.004},
  abstract = {Nominal rewriting generalises first-order rewriting by providing support for the specification of binding operators. In this paper, we give sufficient conditions for (local) confluence of closed nominal rewriting theories, based on the analysis of rule overlaps. More precisely, we show that closed nominal rewriting rules where all proper critical pairs are joinable are locally confluent. We also show how to refine the notion of rule overlap to derive confluence of the closed rewriting relation. The conditions that we define are easy to check using a nominal unification algorithm.},
  keywords = {binding,confluence,nominal syntax,rewriting}
}

@article{ayala-rinconComparingCalculiExplicit2002,
  title = {Comparing {{Calculi}} of {{Explicit Substitutions}} with {{Eta-reduction}}},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and De Moura, Fl{\'a}vio L.C. and Kamareddine, Fairouz},
  year = {2002},
  month = oct,
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {67},
  pages = {76--95},
  issn = {15710661},
  doi = {10.1016/S1571-0661(04)80542-5},
  urldate = {2023-09-08},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/L2G666HI/main.pdf}
}

@article{ayala-rinconComparingImplementingCalculi2005,
  title = {Comparing and Implementing Calculi of Explicit Substitutions with Eta-Reduction},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and De Moura, Fl{\'a}vio L.C. and Kamareddine, Fairouz},
  year = {2005},
  month = jun,
  journal = {Annals of Pure and Applied Logic},
  volume = {134},
  number = {1},
  pages = {5--41},
  issn = {01680072},
  doi = {10.1016/j.apal.2004.06.009},
  urldate = {2023-09-08},
  abstract = {The past decade has seen an explosion of work on calculi of explicit substitutions. Numerous works have illustrated the usefulness of these calculi for practical notions like the implementation of typed functional programming languages and higher order proof assistants. It has also been shown that eta-reduction is useful for adapting substitution calculi for practical problems like higher order unification. This paper concentrates on rewrite rules for eta-reduction in three different styles of explicit substitution calculi: {$\lambda\sigma$} , {$\lambda$}se and the suspension calculus. Both {$\lambda\sigma$} and {$\lambda$}se when extended with eta-reduction rules, have proved useful for solving higher order unification. We enlarge the suspension calculus with an adequate eta-reduction rule which we show to preserve termination and confluence of the associated substitution calculus and to correspond to the eta rules of the other two calculi. We prove that {$\lambda\sigma$} and {$\lambda$}se as well as {$\lambda\sigma$} and the suspension calculus are non-comparable while {$\lambda$}se is more adequate than the suspension calculus in simulating one-step beta-reduction.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/KBX2HJCT/Ayala-RincÃ³n et al. - 2005 - Comparing and implementing calculi of explicit sub.pdf}
}

@article{ayala-rinconCompletenessPvsNominal2016,
  title = {Completeness in {{Pvs}} of a {{Nominal Unification Algorithm}}},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and Fern{\'a}ndez, Maribel and {Rocha-Oliveira}, Ana Cristina},
  year = {2016},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {323},
  number = {nil},
  pages = {57--74},
  doi = {10.1016/j.entcs.2016.06.005}
}

@inproceedings{ayala-rinconComputationalDeductionFormal2013,
  title = {Computational {{Deduction}} and {{Formal Proofs Logic}} for {{Computation}} That Is Truly {{Computational}}},
  booktitle = {8th {{Colombian Conference}} on {{Computation}} - {{8CCC}}},
  author = {{Ayala-Rinc{\'o}n}, M. and de Moura, F. L. C.},
  year = {2013}
}

@unpublished{ayala-rinconFormalisationNominalAequivalence2016,
  title = {A {{Formalisation}} of {{Nominal}} {$\alpha$}-Equivalence with {{A}} and {{AC Function Symbols}}},
  author = {{Ayala-Rinc{\'o}n}, M. and {Carvalho-Segundo}, W. and Fern{\'a}ndez, M. and {Nantes-Sobrinho}, D.},
  year = {2016}
}

@book{ayala-rinconFundamentosProgramacaoLogica2014,
  title = {Fundamentos Da {{Programa{\c c}{\~a}o L{\'o}gica}} e {{Funcional}} - {{O}} Princ{\'i}pio de {{Resolu{\c c}{\~a}o}} e a {{Teoria}} de {{Reescrita}}},
  author = {{Ayala-Rinc{\'o}n}, M. and de Moura, F. L. C.},
  year = {2014},
  publisher = {Universidade de Bras{\'i}lia},
  file = {/home/flaviomoura/Zotero/storage/WH98XV27/Ayala-RincÃ³n e Moura - 2014 - Fundamentos da ProgramaÃ§Ã£o LÃ³gica e Funcional - O .pdf}
}

@book{ayala-rinconInteractiveTheoremProving2017,
  title = {Interactive {{Theorem Proving}} - 8th {{International Conference}}, {{ITP}} 2017, {{Bras{\'i}lia}}, {{Brazil}}, {{September}} 26-29, 2017, {{Proceedings}}},
  editor = {{Ayala-Rinc{\'o}n}, Mauricio and Mu{\~n}oz, C{\'e}sar A.},
  year = {2017},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {10499},
  publisher = {Springer},
  doi = {10.1007/978-3-319-66107-0},
  isbn = {978-3-319-66106-3}
}

@article{ayala-rinconNominalSyntaxPermutation2020,
  title = {On {{Nominal Syntax}} and {{Permutation Fixed Points}}},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and Fern{\'a}ndez, Maribel and {Nantes-Sobrinho}, Daniele},
  year = {2020},
  month = feb,
  journal = {Logical Methods in Computer Science},
  volume = {Volume 16, Issue 1},
  publisher = {Episciences.org},
  issn = {1860-5974},
  doi = {10.23638/LMCS-16(1:19)2020},
  urldate = {2024-06-03},
  abstract = {We propose a new axiomatisation of the alpha-equivalence relation for nominal terms, based on a primitive notion of fixed-point constraint. We show that the standard freshness relation between atoms and terms can be derived from the more primitive notion of permutation fixed-point, and use this result to prove the correctness of the new \${\textbackslash}alpha\$-equivalence axiomatisation. This gives rise to a new notion of nominal unification, where solutions for unification problems are pairs of a fixed-point context and a substitution. Although it may seem less natural than the standard notion of nominal unifier based on freshness constraints, the notion of unifier based on fixed-point constraints behaves better when equational theories are considered: for example, nominal unification remains finitary in the presence of commutativity, whereas it becomes infinitary when unifiers are expressed using freshness contexts. We provide a definition of \${\textbackslash}alpha\$-equivalence modulo equational theories that take into account A, C and AC theories. Based on this notion of equivalence, we show that C-unification is finitary and we provide a sound and complete C-unification algorithm, as a first step towards the development of nominal unification modulo AC and other equational theories with permutative properties.},
  file = {/home/flaviomoura/Zotero/storage/BU4C6APK/Ayala-RincÃ³n et al. - 2020 - On Nominal Syntax and Permutation Fixed Points.pdf}
}

@article{ayala-rinconPrototypingTimeSpace2006,
  title = {Prototyping {{Time}} and {{Space Efficient Computations}} of {{Algebraic Operations}} over {{Dynamically Reconfigurable Systems Modeled}} by {{Rewriting-Logic}}},
  author = {{Ayala-Rinc{\'o}n}, M. and Llanos, C. and Jacobi, R. P. and Hartenstein, R.},
  year = {2006},
  journal = {ACM Transactions on Design Automation of Electronic Systems},
  volume = {11},
  number = {2},
  pages = {251--281}
}

@article{ayala-rinconUnificationLambdaS_e2001,
  ids = {ayala-rinconUnificationLambdaStyle2001a},
  title = {Unification via the \${\textbackslash}lambda S\_e\$-{{Style}} of {{Explicit Substitution}}},
  author = {{Ayala-Rinc{\'o}n}, M. and Kamareddine, F.},
  year = {2001},
  journal = {The Logical Journal of the IGPL},
  volume = {9},
  number = {4},
  pages = {489--523}
}

@article{aydemirEngineeringFormalMetatheory2008,
  title = {Engineering {{Formal Metatheory}}},
  author = {Aydemir, B. and Chargu{\'e}raud, A. and Pierce, B. C. and Pollack, R. and Weirich, S.},
  year = {2008},
  journal = {ACM SIGPLAN Notices},
  volume = {43},
  number = {1},
  pages = {3},
  doi = {10.1145/1328897.1328443},
  file = {/home/flaviomoura/Zotero/storage/RE6BY385/Aydemir et al. - 2008 - Engineering Formal Metatheory.pdf}
}

@misc{aydemirMechanizedMetatheoryMasses2005,
  title = {Mechanized {{Metatheory}} for the {{Masses}}: {{The PoplMark Challenge}}},
  author = {Aydemir, Brian E. and Bohannon, Aaron and Fairbairn, Matthew and Foster, J. Nathan and Pierce, Benjamin C. and Sewell, Peter and Vytiniotis, Dimitrios and Washburn, Geoffrey and Weirich, Stephanie and Zdancewic, Steve},
  year = {2005},
  howpublished = {https://www.seas.upenn.edu/ plclub/poplmark/poplmark.pdf}
}

@article{ayhanWhatMeaningProofs2021,
  title = {What Is the {{Meaning}} of {{Proofs}}?: {{A Fregean Distinction}} in {{Proof-Theoretic Semantics}}},
  shorttitle = {What Is the {{Meaning}} of {{Proofs}}?},
  author = {Ayhan, Sara},
  year = {2021},
  month = jun,
  journal = {Journal of Philosophical Logic},
  volume = {50},
  number = {3},
  pages = {571--591},
  issn = {0022-3611, 1573-0433},
  doi = {10.1007/s10992-020-09577-2},
  urldate = {2023-03-23},
  abstract = {Abstract             The origins of proof-theoretic semantics lie in the question of what constitutes the meaning of the logical connectives and its response: the rules of inference that govern the use of the connective. However, what if we go a step further and ask about the meaning of a proof as a whole? In this paper we address this question and lay out a framework to distinguish sense and denotation of proofs. Two questions are central here. First of all, if we have two (syntactically) different derivations, does this always lead to a difference, firstly, in sense, and secondly, in denotation? The other question is about the relation between different kinds of proof systems (here: natural deduction vs. sequent calculi) with respect to this distinction. Do the different forms of representing a proof necessarily correspond to a difference in how the inferential steps are given? In our framework it will be possible to identify denotation as well as sense of proofs not only within one proof system but also between different kinds of proof systems. Thus, we give an account to distinguish a mere syntactic divergence from a divergence in meaning and a divergence in meaning from a divergence of proof objects analogous to Frege's distinction for singular terms and sentences.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/KP6PQIHL/Ayhan - 2021 - What is the Meaning of Proofs A Fregean Distinct.pdf}
}

@book{baaderTermRewritingEm1998,
  title = {Term {{Rewriting}} and {\textbackslash}em {{All That}}},
  author = {Baader, F. and Nipkow, T.},
  year = {1998},
  publisher = {Cambridge University Press},
  file = {/home/flaviomoura/Zotero/storage/B8KTZTMG/Baader and Nipkow - 1998 - Term Rewriting and em All That.pdf}
}

@book{baaseComputerAlgorithmsIntroduction1999,
  title = {Computer {{Algorithms}}: {{Introduction}} to {{Design}} and {{Analysis}}},
  author = {Baase, S. and Gelder, A. V.},
  year = {1999},
  edition = {3rd},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {Boston, MA, USA},
  isbn = {0-201-61244-5}
}

@article{baazCuteliminationRedundancyeliminationResolution2000,
  title = {Cut-Elimination and {{Redundancy-elimination}} by {{Resolution}}},
  author = {Baaz, Matthias and Leitsch, Alexander},
  year = {2000},
  month = feb,
  journal = {Journal of Symbolic Computation},
  volume = {29},
  number = {2},
  pages = {149--176},
  issn = {0747-7171},
  doi = {10.1006/jsco.1999.0359},
  urldate = {2024-07-13},
  abstract = {A new cut-elimination method for Gentzen's LK is defined. First cut-elimination is generalized to the problem of redundancy-elimination. Then the elimination of redundancy in LK-proofs is performed by a resolution method in the following way. A set of clauses C is assigned to an LK-proof {$\psi$} and it is shown that C is always unsatisfiable. A resolution refutation of C then serves as a skeleton of an LK-proof {$\psi\prime$} with atomic cuts;{$\psi\prime$} can be constructed from the resolution proof and {$\psi$} by a projection method. In the final step the atomic cuts are eliminated and a cut-free proof is obtained. The complexity of the method is analyzed and it is shown that a non-elementary speed-up over Gentzen's method can be achieved. Finally an application to automated deduction is presented: it is demonstrated how informal proofs (containing pseudo-cuts) can be transformed into formal ones by the method of redundancy-elimination; moreover, the method can even be used to transform incorrect proofs into correct ones.},
  file = {/home/flaviomoura/Zotero/storage/X3UDWFIR/Baaz and Leitsch - 2000 - Cut-elimination and Redundancy-elimination by Resolution.pdf}
}

@misc{baazGoedelLogicsPrenex2024,
  title = {Goedel Logics: {{Prenex}} Fragments},
  shorttitle = {Goedel Logics},
  author = {Baaz, Matthias and Gamsakhurdia, Mariami},
  year = {2024},
  month = jul,
  number = {arXiv:2407.16683},
  eprint = {2407.16683},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2407.16683},
  urldate = {2024-07-25},
  abstract = {In this paper, we provide a complete classification for the first-order Goedel logics concerning the property that the formulas admit logically equivalent prenex normal forms. We show that the only first-order Goedel logics that admit such prenex forms are those with finite truth value sets since they allow all quantifier-shift rules and the logic \$G\_{\textbackslash}uparrow\$ with only one accumulation point at 1 in the infinite truth value set. In all the other cases, there are generally no logically equivalent prenex normal forms. We will also see that \$G\_{\textbackslash}uparrow\$ is the intersection of all finite first-order Goedel logics. The second part of this paper investigates the existence of effective equivalence between the validity of a formula and the validity of some prenex normal form. The existence of such a normal form is obvious for finite valued Goedel logic and \$G\_{\textbackslash}uparrow\$. Goedel logics with an uncountable truth value set admit the prenex normal forms if and only if every surrounding of 0 is uncountable or 0 is an isolated point. Otherwise, uncountable Goedel logics are not recursively enumerable, however, the prenex fragment is always recursively enumerable. Therefore, there is no effective translation between the valid formula and the valid prenex normal form. However, the existence of effectively constructible validity equivalent prenex forms for the countable case is still up for debate.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/INXUUVD4/Baaz and Gamsakhurdia - 2024 - Goedel logics Prenex fragments.pdf;/home/flaviomoura/Zotero/storage/4NP5FKAX/2407.html}
}

@inproceedings{baazNoteComplexityClassical2015,
  title = {A {{Note}} on the {{Complexity}} of {{Classical}} and {{Intuitionistic Proofs}}},
  booktitle = {2015 30th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Baaz, Matthias and Leitsch, Alexander and Reis, Giselle},
  year = {2015},
  month = jul,
  pages = {657--666},
  issn = {1043-6871},
  doi = {10.1109/LICS.2015.66},
  urldate = {2024-07-06},
  abstract = {We show an effective cut-free variant of Glivenko's theorem extended to formulas with weak quantifiers: "There is an elementary function f such that if {$\varphi$} is a cut-free LK proof of {$\vdash$} A with symbol complexity {$\leq$} c, then there exists a cut-free LJ proof of {$\vdash$} â¯ â¯ A with symbol complexity {$\leq$} f(c)". This follows from the more general result: "There is an elementary function f such that if {$\varphi$} is a cut-free LK proof of A {$\vdash$} with symbol complexity {$\leq$} c, then there exists a cut-free LJ proof of A {$\vdash$} with symbol complexity {$\leq$} f(c)". The result is proved using a suitable variant of cut-elimination by resolution (CERES) and subsumption.},
  keywords = {Calculus,classical logic,complexity,Complexity theory,Computer science,Context,Geometry,Glivenko's theorem,intuitionistic logic,Merging},
  file = {/home/flaviomoura/Zotero/storage/ZCC45WLS/Baaz et al. - 2015 - A Note on the Complexity of Classical and Intuitio.pdf;/home/flaviomoura/Zotero/storage/MFKTBU4G/7174920.html}
}

@inproceedings{baazShortProofsTautologies1994,
  title = {Short Proofs of Tautologies Using the Schema of Equivalence},
  booktitle = {Computer {{Science Logic}}},
  author = {Baaz, Matthias and Zach, Richard},
  editor = {B{\"o}rger, Egon and Gurevich, Yuri and Meinke, Karl},
  year = {1994},
  pages = {33--35},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/BFb0049322},
  abstract = {It is shown how the schema of equivalence can be used to obtain short proofs of tautologies A, where the depth of proofs is linear in the number of variables in A.},
  isbn = {978-3-540-48599-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/D8Z9BXW2/Baaz and Zach - 1994 - Short proofs of tautologies using the schema of eq.pdf}
}

@article{backStructuredDerivationsUnified2010,
  title = {Structured Derivations: A Unified Proof Style for Teaching Mathematics},
  shorttitle = {Structured Derivations},
  author = {Back, Ralph-Johan},
  year = {2010},
  month = sep,
  journal = {Formal Aspects of Computing},
  volume = {22},
  number = {5},
  pages = {629--661},
  issn = {0934-5043, 1433-299X},
  doi = {10.1007/s00165-009-0136-5},
  urldate = {2023-02-10},
  abstract = {Structured derivations were introduced by Back and von Wright as an extension of the calculational proof style originally proposed by E. W. Dijkstra and his colleagues. Structured derivations added nested subderivations and inherited assumptions to this style. This paper introduces further extensions of the structured derivation format, and gives a precise syntax and semantics for the extended proof style. The extensions provide a unification of the three main proof styles used in mathematics today: Hilbert-style forward chaining proofs, Gentzen-style backward chaining proofs and algebraic derivations and calculations (in particular, Dijkstra's calculational proof style). Each of these proof styles can now be directly presented as a structured derivation. Even more importantly, the three proof styles can be freely intermixed in a single structured derivation, allowing different proof styles to be used in different parts of the derivation, each time choosing the proof style that is most suitable for the (sub)problem at hand. We describe here (extended) structured derivations, feature by feature, and illustrate each feature with examples. We show how to model the three main proof styles as structured derivations. We give an exact syntax for structured derivations and define their semantics by showing how a structured derivation can be automatically translated into an equivalent Gentzen-style sequent calculus derivation. Structured derivations have been primarily developed for teaching mathematics at the secondary and tertiary education level. The syntax of structured derivations determines the general structure of the proof, but does not impose any restrictions on how the basic notions of the underlying mathematical domain are treated. Hence, the style can be used for any kind of proofs, calculations, derivations, and general problem solving found in mathematics education at these levels. The precise syntax makes it easy to provide computer support for structured derivations.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WK5R5RLW/Back - 2010 - Structured derivations a unified proof style for .pdf}
}

@inproceedings{baeldeCombiningDeductionModulo2012,
  title = {Combining {{Deduction Modulo}} and {{Logics}} of {{Fixed-Point Definitions}}},
  booktitle = {2012 27th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Baelde, David and Nadathur, Gopalan},
  year = {2012},
  month = jun,
  pages = {105--114},
  issn = {1043-6871},
  doi = {10.1109/LICS.2012.22},
  abstract = {Inductive and coinductive specifications are widely used in formalizing computational systems. Such specifications have a natural rendition in logics that support fixed-point definitions. Another useful formalization device is that of recursive specifications. These specifications are not directly complemented by fixed-point reasoning techniques and, correspondingly, do not have to satisfy strong monotonicity restrictions. We show how to incorporate a rewriting capability into logics of fixed-point definitions towards additionally supporting recursive specifications. Specifically, we describe a natural deduction calculus that adds a form of "closed-world'' equality - a key ingredient to supporting fixed-point definitions - to deduction modulo, a framework for extending a logic with a rewriting layer operating on formulas. We show that our calculus enjoys strong normalizability when the rewrite system satisfies general properties and we demonstrate its usefulness in specifying and reasoning about syntax-based descriptions. Our integration of closed-world equality into deduction modulo is based on an elimination principle for this form of equality that, for the first time, allows us to require finiteness of proofs without sacrificing stability under reduction.},
  keywords = {Calculus,closed-world equality,Cognition,Context,deduction modulo,Educational institutions,fixed-point and recursive definitions,Semantics,Standards,strong normalizability,Syntactics},
  file = {/home/flaviomoura/Zotero/storage/ZAGQ7RUU/Baelde e Nadathur - 2012 - Combining Deduction Modulo and Logics of Fixed-Poi.pdf;/home/flaviomoura/Zotero/storage/L796VUY6/6280429.html}
}

@article{bagossyEncodingLambdaCalculus2024,
  title = {An Encoding of the \$\${\textbackslash}lambda \$\$-Calculus in the {{String MultiSet Rewriting}} Calculus},
  author = {Bagossy, Attila and Batty{\'a}nyi, P{\'e}ter},
  year = {2024},
  month = mar,
  journal = {Acta Informatica},
  issn = {1432-0525},
  doi = {10.1007/s00236-024-00456-w},
  urldate = {2024-03-15},
  abstract = {In this paper, we present an encoding of the \$\${\textbackslash}lambda \$\$-calculus in a multiset rewriting system and provide a few applications of the construction. For this purpose, we choose the calculus named String MultiSet Rewriting, which was introduced in Barbuti et al. (Electron Notes Theor Comput Sci 194:19--34, 2008) by Barbuti et al. With the help of our encoding, we give alternative proofs for the standardization and the finiteness of developments theorems in the \$\${\textbackslash}lambda \$\$-calculus.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DW2TYRYU/Bagossy e BattyÃ¡nyi - 2024 - An encoding of the $$lambda $$-calculus in the St.pdf}
}

@article{bahramiComputationalLogicBiomedicine2020,
  title = {Computational {{Logic}} for {{Biomedicine}} and {{Neurosciences}}},
  author = {Bahrami, Abdorrahim and {de Maria}, Elisabetta and Despeyroux, Joelle and Felty, Amy and Li{\'o}, Pietro and Olarte, Carlos},
  year = {2020},
  month = jul,
  journal = {arXiv:2007.07571 [cs, q-bio]},
  eprint = {2007.07571},
  primaryclass = {cs, q-bio},
  urldate = {2020-07-16},
  abstract = {We advocate here the use of computational logic for systems biology, as a {\textbackslash}emph\{unified and safe\} framework well suited for both modeling the dynamic behaviour of biological systems, expressing properties of them, and verifying these properties. The potential candidate logics should have a traditional proof theoretic pedigree (including either induction, or a sequent calculus presentation enjoying cut-elimination and focusing), and should come with certified proof tools. Beyond providing a reliable framework, this allows the correct encodings of our biological systems. \% For systems biology in general and biomedicine in particular, we have so far, for the modeling part, three candidate logics: all based on linear logic. The studied properties and their proofs are formalized in a very expressive (non linear) inductive logic: the Calculus of Inductive Constructions (CIC). The examples we have considered so far are relatively simple ones; however, all coming with formal semi-automatic proofs in the Coq system, which implements CIC. In neuroscience, we are directly using CIC and Coq, to model neurons and some simple neuronal circuits and prove some of their dynamic properties. \% In biomedicine, the study of multi omic pathway interactions, together with clinical and electronic health record data should help in drug discovery and disease diagnosis. Future work includes using more automatic provers. This should enable us to specify and study more realistic examples, and in the long term to provide a system for disease diagnosis and therapy prognosis.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Quantitative Biology - Quantitative Methods},
  file = {/home/flaviomoura/Zotero/storage/SA7KGA66/Bahrami et al. - 2020 - Computational Logic for Biomedicine and Neuroscien.pdf;/home/flaviomoura/Zotero/storage/3G7JT38E/2007.html}
}

@book{bakComplexAnalysis2010,
  title = {Complex {{Analysis}}},
  author = {Bak, Joseph and Newman, Donald J.},
  year = {2010},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4419-7288-0}
}

@article{balabonski2021strong,
  title = {A Strong Call-by-Need Calculus},
  author = {Balabonski, Thibaut and Lanco, Antoine and Melquiond, Guillaume},
  year = {2021},
  file = {/home/flaviomoura/Zotero/storage/XV9HYV3B/Balabonski et al. - A strong call-by-need calculus.pdf}
}

@article{balabonskiFoundationsStrongCall2017,
  title = {Foundations of Strong Call by Need},
  author = {Balabonski, Thibaut and Barenbaum, Pablo and Bonelli, Eduardo and Kesner, Delia},
  year = {2017},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {1},
  number = {ICFP},
  pages = {1--29},
  issn = {2475-1421},
  doi = {10.1145/3110264},
  urldate = {2021-04-30},
  abstract = {We present a call-by-need strategy for computing strong normal forms of open terms (reduction is admitted inside the body of abstractions and substitutions, and the terms may contain free variables), which guarantees that arguments are only evaluated when needed and at most once. The strategy is shown to be complete with respect to               {$\beta$}               -reduction to strong normal form. The proof of completeness relies on two key tools: (1) the definition of a strong call-by-need calculus where reduction may be performed inside any context, and (2) the use of non-idempotent intersection types. More precisely, terms admitting a               {$\beta$}               -normal form in pure lambda calculus are typable, typability implies (weak) normalisation in the strong call-by-need calculus, and weak normalisation in the strong call-by-need calculus implies normalisation in the strong call-by-need strategy. Our (strong) call-by-need strategy is also shown to be conservative over the standard (weak) call-by-need.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/59KPXZKV/Balabonski et al. - 2017 - Foundations of strong call by need.pdf}
}

@misc{balcoCompletenessNominalPROPs2022,
  title = {Completeness of {{Nominal PROPs}}},
  author = {Balco, Samuel and Kurz, Alexander},
  year = {2022},
  month = nov,
  number = {arXiv:2004.08380},
  eprint = {2004.08380},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-11-04},
  abstract = {We introduce nominal string diagrams as string diagrams internal in the category of nominal sets. This leads us to define nominal PROPs and nominal monoidal theories. We show that the categories of ordinary PROPs and nominal PROPs are equivalent. This equivalence is then extended to symmetric monoidal theories and nominal monoidal theories, which allows us to transfer completeness results between ordinary and nominal calculi for string diagrams.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4NJ8XUHW/Balco e Kurz - 2022 - Completeness of Nominal PROPs.pdf}
}

@article{baldanFixpointTheoryUpside2021,
  title = {Fixpoint {{Theory}} -- {{Upside Down}}},
  author = {Baldan, Paolo and Eggert, Richard and K{\"o}nig, Barbara and Padoan, Tomasso},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.08184 [cs]},
  eprint = {2101.08184},
  primaryclass = {cs},
  urldate = {2021-01-21},
  abstract = {Knaster-Tarski's theorem, characterising the greatest fixpoint of a monotone function over a complete lattice as the largest post-fixpoint, naturally leads to the so-called coinduction proof principle for showing that some element is below the greatest fixpoint (e.g., for providing bisimilarity witnesses). The dual principle, used for showing that an element is above the least fixpoint, is related to inductive invariants. In this paper we provide proof rules which are similar in spirit but for showing that an element is above the greatest fixpoint or, dually, below the least fixpoint. The theory is developed for non-expansive monotone functions on suitable lattices of the form \${\textbackslash}mathbb\{M\}{\textasciicircum}Y\$, where \$Y\$ is a finite set and \${\textbackslash}mathbb\{M\}\$ an MV-algebra, and it is based on the construction of (finitary) approximations of the original functions. We show that our theory applies to a wide range of examples, including termination probabilities, behavioural distances for probabilistic automata and bisimilarity. Moreover, quite interestingly, it allows us to determine original algorithms for solving simple stochastic games.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.3.1,G.3},
  file = {/home/flaviomoura/Zotero/storage/CQIGNDHQ/Baldan et al. - 2021 - Fixpoint Theory -- Upside Down.pdf;/home/flaviomoura/Zotero/storage/VYGUXIHX/2101.html}
}

@misc{baldanFixpointTheoryUpside2023,
  title = {Fixpoint {{Theory}} -- {{Upside Down}}},
  author = {Baldan, Paolo and Eggert, Richard and K{\"o}nig, Barbara and Padoan, Tommaso},
  year = {2023},
  month = apr,
  number = {arXiv:2101.08184},
  eprint = {2101.08184},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-20},
  abstract = {Knaster-Tarski's theorem, characterising the greatest fixpoint of a monotone function over a complete lattice as the largest post-fixpoint, naturally leads to the so-called coinduction proof principle for showing that some element is below the greatest fixpoint (e.g., for providing bisimilarity witnesses). The dual principle, used for showing that an element is above the least fixpoint, is related to inductive invariants. In this paper we provide proof rules which are similar in spirit but for showing that an element is above the greatest fixpoint or, dually, below the least fixpoint. The theory is developed for non-expansive monotone functions on suitable lattices of the form MY , where Y is a finite set and M an MV-algebra, and it is based on the construction of (finitary) approximations of the original functions. We show that our theory applies to a wide range of examples, including termination probabilities, metric transition systems, behavioural distances for probabilistic automata and bisimilarity. Moreover it allows us to determine original algorithms for solving simple stochastic games.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,F.3.1,G.3},
  file = {/home/flaviomoura/Zotero/storage/VHN25ELN/Baldan et al. - 2023 - Fixpoint Theory -- Upside Down.pdf}
}

@article{balestrieriHilbertTenthProblem2021,
  title = {Hilbert's {{Tenth Problem}} and the {{Inverse Galois Problem}}},
  author = {Balestrieri, Francesca and Park, Jennifer and Shlapentokh, Alexandra},
  year = {2021},
  month = jun,
  journal = {arXiv:2007.13047 [math]},
  eprint = {2007.13047},
  primaryclass = {math},
  urldate = {2021-06-08},
  abstract = {Let \$L\$ be a global field or a function field over a number field. We show that the inverse Galois problems over \$L\$ is Turing reducible to Hilbert's tenth problem over some subrings \$R\$ of \$L\$. In some cases, using results of Dittmann, we can take \$R=L\$.},
  archiveprefix = {arXiv},
  keywords = {11U05 (Primary) 12F12 12L05 (Secondary),Mathematics - Logic,Mathematics - Number Theory},
  file = {/home/flaviomoura/Zotero/storage/7K5TYWDC/2007.html}
}

@inproceedings{balseInvestigatingPotentialGPT32023,
  title = {Investigating the {{Potential}} of {{GPT-3}} in {{Providing Feedback}} for {{Programming Assessments}}},
  booktitle = {Proceedings of the 2023 {{Conference}} on {{Innovation}} and {{Technology}} in {{Computer Science Education V}}. 1},
  author = {Balse, Rishabh and Valaboju, Bharath and Singhal, Shreya and Warriem, Jayakrishnan Madathil and Prasad, Prajish},
  year = {2023},
  month = jun,
  pages = {292--298},
  publisher = {ACM},
  address = {Turku Finland},
  doi = {10.1145/3587102.3588852},
  urldate = {2023-07-04},
  isbn = {9798400701382},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/QQ4THF27/Balse et al. - 2023 - Investigating the Potential of GPT-3 in Providing .pdf}
}

@article{baltagTopologicalMuCalculusCompleteness2021,
  title = {The {{Topological Mu-Calculus}}: Completeness and Decidability},
  shorttitle = {The {{Topological Mu-Calculus}}},
  author = {Baltag, Alexandru and Bezhanishvili, Nick and {Fern{\'a}ndez-Duque}, David},
  year = {2021},
  month = may,
  journal = {arXiv:2105.08231 [cs]},
  eprint = {2105.08231},
  primaryclass = {cs},
  urldate = {2021-06-10},
  abstract = {We study the topological \${\textbackslash}mu\$-calculus, based on both Cantor derivative and closure modalities, proving completeness, decidability and FMP over general topological spaces, as well as over \$T\_0\$ and \$T\_D\$ spaces. We also investigate relational \${\textbackslash}mu\$-calculus, providing general completeness results for all natural fragments of \${\textbackslash}mu\$-calculus over many different classes of relational frames. Unlike most other such proofs for \${\textbackslash}mu\$-calculus, ours is model-theoretic, making an innovative use of a known Modal Logic method (--the 'final' submodel of the canonical model), that has the twin advantages of great generality and essential simplicity.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/KGI9WSAK/2105.html}
}

@incollection{barbeauPellEquationPythagorean2003,
  title = {Pell's {{Equation}} and {{Pythagorean Triples}}},
  booktitle = {Pell's {{Equation}}},
  author = {Barbeau, Edward J.},
  editor = {Barbeau, Edward J.},
  year = {2003},
  series = {Problem {{Books}} in {{Mathematics}}},
  pages = {81--91},
  publisher = {Springer},
  address = {New York, NY},
  doi = {10.1007/0-387-22602-8_6},
  urldate = {2024-03-01},
  abstract = {As we have seen in Chapter 1, Pell's equation comes up in situations requiring integer solutions to quadratic equations. One well-known equation is that of Pythagoras, x2 + y2 = z2; this is closely related to Pell's equation. We continue an investigation begun in Section 1.3.},
  isbn = {978-0-387-22602-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/UWPAB6GD/Barbeau - 2003 - Pellâs Equation and Pythagorean Triples.pdf}
}

@book{barbosaEducacaoNovasTecnologias2020,
  title = {Educa{\c c}{\~a}o e {{Novas Tecnologias}}},
  author = {Barbosa, Rita Cristina and de Andrade, Vivian Galdino},
  year = {2020}
}

@article{barenbaumConstructiveLogicClassical2021,
  title = {A {{Constructive Logic}} with {{Classical Proofs}} and {{Refutations}} ({{Extended Version}})},
  author = {Barenbaum, Pablo and Freund, Teodoro},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.04589 [cs]},
  eprint = {2104.04589},
  primaryclass = {cs},
  urldate = {2021-04-16},
  abstract = {We study a conservative extension of classical propositional logic distinguishing between four modes of statement: a proposition may be affirmed or denied, and it may be strong or classical. Proofs of strong propositions must be constructive in some sense, whereas proofs of classical propositions proceed by contradiction. The system, in natural deduction style, is shown to be sound and complete with respect to a Kripke semantics. We develop the system from the perspective of the propositions-as-types correspondence by deriving a term assignment system with confluent reduction. The proof of strong normalization relies on a translation to System F with Mendler-style recursion.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/A2QXBQKV/Barenbaum e Freund - 2021 - A Constructive Logic with Classical Proofs and Ref.pdf;/home/flaviomoura/Zotero/storage/I3B8EEYD/Barenbaum e Freund - A Constructive Logic with Classical Proofs and Ref.pdf;/home/flaviomoura/Zotero/storage/NRJLQ48A/2104.html}
}

@inproceedings{barenbaumConstructiveLogicClassical2021a,
  title = {A {{Constructive Logic}} with {{Classical Proofs}} and {{Refutations}}},
  booktitle = {2021 36th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}})},
  author = {Barenbaum, Pablo and Freund, Teodoro},
  year = {2021},
  month = jun,
  pages = {1--13},
  doi = {10.1109/LICS52264.2021.9470649},
  urldate = {2024-04-30},
  abstract = {We study a conservative extension of classical propositional logic distinguishing between four modes of statement: a proposition may be affirmed or denied, and it may be strong or classical. Proofs of strong propositions must be constructive in some sense, whereas proofs of classical propositions proceed by contradiction. The system, in natural deduction style, is shown to be sound and complete with respect to a Kripke semantics. We develop the system from the perspective of the propositions-as-types correspondence by deriving a term assignment system with confluent reduction. The proof of strong normalization relies on a translation to System F with Mendler-style recursion.},
  keywords = {Calculus,Cognition,Computational modeling,Computer science,Encoding,Focusing,Semantics},
  file = {/home/flaviomoura/Zotero/storage/H6I4NEJP/9470649.html}
}

@misc{barenbaumConstructiveLogicClassical2021b,
  title = {A {{Constructive Logic}} with {{Classical Proofs}} and {{Refutations}} ({{Extended Version}})},
  author = {Barenbaum, Pablo and Freund, Teodoro},
  year = {2021},
  month = apr,
  number = {arXiv:2104.04589},
  eprint = {2104.04589},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2104.04589},
  urldate = {2024-04-30},
  abstract = {We study a conservative extension of classical propositional logic distinguishing between four modes of statement: a proposition may be affirmed or denied, and it may be strong or classical. Proofs of strong propositions must be constructive in some sense, whereas proofs of classical propositions proceed by contradiction. The system, in natural deduction style, is shown to be sound and complete with respect to a Kripke semantics. We develop the system from the perspective of the propositions-as-types correspondence by deriving a term assignment system with confluent reduction. The proof of strong normalization relies on a translation to System F with Mendler-style recursion.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/RXI6GZGK/Barenbaum and Freund - 2021 - A Constructive Logic with Classical Proofs and Ref.pdf;/home/flaviomoura/Zotero/storage/PIMLT5JF/2104.html}
}

@misc{barenbaumEssenseUsefulEvaluation2024,
  title = {The {{Essense}} of {{Useful Evaluation Through Quantitative Types}} ({{Extended Version}})},
  author = {Barenbaum, Pablo and Kesner, Delia and Milicich, Mariana},
  year = {2024},
  month = apr,
  number = {arXiv:2404.18874},
  eprint = {2404.18874},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.18874},
  urldate = {2024-04-30},
  abstract = {Several evaluation notions for lambda calculus qualify as reasonable cost models according to Slot and van Emde Boas' Invariance Thesis. A notable result achieved by Accattoli and Dal Lago is that leftmost-outermost reduction is reasonable, where the term representation uses sharing and the steps are useful. These results, initially studied in call-by-name, have also been extended to call-by-value. However, the existing formulations of usefulness lack inductive structure, making it challenging in particular to define and reason about type systems on top of the untyped syntax. Additionally, no type-based quantitative interpretations exist for useful evaluation. In this work, we establish the first inductive definition of useful evaluation for open weak call-by-value. This new useful strategy connects to a previous implementation of usefulness through a low-level abstract machine, incurring only in linear time overhead, thus providing a reasonable cost model for open call-by-value implementation. We also propose a semantic interpretation of useful call-by-value using a non-idempotent intersection type system equipped with a notion of tightness. The resulting interpretation is quantitative, i.e. provides exact step-count information for program evaluation. This turns out to be the first semantical interpretation in the literature for a notion of useful evaluation.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/CFU8FL9F/Barenbaum et al. - 2024 - The Essense of Useful Evaluation Through Quantitat.pdf;/home/flaviomoura/Zotero/storage/N47G6PNJ/2404.html}
}

@article{barenbaumSemaNticaDina,
  title = {{{Sema}}{\textasciiacute}ntica Dina{\textasciiacute}mica de Ca{\textasciiacute}lculos de Sustituciones Expl{\textasciiacute}{\i}citas a Distancia},
  author = {Barenbaum, Pablo},
  abstract = {Explicit substitution calculi are variants of the {$\lambda$}-calculus in which the operation of substitution is not de ned at the metalanguage level, but rather implemented by means of rewriting rules. Our main object of study is a particular explicit substitution calculus, the Linear Substitution Calculus (LSC), introduced by Acca oli and Kesner in 2010. Its distinguishing feature is that rewriting rules operate non-locally (at a distance). In this thesis, rst, we de ne abstract machines to implement evaluation strategies in the LSC: call-by-name for weak and strong evaluation, call-by-value, and call-by-need. We prove that these machines are correct and that they preserve computational time complexity. Second, we de ne an extension of the call-by-need evaluation strategy in the LSC for strong reduction. We show that the strong call-by-need strategy is complete with respect to call-by-name, using a non-idempotent intersection type system, and we show how to extend the strategy to deal with pa ern matching and recursion. Finally, we study the theory of residuals and redex families in the LSC. To this aim, we de ne a variant of the LSC endowed with Le{\textasciiacute}vy labels, which allows us to prove that it enjoys the Finite Family Developments property. We apply this property to obtain results on optimality, standardization, and normalization for the LSC, and we generalize some of this results to the axiomatic framework of Deterministic Family Structures.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/S2NQJYWL/Barenbaum - SemaÂ´ntica dinaÂ´mica de caÂ´lculos de sustituciones.pdf}
}

@article{barenbaumSemanticsRelationalLambda2020,
  title = {Semantics of a {{Relational}} \{{\textbackslash}lambda\}-{{Calculus}} ({{Extended Version}})},
  author = {Barenbaum, Pablo and Lochbaum, Federico and Milicich, Mariana},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.10929 [cs]},
  eprint = {2009.10929},
  primaryclass = {cs},
  urldate = {2020-09-29},
  abstract = {We extend the \{{\textbackslash}lambda\}-calculus with constructs suitable for relational and functional-logic programming: non-deterministic choice, fresh variable introduction, and unification of expressions. In order to be able to unify \{{\textbackslash}lambda\}-expressions and still obtain a confluent theory, we depart from related approaches, such as \{{\textbackslash}lambda\}Prolog, in that we do not attempt to solve higher-order unification. Instead, abstractions are decorated with a location, which intuitively may be understood as its memory address, and we impose a simple coherence invariant: abstractions in the same location must be equal. This allows us to formulate a confluent small-step operational semantics which only performs first-order unification and does not require strong evaluation (below lambdas). We study a simply typed version of the system. Moreover, a denotational semantics for the calculus is proposed and reduction is shown to be sound with respect to the denotational semantics.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/DUJZ3M3U/Barenbaum et al. - 2020 - Semantics of a Relational lambda -Calculus (Exte.pdf;/home/flaviomoura/Zotero/storage/Z93WWG3Z/2009.html}
}

@misc{barenbaumTwoDecreasingMeasures2023,
  title = {Two {{Decreasing Measures}} for {{Simply Typed Lambda-Terms}} ({{Extended Version}})},
  author = {Barenbaum, Pablo and Sottile, Cristian},
  year = {2023},
  month = apr,
  number = {arXiv:2304.12440},
  eprint = {2304.12440},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-26},
  abstract = {This paper defines two decreasing measures for terms of the simply typed {$\lambda$}-calculus, called the W-measure and the T m-measure. A decreasing measure is a function that maps each typable {$\lambda$}-term to an element of a well-founded ordering, in such a way that contracting any {$\beta$}-redex decreases the value of the function, entailing strong normalization. Both measures are defined constructively, relying on an auxiliary calculus, a non-erasing variant of the {$\lambda$}-calculus. In this system, dubbed the {$\lambda$}m-calculus, each {$\beta$}-step creates a ``wrapper'' containing a copy of the argument that cannot be erased and cannot interact with the context in any other way. Both measures rely crucially on the observation, known to Turing and Prawitz, that contracting a redex cannot create redexes of higher degree, where the degree of a redex is defined as the height of the type of its {$\lambda$}-abstraction. The W-measure maps each {$\lambda$}-term to a natural number, and it is obtained by evaluating the term in the {$\lambda$}m-calculus and counting the number of remaining wrappers. The T m-measure maps each {$\lambda$}-term to a structure of nested multisets, where the nesting depth is proportional to the maximum redex degree.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/REC5S2X5/Barenbaum e Sottile - 2023 - Two Decreasing Measures for Simply Typed Lambda-Te.pdf}
}

@misc{barenbaumUsefulEvaluationSyntax2025,
  title = {Useful {{Evaluation}}: {{Syntax}} and {{Semantics}} ({{Technical Report}})},
  shorttitle = {Useful {{Evaluation}}},
  author = {Barenbaum, Pablo and Kesner, Delia and Milicich, Mariana},
  year = {2025},
  month = feb,
  number = {arXiv:2404.18874},
  eprint = {2404.18874},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.18874},
  urldate = {2025-02-13},
  abstract = {This work provides the first inductive definition of useful CBV evaluation. For that, we first restrict the substitution operation in the Value Substitution Calculus to be linear, yielding the LCBV strategy. We then further restrict substitution in LCBV, so that substitution contributes to the progress of the computation. This optimisation is the UCBV strategy, and its notion of substitution is sensitive to the surrounding evaluation context, so it is non-trivial to capture it inductively. Moreover, we show that UCBV is a sound and complete implementation of LCBV, optimised to implement useful evaluation. As a further contribution, we show that an existing notion of usefulness in the literature, namely the GLAMoUr abstract machine, implements the UCBV strategy with polynomial overhead in time. This establishes that UCBV is time-invariant, i.e., that the number of reduction steps to normal form in UCBV can be used as a measure of time complexity. Defining UCBV leads us to the first semantic model of useful CBV evaluation through system U, a non-idempotent intersection type system. Our main result is a characterisation of termination for useful CBV evaluation via system U: a term is typable in system U if and only if it terminates in UCBV. Additionally, system U provides a quantitative interpretation for UCBV, offering exact step-count information for program evaluation. Even though the specification of the operational semantics of UCBV is highly complex, system U is notably simple. As far as we know, system U is one of the scarce quantitative type systems capturing exactly the substitution step-count for a call-by-value strategy.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/VWWLNWJC/Barenbaum et al. - 2025 - Useful Evaluation Syntax and Semantics (Technical Report).pdf;/home/flaviomoura/Zotero/storage/827BNKUI/2404.html}
}

@article{barendregtChallengeComputerMathematics2005,
  title = {The {{Challenge}} of {{Computer Mathematics}}},
  author = {Barendregt, H. and Wiedijk, F.},
  year = {2005},
  journal = {Transactions A of the Royal Society},
  volume = {363},
  number = {1835},
  pages = {2351--2375}
}

@article{barendregtImpactLambdaCalculus1997,
  title = {The {{Impact}} of the {{Lambda Calculus}} in {{Logic}} and {{Computer Science}}},
  author = {Barendregt, H.},
  year = {1997},
  journal = {Bulletin of Simbolic Logic},
  volume = {3},
  number = {3},
  pages = {181--215}
}

@book{barendregtLambdaCalculusIts1984,
  title = {The Lambda Calculus: Its Syntax and Semantics},
  shorttitle = {The Lambda Calculus},
  author = {Barendregt, H. P.},
  year = {1984},
  series = {Studies in Logic and the Foundations of Mathematics},
  edition = {Rev. ed},
  number = {v. 103},
  publisher = {{North-Holland ; Sole distributors for the U.S.A. and Canada, Elsevier Science Pub. Co}},
  address = {Amsterdam ; New York : New York, N.Y},
  isbn = {978-0-444-86748-3 978-0-444-87508-2},
  lccn = {QA9.5 .B36 1984},
  keywords = {Lambda calculus},
  file = {/home/flaviomoura/Zotero/storage/4JSYCH9S/Barendregt - 1984 - The Lambda Calculus  Its Syntax and Semantics (re.pdf}
}

@book{barendregtLambdaCalculusSatellite2022,
  title = {A {{Lambda Calculus Satellite}}},
  author = {Barendregt, Henk and Manzonetto, Giulio},
  year = {2022},
  publisher = {College Publications},
  isbn = {978-1-84890-415-6}
}

@article{barendregtLCalculiTypes1992,
  title = {{$\lambda$}-{{Calculi}} with {{Types}}},
  author = {Barendregt, H. P.},
  editor = {S. Abramsky, D. Gabbay and Maibaum, T.},
  year = {1992},
  journal = {Handbook of Logic in Computer Science},
  volume = {II},
  publisher = {Oxford University Press},
  file = {/home/flaviomoura/Zotero/storage/IA5XPWCZ/Barendregt - 1992 - Î»-Calculi with Types.pdf}
}

@incollection{barendregtProofAssistantsUsingDependent2001,
  title = {Proof-{{Assistants Using Dependent Type Systems}}},
  booktitle = {Handbook of {{Automated Reasoning}}},
  author = {Barendregt, Henk and Geuvers, Herman},
  year = {2001},
  pages = {1149--1238},
  publisher = {{Elsevier and MIT Press}}
}

@book{barker-plummerLanguageProofLogic2011,
  title = {Language, Proof, and Logic},
  author = {{Barker-Plummer}, Dave and Barwise, Jon and Etchemendy, John and Liu, Albert and Murray, Michael and Pease, Emma},
  year = {2011},
  edition = {2. rev. ed},
  publisher = {CSLI Publ},
  address = {Stanford, Calif},
  isbn = {978-1-57586-632-1},
  langid = {english},
  annotation = {OCLC: 726620713}
}

@misc{barrettSimplyTypedFunctionalMachine2023,
  title = {On the {{Simply-Typed Functional Machine Calculus}}: {{Categorical Semantics}} and {{Strong Normalisation}}},
  shorttitle = {On the {{Simply-Typed Functional Machine Calculus}}},
  author = {Barrett, Chris},
  year = {2023},
  month = may,
  number = {arXiv:2305.16073},
  eprint = {2305.16073},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-26},
  abstract = {The Functional Machine Calculus (FMC) was recently introduced as a generalization of the lambda-calculus to include higher-order global state, probabilistic and non-deterministic choice, and input and output, while retaining confluence. The calculus can encode both the call-by-name and call-by-value semantics of these effects. This is enabled by two independent generalisations, both natural from the perspective of the FMC's operational semantics, which is given by a simple multi-stack machine. The first generalization decomposes the syntax of the lambda-calculus in a way that allows for sequential composition of terms and the encoding of reduction strategies. Specifically, there exist translations of the call-by-name and call-by-value lambda-calculus which preserve operational semantics. The second parameterizes application and abstraction in terms of 'locations' (corresponding to the multiple stacks of the machine), which gives a unification of the operational semantics, syntax, and reduction rules of the given effects with those of the lambda-calculus. The FMC further comes equipped with a simple type system which restricts and captures the behaviour of effects. This thesis makes two main contributions, showing that two fundamental properties of the lambda-calculus are preserved by the FMC. The first is to show that the categorical semantics of the FMC, modulo an appropriate equational theory, is given by the free Cartesian closed category. The equational theory is validated by a notion of observational equivalence. The second contribution is a proof that typed FMC-terms are strongly normalising. This is an extension (and small simplification) of Gandy's proof for the lambda-calculus, which additionally emphasizes its latent operational intuition.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,F.1.1,F.3.2},
  file = {/home/flaviomoura/Zotero/storage/JN86HN2M/Barrett - 2023 - On the Simply-Typed Functional Machine Calculus C.pdf}
}

@article{bartheSetoidsTypeTheory2003,
  title = {Setoids in {{Type Theory}}},
  author = {BARTHE, {\relax GILLES} and CAPRETTA, {\relax VENANZIO} and PONS, {\relax OLIVIER}},
  year = {2003},
  journal = {Journal of Functional Programming},
  volume = {13},
  number = {2},
  pages = {261--293},
  doi = {10.1017/s0956796802004501},
  file = {/home/flaviomoura/Zotero/storage/SBJRJFJP/Barthe et al. - 2003 - Setoids in type theory.pdf}
}

@inproceedings{bartheVersatilityOpenLogical2020,
  title = {On the {{Versatility}} of {{Open Logical Relations}} - {{Continuity}}, {{Automatic Differentiation}}, and a {{Containment Theorem}}},
  author = {Barthe, Gilles and Crubill{\'e}, Rapha{\"e}lle and Lago, Ugo Dal and Gavazzo, Francesco},
  year = {2020},
  pages = {56--83}
}

@book{barwiseLanguageFirstOrderLogic1993,
  title = {The {{Language}} of {{First-Order Logic Including}} the {{Macintosh Version}} of {{Tarski}}'s {{World}} 4.0},
  author = {Barwise, J. and Etchemendy, J.},
  year = {1993},
  publisher = {Monograph Collection (Matt - Pseudo)}
}

@article{basoldTypeTheoryBased2016,
  title = {Type {{Theory}} Based on {{Dependent Inductive}} and {{Coinductive Types}}},
  author = {Basold, H. and Geuvers, H.},
  year = {2016},
  journal = {CoRR},
  volume = {abs/1605.02206}
}

@inproceedings{basoldTypeTheoryBased2016a,
  title = {Type {{Theory Based}} on {{Dependent Inductive}} and {{Coinductive Types}}},
  booktitle = {Proceedings of the 31st {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Basold, H. and Geuvers, H.},
  year = {2016},
  series = {{{LICS}} '16},
  pages = {327--336},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/2933575.2934514},
  isbn = {978-1-4503-4391-6},
  keywords = {Coinductive Types,Dependent Types,Fibrations,Inductive Types}
}

@article{battyanyiStrongNormalizationLambdaSymProp2017,
  title = {Strong Normalization of Lambda-{{Sym-Prop-}} and Lambda-Bar-Mu-Mu-Tilde-Star- Calculi},
  author = {Battyanyi, P. and Nour, K.},
  year = {2017},
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@misc{baudonAnalysingParallelComplexity2022,
  title = {Analysing {{Parallel Complexity}} of {{Term Rewriting}}},
  author = {Baudon, Tha{\"i}s and Fuhs, Carsten and Gonnord, Laure},
  year = {2022},
  month = aug,
  number = {arXiv:2208.01005},
  eprint = {2208.01005},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-08-02},
  abstract = {We revisit parallel-innermost term rewriting as a model of parallel computation on inductive data structures and provide a corresponding notion of runtime complexity parametric in the size of the start term. We propose automatic techniques to derive both upper and lower bounds on parallel complexity of rewriting that enable a direct reuse of existing techniques for sequential complexity. The applicability and the precision of the method are demonstrated by the relatively light effort in extending the program analysis tool AProVE and by experiments on numerous benchmarks from the literature.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/RUR3AQ9M/Baudon et al. - 2022 - Analysing Parallel Complexity of Term Rewriting.pdf;/home/flaviomoura/Zotero/storage/FNXKP83E/2208.html}
}

@misc{bauerCountableReals2024,
  title = {The {{Countable Reals}}},
  author = {Bauer, Andrej and Hanson, James E.},
  year = {2024},
  month = apr,
  number = {arXiv:2404.01256},
  eprint = {2404.01256},
  primaryclass = {math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.01256},
  urldate = {2024-04-02},
  abstract = {We construct a topos in which the Dedekind reals are countable. To accomplish this, we first define a new kind of toposes that we call parameterized realizability toposes. They are built from partial combinatory algebras whose application operation depends on a parameter, and in which realizers operate uniformly with respect to a given parameter set. Our topos is the parameterized realizability topos whose realizers are oracle-computable partial maps, with oracles serving as parameters and ranging over the representations of a non-diagonalizable sequence, discovered by Joseph Miller. It is a sequence of reals in \$[0,1]\$ that is non-diagonalizable in the sense that any real in \$[0,1]\$ that is oracle-computable, uniformly in oracles representing the sequence, must already appear in the sequence. The Dedekind reals are countable in the topos because the non-diagonalizable sequence appears in it as an epimorphism. The topos is intuitionistic, as it invalidates both the law of excluded middle and the axiom of countable choice. The Cauchy reals are uncountable. The Hilbert cube is countable, from which Brouwer's fixed-point theorem follows as an easy corollary of Lawvere's fixed-point theorem. From the 1-dimensional Brouwer's fixed-point theorem we obtain the intermediate value theorem and the lesser limited principle of omniscience. The Kreisel-Lacombe-Shoenfield-Tseitin theorem stating that all real-valued maps are continuous is valid, because the usual proof is uniform with respect to oracles. Lastly, the closed interval \$[0,1]\$, being countable, can trivially be covered by a sequence of open intervals whose lengths add up to any prescribed \$0 {$<$} {\textbackslash}epsilon {$<$} 1\$, and such a cover has no finite subcover. However, we show that any sequence of open intervals with rational endpoints covering \$[0,1]\$ must has a finite subcover.},
  archiveprefix = {arXiv},
  keywords = {03B99 03F55,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/ISFHVDJE/Bauer e Hanson - 2024 - The Countable Reals.pdf;/home/flaviomoura/Zotero/storage/8TVKZ8N6/2404.html}
}

@article{bauerFiveStagesAccepting2016,
  title = {Five Stages of Accepting Constructive Mathematics},
  author = {Bauer, Andrej},
  year = {2016},
  month = oct,
  journal = {Bulletin of the American Mathematical Society},
  volume = {54},
  number = {3},
  pages = {481--498},
  issn = {0273-0979, 1088-9485},
  doi = {10.1090/bull/1556},
  urldate = {2022-04-02},
  abstract = {On the odd day, a mathematician might wonder what constructive mathematics is all about. They may have heard arguments in favor of constructivism but are not at all convinced by them, and in any case they may care little about philosophy. A typical introductory text about constructivism spends a great deal of time explaining the principles and contains only trivial mathematics, while advanced constructive texts are impenetrable, like all unfamiliar mathematics. How then can a mathematician find out what constructive mathematics feels like? What new and relevant ideas does constructive mathematics have to offer, if any? I shall attempt to answer these questions.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PNSLU3QN/Bauer - 2016 - Five stages of accepting constructive mathematics.pdf}
}

@techreport{bauerFormalizationMathematicsType2019,
  title = {Formalization of {{Mathematics}} in {{Type Theory}} ({{Dagstuhl Seminar}} 18341)},
  author = {Bauer, Andrej and Escard{\'o}, Mart{\'i}n and Lumsdaine, Peter L. and Mahboubi, Assia},
  year = {2019},
  pages = {16 pages, 11715876 bytes},
  institution = {[object Object]},
  issn = {2192-5283},
  doi = {10.4230/DAGREP.8.8.130},
  urldate = {2024-03-23},
  abstract = {Formalized mathematics is mathematical knowledge (definitions, theorems, and proofs) represented in digital form suitable for computer processing. The central goal of this seminar was to identify the theoretical advances and practical improvements needed in the area of formalized mathematics, in order to make it a mature technology, truly useful to a larger community of students and researchers in mathematics. During the seminar, various software systems for formalization were compared, and potential improvements to existing systems were investigated. There have also been discussions on the representation of algebraic structures in formalization systems.},
  copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
  langid = {english},
  keywords = {formal methods,formalized mathematics,proof assistant,type theory},
  file = {/home/flaviomoura/Zotero/storage/JT54APC9/Bauer et al. - 2019 - Formalization of Mathematics in Type Theory (Dagst.pdf}
}

@article{bauerGeneralDefinitionDependent2020,
  title = {A General Definition of Dependent Type Theories},
  author = {Bauer, Andrej and Haselwarter, Philipp G. and Lumsdaine, Peter LeFanu},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.05539 [cs, math]},
  eprint = {2009.05539},
  primaryclass = {cs, math},
  urldate = {2020-09-25},
  abstract = {We define a general class of dependent type theories, encompassing Martin-L{\textbackslash}"of's intuitionistic type theories and variants and extensions. The primary aim is pragmatic: to unify and organise their study, allowing results and constructions to be given in reasonable generality, rather than just for specific theories. Compared to other approaches, our definition stays closer to the direct or naive reading of syntax, yielding the traditional presentations of specific theories as closely as possible. Specifically, we give three main definitions: raw type theories, a minimal setup for discussing dependently typed derivability; acceptable type theories, including extra conditions ensuring well-behavedness; and well-presented type theories, generalising how in traditional presentations, the well-behavedness of a type theory is established step by step as the type theory is built up. Following these, we show that various fundamental fitness-for-purpose metatheorems hold in this generality. Much of the present work has been formalised in the proof assistant Coq.},
  archiveprefix = {arXiv},
  keywords = {03B38 (Primary) 03F50 (Secondary),Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/I6HYK7T8/Bauer et al. - 2020 - A general definition of dependent type theories.pdf;/home/flaviomoura/Zotero/storage/98RMP2JF/2009.html}
}

@article{bauerHoTTLibraryFormalization2016,
  title = {The {{HoTT Library}}: {{A}} Formalization of Homotopy Type Theory in {{Coq}}},
  author = {Bauer, A. and Gross, J. and Lumsdaine, P. LeFanu and Shulman, M. and Sozeau, M. and Spitters, B.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {03B15,03B70,55U35,Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic}
}

@misc{bayerMathematicalProofGenerations2022,
  title = {Mathematical {{Proof Between Generations}}},
  author = {Bayer, Jonas and Benzm{\"u}ller, Christoph and Buzzard, Kevin and David, Marco and Lamport, Leslie and Matiyasevich, Yuri and Paulson, Lawrence and Schleicher, Dierk and Stock, Benedikt and Zelmanov, Efim},
  year = {2022},
  month = jul,
  number = {arXiv:2207.04779},
  eprint = {2207.04779},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-07-13},
  abstract = {A proof is one of the most important concepts of mathematics. However, there is a striking difference between how a proof is defined in theory and how it is used in practice. This puts the unique status of mathematics as exact science into peril. Now may be the time to reconcile theory and practice, i.e. precision and intuition, through the advent of computer proof assistants. For the most time this has been a topic for experts in specialized communities. However, mathematical proofs have become increasingly sophisticated, stretching the boundaries of what is humanly comprehensible, so that leading mathematicians have asked for formal verification of their proofs. At the same time, major theorems in mathematics have recently been computer-verified by people from outside of these communities, even by beginning students. This article investigates the gap between the different definitions of a proof and possibilities to build bridges. It is written as a polemic or a collage by different members of the communities in mathematics and computer science at different stages of their careers, challenging well-known preconceptions and exploring new perspectives.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - History and Overview},
  file = {/home/flaviomoura/Zotero/storage/LSXFM2RI/Bayer et al. - 2022 - Mathematical Proof Between Generations.pdf;/home/flaviomoura/Zotero/storage/S3XTHXYU/2207.html}
}

@article{bayerMathematicalProofGenerations2024,
  title = {Mathematical {{Proof Between Generations}}},
  author = {Bayer, Jonas and Benzm{\"u}ller, Christoph and Buzzard, Kevin and David, Marco and Lamport, Leslie and Matiyasevich, Yuri and Paulson, Lawrence and Schleicher, Dierk and Stock, Benedikt and Zelmanov, Efim},
  year = {2024},
  month = jan,
  journal = {Notices of the American Mathematical Society},
  volume = {71},
  number = {01},
  eprint = {2207.04779},
  primaryclass = {cs, math},
  pages = {1},
  issn = {0002-9920, 1088-9477},
  doi = {10.1090/noti2860},
  urldate = {2024-05-27},
  abstract = {A proof is one of the most important concepts of mathematics. However, there is a striking difference between how a proof is defined in theory and how it is used in practice. This puts the unique status of mathematics as exact science into peril. Now may be the time to reconcile theory and practice, i.e. precision and intuition, through the advent of computer proof assistants. For the most time this has been a topic for experts in specialized communities. However, mathematical proofs have become increasingly sophisticated, stretching the boundaries of what is humanly comprehensible, so that leading mathematicians have asked for formal verification of their proofs. At the same time, major theorems in mathematics have recently been computer-verified by people from outside of these communities, even by beginning students. This article investigates the gap between the different definitions of a proof and possibilities to build bridges. It is written as a polemic or a collage by different members of the communities in mathematics and computer science at different stages of their careers, challenging well-known preconceptions and exploring new perspectives.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - History and Overview},
  file = {/home/flaviomoura/Zotero/storage/TIIUMVX2/Bayer et al. - 2024 - Mathematical Proof Between Generations.pdf;/home/flaviomoura/Zotero/storage/2MFP5WCI/2207.html}
}

@inproceedings{beckmannComplexityConfluenceChurchRosser2024,
  title = {On {{Complexity}} of {{Confluence}} and {{Church-Rosser Proofs}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{MFCS}}.2024.21},
  author = {Beckmann, Arnold and Moser, Georg},
  year = {2024},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.MFCS.2024.21},
  urldate = {2024-10-08},
  abstract = {In this paper, we investigate confluence and the Church-Rosser property - two well-studied properties of rewriting and the {$\lambda$}-calculus - from the viewpoint of proof complexity. With respect to confluence, and focusing on orthogonal term rewrite systems, our main contribution is that the size, measured in number of symbols, of the smallest rewrite proof is polynomial in the size of the peak. For the Church-Rosser property we obtain exponential lower bounds for the size of the join in the size of the equality proof. Finally, we study the complexity of proving confluence in the context of the {$\lambda$}-calculus. Here, we establish an exponential (worst-case) lower bound of the size of the join in the size of the peak.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AXWCKQ25/Beckmann and Moser - 2024 - On Complexity of Confluence and Church-Rosser Proo.pdf}
}

@article{beesonBrouwerEuclid2017,
  title = {Brouwer and {{Euclid}}},
  author = {Beeson, M.},
  year = {2017},
  month = may,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Logic}
}

@book{beesonFoundationsConstructiveMathematics1985,
  title = {Foundations of {{Constructive Mathematics}}},
  author = {Beeson, M. J.},
  year = {1985},
  series = {Nil},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-3-642-68952-9}
}

@misc{behrFundamentalsCompositionalRewriting2022,
  title = {Fundamentals of {{Compositional Rewriting Theory}}},
  author = {Behr, Nicolas and Harmer, Russ and Krivine, Jean},
  year = {2022},
  month = apr,
  number = {arXiv:2204.07175},
  eprint = {2204.07175},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-01-23},
  abstract = {A foundational theory of compositional categorical rewriting theory is presented, based on a collection of fibrationlike properties that collectively induce and structure intrinsically the large collection of lemmata used in the proofs of theorems such as concurrency and associativity. The resulting highly generic proofs of these theorems are given; it is noteworthy that the proof of the concurrency theorem takes only a few lines and, while that of associativity remains somewhat longer, it would be unreadably long if written directly in terms of the basic lemmata. In addition to improving, or even enabling, the readability of human-written proofs, we anticipate that this more generic and modular style of writing proofs should organize and inform the production of formalized proofs in a proof assistant such as Coq or Isabelle. A curated list of known instances of our framework is used to conclude the paper with a detailed discussion of the conditions under which the Double Pushout and Sesqui-Pushout semantics of graph transformation are compositional.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {16B50 60J27 68Q42 (Primary) 60J28 16B50 05E99 (Secondary),Computer Science - Logic in Computer Science,F.4.2,G.2.2,G.3},
  file = {/home/flaviomoura/Zotero/storage/8PJUSUXQ/Behr et al. - 2022 - Fundamentals of Compositional Rewriting Theory.pdf;/home/flaviomoura/Zotero/storage/BE86KSB3/Behr et al. - 2023 - Fundamentals of Compositional Rewriting Theory.pdf}
}

@article{belleSymbolicLogicMeets2020,
  title = {Symbolic {{Logic Meets Machine Learning}}: A {{Brief Survey}} in {{Infinite Domains}}},
  author = {Belle, Vaishak},
  year = {2020},
  journal = {CoRR},
  abstract = {The tension between deduction and induction is perhaps the most fundamental issue in areas such as philosophy, cognition and artificial intelligence (AI). The deduction camp concerns itself with questions about the expressiveness of formal languages for capturing knowledge about the world, together with proof systems for reasoning from such knowledge bases. The learning camp attempts to generalize from examples about partial descriptions about the world. In AI, historically, these camps have loosely divided the development of the field, but advances in cross-over areas such as statistical relational learning, neuro-symbolic systems, and high-level control have illustrated that the dichotomy is not very constructive, and perhaps even ill-formed. In this article, we survey work that provides further evidence for the connections between logic and learning. Our narrative is structured in terms of three strands: logic versus learning, machine learning for logic, and logic for machine learning, but naturally, there is considerable overlap. We place an emphasis on the following "sore" point: there is a common misconception that logic is for discrete properties, whereas probability theory and machine learning, more generally, is for continuous properties. We report on results that challenge this view on the limitations of logic, and expose the role that logic can play for learning in infinite domains.}
}

@book{ben-ariMathematicalLogicComputer2012,
  title = {Mathematical {{Logic}} for {{Computer Science}}},
  author = {{Ben-Ari}, M.},
  year = {2012},
  edition = {3},
  publisher = {Springer-Verlag London},
  isbn = {1-4471-4128-8 978-1-4471-4128-0 1-4471-4129-6 978-1-4471-4129-7}
}

@article{benaissaLnCalculusExplicit1996,
  title = {{$\Lambda\nu$}, a Calculus of Explicit Substitutions Which Preserves Strong Normalisation},
  author = {Benaissa, Zine-El-Abidine and Briaud, Daniel and Lescanne, Pierre and {Rouyer-Degli}, Jocelyne},
  year = {1996},
  month = sep,
  journal = {Journal of Functional Programming},
  volume = {6},
  number = {5},
  pages = {699--722},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796800001945},
  urldate = {2023-09-08},
  abstract = {Explicit substitutions were proposed by Abadi, Cardelli, Curien, Hardin and Levy to internalise substitutions into A-calculus and to propose a mechanism for computing on substitutions. Xo is another view of the same concept which aims to explain the process of substitution and to decompose it in small steps. It favours simplicity and preservation of strong normalisation. This way, another important property is missed, namely confluence on open terms. In spirit, Xv is closely related to another calculus of explicit substitutions proposed by de Bruijn and called CX{\pounds}{$<$}j{$>$}. In this paper, we introduce Xo, we present CX{\pounds}4{$>$} in the same framework as Xv and we compare both calculi. Moreover, we prove properties of Xo; namely Xo correctly implements /? reduction, Xv is confluent on closed terms, i.e. on terms of classical A-calculus and on all terms that are derived from those terms, and finally Xo preserves strong normalisation in the following sense: strongly (I normalising terms are strongly Xo normalising.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IDXXZKNY/Benaissa et al. - 1996 - Î»Î½, a calculus of explicit substitutions which pre.pdf}
}

@inproceedings{bendkowskiCombinatoricsExplicitSubstitutions2018,
  title = {Combinatorics of {{Explicit Substitutions}}},
  booktitle = {Proceedings of the 20th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}}},
  author = {Bendkowski, Maciej and Lescanne, Pierre},
  year = {2018},
  series = {{{PPDP}} '18},
  pages = {7:1--7:12},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/3236950.3236951},
  isbn = {978-1-4503-6441-6}
}

@article{bendkowskiCombinatoricsLtermsNatural2016,
  title = {Combinatorics of {$\lambda$}-Terms: A Natural Approach},
  author = {Bendkowski, M. and Grygiel, K. and Lescanne, P. and Zaionc, M.},
  year = {2016},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Discrete Mathematics,Computer Science - Logic in Computer Science,Mathematics - Combinatorics,Mathematics - Logic}
}

@article{bentonStronglyTypedTerm2012,
  title = {Strongly {{Typed Term Representations}} in {{Coq}}},
  author = {Benton, Nick and Hur, Chung-Kil and Kennedy, Andrew J. and McBride, Conor},
  year = {2012},
  month = aug,
  journal = {Journal of Automated Reasoning},
  volume = {49},
  number = {2},
  pages = {141--159},
  issn = {1573-0670},
  doi = {10.1007/s10817-011-9219-0},
  urldate = {2024-04-23},
  abstract = {There are two approaches to formalizing the syntax of typed object languages in a proof assistant or programming language. The extrinsic approach is to first define a type that encodes untyped object expressions and then make a separate definition of typing judgements over the untyped terms. The intrinsic approach is to make a single definition that captures well-typed object expressions, so ill-typed expressions cannot even be expressed. Intrinsic encodings are attractive and naturally enforce the requirement that metalanguage operations on object expressions, such as substitution, respect object types. The price is that the metalanguage types of intrinsic encodings and operations involve non-trivial dependency, adding significant complexity. This paper describes intrinsic-style formalizations of both simply-typed and polymorphic languages, and basic syntactic operations thereon, in the Coq proof assistant. The Coq types encoding object-level variables (de Bruijn indices) and terms are indexed by both type and typing environment. One key construction is the boot-strapping of definitions and lemmas about the action of substitutions in terms of similar ones for a simpler notion of renamings. In the simply-typed case, this yields definitions that are free of any use of type equality coercions. In the polymorphic case, some substitution operations do still require type coercions, which we at least partially tame by uniform use of heterogeneous equality.},
  langid = {english},
  keywords = {de Bruijn indices,The Coq proof assistant,Typed object languages},
  file = {/home/flaviomoura/Zotero/storage/DAQWKJ7D/Benton et al. - 2012 - Strongly Typed Term Representations in Coq.pdf}
}

@book{benzmullerAutomatedReasoning12th2024,
  title = {Automated {{Reasoning}}: 12th {{International Joint Conference}}, {{IJCAR}} 2024, {{Nancy}}, {{France}}, {{July}} 3--6, 2024, {{Proceedings}}, {{Part II}}},
  shorttitle = {Automated {{Reasoning}}},
  editor = {Benzm{\"u}ller, Christoph and Heule, Marijn J.H. and Schmidt, Renate A.},
  year = {2024},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {14740},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-63501-4},
  urldate = {2024-11-21},
  copyright = {https://creativecommons.org/licenses/by/4.0},
  isbn = {978-3-031-63500-7 978-3-031-63501-4},
  langid = {english},
  keywords = {Automated reasoning,Deontic Logic,Description logics,Equational logic and rewriting,First-order logic,Higher order logic,Interactive proof systems,Intuitionistic Logics,Logic,Logic and verification,Modal and temporal logics,Modal Logics,Non-classical Logics,Open Access,Programming logic,Proof theory,Rewriting,Satisfiability Solving,Separation logic,Theorem Proving},
  file = {/home/flaviomoura/Zotero/storage/EVGBT9X4/BenzmÃ¼ller et al. - 2024 - Automated Reasoning 12th International Joint Conf.pdf}
}

@book{benzmullerAutomatedReasoning12th2024a,
  title = {Automated {{Reasoning}}: 12th {{International Joint Conference}}, {{IJCAR}} 2024, {{Nancy}}, {{France}}, {{July}} 3--6, 2024, {{Proceedings}}, {{Part I}}},
  shorttitle = {Automated {{Reasoning}}},
  editor = {Benzm{\"u}ller, Christoph and Heule, Marijn J.H. and Schmidt, Renate A.},
  year = {2024},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {14739},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-63498-7},
  urldate = {2024-11-21},
  copyright = {https://creativecommons.org/licenses/by/4.0},
  isbn = {978-3-031-63497-0 978-3-031-63498-7},
  langid = {english},
  keywords = {Automated reasoning,Deontic Logic,Description logics,Equational logic and rewriting,First-order logic,Higher order logic,Interactive proof systems,Intuitionistic Logics,Logic,Logic and verification,Modal and temporal logics,Modal Logics,Non-classical Logics,Open Access,Programming logic,Proof theory,Rewriting,Satisfiability Solving,Separation logic,Theorem Proving},
  file = {/home/flaviomoura/Zotero/storage/KXCSLVLL/BenzmÃ¼ller et al. - 2024 - Automated Reasoning 12th International Joint Conf.pdf}
}

@article{bereczkyMechanizingMatchingLogic2022,
  title = {Mechanizing {{Matching Logic}} in {{Coq}}},
  author = {Bereczky, P{\'e}ter and Chen, Xiaohong and Horp{\'a}csi, D{\'a}niel and Mizsei, Tam{\'a}s B{\'a}lint and Pe{\~n}a, Lucas and Tusil, Jan},
  year = {2022},
  month = jan,
  journal = {arXiv:2201.05716 [cs]},
  eprint = {2201.05716},
  primaryclass = {cs},
  urldate = {2022-01-20},
  abstract = {Matching logic is a formalism for specifying and reasoning about structures using patterns and pattern matching. Growing in popularity, matching logic has been used to define many logical systems such as separation logic with recursive definitions and linear-temporal logic. Despite this, there is no way for a user to define his or her own matching logic theories using a theorem prover, with maximal assurance of the properties being proved. Hence, in this work, we formalized a version of matching logic using the Coq proof assistant. Specifically, we create a new version of matching logic that uses a locally nameless representation, where quantified variables are unnamed in order to aid verification. We formalize the syntax, semantics, and proof system of this representation of matching logic using the Coq proof assistant. Crucially, we also verify the soundness of the formalized proof system, thereby guaranteeing that any matching logic properties proved in our Coq formalization are indeed correct. We believe this work provides a previously unexplored avenue for defining and proving matching logic theories and properties.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/LPLQ9P29/Bereczky et al. - 2022 - Mechanizing Matching Logic In Coq.pdf;/home/flaviomoura/Zotero/storage/VAMR9D9C/Bereczky et al. - 2022 - Mechanizing Matching Logic in Coq.pdf}
}

@book{bergComputationalGeometry2008,
  title = {Computational {{Geometry}}},
  author = {de Berg, Mark and Cheong, Otfried and van Kreveld, Marc and Overmars, Mark},
  year = {2008},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-77974-2}
}

@article{bergerIntuitionisticFixedPoint2020,
  title = {Intuitionistic {{Fixed Point Logic}}},
  author = {Berger, Ulrich and Tsuiki, Hideki},
  year = {2020},
  month = dec,
  journal = {arXiv:2002.00188 [cs]},
  eprint = {2002.00188},
  primaryclass = {cs},
  urldate = {2020-12-08},
  abstract = {We study the system IFP of intuitionistic fixed point logic, an extension of intuitionistic first-order logic by strictly positive inductive and coinductive definitions. We define a realizability interpretation of IFP and use it to extract computational content from proofs about abstract structures specified by arbitrary classically true disjunction free formulas. The interpretation is shown to be sound with respect to a domain-theoretic denotational semantics and a corresponding lazy operational semantics of a functional language for extracted programs. We also show how extracted programs can be translated into Haskell. As an application we extract a program converting the signed digit representation of real numbers to infinite Gray-code from a proof of inclusion of the corresponding coinductive predicates.},
  archiveprefix = {arXiv},
  keywords = {03B70 03D70 03D78 03F03 03F60 06B35,Computer Science - Logic in Computer Science,F.1.1,F.4.1,I.2.2,I.2.3},
  file = {/home/flaviomoura/Zotero/storage/YVQPC7QH/Berger e Tsuiki - 2020 - Intuitionistic Fixed Point Logic.pdf;/home/flaviomoura/Zotero/storage/2VPT4JA6/2002.html}
}

@article{bergerProgramExtractionNormalization2005,
  title = {Program Extraction from Normalization Proofs},
  author = {Berger, U. and Berghofer, S. and Letouzey, P. and Schwichtenberg, H.},
  year = {2005},
  journal = {Studia Logica},
  volume = {82}
}

@article{bergerProgramExtractionTyped2011,
  title = {Program Extraction via Typed Realisability for Induction and Coinduction},
  author = {Berger, Ulrich and Seisenberger, Monika},
  year = {2011},
  journal = {Ways of Proof Theory},
  pages = {153},
  publisher = {Ontos Verlag Frankfurt}
}

@article{berghoferHeadtoHeadComparisonBruijn2007,
  title = {A {{Head-to-Head Comparison}} of de {{Bruijn Indices}} and {{Names}}},
  author = {Berghofer, Stefan and Urban, Christian},
  year = {2007},
  month = jun,
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {174},
  number = {5},
  pages = {53--67},
  issn = {15710661},
  doi = {10.1016/j.entcs.2007.01.018},
  urldate = {2021-08-15},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VIYHHPXH/Berghofer e Urban - 2007 - A Head-to-Head Comparison of de Bruijn Indices and.pdf}
}

@incollection{berghoferNominalInversionPrinciples2008,
  title = {Nominal {{Inversion Principles}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Berghofer, Stefan and Urban, Christian},
  editor = {Mohamed, Otmane Ait and Mu{\~n}oz, C{\'e}sar and Tahar, Sofi{\`e}ne},
  year = {2008},
  volume = {5170},
  pages = {71--85},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-71067-7_10},
  urldate = {2023-01-29},
  abstract = {When reasoning about inductively defined predicates, such as typing judgements or reduction relations, proofs are often done by inversion, that is by a case analysis on the last rule of a derivation. In HOL and other formal frameworks this case analysis involves solving equational constraints on the arguments of the inductively defined predicates. This is well-understood when the arguments consist of variables or injective term-constructors. However, when alpha-equivalence classes are involved, that is when term-constructors are not injective, these equational constraints give rise to annoying variable renamings. In this paper, we show that more convenient inversion principles can be derived where one does not have to deal with variable renamings. An interesting observation is that our result relies on the fact that inductive predicates must satisfy the variable convention compatibility condition, which was introduced to justify the admissibility of Barendregt's variable convention in rule inductions.},
  isbn = {978-3-540-71065-3 978-3-540-71067-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Y59THCKC/Berghofer e Urban - 2008 - Nominal Inversion Principles.pdf}
}

@misc{bergstraRingsCommonDivision2024,
  title = {Rings with Common Division, Common Meadows and Their Conditional Equational Theories},
  author = {Bergstra, Jan A. and Tucker, John V.},
  year = {2024},
  month = may,
  number = {arXiv:2405.01733},
  eprint = {2405.01733},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-05-09},
  abstract = {We examine the consequences of having a total division operation x on commutative rings. y We consider two forms of binary division, one derived from a unary inverse, the other defined directly as a general operation; each are made total by setting 1/0 equal to an error value {$\perp$}, which is added to the ring. Such totalised divisions we call common divisions. In a field the two forms are equivalent and we have a finite equational axiomatisation E that is complete for the equational theory of fields equipped with common division, called common meadows. These equational axioms E turn out to be true of commutative rings with common division but only when defined via inverses. We explore these axioms E and their role in seeking a completeness theorem for the conditional equational theory of common meadows. We prove they are complete for the conditional equational theory of commutative rings with inverse based common division. By adding a new proof rule, we can prove a completeness theorem for the conditional equational theory of common meadows. Although, the equational axioms E fail with common division defined directly, we observe that the direct division does satisfies the equations in E under a new congruence for partial terms called eager equality.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Symbolic Computation},
  file = {/home/flaviomoura/Zotero/storage/BELQXISG/Bergstra and Tucker - 2024 - Rings with common division, common meadows and the.pdf}
}

@unpublished{bertotCoqArt2015,
  title = {Le {{Coq}}'{{Art}}},
  author = {Bertot, Y. and Cast{\'e}ran, P.},
  year = {2015},
  file = {/home/flaviomoura/Zotero/storage/UD3VRN2H/Bertot e CastÃ©ran - 2015 - Le Coq'Art.pdf}
}

@unpublished{bertotCoqHurry2010,
  title = {Coq in a {{Hurry}}},
  author = {Bertot, Y.},
  year = {2010},
  month = may
}

@book{bertotInteractiveTheoremProving2004,
  title = {Interactive {{Theorem Proving}} and {{Program Development}} - {{Coq}}'{{Art}}: {{The Calculus}} of {{Inductive Constructions}}},
  author = {Bertot, Y. and Cast{\'e}ran, P.},
  year = {2004},
  series = {{{EATCS}} - {{Texts}} in {{Theoretical Computer Science}}},
  publisher = {Springer}
}

@unpublished{bertrandGradualizingCalculusInductive2020,
  title = {Gradualizing the {{Calculus}} of {{Inductive Constructions}}},
  author = {Bertrand, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, {\'E}ric},
  year = {2020},
  month = nov,
  urldate = {2021-05-01},
  abstract = {Acknowledging the ordeal of a fully formal development in a proof assistant such as Coq, we investigate gradual variations on the Calculus of Inductive Construction (CIC) for swifter prototyping with imprecise types and terms. We observe, with a no-go theorem, a crucial tradeoff between graduality and the key properties of canonicity, decidability and closure of universes under dependent product that CIC enjoys. Beyond this Fire Triangle of Graduality, we explore the gradualization of CIC with three different compromises, each relaxing one edge of the Fire Triangle. We develop a parametrized presentation of Gradual CIC that encompasses all three variations, and jointly develop their metatheory. We first present a bidirectional elaboration of Gradual CIC to a dependently-typed cast calculus, which elucidates the interrelation between typing, conversion, and graduality. We then establish the metatheory of this cast calculus through both a syntactic model into CIC, which provides weak canonicity, confluence, and when applicable, normalization, and a monotone model that purports the study of the graduality of two of the three variants. This work informs and paves the way towards the development of malleable proof assistants and dependently-typed programming languages.},
  file = {/home/flaviomoura/Zotero/storage/TZJYJ3PY/Bertrand et al. - 2020 - Gradualizing the Calculus of Inductive Constructio.pdf}
}

@misc{beyersdorffLIPIcsVolume2892024,
  title = {{{LIPIcs}}, {{Volume}} 289, {{STACS}} 2024, {{Complete Volume}}},
  author = {Beyersdorff, Olaf and Kant{\'e}, Mamadou Moustapha and Kupferman, Orna and Lokshtanov, Daniel},
  year = {2024},
  journal = {Leibniz International Proceedings in Informatics (LIPIcs)},
  volume = {289},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.STACS.2024},
  urldate = {2024-08-30},
  abstract = {LIPIcs, Volume 289, STACS 2024, Complete Volume},
  archiveprefix = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  collaborator = {Beyersdorff, Olaf and Kant{\'e}, Mamadou Moustapha and Kupferman, Orna and Lokshtanov, Daniel},
  copyright = {Creative Commons Attribution 4.0 International license, info:eu-repo/semantics/openAccess},
  langid = {english},
  keywords = {LIPIcs Volume 289 STACS 2024 Complete Volume,Mathematics of computing  Combinatorics,Mathematics of computing  Graph theory,Theory of computation  Computational complexity and cryptography,Theory of computation  Design and analysis of algorithms,Theory of computation  Formal languages and automata theory,Theory of computation  Logic,Theory of computation  Models of computation}
}

@book{bezemTypedLambdaCalculi1993,
  title = {Typed {{Lambda Calculi}} and {{Applications}}, {{International Conference}} on {{Typed Lambda Calculi}} and {{Applications}}, {{TLCA}} '93, {{Utrecht}}, {{The Netherlands}}, {{March}} 16-18, 1993, {{Proceedings}}},
  editor = {Bezem, Marc and Groote, Jan Friso},
  year = {1993},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {664},
  publisher = {Springer},
  doi = {10.1007/BFb0037093},
  isbn = {3-540-56517-5}
}

@misc{bezemTypeTheoryExplicit2023,
  title = {Type {{Theory}} with {{Explicit Universe Polymorphism}}},
  author = {Bezem, Marc and Coquand, Thierry and Dybjer, Peter and Escard{\'o}, Mart{\'i}n},
  year = {2023},
  month = jun,
  number = {arXiv:2212.03284},
  eprint = {2212.03284},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-05},
  abstract = {The aim of this paper is to refine and extend proposals by Sozeau and Tabareau and by Voevodsky for universe polymorphism in type theory. In those systems judgments can depend on explicit constraints between universe levels. We here present a system where we also have products indexed by universe levels and by constraints. Our theory has judgments for internal universe levels, built up from level variables by a successor operation and a binary supremum operation, and also judgments for equality of universe levels.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {03B38,Computer Science - Logic in Computer Science,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/GKCPF5ZH/Bezem et al. - 2023 - Type Theory with Explicit Universe Polymorphism.pdf}
}

@book{bezhanishviliIntuitionisticLogic2005,
  title = {Intuitionistic {{Logic}}},
  author = {Bezhanishvili, N. and de Jongh, D.},
  year = {2005},
  annotation = {Published: {\textbackslash}tt http://www.cs.le.ac.uk/people/nb118/Publications/ESSLLI'05.pdf}
}

@unpublished{bezhanishviliStableFormulasIntuitionistic2016,
  title = {Stable Formulas in Intuitionistic Logic},
  author = {Bezhanishvili, N. and de Jongh, D.},
  year = {2016}
}

@article{bezhanishviliUndecidabilityFirstOrderLogic,
  title = {Undecidability of {{First-Order Logic}}},
  author = {Bezhanishvili, Guram and Moss, Lawrence S},
  pages = {26},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/UWUX6EQ2/Bezhanishvili e Moss - Undecidability of First-Order Logic.pdf}
}

@article{bidlingmaierInterpretationDependentType2020,
  title = {An Interpretation of Dependent Type Theory in a Model Category of Locally Cartesian Closed Categories},
  author = {Bidlingmaier, Martin E.},
  year = {2020},
  month = jul,
  journal = {arXiv:2007.02900 [cs, math]},
  eprint = {2007.02900},
  primaryclass = {cs, math},
  urldate = {2020-07-07},
  abstract = {Locally cartesian closed (lcc) categories are natural categorical models of extensional dependent type theory. This paper introduces the "gros" semantics in the category of lcc categories: Instead of constructing an interpretation in a given individual lcc category, we show that also the category of all lcc categories can be endowed with the structure of a model of dependent type theory. The original interpretation in an individual lcc category can then be recovered by slicing. As in the original interpretation, we face the issue of coherence: Categorical structure is usually preserved by functors only up to isomorphism, whereas syntactic substitution commutes strictly with all type theoretic structure. Our solution involves a suitable presentation of the higher category of lcc categories as model category. To that end, we construct a model category of lcc sketches, from which we obtain by the formalism of algebraically (co)fibrant objects model categories of strict lcc categories and then algebraically cofibrant strict lcc categories. The latter is our model of dependent type theory.},
  archiveprefix = {arXiv},
  keywords = {18C50 03B38,Computer Science - Logic in Computer Science,F.3.2,F.4.1,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/BIKRNN3K/Bidlingmaier - 2020 - An interpretation of dependent type theory in a mo.pdf;/home/flaviomoura/Zotero/storage/FH3YVMBA/2007.html}
}

@article{biermanIntuitionisticModalLogic2000,
  title = {On an {{Intuitionistic Modal Logic}}},
  author = {Bierman, Gavin M. and de Paiva, Valeria},
  year = {2000},
  journal = {Studia Logica},
  volume = {65},
  number = {3},
  pages = {383--416},
  doi = {10.1023/A:1005291931660}
}

@article{biernackaAbstractMachineStrong2020,
  title = {An {{Abstract Machine}} for {{Strong Call}} by {{Value}}},
  author = {Biernacka, Ma{\l}gorzata and Biernacki, Dariusz and Charatonik, Witold and Drab, Tomasz},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.06984 [cs]},
  eprint = {2009.06984},
  primaryclass = {cs},
  urldate = {2020-09-25},
  abstract = {We present an abstract machine that implements a full-reducing (a.k.a. strong) call-by-value strategy for pure \${\textbackslash}lambda\$-calculus. It is derived using Danvy et al.'s functional correspondence from Cr{\textbackslash}'egut's KN by: (1) deconstructing KN to a call-by-name normalization-by-evaluation function akin to Filinski and Rohde's, (2) modifying the resulting normalizer so that it implements the right-to-left call-by-value function application, and (3) constructing the functionally corresponding abstract machine. This new machine implements a reduction strategy that subsumes the fireball-calculus variant of call by value studied by Accattoli et al. We describe the strong strategy of the machine in terms of a reduction semantics and prove the correctness of the machine using a method based on Biernacka et al.'s generalized refocusing. As a byproduct, we present an example application of the machine to checking term convertibility by discriminating on the basis of their partially normalized forms.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/HB8BNJR2/Biernacka et al. - 2020 - An Abstract Machine for Strong Call by Value.pdf;/home/flaviomoura/Zotero/storage/F2YBY94V/2009.html}
}

@article{biernackaStrongCallValue2021,
  title = {Strong {{Call}} by {{Value}} Is {{Reasonable}} for {{Time}}},
  author = {Biernacka, Ma{\l}gorzata and Charatonik, Witold and Drab, Tomasz},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.05985 [cs]},
  eprint = {2102.05985},
  primaryclass = {cs},
  urldate = {2021-02-16},
  abstract = {The invariance thesis of Slot and van Emde Boas states that all reasonable models of computation simulate each other with polynomially bounded overhead in time and constant-factor overhead in space. In this paper we show that a family of strong call-by-value strategies in the \${\textbackslash}lambda\$-calculus are reasonable for time. The proof is based on a construction of an appropriate abstract machine, systematically derived using Danvy et al.'s functional correspondence that connects higher-order interpreters with abstract-machine models by a well-established transformation technique. This is the first machine that implements a strong CbV strategy and simulates \${\textbackslash}beta\$-reduction with the overhead polynomial in the number of \${\textbackslash}beta\$-steps and in the size of the initial term. We prove this property using a form of amortized cost analysis {\textbackslash}`a la Okasaki.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/CGHSXX9T/Biernacka et al. - 2021 - Strong Call by Value is Reasonable for Time.pdf;/home/flaviomoura/Zotero/storage/WTJFHGHJ/2102.html}
}

@article{bimboDecidabilityImplicationalTicket2013,
  title = {On the {{Decidability}} of {{Implicational Ticket Entailment}}},
  author = {Bimb{\'o}, Katalin and Dunn, J. Michael},
  year = {2013},
  journal = {The Journal of Symbolic Logic},
  volume = {78},
  number = {1},
  pages = {214--236},
  doi = {10.2178/jsl.7801150}
}

@book{bimboProofTheorySequent2014,
  title = {Proof {{Theory}}: {{Sequent Calculi}} and {{Related Formalisms}}},
  author = {Bimbo, Katalin},
  year = {2014},
  series = {Discrete {{Mathematics}} and {{Its Applications}}},
  edition = {1},
  publisher = {{Chapman and Hall/CRC}},
  isbn = {978-1-4665-6468-8 978-1-4665-6466-4}
}

@misc{BinaryRelationOverview,
  title = {Binary {{Relation}} - an Overview {\textbar} {{ScienceDirect Topics}}},
  urldate = {2024-09-27},
  howpublished = {https://www.sciencedirect.com/topics/mathematics/binary-relation},
  file = {/home/flaviomoura/Zotero/storage/9PJ8SRDE/binary-relation.html}
}

@misc{binderFormalizingPickTheorem2024,
  title = {Formalizing {{Pick}}'s {{Theorem}} in {{Isabelle}}/{{HOL}}},
  author = {Binder, Sage and Kosaian, Katherine},
  year = {2024},
  month = may,
  number = {arXiv:2405.01793},
  eprint = {2405.01793},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.01793},
  urldate = {2024-06-10},
  abstract = {We formalize Pick's theorem for finding the area of a simple polygon whose vertices are integral lattice points. We are inspired by John Harrison's formalization of Pick's theorem in HOL Light, but tailor our proof approach to avoid a primary challenge point in his formalization, which is proving that any polygon with more than three vertices can be split (in its interior) by a line between some two vertices. We detail the approach we use to avoid this step and reflect on the pros and cons of our eventual formalization strategy. We use the theorem prover Isabelle/HOL, and our formalization involves augmenting the existing geometry libraries in various foundational ways (e.g., by adding the definition of a polygon and formalizing some key properties thereof).},
  archiveprefix = {arXiv},
  keywords = {03B35 68V15 68V20,Computer Science - Logic in Computer Science,F.3.1},
  file = {/home/flaviomoura/Zotero/storage/JHJIR9Y7/Binder e Kosaian - 2024 - Formalizing Pick's Theorem in IsabelleHOL.pdf;/home/flaviomoura/Zotero/storage/9P7ZVBVT/2405.html}
}

@misc{binderGrokkingSequentCalculus2024,
  title = {Grokking the {{Sequent Calculus}} ({{Functional Pearl}})},
  author = {Binder, David and Tzschentke, Marco and M{\"u}ller, Marius and Ostermann, Klaus},
  year = {2024},
  month = jun,
  number = {arXiv:2406.14719},
  eprint = {2406.14719},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-07-23},
  abstract = {The sequent calculus is a proof system which was designed as a more symmetric alternative to natural deduction. The \{{\textbackslash}lambda\}\{{\textbackslash}mu\}\{{\textbackslash}mu\}-calculus is a term assignment system for the sequent calculus and a great foundation for compiler intermediate languages due to its first-class representation of evaluation contexts. Unfortunately, only experts of the sequent calculus can appreciate its beauty. To remedy this, we present the first introduction to the \{{\textbackslash}lambda\}\{{\textbackslash}mu\}\{{\textbackslash}mu\}-calculus which is not directed at type theorists or logicians but at compiler hackers and programming-language enthusiasts. We do this by writing a compiler from a small but interesting surface language to the \{{\textbackslash}lambda\}\{{\textbackslash}mu\}\{{\textbackslash}mu\}-calculus as a compiler intermediate language.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/ZG3REAAC/Binder et al. - 2024 - Grokking the Sequent Calculus (Functional Pearl).pdf}
}

@article{binderProgrammingSymmetricData,
  title = {Programming with {{Symmetric Data}} and {{Codata Types}}},
  author = {Binder, David},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BDWAPFEC/Binder - Programming with Symmetric Data and Codata Types.pdf}
}

@article{birdFunctionalAlgorithmDesign1996,
  title = {Functional Algorithm Design},
  author = {Bird, Richard S.},
  year = {1996},
  month = may,
  journal = {Science of Computer Programming},
  volume = {26},
  number = {1-3},
  pages = {15--31},
  issn = {01676423},
  doi = {10.1016/0167-6423(95)00033-X},
  urldate = {2020-08-04},
  langid = {english}
}

@article{birkhoffStructureAbstractAlgebras1935,
  title = {On the {{Structure}} of {{Abstract Algebras}}},
  author = {Birkhoff, G.},
  year = {1935},
  journal = {Mathematical Proceedings of the Cambridge Philosophical Society},
  volume = {31},
  number = {04},
  pages = {433},
  doi = {10.1017/s0305004100013463}
}

@inproceedings{bitarContributionsDominoProblem2024,
  title = {Contributions to the {{Domino Problem}}: {{Seeding}}, {{Recurrence}} and {{Satisfiability}}},
  shorttitle = {Contributions to the {{Domino Problem}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{STACS}}.2024.17},
  author = {Bitar, Nicol{\'a}s},
  year = {2024},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.STACS.2024.17},
  urldate = {2024-09-10},
  abstract = {We study the seeded domino problem, the recurring domino problem and the k-SAT problem on finitely generated groups. These problems are generalization of their original versions on {$\mathbb{Z}^2$} that were shown to be undecidable using the domino problem. We show that the seeded and recurring domino problems on a group are invariant under changes in the generating set, are many-one reduced from the respective problems on subgroups, and are positive equivalent to the problems on finite index subgroups. This leads to showing that the recurring domino problem is decidable for free groups. Coupled with the invariance properties, we conjecture that the only groups in which the seeded and recurring domino problems are decidable are virtually free groups. In the case of the k-SAT problem, we introduce a new generalization that is compatible with decision problems on finitely generated groups. We show that the subgroup membership problem many-one reduces to the 2-SAT problem, that in certain cases the k-SAT problem many one reduces to the domino problem, and finally that the domino problem reduces to 3-SAT for the class of scalable groups.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/I844E59P/Bitar - 2024 - Contributions to the Domino Problem Seeding, Recu.pdf}
}

@book{bjornerLogicProgrammingArtificial2012,
  title = {Logic for {{Programming}}, {{Artificial Intelligence}}, and {{Reasoning}} - 18th {{International Conference}}, {{LPAR-18}}, {{M{\'e}rida}}, {{Venezuela}}, {{March}} 11-15, 2012. {{Proceedings}}},
  editor = {Bj{\o}rner, Nikolaj and Voronkov, Andrei},
  year = {2012},
  journal = {LPAR},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {7180},
  publisher = {Springer},
  isbn = {978-3-642-28716-9}
}

@misc{blaauwbroekLearningGuidedAutomated2024,
  title = {Learning {{Guided Automated Reasoning}}: {{A Brief Survey}}},
  shorttitle = {Learning {{Guided Automated Reasoning}}},
  author = {Blaauwbroek, Lasse and Cerna, David and Gauthier, Thibault and Jakub{\r u}v, Jan and Kaliszyk, Cezary and Suda, Martin and Urban, Josef},
  year = {2024},
  month = mar,
  number = {arXiv:2403.04017},
  eprint = {2403.04017},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-05-27},
  abstract = {Automated theorem provers and formal proof assistants are general reasoning systems that are in theory capable of proving arbitrarily hard theorems, thus solving arbitrary problems reducible to mathematics and logical reasoning. In practice, such systems however face large combinatorial explosion, and therefore include many heuristics and choice points that considerably influence their performance. This is an opportunity for trained machine learning predictors, which can guide the work of such reasoning systems. Conversely, deductive search supported by the notion of logically valid proof allows one to train machine learning systems on large reasoning corpora. Such bodies of proof are usually correct by construction and when combined with more and more precise trained guidance they can be boostrapped into very large corpora, with increasingly long reasoning chains and possibly novel proof ideas.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Machine Learning,Computer Science - Neural and Evolutionary Computing,Computer Science - Symbolic Computation},
  file = {/home/flaviomoura/Zotero/storage/3PG5Y9G8/Blaauwbroek et al. - 2024 - Learning Guided Automated Reasoning A Brief Surve.pdf}
}

@misc{blaisdellExplorationsSubexponentialNonassociative2023,
  title = {Explorations in {{Subexponential}} Non-Associative Non-Commutative {{Linear Logic}}},
  author = {Blaisdell, Eben and Kanovich, Max and Kuznetsov, Stepan L. and Pimentel, Elaine and Scedrov, Andre},
  year = {2023},
  month = jul,
  number = {arXiv:2307.03059},
  eprint = {2307.03059},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2023-07-11},
  abstract = {In a previous work we introduced a non-associative non-commutative logic extended by multimodalities, called subexponentials, licensing local application of structural rules. Here, we further explore this system, considering a classical one-sided multi-succedent classical version of the system, following the exponential-free calculi of Buszkowski's and de Groote and Lamarche's works, where the intuitionistic calculus is shown to embed faithfully into the classical fragment.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {03F03,Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/796F6B3I/Blaisdell et al. - 2023 - Explorations in Subexponential non-associative non.pdf}
}

@article{blanchetteBindingsBoundedNatural2019,
  title = {Bindings as Bounded Natural Functors},
  author = {Blanchette, Jasmin Christian and Gheri, Lorenzo and Popescu, Andrei and Traytel, Dmitriy},
  year = {2019},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {POPL},
  pages = {22:1--22:34},
  doi = {10.1145/3290335},
  urldate = {2024-02-19},
  abstract = {We present a general framework for specifying and reasoning about syntax with bindings. Abstract binder types are modeled using a universe of functors on sets, subject to a number of operations that can be used to construct complex binding patterns and binding-aware datatypes, including non-well-founded and infinitely branching types, in a modular fashion. Despite not committing to any syntactic format, the framework is ``concrete'' enough to provide definitions of the fundamental operators on terms (free variables, alpha-equivalence, and capture-avoiding substitution) and reasoning and definition principles. This work is compatible with classical higher-order logic and has been formalized in the proof assistant Isabelle/HOL.},
  keywords = {inductive and coinductive datatypes,proof assistants,syntax with bindings},
  file = {/home/flaviomoura/Zotero/storage/2ZAG66P4/Blanchette et al. - 2019 - Bindings as bounded natural functors.pdf}
}

@article{blanquiAxiomsMathematics2021,
  title = {Some Axioms for Mathematics},
  author = {Blanqui, Fr{\'e}d{\'e}ric and Dowek, Gilles and Grienenberger, {\'E}milie and Hondet, Gabriel and Thir{\'e}, Fran{\c c}ois},
  year = {2021},
  pages = {18},
  abstract = {The {$\lambda\Pi$}-calculus modulo theory is a logical framework in which many logical systems can be expressed as theories. We present such a theory, the theory U, where proofs of several logical systems can be expressed. Moreover, we identify a sub-theory of U corresponding to each of these systems, and prove that, when a proof in U uses only symbols of a sub-theory, then it is a proof in that sub-theory.},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/FYF85SQT/Blanqui et al. - 2021 - Some axioms for mathematics.pdf;/home/flaviomoura/Zotero/storage/KIZSJDD3/Blanqui et al. - 2021 - Some axioms for mathematics.pdf;/home/flaviomoura/Zotero/storage/V9H54FVT/Blanqui et al. - 2021 - Some axioms for mathematics.pdf;/home/flaviomoura/Zotero/storage/KML786LW/2111.html}
}

@misc{blanquiAxiomsTypeTheories2022,
  title = {Some Axioms for Type Theories},
  author = {Blanqui, Fr{\'e}d{\'e}ric and Dowek, Gilles and Grienenberger, Emilie and Hondet, Gabriel and Thir{\'e}, Fran{\c c}ois},
  year = {2022},
  month = jul,
  number = {arXiv:2111.00543},
  eprint = {2111.00543},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-07-17},
  abstract = {The \${\textbackslash}lambda{\textbackslash}Pi\$-calculus modulo theory is a logical framework in which many type systems can be expressed as theories. We present such a theory, the theory \${\textbackslash}mathcal\{U\}\$, where proofs of several logical systems can be expressed. Moreover, we identify a sub-theory of \${\textbackslash}mathcal\{U\}\$ corresponding to each of these systems, and prove that, when a proof in \${\textbackslash}mathcal\{U\}\$ uses only symbols of a sub-theory, then it is a proof in that sub-theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/BJQBA5UU/Blanqui et al. - 2022 - Some axioms for type theories.pdf;/home/flaviomoura/Zotero/storage/BXVFNI93/2111.html}
}

@article{blanquiTypeSafetyRewrite2020,
  title = {Type Safety of Rewrite Rules in Dependent Types},
  author = {Blanqui, Fr{\'e}d{\'e}ric},
  year = {2020},
  month = oct,
  journal = {arXiv:2010.16111 [cs]},
  eprint = {2010.16111},
  primaryclass = {cs},
  doi = {10.4230/LIPIcs.FSCD.2020.13},
  urldate = {2020-11-02},
  abstract = {The expressiveness of dependent type theory can be extended by identifying types modulo some additional computation rules. But, for preserving the decidability of type-checking or the logical consistency of the system, one must make sure that those user-defined rewriting rules preserve typing. In this paper, we give a new method to check that property using Knuth-Bendix completion.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/7PKGRI5Y/Blanqui - 2020 - Type safety of rewrite rules in dependent types.pdf;/home/flaviomoura/Zotero/storage/G3YJK74C/2010.html}
}

@book{blazyInteractiveTheoremProving2013,
  title = {Interactive {{Theorem Proving}} - 4th {{International Conference}}, {{ITP}} 2013, {{Rennes}}, {{France}}, {{July}} 22-26, 2013. {{Proceedings}}},
  editor = {Blazy, Sandrine and {Paulin-Mohring}, Christine and Pichardie, David},
  year = {2013},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {7998},
  publisher = {Springer},
  doi = {10.1007/978-3-642-39634-2},
  isbn = {978-3-642-39633-5}
}

@misc{blondeau-patissierExtensionalTaylorExpansion2023,
  title = {Extensional {{Taylor Expansion}}},
  author = {{Blondeau-Patissier}, Lison and Clairambault, Pierre and Auclair, Lionel Vaux},
  year = {2023},
  month = may,
  number = {arXiv:2305.08489},
  eprint = {2305.08489},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-18},
  abstract = {We introduce a calculus of extensional resource terms. These are resource terms {\textbackslash}`a la Ehrhard-Regnier, but in infinite \${\textbackslash}eta\$-long form, while retaining a finite syntax and dynamics: in particular, we prove strong confluence and normalization. Then we define an extensional version of Taylor expansion, mapping ordinary \${\textbackslash}lambda\$-terms to sets (or infinite linear combinations) of extensional resource terms: just like for ordinary Taylor expansion, the dynamics of our resource calculus allows to simulate the \${\textbackslash}beta\$-reduction of \${\textbackslash}lambda\$-terms; the extensional nature of expansion shows in that we are also able to simulate \${\textbackslash}eta\$-reduction. In a sense, extensional resource terms form a language of (non-necessarily normal) finite approximants of Nakajima trees, much like ordinary resource terms are approximants of B{\textbackslash}"ohm-trees. Indeed, we show that the equivalence induced on \${\textbackslash}lambda\$-terms by the normalization of extensional Taylor-expansion is nothing but \$H{\textasciicircum}*\$, the greatest consistent sensible \${\textbackslash}lambda\$-theory. Taylor expansion has profoundly renewed the approximation theory of the \${\textbackslash}lambda\$-calculus by providing a quantitative alternative to order-based approximation techniques, such as Scott continuity and B{\textbackslash}"ohm trees. Extensional Taylor expansion enjoys similar advantages: e.g., to exhibit models of \$H{\textasciicircum}*\$, it is now sufficient to provide a model of the extensional resource calculus. We apply this strategy to give a new, elementary proof of a result by Manzonetto: \$H{\textasciicircum}*\$ is the \${\textbackslash}lambda\$-theory induced by a well-chosen reflexive object in the relational model of the \${\textbackslash}lambda\$-calculus.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/YBUXAIEQ/Blondeau-Patissier et al. - 2023 - Extensional Taylor Expansion.pdf}
}

@article{blooBarendregtCubeDefinitions1996,
  title = {The {{Barendregt Cube}} with {{Definitions}} and {{Generalised Reduction}}},
  author = {Bloo, R. and Kamareddine, F. and Nederpelt, R.},
  year = {1996},
  journal = {Inf. Comput.},
  volume = {126},
  number = {2},
  pages = {123--143},
  doi = {10.1006/inco.1996.0041}
}

@article{blooExplicitSubstitutionEdge1999,
  title = {Explicit {{Substitution}}: On the {{Edge}} of {{Strong Normalization}}},
  author = {Bloo, Roel and Geuvers, Herman},
  year = {1999},
  journal = {Theoretical Computer Science},
  volume = {211},
  number = {1-2},
  pages = {375--395},
  doi = {10.1016/s0304-3975(97)00183-7}
}

@inproceedings{blooPreservationStrongNormalisation1995,
  title = {Preservation of {{Strong Normalisation}} in {{Named Lambda Calculi}} with {{Explicit Substitution}} and {{Garbage Collection}}},
  booktitle = {{{CSN-95}}: {{COMPUTER SCIENCE IN THE NETHERLANDS}}},
  author = {Bloo, R. and Rose, K.},
  year = {1995},
  pages = {62--72}
}

@article{bodiniEnumeratingLambdaTerms2017,
  title = {Enumerating {{Lambda Terms}} by {{Weighted Length}} of {{Their De Bruijn Representation}}},
  author = {Bodini, O. and Gittenberger, B. and {Go{\textbackslash}l{\textbackslash}c ebiewski}, Z.},
  year = {2017},
  month = jul,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Combinatorics,Mathematics - Logic}
}

@unpublished{bodnarIntroductionAlgorithmsSolutions2015,
  title = {Introduction to {{Algorithms}} - {{Solutions Manual}}},
  author = {Bodnar, Michelle and Lohr, Andrew},
  year = {2015},
  file = {/home/flaviomoura/Zotero/storage/K7XKA3K6/Bodnar and Lohr - 2015 - Introduction to Algorithms - Solutions Manual.pdf}
}

@article{bogaertsApproximationFixpointTheory,
  title = {Approximation {{Fixpoint Theory}} in {{Coq}}},
  author = {Bogaerts, Bart and {Cruz-Filipe}, Lu{\'i}s},
  abstract = {Approximation Fixpoint Theory (AFT) is an abstract framework based on lattice theory that unifies semantics of different nonmonotonic logic. AFT has revealed itself to be applicable in a variety of new domains within knowledge representation. In this work, we present a formalisation of the key constructions and results of AFT in the Coq theorem prover, together with a case study illustrating its application to propositional logic programming.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WI7S6I89/Bogaerts e Cruz-Filipe - Approximation Fixpoint Theory in Coq.pdf}
}

@book{bogartDiscreteMathComputer2004,
  title = {Discrete {{Math}} for {{Computer Science Students}}},
  author = {Bogart, B. and Drysdale, S. and Stein, C.},
  year = {2004}
}

@article{bohneLearningHowProve2018,
  title = {Learning How to {{Prove}}: {{From}} the {{Coq Proof Assistant}} to {{Textbook Style}}},
  shorttitle = {Learning How to {{Prove}}},
  author = {B{\"o}hne, Sebastian and Kreitz, Christoph},
  year = {2018},
  month = mar,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {267},
  eprint = {1803.01466},
  pages = {1--18},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.267.1},
  urldate = {2020-07-07},
  abstract = {We have developed an alternative approach to teaching computer science students how to prove. First, students are taught how to prove theorems with the Coq proof assistant. In a second, more difficult, step students will transfer their acquired skills to the area of textbook proofs. In this article we present a realisation of the second step. Proofs in Coq have a high degree of formality while textbook proofs have only a medium one. Therefore our key idea is to reduce the degree of formality from the level of Coq to textbook proofs in several small steps. For that purpose we introduce three proof styles between Coq and textbook proofs, called line by line comments, weakened line by line comments, and structure faithful proofs. While this article is mostly conceptional we also report on experiences with putting our approach into practise.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Electrical Engineering and Systems Science - Systems and Control},
  file = {/home/flaviomoura/Zotero/storage/THTHZCRK/BÃ¶hne e Kreitz - 2018 - Learning how to Prove From the Coq Proof Assistan.pdf;/home/flaviomoura/Zotero/storage/7RRRIBH4/1803.html}
}

@article{bonchiStringDiagramRewrite2021,
  title = {String {{Diagram Rewrite Theory III}}: {{Confluence}} with and without {{Frobenius}}},
  shorttitle = {String {{Diagram Rewrite Theory III}}},
  author = {Bonchi, Filippo and Gadducci, Fabio and Kissinger, Aleks and Soboci{\'n}ski, Pawe{\l} and Zanasi, Fabio},
  year = {2021},
  month = sep,
  journal = {arXiv:2109.06049 [cs]},
  eprint = {2109.06049},
  primaryclass = {cs},
  urldate = {2021-09-18},
  abstract = {In this paper we address the problem of proving confluence for string diagram rewriting, which was previously shown to be characterised combinatorically as double-pushout rewriting with interfaces (DPOI) on (labelled) hypergraphs. For standard DPO rewriting without interfaces, confluence for terminating rewrite systems is, in general, undecidable. Nevertheless, we show here that confluence for DPOI, and hence string diagram rewriting, is decidable. We apply this result to give effective procedures for deciding local confluence of symmetric monoidal theories with and without Frobenius structure by critical pair analysis. For the latter, we introduce the new notion of path joinability for critical pairs, which enables finitely many joins of a critical pair to be lifted to an arbitrary context in spite of the strong non-local constraints placed on rewriting in a generic symmetric monoidal theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/DJTPWJTV/Bonchi et al. - 2021 - String Diagram Rewrite Theory III Confluence with.pdf;/home/flaviomoura/Zotero/storage/98Y72ZQS/2109.html}
}

@article{bonelliPerpetualityNamedLambda2001,
  title = {Perpetuality in a {{Named Lambda Calculus With Explicit Substitutions}}},
  author = {Bonelli, E.},
  year = {2001},
  journal = {Mathematical Structures in Computer Science},
  volume = {11},
  number = {1},
  pages = {47--90},
  doi = {10.1017/s0960129500003248}
}

@misc{bonelliStrongBisimulationClassical2023,
  title = {A {{Strong Bisimulation}} for a {{Classical Term Calculus}}},
  author = {Bonelli, Eduardo and Kesner, Delia and Viso, Andr{\'e}s},
  year = {2023},
  month = jun,
  number = {arXiv:2101.05754},
  eprint = {2101.05754},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-19},
  abstract = {When translating a term calculus into a graphical formalism many inessential details are abstracted away. In the case of {$\lambda$}-calculus translated to proof-nets, these inessential details are captured by a notion of equivalence on {$\lambda$}-terms known as {$\simeq\sigma$}-equivalence, in both the intuitionistic (due to Regnier) and classical (due to Laurent) cases. The purpose of this paper is to uncover a strong bisimulation behind {$\simeq\sigma$} -equivalence, as formulated by Laurent for Parigot's {$\lambda$}{\textmu}-calculus. This is achieved by introducing a relation {$\simeq$}, defined over a revised presentation of {$\lambda$}{\textmu}-calculus we dub {$\Lambda$}M .},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/VY3B3E86/Bonelli et al. - 2023 - A Strong Bisimulation for a Classical Term Calculu.pdf}
}

@article{bonelliStrongBisimulationControl2021,
  title = {A {{Strong Bisimulation}} for {{Control Operators}} by {{Means}} of {{Multiplicative}} and {{Exponential Reduction}}},
  author = {Bonelli, Eduardo and Kesner, Delia and Viso, Andr{\'e}s},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.05754 [cs]},
  eprint = {2101.05754},
  primaryclass = {cs},
  urldate = {2021-01-15},
  abstract = {The purpose of this paper is to identify programs with control operators whose reduction semantics are in exact correspondence. This is achieved by introducing a relation \${\textbackslash}simeq\$, defined over a revised presentation of Parigot's \${\textbackslash}lambda{\textbackslash}mu\$-calculus we dub \${\textbackslash}Lambda M\$. Our result builds on three main ingredients which guide our semantical development: (1) factorization of Parigot's \${\textbackslash}lambda{\textbackslash}mu\$-reduction into multiplicative and exponential steps by means of explicit operators, (2) adaptation of Laurent's original \${\textbackslash}simeq\_{\textbackslash}sigma\$-equivalence to \${\textbackslash}Lambda M\$, and (3) interpretation of \${\textbackslash}Lambda M\$ into Laurent's polarized proof-nets (PPN). More precisely, we first give a translation of \${\textbackslash}Lambda M\$-terms into PPN which simulates the reduction relation of our calculus via cut elimination of PPN. Second, we establish a precise correspondence between our relation \${\textbackslash}simeq\$ and Laurent's \${\textbackslash}simeq\_{\textbackslash}sigma\$-equivalence for \${\textbackslash}lambda{\textbackslash}mu\$-terms. Moreover, \${\textbackslash}simeq\$-equivalent terms translate to structurally equivalent PPN. Most notably, \${\textbackslash}simeq\$ is shown to be a strong bisimulation with respect to reduction in \${\textbackslash}Lambda M\$, i.e. two \${\textbackslash}simeq\$-equivalent terms have the exact same reduction semantics, a result which fails for Regnier's \${\textbackslash}simeq\_{\textbackslash}sigma\$-equivalence in \${\textbackslash}lambda\$-calculus as well as for Laurent's \${\textbackslash}simeq\_{\textbackslash}sigma\$-equivalence in \${\textbackslash}lambda{\textbackslash}mu\$.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/Y8JYY9MA/Bonelli et al. - 2021 - A Strong Bisimulation for Control Operators by Mea.pdf;/home/flaviomoura/Zotero/storage/YLRYEUNW/2101.html}
}

@book{boolosdComputabilityLogic4th2002,
  title = {Computability and {{Logic}}: 4th {{Ed}}.},
  author = {Boolosd, G. S. and Burgess, J. P. and Richard, R. C. Jeffrey},
  year = {2002},
  publisher = {Cambridge University Press}
}

@misc{borgesCoqFormalizationQuantified2022,
  title = {Towards a {{Coq}} Formalization of a Quantified Modal Logic},
  author = {Borges, Ana de Almeida},
  year = {2022},
  month = jul,
  number = {arXiv:2206.03358},
  eprint = {2206.03358},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-07-05},
  abstract = {We present a Coq formalization of the Quantified Reflection Calculus with one modality, or QRC1. This is a decidable, strictly positive, and quantified modal logic previously studied for its applications in proof theory. The highlights are a deep embedding of QRC1 in the Coq proof assistant, a mechanization of the notion of Kripke model with varying domains and a formalization of the soundness theorem. We focus on the design decisions inherent to the formalization and the insights that led to new and simplified proofs.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/6SJT3L8F/Borges - 2022 - Towards a Coq formalization of a quantified modal .pdf}
}

@article{borgesLessonsInteractiveTheorem2023,
  title = {Lessons for {{Interactive Theorem Proving Researchers}} from a {{Survey}} of {{Coq Users}}},
  author = {Borges, Ana de Almeida},
  year = {2023},
  abstract = {The Coq Community Survey 2022 was an online public survey of users of the Coq proof assistant conducted during February 2022. Broadly, the survey asked about use of Coq features, user interfaces, libraries, plugins, and tools, views on renaming Coq and Coq improvements, and also demographic data such as education and experience with Coq and other proof assistants and programming languages. The survey received 466 submitted responses, making it the largest survey of users of an interactive theorem prover (ITP) so far. We present the design of the survey, a summary of key results, and analysis of answers relevant to ITP technology development and usage. In particular, we analyze user characteristics associated with adoption of tools and libraries and make comparisons to adjacent software communities. Notably, we find that experience has significant impact on Coq user behavior, including on usage of tools, libraries, and integrated development environments.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/YM5AHFI8/Borges - 2023 - Lessons for Interactive Theorem Proving Researcher.pdf}
}

@inproceedings{bornatJapeCalculatorAnimating1997,
  title = {Jape: {{A Calculator}} for {{Animating Proof-on-Paper}}},
  booktitle = {Automated {{Deduction}} - {{CADE-14}}, 14th {{International Conference}} on {{Automated Deduction}}, {{Townsville}}, {{North Queensland}}, {{Australia}}, {{July}} 13-17, 1997, {{Proceedings}}},
  author = {Bornat, Richard and Sufrin, Bernard},
  year = {1997},
  pages = {412--415},
  doi = {10.1007/3-540-63104-6_41}
}

@inproceedings{borovanskyImplementationHigherOrderUnification1995,
  title = {Implementation of {{Higher-Order Unification Based}} on {{Calculus}} of {{Explicit Substitutions}}},
  booktitle = {Proceedings of the {{SOFSEM}}'95: {{Theory}} and {{Practice}} of {{Informatics}}},
  author = {Borovansk{\'y}, P.},
  editor = {Barto{\v s}ek, M. and Staudek, J. and Wiedermann, J.},
  year = {1995},
  series = {{{LNCS}}},
  volume = {1012},
  pages = {363--368},
  publisher = {Springer Verlag}
}

@book{borovkovProbabilityTheory2013,
  title = {Probability {{Theory}}},
  author = {Borovkov, Alexandr A.},
  year = {2013},
  series = {Universitext},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-5201-9}
}

@article{boudouDecidableIntuitionisticTemporal2017,
  title = {A {{Decidable Intuitionistic Temporal Logic}}},
  author = {Boudou, J. and Di{\'e}guez, M. and {Fern{\'a}ndez-Duque}, D.},
  year = {2017},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Logic}
}

@book{bouyerFoundationsSoftwareScience2022,
  title = {Foundations of {{Software Science}} and {{Computation Structures}}: 25th {{International Conference}}, {{FOSSACS}} 2022, {{Held}} as {{Part}} of the {{European Joint Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2022, {{Munich}}, {{Germany}}, {{April}} 2--7, 2022, {{Proceedings}}},
  shorttitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  editor = {Bouyer, Patricia and Schr{\"o}der, Lutz},
  year = {2022},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {13242},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-99253-8},
  urldate = {2023-11-17},
  isbn = {978-3-030-99252-1 978-3-030-99253-8},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SPYSNUHY/Bouyer e SchrÃ¶der - 2022 - Foundations of Software Science and Computation St.pdf}
}

@article{boveAnotherLookFunction2009,
  title = {Another {{Look At Function Domains}}},
  author = {Bove, A.},
  year = {2009},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {249},
  number = {nil},
  pages = {61--74},
  doi = {10.1016/j.entcs.2009.07.084}
}

@inproceedings{boveDependentTypesWork2008,
  title = {Dependent {{Types}} at {{Work}}},
  booktitle = {Language {{Engineering}} and {{Rigorous Software Development}}, {{International LerNet ALFA Summer School}} 2008, {{Piriapolis}}, {{Uruguay}}, {{February}} 24 - {{March}} 1, 2008, {{Revised Tutorial Lectures}}},
  author = {Bove, A. and Dybjer, P.},
  year = {2008},
  pages = {57--99},
  doi = {10.1007/978-3-642-03153-3_2}
}

@book{boveLanguageEngineeringRigorous2009,
  title = {Language {{Engineering}} and {{Rigorous Software Development}}, {{International LerNet ALFA Summer School}} 2008, {{Piriapolis}}, {{Uruguay}}, {{February}} 24 - {{March}} 1, 2008, {{Revised Tutorial Lectures}}},
  editor = {Bove, Ana and Barbosa, Lu{\'i}s Soares and Pardo, Alberto and Pinto, Jorge Sousa},
  year = {2009},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {5520},
  publisher = {Springer},
  doi = {10.1007/978-3-642-03153-3},
  isbn = {978-3-642-03152-6}
}

@inproceedings{boveNestedGeneralRecursion2001,
  title = {Nested {{General Recursion}} and {{Partiality}} in {{Type Theory}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Bove, A. and Capretta, V.},
  editor = {Boulton, Richard J. and Jackson, Paul B.},
  year = {2001},
  pages = {121--125},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  abstract = {We extend Bove's technique for formalising simple general recursive algrithms in constructive type theory to nested recursive algorithms. The method consists in defining an inductive special-purpose accessibility predicate, that characterizes the inputs on which the algorithm terminates. As a result, the type-theoretic version of the algorithm can be defined by structural recursion on the proof that the input values satisfy this predicate. This technique results in definitions in which the computational and logical parts are clearly separated; hence, the type-theoretic version of the algorithm is given by its purely functional content, similarly to the corresponding program in a functional programming language. In the case of nested recursion, the special predicate and the type-theoretic algorithm must be defined simultaneously, because they depend on each other. This kind of definitions is not allowed in ordinary type theory, but it is provided in type theories extended with Dybjer's schema for simultaneous inductive-recursive definitions. The technique applies also to the formalisation of partial functions as proper type-theoretic functions, rather than relations representing their graphs.},
  isbn = {978-3-540-44755-9}
}

@article{bovePartialityRecursionInteractive2014,
  title = {Partiality and {{Recursion}} in {{Interactive Theorem Provers}} - an {{Overview}}},
  author = {BOVE, {\relax ANA} and KRAUSS, {\relax ALEXANDER} and SOZEAU, {\relax MATTHIEU}},
  year = {2014},
  journal = {Mathematical Structures in Computer Science},
  volume = {26},
  number = {01},
  pages = {38--88},
  doi = {10.1017/s0960129514000115}
}

@book{bradleyCalculusComputation2007,
  title = {The {{Calculus}} of {{Computation}}},
  author = {Bradley, Aaron R. and Manna, Zohar},
  year = {2007},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-74113-8}
}

@book{brassAdvancedDataStructures2008,
  title = {Advanced {{Data Structures}}},
  author = {Brass, Peter},
  year = {2008},
  month = sep,
  edition = {1},
  publisher = {Cambridge University Press},
  doi = {10.1017/CBO9780511800191},
  urldate = {2024-07-15},
  abstract = {This text closely examines ideas, analysis, and implementation details of data structures as a specialised topic in applied algorithms. It looks at efficient ways to realise query and update operations on sets of numbers, intervals, or strings by various data structures, including: search trees; structures for sets of intervals or piece-wise constant functions; orthogonal range search structures; heaps; union-find structures; dynamization and persistence of structures; structures for strings; and hash tables. Instead of relegating data structures to trivial material used to illustrate object-oriented programming methodology, this is the first volume to show data structures as a crucial algorithmic topic. Numerous code examples in C and more than 500 references make Advanced Data Structures an indispensable text.},
  copyright = {https://www.cambridge.org/core/terms},
  isbn = {978-0-521-88037-4 978-0-511-80019-1},
  file = {/home/flaviomoura/Zotero/storage/H3L4CS44/Brass - 2008 - Advanced Data Structures.pdf}
}

@book{brassard,
  title = {Fundamentals of Algorithmics},
  author = {Brassard, Gilles and Bratley, Paul},
  year = {1996},
  publisher = {Prentice-Hall, Inc.},
  address = {USA},
  isbn = {0-13-335068-1},
  file = {/home/flaviomoura/Zotero/storage/WA27NF83/Brassard and Bratley - 1996 - Fundamentals of algorithmics.pdf}
}

@article{bredeLogicalStructureChoice,
  title = {On the Logical Structure of Choice and Bar Induction Principles},
  author = {Brede, Nuria and Herbelin, Hugo},
  pages = {22},
  abstract = {We develop an approach to choice principles and their contra-positive bar-induction principles as extensionality schemes connecting an ``effective'' or ``intensional'' view of respectively ill- and well-foundedness properties to an ``extensional'' or ``ideal'' view of these properties. After classifying and analysing the relations between different intensional definitions of ill-foundedness and well-foundedness, we introduce, for a domain A, a codomain B and a ``filter'' T on finite approximations of functions from A to B, a generalised form GDCABT of the axiom of dependent choice and dually a generalised bar induction principle GBIABT such that: GDCABT intuitionistically captures {$\bullet$} the strength of the general axiom of choice expressed as {$\forall$}a {$\exists$}b R(a, b) {$\Rightarrow$} {$\exists\alpha$} {$\forall$}a R(a, {$\alpha$}(a))) when T is a filter that derives point-wise from a relation R on A {\texttimes} B without introducing further constraints, {$\bullet$} the strength of the Boolean Prime Filter Theorem / Ultrafilter Theorem if B is the two-element set B, {$\bullet$} the strength of the axiom of dependent choice if A = N, and up to weak classical reasoning {$\bullet$} the (choice) strength of Weak K{\H o}nig's Lemma if A = N and B = B. GBIABT intuitionistically captures {$\bullet$} the strength of G{\"o}del's completeness theorem in the form validity implies provability for entailment relations when B = B, {$\bullet$} the strength of the Bar Induction when A = N, {$\bullet$} the (choice) strength of the Weak Fan Theorem when A = N and B = B. Contrastingly, even though GDCABT and GBIABT smoothly capture several variants of choice and bar induction, some instances are inconsistent, e.g. when A is BN and B is N.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/6QUF6TZB/Brede e Herbelin - On the logical structure of choice and bar inducti.pdf;/home/flaviomoura/Zotero/storage/ZTS5IH48/Brede e Herbelin - On the logical structure of choice and bar inducti.pdf}
}

@misc{bredeLogicalStructureChoice2022,
  title = {On the Logical Structure of Choice and Bar Induction Principles},
  author = {Brede, Nuria and Herbelin, Hugo},
  year = {2022},
  month = jul,
  number = {arXiv:2105.08951},
  eprint = {2105.08951},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-07-07},
  abstract = {We develop an approach to choice principles and their contrapositive bar-induction principles as extensionality schemes connecting an ``intensional'' or ``effective'' view of respectively ill- and well-foundedness properties to an ``extensional'' or ``ideal'' view of these properties. After classifying and analysing the relations between different intensional definitions of ill-foundedness and well-foundedness, we introduce, for a domain A, a codomain B and a ``filter'' T on finite approximations of functions from A to B, a generalised form GDCABT of the axiom of dependent choice and dually a generalised bar induction principle GBIABT such that: GDCABT intuitionistically captures the strength of {$\bullet$} the general axiom of choice expressed as {$\forall$}a {$\exists$}b R(a, b) {$\Rightarrow$} {$\exists\alpha$} {$\forall$}a R(a, {$\alpha$}(a))) when T is a filter that derives point-wise from a relation R on A {\texttimes} B without introducing further constraints, {$\bullet$} the Boolean Prime Filter Theorem / Ultrafilter Theorem if B is the two-element set B (for a constructive definition of prime filter), {$\bullet$} the axiom of dependent choice if A = N, {$\bullet$} Weak Ko{\textacutedbl}nig's Lemma if A = N and B = B (up to weak classical reasoning). GBIABT intuitionistically captures the strength of {$\bullet$} G{\"o}del's completeness theorem in the form validity implies provability for entailment relations if B = B (for a constructive definition of validity), {$\bullet$} bar induction if A = N, {$\bullet$} the Weak Fan Theorem if A = N and B = B. Contrastingly, even though GDCABT and GBIABT smoothly capture several variants of choice and bar induction, some instances are inconsistent, e.g. when A is BN and B is N.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/Z9D2SNYM/Brede and Herbelin - 2022 - On the logical structure of choice and bar inducti.pdf}
}

@article{brietzkeUmaFormulaCuriosa2024,
  title = {{Uma f{\'o}rmula curiosa para os n{\'u}meros de Fibonacci}},
  author = {Brietzke, Eduardo},
  year = {2024},
  journal = {Revista Professor de Matem{\'a}tica On line},
  volume = {12},
  number = {3},
  issn = {2319023X},
  doi = {10.21711/2319023x2024/pmo123},
  urldate = {2024-04-03},
  abstract = {In this article we present a curious formula for the Fibonacci and Lucas numbers in terms of hyperbolic functions. These formulas were discovered in the 1980s, but apparently have been almost forgotten. We also show how these formulas allow us to give new proofs for well known properties of the Fibonacci and Lucas sequences. It is well known that there is a correspondence between trigonometric identities and identities with hyperbolic functions. It is our aim to extend this analogy, showing that there is a correspondence between identities of hyperbolic functions and identities of Fibonacci and Lucas numbers. To develop these ideas, we also approach a combinatorial identity due to Gould.},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/4EF8XJ9L/Brietzke - 2024 - Uma fÃ³rmula curiosa para os nÃºmeros de Fibonacci.pdf}
}

@article{brightEffectiveProblemSolving2019,
  title = {Effective {{Problem Solving Using Sat Solvers}}},
  author = {Bright, Curtis and Gerhard, J{\"u}rgen and Kotsireas, Ilias and Ganesh, Vijay},
  year = {2019},
  journal = {CoRR},
  abstract = {In this article we demonstrate how to solve a variety of problems and puzzles using the built-in SAT solver of the computer algebra system Maple. Once the problems have been encoded into Boolean logic, solutions can be found (or shown to not exist) automatically, without the need to implement any search algorithm. In particular, we describe how to solve the \$n\$-queens problem, how to generate and solve Sudoku puzzles, how to solve logic puzzles like the Einstein riddle, how to solve the 15-puzzle, how to solve the maximum clique problem, and finding Graeco-Latin squares.}
}

@incollection{brodalPurelyFunctionalWorst2006,
  title = {Purely {{Functional Worst Case Constant Time Catenable Sorted Lists}}},
  booktitle = {Algorithms -- {{ESA}} 2006},
  author = {Brodal, Gerth St{\o}lting and Makris, Christos and Tsichlas, Kostas},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Azar, Yossi and Erlebach, Thomas},
  year = {2006},
  volume = {4168},
  pages = {172--183},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/11841036_18},
  urldate = {2023-06-22},
  isbn = {978-3-540-38875-3 978-3-540-38876-0},
  file = {/home/flaviomoura/Zotero/storage/YXFGT8YL/Brodal et al. - 2006 - Purely Functional Worst Case Constant Time Catenab.pdf}
}

@article{brotherstonSequentCalculiInduction2010,
  title = {Sequent {{Calculi}} for {{Induction}} and {{Infinite Descent}}},
  author = {Brotherston, J. and Simpson, A.},
  year = {2010},
  journal = {Journal of Logic and Computation},
  volume = {21},
  number = {6},
  pages = {1177--1216},
  doi = {10.1093/logcom/exq052}
}

@phdthesis{brotherstonSequentCalculusProof2006,
  title = {Sequent {{Calculus Proof Systems}} for {{Inductive Definitions}}},
  author = {Brotherston, J.},
  year = {2006},
  month = nov,
  school = {University of Edinburgh}
}

@misc{brownComputationalCategorytheoreticRewriting2023,
  title = {Computational Category-Theoretic Rewriting},
  author = {Brown, Kristopher and Patterson, Evan and Hanks, Tyler and Fairbanks, James},
  year = {2023},
  month = mar,
  number = {arXiv:2111.03784},
  eprint = {2111.03784},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-04},
  abstract = {We demonstrate how category theory provides specifications that can efficiently be implemented via imperative algorithms and apply this to the field of graph rewriting. By examples, we show how this paradigm of software development makes it easy to quickly write correct and performant code. We provide a modern implementation of graph rewriting techniques at the level of abstraction of finitely-presented C-sets and clarify the connections between C-sets and the typed graphs supported in existing rewriting software. We emphasize that our open-source library is extensible: by taking new categorical constructions (such as slice categories, structured cospans, and distributed graphs) and relating their limits and colimits to those of their underlying categories, users inherit efficient algorithms for pushout complements and (final) pullback complements. This allows one to perform double-, single-, and sesqui-pushout rewriting over a broad class of data structures.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/Q85VL9AW/Brown et al. - 2023 - Computational category-theoretic rewriting.pdf}
}

@article{brownGLIVENKOKURODASIMPLE2014,
  title = {{{GLIVENKO AND KURODA FOR SIMPLE TYPE THEORY}}},
  author = {Brown, Chad E. and Rizkallah, Christine},
  year = {2014},
  month = jun,
  journal = {The Journal of Symbolic Logic},
  volume = {79},
  number = {2},
  pages = {485--495},
  issn = {0022-4812, 1943-5886},
  doi = {10.1017/jsl.2013.10},
  urldate = {2023-06-26},
  abstract = {Glivenko's theorem states that an arbitrary propositional formula is classically provable if and only if its double negation is intuitionistically provable. The result does not extend to full first-order predicate logic, but does extend to first-order predicate logic without the universal quantifier. A recent paper by Zdanowski shows that Glivenko's theorem also holds for secondorder propositional logic without the universal quantifier. We prove that Glivenko's theorem extends to some versions of simple type theory without the universal quantifier. Moreover we prove that Kuroda's negative translation, which is known to embed classical first-order logic into intuitionistic first-order logic, extends to the same versions of simple type theory. We also prove that the Glivenko property fails for simple type theory once a weak form of functional extensionality is included.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ECEV5S7V/Brown e Rizkallah - 2014 - GLIVENKO AND KURODA FOR SIMPLE TYPE THEORY.pdf}
}

@article{browningFormalizingGaloisTheory2021,
  title = {Formalizing {{Galois Theory}}},
  author = {Browning, Thomas and Lutz, Patrick},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.10988 [cs, math]},
  eprint = {2107.10988},
  primaryclass = {cs, math},
  urldate = {2021-07-26},
  abstract = {We describe a project to formalize Galois theory using the Lean theorem prover, which is part of a larger effort to formalize all of the standard undergraduate mathematics curriculum in Lean. We discuss some of the challenges we faced and the decisions we made in the course of this project. The main theorems we formalized are the primitive element theorem, the fundamental theorem of Galois theory, and the equivalence of several characterizations of finite degree Galois extensions.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Number Theory},
  file = {/home/flaviomoura/Zotero/storage/YZ795XLU/Browning e Lutz - 2021 - Formalizing Galois Theory.pdf;/home/flaviomoura/Zotero/storage/KYWI69V7/2107.html}
}

@misc{brownSymbolicComputationAll2024,
  title = {Symbolic {{Computation}} for {{All}} the {{Fun}}},
  author = {Brown, Chad E. and Janota, Mikol{\'a}{\v s} and Ol{\v s}{\'a}k, Mirek},
  year = {2024},
  month = apr,
  number = {arXiv:2404.12048},
  eprint = {2404.12048},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.12048},
  urldate = {2024-04-19},
  abstract = {Motivated by the recent 10 million dollar AIMO challenge, this paper targets the problem of finding all functions conforming to a given specification. This is a popular problem at mathematical competitions and it brings about a number of challenges, primarily, synthesizing the possible solutions and proving that no other solutions exist. Often, there are infinitely many solutions and then the set of solutions has to be captured symbolically. We propose an approach to solving this problem and evaluate it on a set of problems that appeared in mathematical competitions and olympics.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/95X6ZFM6/Brown et al. - 2024 - Symbolic Computation for All the Fun.pdf;/home/flaviomoura/Zotero/storage/87UTUFZV/2404.html}
}

@article{bruijnLambdaCalculusNotation1972,
  ids = {bruijnLambdaCalculusNotationNameless1972},
  title = {Lambda {{Calculus Notation With Nameless Dummies}}, a {{Tool}} for {{Automatic Formula Manipulation}}, {{With Application To}} the {{Church-Rosser Theorem}}},
  author = {de Bruijn, N. G.},
  year = {1972},
  journal = {Indagationes Mathematicae (Proceedings)},
  volume = {75},
  number = {5},
  pages = {381--392},
  doi = {10.1016/1385-7258(72)90034-0}
}

@article{bruijnLambdaCalculusNotationNamefree1978,
  title = {Lambda-{{Calculus Notation}} with {{Namefree Formulas Involving Symbols}} That {{Represent Reference Transforming Mappings}}},
  author = {de Bruijn, N. G.},
  year = {1978},
  journal = {Indag. Mat.},
  volume = {40},
  pages = {348--356}
}

@misc{bruniSkolemisationIntuitionisticLinear2024,
  title = {Skolemisation for {{Intuitionistic Linear Logic}}},
  author = {Bruni, Alessandro and Ritter, Eike and Sch{\"u}rmann, Carsten},
  year = {2024},
  month = may,
  number = {arXiv:2405.01375},
  eprint = {2405.01375},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-05-09},
  abstract = {Focusing is a known technique for reducing the number of proofs while preserving derivability. Skolemisation is another technique designed to improve proof search, which reduces the number of backtracking steps by representing dependencies on the term level and instantiate witness terms during unification at the axioms or fail with an occurs-check otherwise. Skolemisation for classical logic is well understood, but a practical skolemisation procedure for focused intuitionistic linear logic has been elusive so far. In this paper we present a focused variant of first-order intuitionistic linear logic together with a sound and complete skolemisation procedure.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/37IXGQBT/Bruni et al. - 2024 - Skolemisation for Intuitionistic Linear Logic.pdf}
}

@techreport{bryantIntroductioryComputerScience2010,
  title = {Introductiory {{Computer Science Education}} at {{Carnegie Mellon University}}: {{A Deans}}' Perspective},
  author = {Bryant, R. E. and Sutner, K. and Stehlik, M. J.},
  year = {2010},
  institution = {Carnegie Mellon University}
}

@article{bu4thYearProject,
  title = {4th {{Year Project Report Cognitive Science School}} of {{Informatics University}} of {{Edinburgh}} 2024},
  author = {Bu, Di N},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AKEX53YD/Bu - 4th Year Project Report Cognitive Science School o.pdf}
}

@misc{bucciarelliBangCalculusRevisited2022,
  title = {The {{Bang Calculus Revisited}}},
  author = {Bucciarelli, Antonio and Kesner, Delia and R{\'i}os, Alejandro and Viso, Andr{\'e}s},
  year = {2022},
  month = sep,
  eprint = {2002.04011},
  primaryclass = {cs},
  doi = {10.1007/978-3-030-59025-3\_2},
  urldate = {2022-09-28},
  abstract = {Call-by-Push-Value (CBPV) is a programming paradigm subsuming both Callby-Name (CBN) and Call-by-Value (CBV) semantics. The essence of this paradigm is captured by the Bang Calculus, a (concise) term language connecting CBPV and Linear Logic.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/7KURGYK6/Bucciarelli et al. - 2022 - The Bang Calculus Revisited.pdf;/home/flaviomoura/Zotero/storage/LM6TGL2G/Bucciarelli et al. - 2023 - The Bang Calculus Revisited.pdf}
}

@misc{bucciarelliHigherDimensionalPropositional2024,
  title = {The Higher Dimensional Propositional Calculus},
  author = {Bucciarelli, Antonio and Curien, Pierre-Louis and Ledda, Antonio and Paoli, Francesco and Salibra, Antonino},
  year = {2024},
  month = may,
  number = {arXiv:2204.00435},
  eprint = {2204.00435},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2204.00435},
  urldate = {2024-05-08},
  abstract = {In recent research, some of the present authors introduced the concept of an n-dimensional Boolean algebra and its corresponding propositional logic nCL, generalising the Boolean propositional calculus to n{$>$}= 2 perfectly symmetric truth values. This paper presents a sound and complete sequent calculus for nCL, named nLK. We provide two proofs of completeness: one syntactic and one semantic. The former implies as a corollary that nLK enjoys the cut admissibility property. The latter relies on the generalisation to the n-ary case of the classical proof based on the Lindenbaum algebra of formulas and Boolean ultrafilters.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/H34SP8BG/Bucciarelli et al. - 2024 - The higher dimensional propositional calculus.pdf;/home/flaviomoura/Zotero/storage/2EY2PSLF/2204.html}
}

@article{bucciarelliObservabilityTypabilityInhabitation2018,
  title = {Observability = {{Typability}} + {{Inhabitation}}},
  author = {Bucciarelli, Antonio and Kesner, Delia and Rocca, Simona Ronchi Della},
  year = {2018},
  journal = {CoRR},
  abstract = {We define an observability property for a calculus with pattern matching which is inspired by the notion of solvability for the lambda-calculus. We prove that observability can be characterized by means of typability and inhabitation in an intersection type system P based on non-idempotent types. We show first that the system P characterizes the set of terms having canonical form, i.e. that a term is typable if and only if it reduces to a canonical form. But the set of observable terms is properly contained in the set of canonical. Thus, typability alone is not sufficient to characterize observability, in contrast to the solvability case for lambda-calculus. We then prove that typability, together with inhabitation, provides a full characterization of observability, in the sense that a term is observable if and only if it is typable and the types of all its arguments are inhabited. We complete the picture by providing an algorithm for the inhabitation problem of P.}
}

@article{bucciarelliSolvabilityTypabilityInhabitation2020,
  title = {Solvability = {{Typability}} + {{Inhabitation}}},
  author = {Bucciarelli, Antonio and Kesner, Delia and Della Rocca, Simona Ronchi},
  year = {2020},
  month = nov,
  journal = {arXiv:1812.06009 [cs]},
  eprint = {1812.06009},
  primaryclass = {cs},
  urldate = {2020-12-01},
  abstract = {We extend the classical notion of solvability to a lambda-calculus equipped with pattern matching. We prove that solvability can be characterized by means of typability and inhabitation in an intersection type system P based on non-idempotent types. We show first that the system P characterizes the set of terms having canonical form, i.e. that a term is typable if and only if it reduces to a canonical form. But the set of solvable terms is properly contained in the set of canonical forms. Thus, typability alone is not sufficient to characterize solvability, in contrast to the case for the lambda-calculus. We then prove that typability, together with inhabitation, provides a full characterization of solvability, in the sense that a term is solvable if and only if it is typable and the types of all its arguments are inhabited. We complete the picture by providing an algorithm for the inhabitation problem of P.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/F4EBMRJ4/Bucciarelli et al. - 2020 - Solvability = Typability + Inhabitation.pdf;/home/flaviomoura/Zotero/storage/FG9CXPLS/1812.html}
}

@misc{buranOneNothingAntiunification2022,
  title = {One or {{Nothing}}: {{Anti-unification}} over the {{Simply-Typed Lambda Calculus}}},
  shorttitle = {One or {{Nothing}}},
  author = {Buran, Michal and Cerna, David M.},
  year = {2022},
  month = jul,
  number = {arXiv:2207.08918},
  eprint = {2207.08918},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {Investigations concerned with anti-unification (AU) over \${\textbackslash}lambda\$-terms have focused on developing algorithms that produce generalizations residing within well-studied fragments of the simply-typed \${\textbackslash}lambda\$-calculus. These fragments forbid the nesting of generalizations variables, restrict the structure of their arguments, and are {\textbackslash}textit\{unitary\}. We consider the case of nested generalization variables and show that this AU problem is {\textbackslash}textit\{nullary\}, even when the arguments to free variables are severely restricted.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4K72QJJQ/Buran and Cerna - 2022 - One or Nothing Anti-unification over the Simply-T.pdf;/home/flaviomoura/Zotero/storage/BTE7YHDK/2207.html}
}

@article{burckertMatchingSpecialCase1989,
  title = {Matching - {{A Special Case}} of {{Unification}}?},
  author = {Burckert, H. J.},
  year = {1989},
  journal = {journal of Symbolic Computation},
  volume = {8},
  pages = {523--536}
}

@misc{burelHowCanWe2023,
  title = {How Can We Prove That a Proof Search Method Is Not an Instance of Another?},
  author = {Burel, Guillaume and Dowek, Gilles},
  year = {2023},
  month = apr,
  number = {arXiv:2304.11882},
  eprint = {2304.11882},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-25},
  abstract = {We introduce a method to prove that a proof search method is not an instance of another. As an example of application, we show that Polarized resolution modulo, a method that mixes clause selection restrictions and literal selection restrictions, is not an instance of Ordered resolution with selection.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/P9ZWDSIJ/Burel e Dowek - 2023 - How can we prove that a proof search method is not.pdf}
}

@article{burgeComputerProofApriori1998,
  title = {Computer {{Proof}}, {{Apriori Knowledge}}, and {{Other Minds The Sixth Philosophical Perspectives Lecture}}},
  author = {Burge, T.},
  year = {1998},
  journal = {Nous},
  volume = {32},
  number = {S12},
  pages = {1--37},
  doi = {10.1111/0029-4624.32.s12.1}
}

@book{burrisLogicMathematicsComputer1998,
  title = {Logic for {{Mathematics}} and {{Computer Science}}},
  author = {Burris, S. N.},
  year = {1998},
  publisher = {Prentice Hall}
}

@article{burstallProvingPropertiesPrograms1969,
  title = {Proving {{Properties}} of {{Programs By Structural Induction}}},
  author = {Burstall, R. M.},
  year = {1969},
  journal = {The Computer Journal},
  volume = {12},
  number = {1},
  pages = {41--48},
  doi = {10.1093/comjnl/12.1.41}
}

@article{bussIntroductionMathematicalLogic,
  title = {Introduction to {{Mathematical Logic}}},
  author = {Buss, Sam},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/CPESH6UI/Buss - Introduction to Mathematical Logic.pdf}
}

@article{bussIntroductionProofTheory,
  title = {An {{Introduction}} to {{Proof Theory}}},
  author = {Buss, Samuel R},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7DBK8MEX/Buss - An Introduction to Proof Theory.pdf}
}

@article{bussPropositionalProofComplexity1999,
  title = {Propositional {{Proof Complexity}}: {{An Introduction}}},
  author = {Buss, S. R.},
  year = {1999},
  journal = {Computational Logic},
  pages = {127--178}
}

@article{butrahandisyaElementaryAlgorithmicMethods2024,
  title = {Elementary {{Algorithmic Methods}} for {{Solving Suguru Puzzles}}},
  author = {Butrahandisya, Butrahandisya and Arzaki, Muhammad and Wulandari, Gia Septiana},
  year = {2024},
  month = apr,
  journal = {(IJCSAM) International Journal of Computing Science and Applied Mathematics},
  volume = {10},
  number = {1},
  pages = {12--26},
  issn = {2477-5401},
  doi = {10.12962/j24775401.v10i1.17249},
  urldate = {2024-04-18},
  abstract = {We discuss elementary algorithmic aspects of the Suguru puzzle---a single-player paper-and-pencil puzzle introduced in 2001 and confirmed NP-complete in 2022. We propose a backtracking algorithm with pruning optimizations for solving an \$m {\textbackslash}times n\$ Suguru puzzles containing \$R\$ regions and \$H\$ hint cells in \$O(R {\textbackslash}cdot (mn-H+2)!)\$ time. Despite this factorial asymptotic upper bound, a C++ implementation of our proposed algorithm successfully solved all Suguru instances with no more than \$100\$ cells using a personal computer in less than \$0.5\$ second. We also prove that any Suguru instance of size \$m {\textbackslash}times n\$ with either \$m = 1\$ or \$n = 1\$ can be solved in linear time in terms of the puzzle size. Finally, we provide an upper bound for the number of solutions to such tractable instances.},
  copyright = {With the receipt of the article by the IJCSAM (International Journal of Computing Science and Applied Mathematics) Editorial Board and the decision to be published, then the copyright regarding the article will be retained by the authors.  With the acceptance of the article by the Editorial Board of this journal and the decision to publish, the copyright of the article remains the property of the Author. The copyright of all papers published in this journal remains the property of the Author. ITS Scientific Publication Center as the publisher of this journal has the right to distribute all articles in this journal.    licensed under a  Creative Commons Attribution-ShareAlike 4.0 International License .},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Y4D9N4SV/Butrahandisya et al. - 2024 - Elementary Algorithmic Methods for Solving Suguru .pdf}
}

@article{caicedoAlgebraicApproachIntuitionistic2001,
  title = {An Algebraic Approach to Intuitionistic Connectives},
  author = {Caicedo, Xavier and Cignoli, Roberto},
  year = {2001},
  month = dec,
  journal = {Journal of Symbolic Logic},
  volume = {66},
  number = {4},
  pages = {1620--1636},
  issn = {0022-4812, 1943-5886},
  doi = {10.2307/2694965},
  urldate = {2023-04-22},
  abstract = {Abstract.                            It is shown that axiomatic extensions of intuitionistic propositional calculus defining univocally new connectives, including those proposed by Gabbay, are strongly complete with respect to valuations in Heyting algebras with additional operations. In all cases, the double negation of such a connective is equivalent to a formula of intuitionistic calculus. Thus, under the excluded third law it collapses to a classical formula, showing that this condition in Gabbay's definition is redundant. Moreover, such connectives can not be interpreted in all Heyting algebras, unless they are already equivalent to a formula of intuitionistic calculus. These facts relativize to connectives over intermediate logics. In particular, the intermediate logic with values in the chain of length               n               may be ``completed'' conservatively by adding a single unary connective, so that the expanded               system               does not allow further axiomatic extensions by new connectives.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ME25ZYQN/Caicedo e Cignoli - 2001 - An algebraic approach to intuitionistic connective.pdf}
}

@book{caicedoElementosLogicaCalculabilidad1983,
  title = {Elementos de Logica y Calculabilidad},
  author = {Caicedo, X.},
  year = {1983},
  publisher = {Universidad de los Andes, Departamento de Matematicas}
}

@misc{caires-santosStrongNominalSemantics2024,
  title = {Strong {{Nominal Semantics}} for {{Fixed-Point Constraints}}},
  author = {{Caires-Santos}, Ali K. and Fern{\'a}ndez, Maribel and {Nantes-Sobrinho}, Daniele},
  year = {2024},
  month = nov,
  number = {arXiv:2407.14253},
  eprint = {2407.14253},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2407.14253},
  urldate = {2024-11-19},
  abstract = {Nominal algebra includes \${\textbackslash}alpha\$-equality and freshness constraints on nominal terms endowed with a nominal set semantics that facilitates reasoning about languages with binders. Nominal unification is decidable and unitary, however, its extension with equational axioms such as Commutativity (which has a finitary first-order unification type) is no longer finitary unless permutation fixed-point constraints are used. In this paper, we extend the notion of nominal algebra by introducing fixed-point constraints and provide a sound semantics using strong nominal sets. We show, by providing a counter-example, that the class of nominal sets is not a sound denotation for this extended nominal algebra. To recover soundness we propose two different formulations of nominal algebra, one obtained by restricting to a class of fixed-point contexts that are in direct correspondence with freshness contexts and another obtained by using a different set of derivation rules.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/QE6JBX49/Caires-Santos et al. - 2024 - Strong Nominal Semantics for Fixed-Point Constrain.pdf;/home/flaviomoura/Zotero/storage/VARLTA9I/2407.html}
}

@article{caldwellStructuralInductionPrinciples2013,
  title = {Structural {{Induction Principles}} for {{Functional Programmers}}},
  author = {Caldwell, James},
  year = {2013},
  journal = {CoRR},
  abstract = {User defined recursive types are a fundamental feature of modern functional programming languages like Haskell, Clean, and the ML family of languages. Properties of programs defined by recursion on the structure of recursive types are generally proved by structural induction on the type. It is well known in the theorem proving community how to generate structural induction principles from data type declarations. These methods deserve to be better know in the functional programming community. Existing functional programming textbooks gloss over this material. And yet, if functional programmers do not know how to write down the structural induction principle for a new type - how are they supposed to reason about it? In this paper we describe an algorithm to generate structural induction principles from data type declarations. We also discuss how these methods are taught in the functional programming course at the University of Wyoming. A Haskell implementation of the algorithm is included in an appendix.}
}

@mastersthesis{calistoFormalizationCoqStandardization2023,
  title = {Formalization in {{Coq}} of the Standardization Theorem for {$\lambda$}-Calculus},
  author = {Calisto, Bruna Isabel Afonso},
  year = {2023},
  month = jan,
  urldate = {2024-09-18},
  abstract = {Os teoremas da standardiza{\c c}{\~a}o s{\~a}o resultados fundamentais da teoria da redu{\c c}{\~a}o do C{\'a}lculo-{$\lambda$}. Estes resultados estabelecem que um termo t reduz para um termo t{$\prime$} se e s{\'o} se t reduz para t{$\prime$} seguindo uma sequ{\^e}ncia de redu{\c c}{\~a}o espec{\'i}fica, dita standard. Em particular, estes resultados garantem a completude de certas maneiras espec{\'i}ficas de efetuar redu{\c c}{\~o}es, e s{\~a}o a base dos resultados sobre estrat{\'e}gias de avalia{\c c}{\~a}o, nomeadamente chamada-por-nome e chamada-por-valor, fazendo a ponte entre um c{\'a}lculo (uma teoria equacional) e uma linguagem de programa{\c c}{\~a}o. Esta disserta{\c c}{\~a}o apresenta uma formaliza{\c c}{\~a}o no sistema de prova assistida Coq do Teorema da Standardiza{\c c}{\~a}o para o C{\'a}lculo-{$\lambda$}. Neste sentido, consideramos uma prova deste resultado que extra{\'i}mos de uma prova de um Teorema da Standardiza{\c c}{\~a}o para um c{\'a}lculo-{$\lambda$} para l{\'o}gica modal proposto por Esp{\'i}rito Santo-Pinto-Uustalu, onde redu{\c c}{\~a}o standard {\'e} capturada atrav{\'e}s de uma rela{\c c}{\~a}o definida indutivamente nos termos-{$\lambda$}, em linha com tratamentos de standardiza{\c c}{\~a}o para o C{\'a}lculo-{$\lambda$} por Loader e por Joachimski Matthes. A implementa{\c c}{\~a}o da sintaxe dos termos-{$\lambda$} usa os {\'i}ndices de De Bruijn, mas a formaliza{\c c}{\~a}o Coq segue de muito perto a estrutura da prova do Teorema da Standardiza{\c c}{\~a}o (com termos-{$\lambda$} ordin{\'a}rios). Adicionalmente, esta disserta{\c c}{\~a}o considera uma no{\c c}{\~a}o independente de sequ{\^e}ncia de redu{\c c}{\~a}o stan dard para o C{\'a}lculo-{$\lambda$} estudada por Plotkin. Por um lado, prov{\'a}mos que sequ{\^e}ncias de redu{\c c}{\~a}o e a abordagem inicial de redu{\c c}{\~a}o standard como uma rela{\c c}{\~a}o indutiva nos termos-{$\lambda$} s{\~a}o formas equivalentes de caracterizar redu{\c c}{\~a}o standard e, por outro, fornecemos uma formaliza{\c c}{\~a}o dessa equival{\^e}ncia em Coq.},
  copyright = {openAccess},
  langid = {english},
  annotation = {Accepted: 2023-06-19T18:27:28Z},
  file = {/home/flaviomoura/Zotero/storage/58HX9R25/Calisto - 2023 - Formalization in Coq of the standardization theore.pdf}
}

@article{calvesMatchingAlphaEquivalenceCheck2010,
  title = {Matching and {{Alpha-Equivalence Check}} for {{Nominal Terms}}},
  author = {Calv{\`e}s, C. and Fern{\'a}ndez, M.},
  year = {2010},
  journal = {Journal of Computer and System Sciences},
  volume = {76},
  number = {5},
  pages = {283--301},
  doi = {10.1016/j.jcss.2009.10.003}
}

@article{campbellConfluenceGarbageGraph2021,
  title = {Confluence up to {{Garbage}} in {{Graph Transformation}}},
  author = {Campbell, Graham and Plump, Detlef},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.01842 [cs]},
  eprint = {2101.01842},
  primaryclass = {cs},
  urldate = {2021-01-07},
  abstract = {The transformation of graphs and graph-like structures is ubiquitous in computer science. When a system is described by graph-transformation rules, it is often desirable that the rules are both terminating and confluent so that rule applications in an arbitrary order produce unique resulting graphs. However, there are application scenarios where the rules are not globally confluent but confluent on a subclass of graphs that are of interest. In other words, non-resolvable conflicts can only occur on graphs that are considered as "garbage". In this paper, we introduce the notion of confluence up to garbage and generalise Plump's critical pair lemma for double-pushout graph transformation, providing a sufficient condition for confluence up to garbage by non-garbage critical pair analysis. We apply our results in two case studies about efficient language recognition: we present backtracking-free graph reduction systems which recognise a class of flow diagrams and a class of labelled series-parallel graphs, respectively. Both systems are non-confluent but confluent up to garbage. We also give a critical pair condition for subcommutativity up to garbage which, together with closedness, implies confluence up to garbage even in non-terminating systems.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/QDK6HKFM/Campbell e Plump - 2021 - Confluence up to Garbage in Graph Transformation.pdf;/home/flaviomoura/Zotero/storage/S8MNFRH4/2101.html}
}

@inproceedings{camposAKSAlgorithmACL22004,
  title = {The {{AKS Algorithm}} in {{ACL2}}},
  booktitle = {Fifth {{International Conference}} on {{Intelligent Technologies}}},
  author = {Campos, C. and Modave, F. and Roach, S.},
  year = {2004}
}

@article{canouScalingFunctionalProgramming2017,
  title = {Scaling {{Up Functional Programming Education}}: {{Under}} the {{Hood}} of the {{OCaml MOOC}}},
  author = {Canou, B. and Cosmo, R. Di and Henry, G.},
  year = {2017},
  month = aug,
  journal = {Proc. ACM Program. Lang.},
  volume = {1},
  number = {ICFP},
  pages = {4:1--4:25},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3110248},
  keywords = {automated grading,browser based education platform,functional programming,MOOC,programming education,safe program introspection}
}

@article{caoCoqLibrarySets,
  title = {A {{Coq Library}} of {{Sets}} for {{Teaching Denotational Semantics}}},
  author = {Cao, Qinxiang and Wu, Xiwei and Liang, Yalun},
  journal = {EPTCS},
  volume = {400},
  pages = {79--95},
  urldate = {2024-04-08},
  file = {/home/flaviomoura/Zotero/storage/RVHNIX85/Cao et al. - A Coq Library of Sets for Teaching Denotational Se.pdf}
}

@phdthesis{capriottiModelsTypeTheory2016,
  title = {Models of {{Type Theory}} with {{Strict Equality}}},
  author = {Capriotti, P.},
  year = {2016},
  school = {University of Nottingham}
}

@article{carboneConcurrentCalculiFormalisation,
  title = {The {{Concurrent Calculi Formalisation Benchmark}}},
  author = {Carbone, Marco and {Castro-Perez}, David and Ferreira, Francisco and Gheri, Lorenzo and Jacobsen, Frederik Krogsdal and Padovani, Luca and Tirore, Dawit and Yoshida, Nobuko},
  abstract = {POPLMark and POPLMark Reloaded sparked a flurry of work on machine-checked proofs, and fostered the adoption of proof mechanisation in programming language research. Both challenges were purposely limited in scope, and they do not address concurrency-related issues. We propose a new collection of benchmark challenges focused on the difficulties that typically arise when mechanising formal models of concurrent and distributed programming languages, such as process calculi. Our benchmark challenges address three key topics: linearity, scope extrusion, and coinductive reasoning. The goal of this new benchmark is to clarify, compare, and advance the state of the art, fostering the adoption of proof mechanisation in future research on concurrency.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/A49HC8MT/Carbone et al. - The Concurrent Calculi Formalisation Benchmark.pdf}
}

@article{carlImprovingDiprocheCNL,
  title = {Improving the {{Diproche CNL}} through {{Autoformalization}} via {{Large Language Models}}},
  author = {Carl, Merlin},
  journal = {EPTCS},
  volume = {400},
  pages = {44--58},
  urldate = {2024-04-08},
  file = {/home/flaviomoura/Zotero/storage/89IFJWRU/Carl - Improving the Diproche CNL through Autoformalizati.pdf}
}

@article{carlssonNoteHEAPSORT1992,
  title = {A {{Note}} on {{HEAPSORT}}},
  author = {Carlsson, S.},
  year = {1992},
  month = aug,
  journal = {The Computer Journal},
  volume = {35},
  number = {4},
  pages = {410--411},
  issn = {0010-4620, 1460-2067},
  doi = {10.1093/comjnl/35.4.410},
  urldate = {2024-07-15},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HBGIAQ2L/Carlsson - 1992 - A Note on HEAPSORT.pdf}
}

@article{carlUsingLargeLanguage,
  title = {Using {{Large Language Models}} for ({{De-}}){{Formalization}} and {{Natural Argumentation Exercises}} for {{Beginner}}'s {{Students}}},
  author = {Carl, Merlin},
  journal = {EPTCS},
  volume = {400},
  pages = {28--43},
  urldate = {2024-04-08},
  keywords = {Computer Science - Computation and Language,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/KH9FWSPY/Carl - Using Large Language Models for (De-)Formalization.pdf;/home/flaviomoura/Zotero/storage/5UBPRZ8J/2304.html}
}

@misc{carneiroLean4LeanFormalizedMetatheory2024,
  title = {{{Lean4Lean}}: {{Towards}} a Formalized Metatheory for the {{Lean}} Theorem Prover},
  shorttitle = {{{Lean4Lean}}},
  author = {Carneiro, Mario},
  year = {2024},
  month = mar,
  number = {arXiv:2403.14064},
  eprint = {2403.14064},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-25},
  abstract = {In this paper we present a new "external verifier" for the Lean theorem prover, written in Lean itself. This is the first complete verifier for Lean 4 other than the reference implementation in C++ used by Lean itself, and our new verifier is competitive with the original, running between 20\% and 50\% slower and usable to verify all of Lean's mathlib library, forming an additional step in Lean's aim to self-host the full elaborator and compiler. Moreover, because the verifier is written in a language which admits formal verification, it is possible to state and prove properties about the kernel itself, and we report on some initial steps taken in this direction to formalize the Lean type theory abstractly and show that the kernel correctly implements this theory, to eliminate the possibility of implementation bugs in the kernel and increase the trustworthiness of proofs conducted in it. This work is still ongoing but we plan to use this project to help justify any future changes to the kernel and type theory and ensure unsoundness does not sneak in through either the abstract theory or implementation bugs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages,D.2.4,F.4.1,G.4},
  file = {/home/flaviomoura/Zotero/storage/UV67CKDP/Carneiro - 2024 - Lean4Lean Towards a formalized metatheory for the.pdf;/home/flaviomoura/Zotero/storage/VEFT8CFA/2403.html}
}

@article{carnielliHowAICan2021,
  title = {How {{AI}} Can Be Surprisingly Dangerous for the Philosophy of Mathematics--- and of Science},
  author = {Carnielli, Walter},
  year = {2021},
  month = jul,
  journal = {Circumscribere},
  volume = {27},
  pages = {1--12},
  issn = {1980-7651},
  doi = {10.23925/1980-7651.2021v27;p01-12},
  urldate = {2021-09-23},
  abstract = {In addition to the obvious social and ethical risks, there are philosophical hazards behind~artificial intelligence and machine learning. I try to raise here some critical points that might~counteract some naive optimism, and warn against the possibility that synthetic intelligence~may surreptitiously influence the agenda of science before we can realize it.},
  copyright = {Copyright (c) 2021 Circumscribere: International Journal for the History of Science},
  langid = {english},
  keywords = {Interpretability},
  file = {/home/flaviomoura/Zotero/storage/94UKIMUP/Carnielli - 2021 - How AI can be surprisingly dangerous for the philo.pdf}
}

@inproceedings{carraro2014semantical,
  title = {A Semantical and Operational Account of Call-by-Value Solvability},
  booktitle = {International Conference on Foundations of Software Science and Computation Structures},
  author = {Carraro, Alberto and Guerrieri, Giulio},
  year = {2014},
  pages = {103--118},
  organization = {Springer}
}

@incollection{carraroSemanticalOperationalAccount2014,
  title = {A {{Semantical}} and {{Operational Account}} of {{Call-by-Value Solvability}}},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  author = {Carraro, Alberto and Guerrieri, Giulio},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Muscholl, Anca},
  year = {2014},
  volume = {8412},
  pages = {103--118},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-54830-7_7},
  urldate = {2021-04-06},
  abstract = {In Plotkin's call-by-value lambda-calculus, solvable terms are characterized syntactically by means of call-by-name reductions and there is no neat semantical characterization of such terms. Preserving confluence, we extend Plotkin's original reduction without adding extra syntactical constructors, and we get a call-by-value operational characterization of solvable terms. Moreover, we give a semantical characterization of solvable terms in a relational model, based on Linear Logic, satisfying the Taylor expansion formula. As a technical tool, we also use a resource-sensitive calculus (with tests) in which the elements of the model are definable.},
  isbn = {978-3-642-54829-1 978-3-642-54830-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AU75C7CQ/Carraro e Guerrieri - 2014 - A Semantical and Operational Account of Call-by-Va.pdf}
}

@incollection{carraroSemanticalOperationalAccount2014a,
  title = {A {{Semantical}} and {{Operational Account}} of {{Call-by-Value Solvability}}},
  booktitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  author = {Carraro, Alberto and Guerrieri, Giulio},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Muscholl, Anca},
  year = {2014},
  volume = {8412},
  pages = {103--118},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-54830-7_7},
  urldate = {2021-06-11},
  abstract = {In Plotkin's call-by-value lambda-calculus, solvable terms are characterized syntactically by means of call-by-name reductions and there is no neat semantical characterization of such terms. Preserving confluence, we extend Plotkin's original reduction without adding extra syntactical constructors, and we get a call-by-value operational characterization of solvable terms. Moreover, we give a semantical characterization of solvable terms in a relational model, based on Linear Logic, satisfying the Taylor expansion formula. As a technical tool, we also use a resource-sensitive calculus (with tests) in which the elements of the model are definable.},
  isbn = {978-3-642-54829-1 978-3-642-54830-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/C62H662R/Carraro e Guerrieri - 2014 - A Semantical and Operational Account of Call-by-Va.pdf}
}

@book{carterHigherEducationComputer2018,
  title = {Higher {{Education Computer Science}}: {{A Manual}} of {{Practical Approaches}}},
  shorttitle = {Higher {{Education Computer Science}}},
  editor = {Carter, Jenny and O'Grady, Michael and Rosen, Clive},
  year = {2018},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-98590-9},
  urldate = {2020-07-07},
  isbn = {978-3-319-98589-3 978-3-319-98590-9},
  langid = {english}
}

@unpublished{cartwrightDomainTheoryIntroduction2016,
  title = {Domain {{Theory}}: {{An Introduction}}},
  author = {Cartwright, R. and Parsons, R. and Abdelgawad, M.},
  year = {2016}
}

@inproceedings{casteranHydrasCoFormalized2022,
  title = {Hydras \& {{Co}}.: {{Formalized}} Mathematics in {{Coq}} for Inspiration and Entertainment},
  shorttitle = {Hydras \& {{Co}}.},
  booktitle = {Journ{\'e}es {{Francophones}} Des {{Langages Applicatifs}}: {{JFLA}} 2022},
  author = {Cast{\'e}ran, Pierre and Damour, J{\'e}r{\'e}my and Palmskog, Karl and {Pit-Claudel}, Cl{\'e}ment and Zimmermann, Th{\'e}o},
  year = {2022},
  month = jun,
  address = {St-M{\'e}dard d'Excideuil, France},
  urldate = {2023-10-08},
  abstract = {Hydras \& Co. is a collaborative library of discrete mathematics for the Coq proof assistant, developed as part of the Coq-community organization on GitHub. The Coq code is accompanied by an electronic book, generated with the help of the Alectryon literate proving tool. We present the evolution of the mathematical contents of the library since former presentations at JFLA meetings. Then, we describe how the structure of the project is determined by two requirements which must be continuously satisfied. First, the Coq code needs to be compatible with its ever-evolving dependencies (the Coq proof assistant and several Coq packages both from inside and outside Coq-community) and reverse dependencies (Coq-community projects that depend on it). Second, the book needs to be consistent with the Coq code, which undergoes frequent changes to improve structure and include new material. We believe Hydras \& Co. demonstrates that books on formalized mathematics are not limited to providing exposition of theories and reasoning techniquesthey can also provide inspiration and entertainment that transcends educational goals.},
  file = {/home/flaviomoura/Zotero/storage/FXZFW9A2/CastÃ©ran et al. - 2022 - Hydras & Co. Formalized mathematics in Coq for in.pdf}
}

@article{castro-manzanoTraditionalLogicComputational2021,
  title = {Traditional {{Logic}} and {{Computational Thinking}}},
  author = {{Castro-Manzano}, J.-Mart{\'i}n},
  year = {2021},
  month = feb,
  journal = {Philosophies},
  volume = {6},
  number = {1},
  pages = {12},
  issn = {2409-9287},
  doi = {10.3390/philosophies6010012},
  urldate = {2021-02-15},
  abstract = {In this contribution, we try to show that traditional Aristotelian logic can be useful (in a non-trivial way) for computational thinking. To achieve this objective, we argue in favor of two statements: (i) that traditional logic is not classical and (ii) that logic programming emanating from traditional logic is not classical logic programming.},
  langid = {english}
}

@book{celes2017introduÃ§Ã£o,
  title = {Introdu{\c c}{\~a}o a Estruturas de Dados: {{Com}} T{\'e}cnicas de Programa{\c c}{\~a}o Em c},
  author = {Celes, W. and Cerqueira, R. and Rangel, J.},
  year = {2017},
  publisher = {Elsevier Brasil},
  isbn = {978-85-352-8346-4}
}

@book{centroneReflectionsFoundationsMathematics2019,
  title = {Reflections on the {{Foundations}} of {{Mathematics}}},
  editor = {Centrone, Stefania and Kant, Deborah and Sarikaya, Deniz},
  year = {2019},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-15655-8}
}

@inproceedings{cerna2020computational,
  title = {Computational Logic in the First Semester of Computer Science: {{An}} Experience Report.},
  booktitle = {{{CSEDU}} (2)},
  author = {Cerna, David M and Seidl, Martina and Schreiner, Wolfgang and Windsteiger, Wolfgang and Biere, Armin},
  year = {2020},
  pages = {374--381}
}

@misc{cernaAntiunificationGeneralizationSurvey2023,
  title = {Anti-Unification and {{Generalization}}: {{A Survey}}},
  shorttitle = {Anti-Unification and {{Generalization}}},
  author = {Cerna, David M. and Kutsia, Temur},
  year = {2023},
  month = feb,
  number = {arXiv:2302.00277},
  eprint = {2302.00277},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-02-02},
  abstract = {Anti-unification (AU), also known as generalization, is a fundamental operation used for inductive inference and is the dual operation to unification, an operation at the foundation of theorem proving. Interest in AU from the AI and related communities is growing, but without a systematic study of the concept, nor surveys of existing work, investigations often resort to developing application specific methods that may be covered by existing approaches. We provide the first survey of AU research and its applications, together with a general framework for categorizing existing and future developments.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/QTN7W55R/Cerna e Kutsia - 2023 - Anti-unification and Generalization A Survey.pdf}
}

@article{cernaCeresIntuitionisticLogic2017,
  title = {Ceres in Intuitionistic Logic},
  author = {Cerna, David and Leitsch, Alexander and Reis, Giselle and Wolfsteiner, Simon},
  year = {2017},
  month = oct,
  journal = {Annals of Pure and Applied Logic},
  volume = {168},
  number = {10},
  pages = {1783--1836},
  issn = {0168-0072},
  doi = {10.1016/j.apal.2017.04.001},
  urldate = {2024-07-16},
  abstract = {In this paper we present a procedure allowing the extension of a CERES-based cut-elimination method to intuitionistic logic. Previous results concerning this problem manage to capture fragments of intuitionistic logic, but in many essential cases structural constraints were violated during normal form construction resulting in a classical proof. The heart of the CERES method is the resolution calculus, which ignores the structural constraints of the well known intuitionistic sequent calculi. We propose, as a method of avoiding the structural violations, the generalization of resolution from the resolving of clauses to the resolving of cut-free proofs, in other words, what we call proof resolution. The result of proof resolution is a cut-free proof rather than a clause. Note that resolution on ground clauses is essentially atomic cut, thus using proof resolution to construct cut-free proofs one would need to join the two proofs together and remove the atoms which where resolved. To efficiently perform this joining (and guarantee that the resulting cut-free proof is intuitionistic) we develop the concept of proof subsumption (similar to clause subsumption) and indexed resolution, a refinement indexing atoms by their corresponding positions in the cut formula. Proof subsumption serves as a tool to prove the completeness of the new method CERES-i, and indexed resolution provides an efficient strategy for the joining of two proofs which is in general a nondeterministic search. Such a refinement is essential for any attempt to implement this method. Finally we compare the complexity of CERES-i with that of Gentzen-based methods.},
  keywords = {CERES,Cut-elimination,Intuitionistic logic,Proof resolution},
  file = {/home/flaviomoura/Zotero/storage/QX4ZXVTB/Cerna et al. - 2017 - Ceres in intuitionistic logic.pdf;/home/flaviomoura/Zotero/storage/NX62VY2M/S0168007217300490.html}
}

@misc{cernaOneAllYou2024,
  title = {One Is All You Need: {{Second-order Unification}} without {{First-order Variables}}},
  shorttitle = {One Is All You Need},
  author = {Cerna, David M. and Parsert, Julian},
  year = {2024},
  month = apr,
  number = {arXiv:2404.10616},
  eprint = {2404.10616},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-04-22},
  abstract = {We consider the fragment of Second-Order unification with the following properties: (i) only one second-order variable allowed, (ii) first-order variables do not occur. We show that Hilbert's 10\${\textasciicircum}\{th\}\$ problem is reducible to this fragment if the signature contains a binary function symbol and two constants. This generalizes known undecidability results. Furthermore, We show that adding the following restriction: (i) the second-order variable has arity 1, (ii) the signature is finite, and (iii) the problem has {\textbackslash}emph\{bounded congruence\}, results in a decidable fragment. The latter fragment is related to {\textbackslash}emph\{Bounded second-order unification\}, i.e. the number of holes is a function of the problem structure.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/54GFC294/Cerna and Parsert - 2024 - One is all you need Second-order Unification with.pdf;/home/flaviomoura/Zotero/storage/6U6DDLL7/2404.html}
}

@article{cernaSchematicRefutationsFormula2021,
  title = {Schematic {{Refutations}} of {{Formula Schemata}}},
  author = {Cerna, David M. and Leitsch, Alexander and Lolic, Anela},
  year = {2021},
  month = jun,
  journal = {Journal of Automated Reasoning},
  volume = {65},
  number = {5},
  pages = {599--645},
  issn = {1573-0670},
  doi = {10.1007/s10817-020-09583-8},
  urldate = {2024-08-01},
  abstract = {Proof schemata are infinite sequences of proofs which are defined inductively. In this paper we present a general framework for schemata of terms, formulas and unifiers and define a resolution calculus for schemata of quantifier-free formulas. The new calculus generalizes and improves former approaches to schematic deduction. As an application of the method we present a schematic refutation formalizing a proof of a weak form of the pigeon hole principle.},
  langid = {english},
  keywords = {Induction,Resolution,Schematic formulas,Schematic proofs},
  file = {/home/flaviomoura/Zotero/storage/2ZUJDXXX/Cerna et al. - 2021 - Schematic Refutations of Formula Schemata.pdf}
}

@article{cernaSpecialCaseSchematic,
  title = {A {{Special Case}} of {{Schematic Syntactic Unification}}},
  author = {Cerna, David M},
  pages = {8},
  abstract = {We present a unification problem based on firstorder syntactic unification which ask whether every problem in a schematically-defined sequence of unification problems is unifiable, so called loop unification. Alternatively, our problem may be formulated as a recursive procedure calling first-order syntactic unification on certain bindings occurring in the solved form resulting from unification. Loop unification is closely related to Narrowing as the schematic constructions can be seen as a rewrite rule applied during unification, and primal grammars, as we deal with recursive term constructions. However, loop unification relaxes the restrictions put on variables as fresh as well as used extra variables may be introduced by rewriting. In this work we consider an important special case, so called semiloop unification. We provide a sufficient condition for unifiability of the entire sequence based on the structure of a sufficiently long initial segment. It remains an open question whether this condition is also necessary for semiloop unification and how it may be extended to loop unification.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DISML8AD/Cerna - A Special Case of Schematic Syntactic Uniï¬cation.pdf}
}

@book{ceulemansGroupTheoryApplied2013,
  title = {Group {{Theory Applied}} to {{Chemistry}}},
  author = {Ceulemans, Arnout Jozef},
  year = {2013},
  series = {Theoretical {{Chemistry}} and {{Computational Modelling}}},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-007-6863-5}
}

@article{changKreiselKrivineElements1969,
  title = {Kreisel {{G}}. and {{Krivine J}}. {{L}}.. {{Elements}} of {{Mathematical Logic}}. (Model {{Theory}}). {{North-Holland Publishing Company}}, {{Amsterdam}} 1967, {{Xi}} + 222 {{Pp}}.},
  author = {Chang, C. C.},
  year = {1969},
  journal = {The Journal of Symbolic Logic},
  volume = {34},
  number = {01},
  pages = {112},
  doi = {10.2307/2270989}
}

@inproceedings{chanMechanisationAKSAlgorithm2015,
  title = {Mechanisation of {{AKS Algorithm}}: {{Part}} 1 - {{The Main Theorem}}},
  booktitle = {Interactive {{Theorem Proving}} - 6th {{International Conference}}, {{ITP}} 2015, {{Nanjing}}, {{China}}, {{August}} 24-27, 2015, {{Proceedings}}},
  author = {Chan, Hing-Lun and Norrish, Michael},
  year = {2015},
  pages = {117--136},
  doi = {10.1007/978-3-319-22102-1_8}
}

@article{chanPrimalityTestingPolynomialtime,
  title = {Primality {{Testing}} Is {{Polynomial-time}}: {{A Mechanised Verification}} of the {{AKS Algorithm}}},
  author = {Chan, Hing Lun},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DLLFRAZN/Chan - Primality Testing is Polynomial-time A Mechanised.pdf}
}

@misc{chardonnetCurryHowardCorrespondenceLinear2023,
  title = {A {{Curry-Howard Correspondence}} for {{Linear}}, {{Reversible Computation}}},
  author = {Chardonnet, Kostia and Saurin, Alexis and Valiron, Beno{\^i}t},
  year = {2023},
  month = jul,
  eprint = {2302.11887},
  primaryclass = {cs},
  doi = {10.4230/LIPIcs.CSL.2023.13},
  urldate = {2023-08-01},
  abstract = {In this paper, we present a linear and reversible programming language with inductives types and recursion. The semantics of the languages is based on pattern-matching; we show how ensuring syntactical exhaustivity and non-overlapping of clauses is enough to ensure reversibility. The language allows to represent any Primitive Recursive Function. We then give a Curry-Howard correspondence with the logic \${\textbackslash}mu\$MALL: linear logic extended with least fixed points allowing inductive statements. The critical part of our work is to show how primitive recursion yields circular proofs that satisfy \${\textbackslash}mu\$MALL validity criterion and how the language simulates the cut-elimination procedure of \${\textbackslash}mu\$MALL.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/LDSZESPG/Chardonnet et al. - 2023 - A Curry-Howard Correspondence for Linear, Reversib.pdf}
}

@article{chargueraudLocallyNamelessRepresentation2011,
  title = {The {{Locally Nameless Representation}}},
  author = {Chargu{\'e}raud, A.},
  year = {2011},
  journal = {Journal of Automated Reasoning},
  pages = {1--46},
  publisher = {Springer Netherlands},
  issn = {0168-7433},
  doi = {10.1007/s10817-011-9225-2},
  abstract = {This paper provides an introduction to the locally nameless approach to the representation of syntax with variable binding, focusing in particular on the use of this technique in formal proofs. First, we explain the benefits of representing bound variables with de Bruijn indices while retaining names for free variables. Then, we explain how to describe and manipulate syntax in that form, and show how to define and reason about judgments on locally nameless terms.},
  file = {/home/flaviomoura/Zotero/storage/V2WTTAZ6/CharguÃ©raud - 2011 - The Locally Nameless Representation.pdf}
}

@incollection{chargueraudMachineCheckedVerificationCorrectness2015,
  title = {Machine-{{Checked Verification}} of the {{Correctness}} and {{Amortized Complexity}} of an {{Efficient Union-Find Implementation}}},
  booktitle = {Interactive {{Theorem Proving}}},
  author = {Chargu{\'e}raud, Arthur and Pottier, Fran{\c c}ois},
  editor = {Urban, Christian and Zhang, Xingyuan},
  year = {2015},
  volume = {9236},
  pages = {137--153},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-22102-1_9},
  urldate = {2022-03-30},
  abstract = {Union-Find is a famous example of a simple data structure whose amortized asymptotic time complexity analysis is non-trivial. We present a Coq formalization of this analysis. Moreover, we implement Union-Find as an OCaml library and formally endow it with a modular specification that offers a full functional correctness guarantee as well as an amortized complexity bound. Reasoning in Coq about imperative OCaml code relies on the CFML tool, which is based on characteristic formulae and Separation Logic, and which we extend with time credits. Although it was known in principle that amortized analysis can be explained in terms of time credits and that time credits can be viewed as resources in Separation Logic, we believe our work is the first practical demonstration of this approach.},
  isbn = {978-3-319-22101-4 978-3-319-22102-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/6WR6DGEP/CharguÃ©raud and Pottier - 2015 - Machine-Checked Verification of the Correctness an.pdf}
}

@inproceedings{chargueraudMachineCheckedVerificationCorrectness2015a,
  title = {Machine-{{Checked Verification}} of the {{Correctness}} and {{Amortized Complexity}} of an {{Efficient Union-Find Implementation}}},
  booktitle = {Interactive {{Theorem Proving}}},
  author = {Chargu{\'e}raud, Arthur and Pottier, Fran{\c c}ois},
  editor = {Urban, Christian and Zhang, Xingyuan},
  year = {2015},
  pages = {137--153},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-22102-1_9},
  abstract = {Union-Find is a famous example of a simple data structure whose amortized asymptotic time complexity analysis is non-trivial. We present a Coq formalization of this analysis. Moreover, we implement Union-Find as an OCaml library and formally endow it with a modular specification that offers a full functional correctness guarantee as well as an amortized complexity bound. Reasoning in Coq about imperative OCaml code relies on the CFML tool, which is based on characteristic formulae and Separation Logic, and which we extend with time credits. Although it was known in principle that amortized analysis can be explained in terms of time credits and that time credits can be viewed as resources in Separation Logic, we believe our work is the first practical demonstration of this approach.},
  isbn = {978-3-319-22102-1},
  langid = {english},
  keywords = {Characteristic Formula,Function Call,Functional Correctness,Garbage Collection,Separation Logic},
  file = {/home/flaviomoura/Zotero/storage/CKSSJMBL/CharguÃ©raud e Pottier - 2015 - Machine-Checked Verification of the Correctness an.pdf}
}

@article{chargueraudModernEyeSeparation,
  title = {A {{Modern Eye}} on {{Separation Logic}} for {{Sequential Programs}}},
  author = {Chargu{\'e}raud, Arthur},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9ZRLAVBU/CharguÃ©raud - A Modern Eye on Separation Logic for Sequential Pr.pdf}
}

@article{chargueraudOmnisemanticsSmoothHandling2023,
  title = {Omnisemantics: {{Smooth Handling}} of {{Nondeterminism}}},
  shorttitle = {Omnisemantics},
  author = {Chargu{\'e}raud, Arthur and Chlipala, Adam and Erbsen, Andres and Gruetter, Samuel},
  year = {2023},
  month = mar,
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {45},
  number = {1},
  pages = {1--43},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/3579834},
  urldate = {2024-07-02},
  abstract = {This paper gives an in-depth presentation of the omni-big-step and omni-small-step styles of semantic judgments. These styles describe operational semantics by relating starting states to sets of outcomes rather than to individual outcomes. A single derivation of these semantics for a particular starting state and program describes all possible nondeterministic executions (hence the name omni), whereas in traditional small-step and big-step semantics, each derivation only talks about one single execution. This restructuring allows for straightforward modeling of both nondeterminism and undefined behavior as commonly encountered in sequential functional and imperative programs. Specifically, omnisemantics inherently assert safety, i.e. they guarantee that none of the execution branches gets stuck, while traditional semantics need either a separate judgment or additional error markers to specify safety in the presence of nondeterminism. Omnisemantics can be understood as an inductively defined weakest-precondition semantics (or more generally, predicate-transformer semantics) that does not involve invariants for loops and recursion but instead uses unrolling rules like in traditional small-step and big-step semantics. Omnisemantics were previously described in association with several projects, but we believe the technique has been underappreciated and deserves a well-motivated, extensive, and pedagogical presentation of its benefits. We also explore several novel aspects associated with these semantics, in particular their use in type-safety proofs for lambda calculi, partial-correctness reasoning, and forward proofs of compiler correctness for terminating but potentially nondeterministic programs being compiled to nondeterministic target languages. All results in this paper are formalized in Coq. CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Operational semantics; Axiomatic semantics; Pre- and post-conditions; Program verification; Hoare logic; Separation logic.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/8LIUVCFJ/CharguÃ©raud et al. - 2023 - Omnisemantics Smooth Handling of Nondeterminism.pdf;/home/flaviomoura/Zotero/storage/C5Z3T9QU/CharguÃ©raud et al. - 2023 - Omnisemantics Smooth Handling of Nondeterminism.pdf}
}

@article{chargueraudVerifyingCorrectnessAmortized2019,
  title = {Verifying the {{Correctness}} and {{Amortized Complexity}} of a {{Union-Find Implementation}} in {{Separation Logic}} with {{Time Credits}}},
  author = {Chargu{\'e}raud, Arthur and Pottier, Fran{\c c}ois},
  year = {2019},
  month = mar,
  journal = {Journal of Automated Reasoning},
  volume = {62},
  number = {3},
  pages = {331--365},
  issn = {0168-7433, 1573-0670},
  doi = {10.1007/s10817-017-9431-7},
  urldate = {2020-11-13},
  langid = {english},
  keywords = {Separation logic,Time credits,Union-Find,Verification},
  file = {/home/flaviomoura/Zotero/storage/C99LXA33/10.1007@s10817-017-9431-7.pdf;/home/flaviomoura/Zotero/storage/XY46B9QZ/CharguÃ©raud e Pottier - 2019 - Verifying the Correctness and Amortized Complexity.pdf}
}

@article{chargueraudVOCALVerifiedOCAml,
  title = {{{VOCAL}} -- {{A Verified OCAml Library}}},
  author = {Chargu{\'e}raud, Arthur and Filli{\^a}tre, Jean-Christophe and Pereira, M{\'a}rio and Pottier, Fran{\c c}ois},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/CU32XBNX/CharguÃ©raud et al. - VOCAL â A Verified OCAml Library.pdf}
}

@article{cheneyEquivariantUnification2010,
  title = {Equivariant {{Unification}}},
  author = {Cheney, James},
  year = {2010},
  month = oct,
  journal = {Journal of Automated Reasoning},
  volume = {45},
  number = {3},
  pages = {267--300},
  issn = {0168-7433, 1573-0670},
  doi = {10.1007/s10817-009-9164-3},
  urldate = {2021-02-21},
  langid = {english}
}

@inproceedings{cheneyGeneralTheoryNames2005,
  title = {Toward a General Theory of Names: Binding and Scope},
  shorttitle = {Toward a General Theory of Names},
  booktitle = {Proceedings of the 3rd {{ACM SIGPLAN}} Workshop on {{Mechanized}} Reasoning about Languages with Variable Binding  - {{MERLIN}} '05},
  author = {Cheney, James},
  year = {2005},
  pages = {33--40},
  publisher = {ACM Press},
  address = {Tallinn, Estonia},
  doi = {10.1145/1088454.1088459},
  urldate = {2021-02-21},
  isbn = {978-1-59593-072-9},
  langid = {english}
}

@article{cheneyNominalLogicProgramming2008,
  title = {Nominal Logic Programming},
  author = {Cheney, James and Urban, Christian},
  year = {2008},
  month = aug,
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {30},
  number = {5},
  pages = {1--47},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/1387673.1387675},
  urldate = {2021-02-21},
  abstract = {Nominal logic is an extension of first-order logic which provides a simple foundation for formalizing and reasoning about abstract syntax modulo consistent renaming of bound names (that is, {$\alpha$}-equivalence). This article investigates logic programming based on nominal logic. We describe some typical nominal logic programs, and develop the model-theoretic, proof-theoretic, and operational semantics of such programs. Besides being of interest for ensuring the correct behavior of implementations, these results provide a rigorous foundation for techniques for analysis and reasoning about nominal logic programs, as we illustrate via examples.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/JTSGBTIQ/Cheney e Urban - 2008 - Nominal logic programming.pdf}
}

@misc{cheneyNominalMatchingLogic2022,
  title = {Nominal {{Matching Logic}}},
  author = {Cheney, James and Fern{\'a}ndez, Maribel},
  year = {2022},
  month = jul,
  eprint = {2207.14139},
  primaryclass = {cs},
  doi = {10.1145/3551357.3551375},
  urldate = {2022-08-01},
  abstract = {We introduce Nominal Matching Logic (NML) as an extension of Matching Logic with names and binding following the Gabbay-Pitts nominal approach. Matching logic is the foundation of the \${\textbackslash}mathbb\{K\}\$ framework, used to specify programming languages and automatically derive associated tools (compilers, debuggers, model checkers, program verifiers). Matching logic does not include a primitive notion of name binding, though binding operators can be represented via an encoding that internalises the graph of a function from bound names to expressions containing bound names. This approach is sufficient to represent computations involving binding operators, but has not been reconciled with support for inductive reasoning over syntax with binding (e.g., reasoning over \${\textbackslash}lambda\$-terms). Nominal logic is a formal system for reasoning about names and binding, which provides well-behaved and powerful principles for inductive reasoning over syntax with binding, and NML inherits these principles. We discuss design alternatives for the syntax and the semantics of NML, prove meta-theoretical properties and give examples to illustrate its expressive power. In particular, we show how induction principles for \${\textbackslash}lambda\$-terms (\${\textbackslash}alpha\$-structural induction) can be defined and used to prove standard properties of the \${\textbackslash}lambda\$-calculus.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/UJIRSVVR/Cheney and FernÃ¡ndez - 2022 - Nominal Matching Logic.pdf;/home/flaviomoura/Zotero/storage/FK5RNH6G/2207.html}
}

@inproceedings{cheneySimplerProofTheory2005,
  title = {A {{Simpler Proof Theory}} for {{Nominal Logic}}},
  booktitle = {Foundations of {{Software Science}} and {{Computational Structures}}, 8th {{International Conference}}, {{FOSSACS}} 2005, {{Held}} as {{Part}} of the {{Joint European Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2005, {{Edinburgh}}, {{UK}}, {{April}} 4-8, 2005, {{Proceedings}}},
  author = {Cheney, J.},
  year = {2005},
  pages = {379--394},
  doi = {10.1007/978-3-540-31982-5_24}
}

@article{cheneySimpleSequentCalculus2014,
  title = {A {{Simple Sequent Calculus}} for {{Nominal Logic}}},
  author = {Cheney, J.},
  year = {2014},
  journal = {Journal of Logic and Computation},
  volume = {26},
  number = {2},
  pages = {699--726},
  doi = {10.1093/logcom/exu024},
  file = {/home/flaviomoura/Zotero/storage/2RGS9WBV/Cheney - 2014 - A Simple Sequent Calculus for Nominal Logic.pdf}
}

@inproceedings{chenFormalProofsTarjan2019,
  title = {Formal {{Proofs}} of {{Tarjan}}'s {{Strongly Connected Components Algorithm}} in {{Why3}}, {{Coq}} and {{Isabelle}}},
  booktitle = {Tenth {{Conference}} on {{Interactive Theorem Proving}} - {{ITP}} 2019},
  author = {Chen, Ran and Cohen, Cyril and L{\'e}vy, Jean-Jacques and Merz, Stephan and Th{\'e}ry, Laurent},
  year = {2019},
  file = {/home/flaviomoura/Zotero/storage/6YDK832J/Chen et al. - Formal Proofs of Tarjan's Strongly Connected Compo.pdf}
}

@inproceedings{chenFormalTreatmentBidirectional2024,
  title = {A {{Formal Treatment}} of {{Bidirectional Typing}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Chen, Liang-Ting and Ko, Hsiang-Shang},
  editor = {Weirich, Stephanie},
  year = {2024},
  pages = {115--142},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-57262-3_5},
  abstract = {There has been much progress in designing bidirectional type systems and associated type synthesis algorithms, but mainly on a case-by-case basis. To remedy the situation, this paper develops a general and formal theory of bidirectional typing for simply typed languages: for every signature that specifies a mode-correct bidirectionally typed language, there exists a proof-relevant type synthesiser which, given an input abstract syntax tree, constructs a typing derivation if any, gives its refutation if not, or reports that the input does not have enough type annotations. Sufficient conditions for deriving a type synthesiser such as soundness, completeness, and mode-correctness are studied universally for all signatures. We propose a preprocessing step called mode decoration, which helps the user to deal with missing type annotations. The entire theory is formally implemented in Agda, so we provide a verified generator of proof-relevant type synthesisers as a by-product of our formalism.},
  isbn = {978-3-031-57262-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/A83ZHQIX/Chen e Ko - 2024 - A Formal Treatment of Bidirectional Typing.pdf}
}

@article{chenReviewMechanicalProving2025,
  title = {A {{Review}} on {{Mechanical Proving}} and {{Formalization}} of {{Mathematical Theorems}}},
  author = {Chen, Si and Yu, Wensheng and Dou, Guowei and Zhang., Qimeng},
  year = {2025},
  journal = {IEEE Access},
  pages = {1--1},
  issn = {2169-3536},
  doi = {10.1109/ACCESS.2025.3552634},
  urldate = {2025-03-23},
  abstract = {The field of artificial intelligence represents a frontier and a focal point of contemporary technological development. As an important embodiment of artificial intelligence applied to theoretical-level research, mechanical proving has been a subject of significant interest among researchers. The past few centuries have witnessed multiple periods of machine proof of mathematical theorems as computer technology has continued to evolve. From the initial proposal of ``mechanization of human mental labor'' being proposed to the present, the idea of ``mechanization of mathematics'' has been gradually being realized. Along with various formalization tools being developed, mechanical proving have ushered in a new era nowadays. This paper introduces and summarizes the history of mathematical formalization, the main formalization tools and the main theoretical achievements in different stages and fields. This paper also provides an overview of our group's work in the formalization of a series of mathematical theorems using Coq, including Morse-Kelly axiomatic set theory and the foundations of analysis among others. Despite the considerable promise of formal tools in bolstering system reliability and mathematical rigorousness, it continues to encounter obstacles in practical applications. Although the formal tool holds considerable prospects in enhancing system reliability and mathematical rigorousness, it still meets with barriers in practical application. The paper concludes with a discussion of some of the current challenges associated with mechanical proving, as well as offers suggestions for future research directions.},
  keywords = {Artificial intelligence,Artificial Intelligence,Automation,Cognition,Convergence,Coq,formalization,Logic,Mathematics,mechanical proving,Morse-Kelley axiomatic set theory,Refining,Reliability,Set theory,Telecommunications,theorem provers},
  file = {/home/flaviomoura/Zotero/storage/2GWASXNT/Chen et al. - 2025 - A Review on Mechanical Proving and Formalization o.pdf;/home/flaviomoura/Zotero/storage/7AA649N6/10930874.html}
}

@incollection{chenSemiautomaticProofStrong2017,
  title = {A {{Semi-automatic Proof}} of {{Strong Connectivity}}},
  booktitle = {Verified {{Software}}. {{Theories}}, {{Tools}}, and {{Experiments}}},
  author = {Chen, Ran and L{\'e}vy, Jean-Jacques},
  editor = {Paskevich, Andrei and Wies, Thomas},
  year = {2017},
  volume = {10712},
  pages = {49--65},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-72308-2_4},
  urldate = {2020-10-10},
  isbn = {978-3-319-72307-5 978-3-319-72308-2},
  file = {/home/flaviomoura/Zotero/storage/6ELWIPT2/Chen e LÃ©vy - 2017 - A Semi-automatic Proof of Strong Connectivity.pdf}
}

@article{cherevichenkoAlphaconversionEasy2013,
  title = {Is Alpha-Conversion Easy?},
  author = {Cherevichenko, G.},
  year = {2013},
  month = mar,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic}
}

@incollection{chicliMathematicalQuotientsQuotient2003,
  title = {Mathematical {{Quotients}} and {{Quotient Types}} in {{Coq}}},
  booktitle = {Lecture {{Notes}} in {{Computer Science}}},
  author = {Chicli, Laurent and Pottier, Lo{\"i}c and Simpson, Carlos},
  year = {2003},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {95--107},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-39185-1_6}
}

@book{chiswellMathematicalLogic2007,
  title = {Mathematical {{Logic}}},
  author = {Chiswell, I. and Hodges, W.},
  year = {2007},
  series = {{{OXFORD TEXTS IN LOGIC}}},
  publisher = {OUP Oxford},
  isbn = {978-0-19-857100-1},
  lccn = {2006103200}
}

@book{chiswellMathematicalLogic2007a,
  title = {Mathematical Logic},
  author = {Chiswell, Ian and Hodges, Wilfrid},
  year = {2007},
  series = {Oxford Texts in Logic},
  number = {3},
  publisher = {Oxford University Press},
  address = {London ; New York},
  isbn = {978-0-19-921562-1 978-0-19-857100-1},
  lccn = {QA9.2 .C45 2007},
  keywords = {Logic Symbolic and mathematical},
  annotation = {OCLC: ocm77012114}
}

@book{chlipalaCertifiedProgrammingDependent2017,
  title = {Certified {{Programming}} with {{Dependent Types}}},
  author = {Chlipala, A.},
  year = {2017},
  publisher = {MIT Press}
}

@book{chlipalaFormalReasoningPrograms2017,
  title = {Formal {{Reasoning About Programs}}},
  author = {Chlipala, A.},
  year = {2017}
}

@article{chlipalaIntroductionProgrammingProving2010,
  title = {An {{Introduction}} to {{Programming}} and {{Proving}} with {{Dependent Types}} in {{Coq}}},
  author = {Chlipala, Adam},
  year = {2010},
  month = dec,
  journal = {Journal of Formalized Reasoning},
  volume = {3},
  number = {2},
  pages = {1--93},
  issn = {1972-5787},
  doi = {10.6092/issn.1972-5787/1978},
  urldate = {2024-10-11},
  abstract = {Computer proof assistants vary along many dimensions. Among the mature implementations, the Coq system is distinguished by two key features. First, we have support for programming with dependent types in the tradition of type theory, based on dependent function types and inductive type families. Second, we have a domain-specific language for coding correct-by-construction proof automation. Though the Coq user community has grown quite large, neither of the aspects I highlight is widely used. In this tutorial, I aim to provide a pragmatic introduction to both, showing how they can bring significant improvements in productivity.},
  copyright = {Copyright (c) 2010 Adam Chlipala},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HJJWRMYH/Chlipala - 2010 - An Introduction to Programming and Proving with De.pdf}
}

@inproceedings{chlipalaParametricHigherorderAbstract2008,
  title = {Parametric Higher-Order Abstract Syntax for Mechanized Semantics},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Chlipala, Adam},
  year = {2008},
  month = sep,
  series = {{{ICFP}} '08},
  pages = {143--156},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1411204.1411226},
  urldate = {2024-04-26},
  abstract = {We present parametric higher-order abstract syntax (PHOAS), a new approach to formalizing the syntax of programming languages in computer proof assistants based on type theory. Like higher-order abstract syntax (HOAS), PHOAS uses the meta language's binding constructs to represent the object language's binding constructs. Unlike HOAS, PHOAS types are definable in general-purpose type theories that support traditional functional programming, like Coq's Calculus of Inductive Constructions. We walk through how Coq can be used to develop certified, executable program transformations over several statically-typed functional programming languages formalized with PHOAS; that is, each transformation has a machine-checked proof of type preservation and semantic preservation. Our examples include CPS translation and closure conversion for simply-typed lambda calculus, CPS translation for System F, and translation from a language with ML-style pattern matching to a simpler language with no variable-arity binding constructs. By avoiding the syntactic hassle associated with first-order representation techniques, we achieve a very high degree of proof automation.},
  isbn = {978-1-59593-919-7},
  keywords = {compiler verification,dependent types,interactive proof assistants,type-theoretic semantics}
}

@article{chlipalaSkippingBinderBureaucracy,
  title = {Skipping the {{Binder Bureaucracy}} with {{Mixed Embeddings}} in a {{Semantics Course}} ({{Functional Pearl}})},
  author = {Chlipala, Adam},
  volume = {5},
  pages = {28},
  abstract = {ADAM CHLIPALA, MIT, USA Rigorous reasoning about programs calls for some amount of bureaucracy in managing details like variable binding, but, in guiding students through big ideas in semantics, we might hope to minimize the overhead. We describe our experiment introducing a range of such ideas, using the Coq proof assistant, without any explicit representation of variables, instead using a higher-order syntax encoding that we dub {\l}mixed embedding{\v z}: it is neither the fully explicit syntax of deep embeddings nor the syntax-free programming of shallow embeddings. Marquee examples include different takes on concurrency reasoning, including in the traditions of model checking (partial-order reduction), program logics (concurrent separation logic), and type checking (session types) {\'s} all presented without any side conditions on variables. CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Program semantics; Program reasoning.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/58C4SYN7/Chlipala - Skipping the Binder Bureaucracy with Mixed Embeddi.pdf}
}

@book{chongchitnanExploringUniversityMathematics2023,
  title = {Exploring {{University Mathematics}} with {{Python}}},
  author = {Chongchitnan, Siri},
  year = {2023},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-46270-2},
  urldate = {2024-12-10},
  copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
  isbn = {978-3-031-46269-6 978-3-031-46270-2},
  langid = {english}
}

@article{choudhuryFreeCommutativeMonoids,
  title = {Free {{Commutative Monoids}} in {{Homotopy Type Theory}}},
  author = {Choudhury, Vikraman and Fiore, Marcelo},
  abstract = {We develop a constructive theory of finite multisets in Homotopy Type Theory, defining them as free commutative monoids. After recalling basic structural properties of the free commutative-monoid construction, we formalise and establish the categorical universal property of two, necessarily equivalent, algebraic presentations of free commutative monoids using 1-HITs. These presentations correspond to two different equational theories invariably including commutation axioms. In this setting, we prove important structural combinatorial properties of finite multisets. These properties are established in full generality without assuming decidable equality on the carrier set. As an application, we present a constructive formalisation of the relational model of classical linear logic and its differential structure. This leads to constructively establishing that free commutative monoids are conical refinement monoids. Thereon we obtain a characterisation of the equality type of finite multisets and a new presentation of the free commutative-monoid construction as a set-quotient of the list construction. These developments crucially rely on the commutation relation of creation/annihilation operators associated with the free commutative-monoid construction seen as a combinatorial Fock space.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DUCECPZA/Choudhury e Fiore - Free Commutative Monoids in Homotopy Type Theory.pdf}
}

@inproceedings{chrzaszczImplementingModulesCoq2003,
  title = {Implementing {{Modules}} in the {{Coq System}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Chrz{\k a}szcz, Jacek},
  editor = {Basin, David and Wolff, Burkhart},
  year = {2003},
  pages = {270--286},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/10930755_18},
  abstract = {The paper describes the implementation of interactive ML-style modules in the recent version 7.4 of Coq proof assistant. Modules (especially higher-order) provide a very convenient tool for parametrized theories which was lacking in Coq for years. Their interactive character extends naturally the interactive environment provided by the proof assistant. The implementation follows the paradigm of recent versions of Coq to separate the correctness-critical code from the rest of the system, using abstraction barriers.},
  isbn = {978-3-540-45130-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SMCGZSGH/ChrzÄszcz - 2003 - Implementing Modules in the Coq System.pdf}
}

@article{churchFormulationSimpleTheory1940,
  title = {A {{Formulation}} of the {{Simple Theory}} of {{Types}}},
  author = {Church, A.},
  year = {1940},
  journal = {journal of Symbolic Logic},
  volume = {5},
  pages = {56--68}
}

@article{churchPropertiesConversion1936,
  title = {Some Properties of Conversion},
  author = {Church, A. and Rosser, J. B.},
  year = {1936},
  journal = {Trans. Amer. Math. Soc.},
  volume = {39},
  pages = {472--482}
}

@article{churchSetPostulatesFoundation1932,
  title = {A Set of Postulates for the Foundation of Logic},
  author = {Church, A.},
  year = {1932},
  journal = {Annals of Math.},
  volume = {33},
  number = {2},
  pages = {346--366}
}

@article{churchSetPostulatesFoundation1933,
  title = {A Set of Postulates for the Foundation of Logic ({{Second Paper}})},
  author = {Church, A.},
  year = {1933},
  journal = {Annals of Math.},
  volume = {34},
  number = {2},
  pages = {839--864}
}

@article{churchUnsolvableProblemElementary1936,
  title = {An {{Unsolvable Problem}} of {{Elementary Number Theory}}},
  author = {Church, A.},
  year = {1936},
  journal = {American Journal of Mathematics},
  volume = {58},
  number = {2},
  pages = {345--363}
}

@misc{ciattoLargeLanguageModels2024,
  title = {Large Language Models as Oracles for Instantiating Ontologies with Domain-Specific Knowledge},
  author = {Ciatto, Giovanni and Agiollo, Andrea and Magnini, Matteo and Omicini, Andrea},
  year = {2024},
  month = apr,
  number = {arXiv:2404.04108},
  eprint = {2404.04108},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.04108},
  urldate = {2024-04-08},
  abstract = {Background. Endowing intelligent systems with semantic data commonly requires designing and instantiating ontologies with domain-specific knowledge. Especially in the early phases, those activities are typically performed manually by human experts possibly leveraging on their own experience. The resulting process is therefore time-consuming, error-prone, and often biased by the personal background of the ontology designer. Objective. To mitigate that issue, we propose a novel domain-independent approach to automatically instantiate ontologies with domain-specific knowledge, by leveraging on large language models (LLMs) as oracles. Method. Starting from (i) an initial schema composed by inter-related classes andproperties and (ii) a set of query templates, our method queries the LLM multi- ple times, and generates instances for both classes and properties from its replies. Thus, the ontology is automatically filled with domain-specific knowledge, compliant to the initial schema. As a result, the ontology is quickly and automatically enriched with manifold instances, which experts may consider to keep, adjust, discard, or complement according to their own needs and expertise. Contribution. We formalise our method in general way and instantiate it over various LLMs, as well as on a concrete case study. We report experiments rooted in the nutritional domain where an ontology of food meals and their ingredients is semi-automatically instantiated from scratch, starting from a categorisation of meals and their relationships. There, we analyse the quality of the generated ontologies and compare ontologies attained by exploiting different LLMs. Finally, we provide a SWOT analysis of the proposed method.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computation and Language,Computer Science - Information Retrieval,Computer Science - Logic in Computer Science,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/SMTAVUZF/Ciatto et al. - 2024 - Large language models as oracles for instantiating.pdf;/home/flaviomoura/Zotero/storage/Q9ACX82Q/2404.html}
}

@unpublished{cicAtaPrimeiraReuniao2020,
  title = {Ata Da {{Primeira Reuni{\~a}o Extraordin{\'a}ria}} Do {{Colegiado}} Do {{CIC}}},
  author = {CIC},
  year = {2020},
  abstract = {Ata de reuni{\~a}o do Colegiado}
}

@book{cicListaContatosCIC2016,
  title = {Lista de Contatos Do {{CIC}}},
  author = {CIC, Secretaria},
  year = {2016}
}

@unpublished{cicPautaColegiadoCIC2020,
  title = {Pauta Do Colegiado {{CIC}} de 10 de Julho de 2020},
  author = {CIC},
  year = {2020},
  abstract = {Pauta do Colegiado CIC}
}

@article{cintulaAdmissibleRulesImplicationnegation2010,
  title = {Admissible {{Rules}} in the {{Implication-negation Fragment}} of {{Intuitionistic Logic}}},
  author = {Cintula, P. and Metcalfe, G.},
  year = {2010},
  journal = {Annals of Pure and Applied Logic},
  volume = {162},
  number = {2},
  pages = {162--171},
  doi = {10.1016/j.apal.2010.09.001}
}

@book{ClassicalDecisionProblem,
  title = {The {{Classical Decision Problem}}},
  urldate = {2024-08-05},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DMFQ2E6Q/9783540423249.html}
}

@misc{clementFiniteElementMethod2024,
  title = {Finite Element Method. {{Detailed}} Proofs to Be Formalized in {{Coq}}},
  author = {Cl{\'e}ment, Fran{\c c}ois and Martin, Vincent},
  year = {2024},
  month = oct,
  number = {arXiv:2410.01538},
  eprint = {2410.01538},
  publisher = {arXiv},
  urldate = {2024-10-10},
  abstract = {To obtain the highest confidence on the correction of numerical simulation programs for the resolution of Partial Differential Equations (PDEs), one has to formalize the mathematical notions and results that allow to establish the soundness of the approach. The finite element method is one of the popular tools for the numerical resolution of a wide range of PDEs. The purpose of this document is to provide the formal proof community with very detailed pen-and-paper proofs for the construction of the Lagrange finite elements of any degree on simplices in positive dimension.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Numerical Analysis,Mathematics - Numerical Analysis},
  file = {/home/flaviomoura/Zotero/storage/5QSEQU5T/ClÃ©ment e Martin - 2024 - Finite element method. Detailed proofs to be forma.pdf;/home/flaviomoura/Zotero/storage/BIH29MCB/2410.html}
}

@incollection{coenSemireflexiveTacticSub2006,
  title = {A {{Semi-reflexive Tactic}} for ({{Sub-}}){{Equational Reasoning}}},
  booktitle = {Lecture {{Notes}} in {{Computer Science}}},
  author = {Coen, C. S.},
  year = {2006},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {98--114},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/11617990_7}
}

@misc{cohenBargainMergesortsFunctional2024,
  title = {A Bargain for Mergesorts (Functional Pearl) -- {{How}} to Prove Your Mergesort Correct and Stable, Almost for Free},
  author = {Cohen, Cyril and Sakaguchi, Kazuhiko},
  year = {2024},
  month = mar,
  number = {arXiv:2403.08173},
  eprint = {2403.08173},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-14},
  abstract = {We present a novel characterization of stable mergesort functions using relational parametricity, and show that it implies the correctness of mergesort. As a result, one can prove the correctness of several variations of mergesort (e.g., top-down, bottom-up, tail-recursive, non-tail-recursive, smooth, and non-smooth mergesorts) by proving the characterization property for each variation. To further motivate this work, we show a performance trade-off between tail-recursive and non-tail-recursive mergesorts that (1) the former in call-by-value evaluation avoids using up stack space and is efficient and (2) the latter in call-by-need evaluation is an optimal incremental sort, meaning that it performs only \${\textbackslash}mathcal\{O\}(n + k {\textbackslash}log k)\$ comparisons to compute the least (or greatest) \$k\$ items of a list of length \$n\$. Thanks to our characterization and the parametricity translation, we deduced the correctness results, including stability, of various implementations of mergesort for lists, including highly optimized ones, in the Coq proof assistant.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/QIK2KUXZ/Cohen e Sakaguchi - 2024 - A bargain for mergesorts (functional pearl) -- How.pdf;/home/flaviomoura/Zotero/storage/TPQ5UTZ5/2403.html}
}

@book{cohenCourseSimpleHomotopyTheory1973,
  title = {A {{Course}} in {{Simple-Homotopy Theory}}},
  author = {Cohen, Marshall M.},
  editor = {Halmos, P. R.},
  year = {1973},
  series = {Graduate {{Texts}} in {{Mathematics}}},
  volume = {10},
  publisher = {Springer New York},
  address = {New York, NY},
  doi = {10.1007/978-1-4684-9372-6},
  urldate = {2023-11-08},
  isbn = {978-0-387-90055-1 978-1-4684-9372-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9KXHECLF/Cohen - 1973 - A Course in Simple-Homotopy Theory.pdf}
}

@phdthesis{cohenFormalizedAlgebraicNumbers2012,
  title = {Formalized Algebraic Numbers: Construction and First-Order Theory},
  author = {Cohen, Cyril},
  year = {2012},
  month = nov,
  langid = {english},
  school = {{\'E}cole polytechnique},
  keywords = {Algebraic numbers,Constructive mathematics,Coq,Formal proofs,Formalization of mathematics,Quantifier elimination,Real numbers,Small scale reflection}
}

@article{cohenFrontMatterTable2021,
  title = {Front {{Matter}}, {{Table}} of {{Contents}}, {{Preface}}, {{Conference Organization}}},
  author = {Cohen, Liron and Kaliszyk, Cezary},
  year = {2021},
  pages = {8 pages, 454057 bytes},
  publisher = {[object Object]},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.ITP.2021.0},
  urldate = {2024-04-17},
  abstract = {Front Matter, Table of Contents, Preface, Conference Organization},
  collaborator = {Cohen, Liron and Kaliszyk, Cezary},
  copyright = {Creative Commons Attribution 4.0 International license, info:eu-repo/semantics/openAccess},
  isbn = {9783959771887},
  langid = {english},
  keywords = {Conference Organization,Front Matter,Preface,Table of Contents,Theory of computation  Logic},
  file = {/home/flaviomoura/Zotero/storage/LIQ9PZMD/Cohen e Kaliszyk - 2021 - Front Matter, Table of Contents, Preface, Conferen.pdf}
}

@inproceedings{cohenPragmaticQuotientTypes2013,
  title = {Pragmatic {{Quotient Types}} in {{Coq}}},
  booktitle = {Interactive {{Theorem Proving}} - 4th {{International Conference}}, {{ITP}} 2013, {{Rennes}}, {{France}}, {{July}} 22-26, 2013. {{Proceedings}}},
  author = {Cohen, Cyril},
  year = {2013},
  pages = {213--228},
  doi = {10.1007/978-3-642-39634-2_17}
}

@article{colacitoMScThesisAfstudeerscriptie,
  title = {{{MSc Thesis}} ({{Afstudeerscriptie}})},
  author = {Colacito, Almudena},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ZYYCZFTR/Colacito - MSc Thesis (Afstudeerscriptie).pdf}
}

@article{colacitoSubminimalNegation2017,
  title = {Subminimal Negation},
  author = {Colacito, Almudena and De Jongh, Dick and Vargas, Ana Lucia},
  year = {2017},
  month = jan,
  journal = {Soft Computing},
  volume = {21},
  number = {1},
  pages = {165--174},
  issn = {1432-7643, 1433-7479},
  doi = {10.1007/s00500-016-2391-8},
  urldate = {2023-04-22},
  abstract = {Minimal Logic, i.e. intuitionistic logic without the ex falso principle, is investigated in its original form with a negation symbol instead of a symbol denoting the contradiction. A Kripke semantics is developed for minimal logic and its sublogics with a still weaker negation by introducing a function on the upward closed sets of the models. The basic logic is a logic in which the negation has no properties but the one of being a unary operator. A number of extensions is studied of which the most important ones are contraposition logic and negative ex falso, a weak form of the ex falso principle. Completeness is proved and the created semantics is further studied. The negative translation of classical logic into intutionistic logic is made part of a chain of translations by introducing translations from minimal logic into contraposition logic and intuitionistic logic into minimal logic, the latter having been discovered in the correspondence between Johansson and Heyting. Finally, as a bridge to the work of Franco Montagna a start is made of a study of linear models of these logics.},
  langid = {english},
  keywords = {Canonical Model,Classical Logic,Intuitionistic Logic,Kripke Model,Propositional Variable},
  file = {/home/flaviomoura/Zotero/storage/2GFHFCZW/Colacito et al. - 2017 - Subminimal negation.pdf;/home/flaviomoura/Zotero/storage/JH3HCPJK/Colacito et al. - 2017 - Subminimal negation.pdf}
}

@article{collinsCOGNITIVEAPPRENTICESHIPMAKING,
  title = {{{COGNITIVE APPRENTICESHIP}}: {{MAKING THINKING VISIBLE}}},
  author = {Collins, Allan and Brown, John Seely and Holum, Ann},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9GG7VHQM/Collins et al. - COGNITIVE APPRENTICESHIP MAKING THINKING VISIBLE.pdf}
}

@book{comonTreeAutomataTechniques2007,
  title = {Tree {{Automata Techniques}} and {{Applications}}},
  author = {Comon, H. and Dauchet, M. and Gilleron, R. and L{\"o}ding, C. and Jacquemard, F. and Lugiez, D. and Tison, S. and Tommasi, M.},
  year = {2007},
  annotation = {Published: Available on: http://www.grappa.univ-lille3.fr/tata}
}

@article{condoluciAdmissibleToolsKitchen2018,
  ids = {condoluciAdmissibleToolsKitchen2018a},
  title = {Admissible {{Tools}} in the {{Kitchen}} of {{Intuitionistic Logic}}},
  author = {Condoluci, Andrea and Manighetti, Matteo},
  year = {2018},
  month = oct,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {281},
  eprint = {1810.07372},
  pages = {10--23},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.281.2},
  urldate = {2020-11-22},
  abstract = {The usual reading of logical implication "A implies B" as "if A then B" fails in intuitionistic logic: there are formulas A and B such that "A implies B" is not provable, even though B is provable whenever A is provable. Intuitionistic rules apparently do not capture interesting meta-properties of the logic and, from a computational perspective, the programs corresponding to intuitionistic proofs are not powerful enough. Such non-provable implications are nevertheless admissible, and we study their behavior by means of a proof term assignment and related rules of reduction. We introduce V, a calculus that is able to represent admissible inferences, while remaining in the intuitionistic world by having normal forms that are just intuitionistic terms. We then extend intuitionistic logic with principles corresponding to admissible rules. As an example, we consider the Kreisel-Putnam logic KP, for which we prove the strong normalization and the disjunction property through our term assignment. This is our first step in understanding the essence of admissible rules for intuitionistic logic.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/28K6ZRN8/Condoluci e Manighetti - 2018 - Admissible Tools in the Kitchen of Intuitionistic .pdf;/home/flaviomoura/Zotero/storage/63LIQT8X/Condoluci e Manighetti - 2018 - Admissible Tools in the Kitchen of Intuitionistic .pdf;/home/flaviomoura/Zotero/storage/AIPWMKBJ/1810.html;/home/flaviomoura/Zotero/storage/SD5X3CIZ/1810.html}
}

@incollection{constableFormalSystemsLogics2017,
  title = {Formal {{Systems}}, {{Logics}}, and {{Programs}}},
  booktitle = {Raymond {{Smullyan}} on {{Self Reference}}},
  author = {Constable, Robert L.},
  year = {2017},
  series = {Raymond {{Smullyan}} on {{Self Reference}}},
  pages = {23--38},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-68732-2_2}
}

@misc{contenteCompatibilityMinimalistFoundation2022,
  title = {The {{Compatibility}} of the {{Minimalist Foundation}} with {{Homotopy Type Theory}}},
  author = {Contente, Michele and Maietti, Maria Emilia},
  year = {2022},
  month = jul,
  number = {arXiv:2207.03802},
  eprint = {2207.03802},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {The Minimalist Foundation, for short MF, is a two-level foundation for constructive mathematics ideated by Maietti and Sambin in 2005 and then fully formalized by Maietti in 2009. MF serves as a common core among the most relevant foundations for mathematics in the literature by choosing for each of them the appropriate level of MF to be translated in a compatible way, namely by preserving the meaning of logical and set-theoretical constructors. The two-level structure consists of an intensional level, an extensional one, and an interpretation of the latter in the former in order to extract intensional computational contents from mathematical proofs involving extensional constructions used in everyday mathematical practice. In 2013 a completely new foundation for constructive mathematics appeared in the literature, called Homotopy Type Theory, for short HoTT, which is an example of Voevodsky's Univalent Foundations with a computational nature. So far no level of MF has been proved to be compatible with any of the Univalent Foundations in the literature. Here we show that both levels of MF are compatible with HoTT. This result is made possible thanks to the peculiarities of HoTT which combines intensional features of type theory with extensional ones by assuming Voevodsky's Univalence Axiom and higher inductive quotient types. As a relevant consequence, MF inherits entirely new computable models.},
  archiveprefix = {arXiv},
  keywords = {03B38 03F50 03F04,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/TP8EDBGI/Contente and Maietti - 2022 - The Compatibility of the Minimalist Foundation wit.pdf;/home/flaviomoura/Zotero/storage/33IC7JBS/2207.html}
}

@article{copelloAlphaStructuralInductionRecursion2016,
  title = {Alpha-{{Structural Induction}} and {{Recursion}} for the {{Lambda Calculus}} in {{Constructive Type Theory}}},
  author = {Copello, E. and Tasistro, A. and Szasz, N. and Bove, A. and Fern{\'a}ndez, M.},
  year = {2016},
  journal = {Electr. Notes Theor. Comput. Sci.},
  volume = {323},
  pages = {109--124},
  doi = {10.1016/j.entcs.2016.06.008},
  keywords = {Constructive Type Theory,Formal Metatheory,Lambda Calculus},
  file = {/home/flaviomoura/Zotero/storage/QPLCWQH6/Copello et al. - 2016 - Alpha-Structural Induction and Recursion for the L.pdf}
}

@inproceedings{copelloCaseQuitePainless2014,
  title = {Case of ({{Quite}}) {{Painless Dependently Typed Programming}}: {{Fully Certified Merge Sort}} in {{Agda}}},
  shorttitle = {Case of ({{Quite}}) {{Painless Dependently Typed Programming}}},
  booktitle = {Programming {{Languages}}},
  author = {Copello, Ernesto and Tasistro, {\'A}lvaro and Bianchi, Bruno},
  editor = {Quint{\~a}o Pereira, Fernando Magno},
  year = {2014},
  pages = {62--76},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-11863-5_5},
  abstract = {We present a full certification of merge sort in the language Agda. It features: termination warrant without explicit proof, no proof cost to ensure that the output is sorted, and a succinct proof that the output is a permutation of the input.},
  isbn = {978-3-319-11863-5},
  langid = {english}
}

@article{copelloFormalisationConstructiveType2018,
  title = {Formalisation in {{Constructive Type Theory}} of {{Barendregt}}'s {{Variable Convention}} for {{Generic Structures}} with {{Binders}}},
  author = {Copello, Ernesto and Szasz, Nora and Tasistro, {\'A}lvaro},
  year = {2018},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {274},
  pages = {11--26},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.274.2},
  urldate = {2023-06-23},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Q9BEEKTW/Copello et al. - 2018 - Formalisation in Constructive Type Theory of Baren.pdf}
}

@article{copelloFormalizationMetatheoryLambda2021,
  title = {Formalization of Metatheory of the {{Lambda Calculus}} in Constructive Type Theory Using the {{Barendregt}} Variable Convention},
  author = {Copello, Ernesto and Szasz, Nora and Tasistro, {\'A}lvaro},
  year = {2021},
  month = mar,
  journal = {Mathematical Structures in Computer Science},
  volume = {31},
  number = {3},
  pages = {341--360},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129521000335},
  urldate = {2024-04-22},
  abstract = {We formalize in Constructive Type Theory the Lambda Calculus in its classical first-order syntax, employing only one sort of names for both bound and free variables, and with {$\alpha$}-conversion based upon name swapping. As a fundamental part of the formalization, we introduce principles of induction and recursion on terms which provide a framework for reproducing the use of the Barendregt Variable Convention as in pen-and-paper proofs within the rigorous formal setting of a proof assistant. The principles in question are all formally derivable from the simple principle of structural induction/recursion on concrete terms. We work out applications to some fundamental meta-theoretical results, such as the Church--Rosser Theorem and Weak Normalization for the Simply Typed Lambda Calculus. The whole development has been machine checked using the system Agda.},
  langid = {english},
  keywords = {constructive type theory,Formalized metatheory,Lambda Calculus,nominal syntax,proof assistants}
}

@article{copelloFormalMetatheoryLambda2016,
  title = {Formal {{Metatheory}} of the Lambda Calculus Using {{Stoughton}}'s Substitution},
  author = {Copello, E. and Szasz, N. and Tasistro, A.},
  year = {2016},
  journal = {Theoretical Computer Science},
  keywords = {Formal metatheory,Lambda calculus,Type Theory},
  file = {/home/flaviomoura/Zotero/storage/SNPWC4PL/Copello et al. - 2017 - Formal metatheory of the Lambda calculus using Sto.pdf;/home/flaviomoura/Zotero/storage/RCCNWXSW/S0304397516304820.html}
}

@book{copelloMachinecheckedProofChurchRosser2017,
  title = {Machine-Checked Proof of the {{Church-Rosser}} Theorem for the {{Lambda Calculus}} Using the {{Barendregt Variable Convention}} in {{Constructive Type Theory}}},
  author = {Copello, E. and Szasz, N. and Tasistro, A.},
  year = {2017},
  annotation = {Published: Submitted to LSFA 2017},
  file = {/home/flaviomoura/Zotero/storage/CF7VVGBW/Copello et al. - 2017 - Machine-checked proof of the Church-Rosser theorem.pdf}
}

@article{copesFormalizationConstructiveType2018,
  title = {Formalization in {{Constructive Type Theory}} of the {{Standardization Theorem}} for the {{Lambda Calculus}} Using {{Multiple Substitution}}},
  author = {Copes, Mart{\'i}n and Szasz, Nora and Tasistro, {\'A}lvaro},
  year = {2018},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {274},
  eprint = {1807.01871},
  primaryclass = {cs},
  pages = {27--41},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.274.3},
  urldate = {2024-04-23},
  abstract = {We present a full formalization in Martin-L{\textbackslash}"of's Constructive Type Theory of the Standardization Theorem for the Lambda Calculus using first-order syntax with one sort of names for both free and bound variables and Stoughton's multiple substitution. Our formalization is based on a proof by Ryo Kashima, in which a notion of beta-reducibility with a standard sequence is captured by an inductive relation. The proof uses only structural induction over the syntax and the relations defined, which is possible due to the specific formulation of substitution that we employ. The whole development has been machine-checked using the system Agda.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/MWSCU9QH/Copes et al. - 2018 - Formalization in Constructive Type Theory of the S.pdf;/home/flaviomoura/Zotero/storage/HUSEQFZB/1807.html}
}

@article{coquandCalculusConstructions1988,
  title = {The {{Calculus}} of {{Constructions}}},
  author = {Coquand, T. and Huet, G.},
  year = {1988},
  journal = {Information and Computation},
  volume = {76},
  number = {2-3},
  pages = {95--120},
  doi = {10.1016/0890-5401(88)90005-3},
  file = {/home/flaviomoura/Zotero/storage/CQ4Q972R/Coquand and Huet - 1988 - The calculus of constructions.pdf;/home/flaviomoura/Zotero/storage/8JNJGJQC/0890540188900053.html}
}

@article{coquandConstructionsHigherorderProof1985,
  title = {Constructions: A Higher-Order Proof System for Mechanizing Mathematics},
  author = {Coquand, T. and Huet, G.},
  year = {1985},
  journal = {EUROCAL85 in LNCS 203},
  publisher = {Springer Verlag}
}

@misc{coquandConstructiveBasicTheory2023,
  title = {Constructive Basic Theory of Central Simple Algebras},
  author = {Coquand, Thierry and Lombardi, Henri and Neuwirth, Stefan},
  year = {2023},
  month = jun,
  number = {arXiv:2102.12775},
  eprint = {2102.12775},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2023-07-03},
  abstract = {We provide a constructive treatment of basic results in the theory of central simple algebras. One main issue is the fact that one starting result, Wedderburn's Theorem stating that a simple algebra is a matrix algebra over a skew field, is not constructively valid. We solve this problem by proving instead a dynamical version of this theorem. One can use this to give constructive proofs of basic results of the theory of central simple algebras, such as Skolem-Noether Theorem. We illustrate this development by giving an elementary constructive proof of a theorem of Becher (which is itself a consequence of a celebrated theorem of Merkurjev).},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {16B70 03F65 19C30,Mathematics - Logic,Mathematics - Rings and Algebras},
  file = {/home/flaviomoura/Zotero/storage/EUAR6MM9/Coquand et al. - 2023 - Constructive basic theory of central simple algebr.pdf}
}

@article{coquandFormalisedProofSoundness2002,
  title = {A {{Formalised Proof}} of the {{Soundness}} and {{Completeness}} of a {{Simply Typed Lambda-Calculus}} with {{Explicit Substitutions}}},
  author = {Coquand, C.},
  year = {2002},
  journal = {Higher-Order and Symbolic Computation},
  volume = {15},
  number = {1},
  pages = {57--90},
  issn = {1573-0557},
  doi = {10.1023/A:1019964114625},
  abstract = {We present a simply-typed {$\lambda$}-calculus with explicit substitutions and we give a fully formalised proof of its soundness and completeness with respect to Kripke models. We further give conversion rules for the calculus and show also for them that they are sound and complete with respect to extensional equality in the Kripke model. A decision algorithm for conversion is given and proven correct. We use the technique ``normalisation by evaluation'' in order to prove these results. An important aspect of this work is that it is not a formalisation of an existing proof, instead the proof has been done in interaction with the proof system, ALF.},
  keywords = {explicit substitutions,formal methods,normalisation,type theory},
  file = {/home/flaviomoura/Zotero/storage/TIHRUT92/Coquand - 2002 - A Formalised Proof of the Soundness and Completene.pdf}
}

@article{coquandHigherInductiveTypes2018,
  title = {On {{Higher Inductive Types}} in {{Cubical Type Theory}}},
  author = {Coquand, Thierry and Huber, Simon and M{\"o}rtberg, Anders},
  year = {2018},
  month = apr,
  journal = {arXiv:1802.01170 [cs, math]},
  eprint = {1802.01170},
  primaryclass = {cs, math},
  urldate = {2022-05-11},
  abstract = {Cubical type theory provides a constructive justification to certain aspects of homotopy type theory such as Voevodsky's univalence axiom. This makes many extensionality principles, like function and propositional extensionality, directly provable in the theory. This paper describes a constructive semantics, expressed in a presheaf topos with suitable structure inspired by cubical sets, of some higher inductive types. It also extends cubical type theory by a syntax for the higher inductive types of spheres, torus, suspensions, truncations, and pushouts. All of these types are justified by the semantics and have judgmental computation rules for all constructors, including the higher dimensional ones, and the universes are closed under these type formers.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/Q8YY9WNC/Coquand et al. - 2018 - On Higher Inductive Types in Cubical Type Theory.pdf}
}

@article{coquandIndependenceMarkovPrinciple2016,
  title = {The {{Independence}} of {{Markov}}'s {{Principle}} in {{Type Theory}}},
  author = {Coquand, T. and Mannaa, B.},
  year = {2016},
  month = feb,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,F.4.1}
}

@article{coquandLorenzenProofConsistency2020,
  title = {Lorenzen's {{Proof}} of {{Consistency}} for {{Elementary Number Theory}} [with an {{Edition}} and {{Translation}} of "{{Ein Halbordnungstheoretischer Widerspruchsfreiheitsbeweis}}'']},
  author = {Coquand, Thierry and Neuwirth, Stefan},
  year = {2020},
  journal = {CoRR},
  abstract = {We present a manuscript of Paul Lorenzen that provides a proof of consistency for elementary number theory as an application of the construction of the free countably complete pseudocomplemented semilattice over a preordered set. This manuscript rests in the Oskar-Becker-Nachlass at the Philosophisches Archiv of Universit{\"a}t Konstanz, file OB 5-3b-5. It has probably been written between March and May 1944. We also compare this proof to Gentzen's and Novikov's, and provide a translation of the manuscript.}
}

@article{corcoranSchemataConceptSchema2006,
  title = {Schemata: {{The Concept}} of {{Schema}} in the {{History}} of {{Logic}}},
  shorttitle = {Schemata},
  author = {Corcoran, John},
  year = {2006},
  journal = {Bulletin of Symbolic Logic},
  volume = {12},
  number = {2},
  pages = {219--240},
  publisher = {Jstor},
  doi = {10.2178/bsl/1146620060},
  urldate = {2024-07-29},
  file = {/home/flaviomoura/Zotero/storage/YZAEZ5MC/Corcoran - 2006 - Schemata The Concept of Schema in the History of .pdf}
}

@book{cormenAlgorithmsUnlocked2013,
  title = {Algorithms Unlocked},
  author = {Cormen, Thomas H.},
  year = {2013},
  publisher = {The MIT Press},
  address = {Cambridge, Massachusetts},
  isbn = {978-0-262-51880-2},
  lccn = {QA76.9.A43 C685 2013},
  keywords = {Computer algorithms},
  file = {/home/flaviomoura/Zotero/storage/VNTB5BBB/Cormen - 2013 - Algorithms unlocked.pdf}
}

@book{cormenIntroductionAlgorithms2022,
  title = {Introduction to {{Algorithms}}},
  author = {Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald L. and Stein, Clifford},
  year = {2022},
  month = apr,
  edition = {4},
  publisher = {MIT Press},
  address = {Cambridge, MA, USA},
  abstract = {A comprehensive update of the leading algorithms text, with new material on matchings in bipartite graphs, online algorithms, machine learning, and other topics.},
  isbn = {978-0-262-04630-5},
  langid = {english},
  keywords = {Computer algorithms,Computer programming}
}

@book{cormenIntroductionAlgorithmsThird2009,
  title = {Introduction to {{Algorithms}}, {{Third Edition}}},
  author = {Cormen, T. H. and Leiserson, C. E. and Rivest, R. L. and Stein, C.},
  year = {2009},
  edition = {3rd},
  publisher = {The MIT Press},
  isbn = {0-262-03384-4 978-0-262-03384-8},
  file = {/home/flaviomoura/Zotero/storage/7K5S7BFF/bodnarIntroductionAlgorithmsSolutions2015.pdf;/home/flaviomoura/Zotero/storage/EJFSFAC2/Cormen et al. - 2009 - Introduction to Algorithms, Third Edition.pdf}
}

@book{corneliusgerardConciseGuideSoftware2017,
  title = {Concise {{Guide}} to {{Software Engineering}}: {{From Fundamentals}} to {{Application Methods}}},
  author = {Cornelius Gerard, O'Regan},
  year = {2017},
  series = {{{UTCS}}},
  publisher = {Springer}
}

@article{coskunHowHelpYour2022,
  title = {3. {{How}} to {{Help Your Graduate Students}} and {{Postdocs Find}} a {{Problem}} by {{Izzet Coskun}}},
  author = {Coskun, Izzet},
  year = {2022},
  month = jun,
  journal = {Notices of the American Mathematical Society},
  volume = {69},
  number = {06},
  pages = {1},
  issn = {0002-9920, 1088-9477},
  doi = {10.1090/noti2498},
  urldate = {2024-03-17},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IMYMLK4J/Coskun - 2022 - 3. How to Help Your Graduate Students and Postdocs.pdf}
}

@article{costaPeirceRuleFull2009,
  title = {Peirce's {{Rule}} in a {{Full Natural Deduction System}}},
  author = {Costa, Vaston G. and Sanz, Wagner and Haeusler, Edward H. and Pereira, Luiz C.},
  year = {2009},
  month = dec,
  journal = {Electronic Notes in Theoretical Computer Science},
  series = {Proceedings of the {{Fourth Workshop}} on {{Logical}} and {{Semantic Frameworks}}, with {{Applications}} ({{LSFA}} 2009)},
  volume = {256},
  pages = {5--18},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2009.11.002},
  urldate = {2024-06-17},
  abstract = {Natural deduction (ND) for first order classical logic is obtainable from the intuitionist system by the addition of Peirce rule. In a previous paper [Luiz Carlos Pereira, Edward Hermann Haeusler, Vaston G. Costa, and Wagner Sanz. Normalization for the implicational fragment of classical propositional logic. Submited to a Journal, 2008], it was presented a normalization strategy for the implicational fragment with Pierce rule. The end normal form is divided in two parts: an intuitionist subdeduction followed by a series of Peirce rule applications, maybe empty. Here, we extend this normalization process to the system for first order classical logic NP system. NP normal derivations also present the same structure. This structure is the basis on which many properties for ND derivations can be presented. In particular, we present a form of Glivenko's theorem for the conjunction-implication fragment. Unfortunately, NP lacks strong normalization, although ND with classical absurdity rule doesn't lack it, as it's well-known.},
  keywords = {Natural Deduction,Normalization,Peirce Rule},
  file = {/home/flaviomoura/Zotero/storage/YMHIPY8M/S1571066109004526.html}
}

@book{coutinhoPrimalidadeEmTempo2004,
  title = {Primalidade Em {{Tempo Polinomial}}: {{Uma Introdu{\c c}{\~a}o}} Ao {{Algoritmo AKS}}},
  author = {Coutinho, Severino Colier},
  year = {2004},
  series = {Cole{\c c}{\~a}o {{Inicia{\c c}{\~a}o Cient{\'i}fica}}},
  publisher = {SBM},
  address = {Rio de Janeiro},
  file = {/home/flaviomoura/Zotero/storage/8S3KCRJA/coutinho04.pdf}
}

@inproceedings{cowlingStagesTeachingFormal2010,
  title = {Stages in {{Teaching Formal Methods}}},
  booktitle = {2010 23rd {{IEEE Conference}} on {{Software Engineering Education}} and {{Training}}},
  author = {Cowling, A. J.},
  year = {2010},
  month = mar,
  pages = {nil},
  doi = {10.1109/cseet.2010.19}
}

@book{crandallPrimeNumbers2005,
  title = {Prime {{Numbers}}},
  author = {Crandall, Richard and Pomerance, Carl},
  year = {2005},
  series = {[]},
  publisher = {Springer-Verlag},
  doi = {10.1007/0-387-28979-8}
}

@techreport{crarySimpleProofCallbyValue2009,
  type = {Technical {{Report CMU-CS-09-137}}},
  title = {A {{Simple Proof}} of {{Call-by-Value Standardization}}},
  author = {Crary, Karl},
  year = {2009},
  institution = {Carnegie Mellon University}
}

@article{croleAlphaEquivalenceEqualities2012,
  title = {Alpha Equivalence Equalities},
  author = {Crole, Roy L.},
  year = {2012},
  month = may,
  journal = {Theoretical Computer Science},
  volume = {433},
  pages = {1--19},
  issn = {03043975},
  doi = {10.1016/j.tcs.2012.01.030},
  urldate = {2022-10-29},
  abstract = {Programming languages and logics, which are pervasive in Computer Science, have syntax which involves variable binding constructors. As such, reasoning about such languages in general, and formal reasoning in particular (such as within a theorem prover), requires frameworks within which the syntax may be properly represented. One key requirement is a correct representation of {$\alpha$}-equivalence.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7LR7EQMQ/Crole - 2012 - Alpha equivalence equalities.pdf}
}

@article{croleRepresentationalAdequacyHybrid2011,
  title = {The Representational Adequacy of {{{\textsc{Hybrid}}}}},
  shorttitle = {The Representational Adequacy Of},
  author = {Crole, R. L.},
  year = {2011},
  month = jun,
  journal = {Mathematical Structures in Computer Science},
  volume = {21},
  number = {3},
  pages = {585--646},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129511000041},
  urldate = {2022-10-29},
  abstract = {The               Hybrid               system (Ambler               et al               . 2002b), implemented within Isabelle/HOL, allows object logics to be represented using higher order abstract syntax (HOAS), and reasoned about using tactical theorem proving in general, and principles of (co)induction in particular. The form of HOAS provided by               Hybrid               is essentially a lambda calculus with constants.                                         Of fundamental interest is the form of the lambda abstractions provided by               Hybrid               . The user has the convenience of writing lambda abstractions using names for the binding variables. However, each abstraction is actually a               definition               of a de Bruijn expression, and               Hybrid               can unwind the user's abstractions (written with names) to machine friendly de Bruijn expressions (without names). In this sense the formal system contains a               hybrid               of named and nameless bound variable notation.                                         In this paper, we present a formal theory in a logical framework, which can be viewed as a model of core               Hybrid               , and state and prove that the model is representationally adequate for HOAS. In particular, it is the canonical translation function from {$\lambda$}-expressions to               Hybrid               that witnesses adequacy. We also prove two results that characterise how               Hybrid               represents certain classes of {$\lambda$}-expression.                                         We provide the first detailed proof to be published that proper locally nameless de Bruijn expressions and {$\alpha$}-equivalence classes of {$\lambda$}-expressions are in bijective correspondence. This result is presented as a form of de Bruijn representational adequacy, and is a key component of the proof of               Hybrid               adequacy.                                         The               Hybrid               system contains a number of different syntactic classes of expression, and associated abstraction mechanisms. Hence, this paper also aims to provide a self-contained theoretical introduction to both the syntax and key ideas of the system. Although this paper will be of considerable interest to those who wish to work with               Hybrid               in Isabelle/HOL, a background in automated theorem proving is not essential.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/B65PGPTH/Crole - 2011 - The representational adequacy of span style=font.pdf}
}

@article{crouchPeerInstructionTen2001,
  title = {Peer {{Instruction}}: {{Ten Years}} of {{Experience}} and {{Results}}},
  author = {Crouch, Catherine H. and Mazur, Eric},
  year = {2001},
  journal = {American Journal of Physics},
  volume = {69},
  number = {9},
  pages = {970--977},
  doi = {10.1119/1.1374249}
}

@incollection{csornyeiIntroductionLambdaCalculus2008,
  title = {An {{Introduction}} to the {{Lambda Calculus}}},
  booktitle = {Central {{European Functional Programming School}}},
  author = {Cs{\"o}rnyei, Zolt{\'a}n and D{\'e}vai, Gergely},
  editor = {Horv{\'a}th, Zolt{\'a}n and Plasmeijer, Rinus and So{\'o}s, Anna and Zs{\'o}k, Vikt{\'o}ria},
  year = {2008},
  volume = {5161},
  pages = {87--111},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-88059-2_3},
  urldate = {2023-09-08},
  isbn = {978-3-540-88058-5 978-3-540-88059-2},
  langid = {english}
}

@phdthesis{cuconatoclaroLABELLEDNATURALDEDUCTION2023,
  type = {{{DOUTOR EM CI{\^E}NCIAS}} - {{INFORM{\'A}TICA}}},
  title = {A {{LABELLED NATURAL DEDUCTION LOGICAL FRAMEWORK}}},
  author = {Cuconato Claro, Bruno},
  year = {2023},
  month = sep,
  address = {Rio de Janeiro, Brazil},
  doi = {10.17771/PUCRio.acad.65161},
  urldate = {2023-12-05},
  langid = {english},
  school = {PONTIF{\'I}CIA UNIVERSIDADE CAT{\'O}LICA DO RIO DE JANEIRO},
  file = {/home/flaviomoura/Zotero/storage/FM3ESSIU/Cuconato Claro - 2023 - A LABELLED NATURAL DEDUCTION LOGICAL FRAMEWORK.pdf}
}

@article{cuconatoLogicalFrameworkGraph2021,
  title = {A Logical Framework with a Graph Meta-Language},
  author = {Cuconato, Bruno and Santos, Jefferson de Barros and Haeusler, Edward Hermann},
  year = {2021},
  month = jun,
  journal = {arXiv:2106.13843 [cs]},
  eprint = {2106.13843},
  primaryclass = {cs},
  urldate = {2021-06-29},
  abstract = {We conjecture that the relative unpopularity of logical frameworks among practitioners is partly due to their complex meta-languages, which often demand both programming skills and theoretical knowledge of the meta-language in question for them to be fruitfully used. We present ongoing work on a logical framework with a meta-language based on graphs. A simpler meta-language leads to a shallower embedding of the object language, but hopefully leads to easier implementation and usage. A graph-based logical framework also opens up interesting possibilities in time and space performance by using heavily optimized graph databases as backends and by proof compression algorithms geared towards graphs. Deductive systems can be specified using simple domain-specific languages built on top of the graph database's query language. There is support for interactive (through a web-based interface) and semiautomatic (following user-defined tactics specified by a domain-specific language) proof modes. We have so far implemented nine systems for propositional logic, including Fitch-style and backward-directed Natural Deduction systems for intuitionistic and classical logic (with the classical systems reusing the rules of the intuitionistic ones), and a Hilbert-style system for the K modal logic.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/WPIUCGHY/Cuconato et al. - 2021 - A logical framework with a graph meta-language.pdf;/home/flaviomoura/Zotero/storage/R4WCQKVA/2106.html}
}

@book{cunninghamLogicalIntroductionProof2013,
  title = {A {{Logical Introduction}} to {{Proof}}},
  author = {Cunningham, D. W.},
  year = {2013},
  series = {Nil},
  publisher = {Springer Nature},
  doi = {10.1007/978-1-4614-3631-7}
}

@book{cunyGraphGramarsTheir1996,
  title = {Graph {{Gramars}} and {{Their Application}} to {{Computer Science}}, 5th {{International Workshop}}, {{Williamsburg}}, {{VA}}, {{USA}}, {{November}} 13-18, 1994, {{Selected Papers}}},
  editor = {Cuny, Janice E. and Ehrig, Hartmut and Engels, Gregor and Rozenberg, Grzegorz},
  year = {1996},
  journal = {TAGT},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1073},
  publisher = {Springer},
  isbn = {3-540-61228-9}
}

@article{curienAbstractFrameworkEnvironment1991,
  title = {An {{Abstract Framework}} for {{Environment Machines}}},
  author = {Curien, P.-L.},
  year = {1991},
  journal = {Theoretical Computer Science},
  volume = {82},
  number = {2},
  pages = {389--402},
  doi = {10.1016/0304-3975(91)90230-y}
}

@book{curienCategoricalCombinatorsSequential1986,
  title = {Categorical {{Combinators}}, {{Sequential Algorithms}} and {{Functional Programming}}},
  author = {Curien, P.-L.},
  year = {1986},
  publisher = {Pitman}
}

@article{curienConfluencePropertiesWeak1996,
  title = {Confluence {{Properties}} of {{Weak}} and {{Strong Calculi}} of {{Explicit Substitutions}}},
  author = {Curien, Pierre-Louis and Hardin, Th{\'e}r{\`e}se and L{\'e}vy, Jean-Jacques},
  year = {1996},
  journal = {Journal of the ACM},
  volume = {43},
  number = {2},
  pages = {362--397},
  doi = {10.1145/226643.226675},
  file = {/home/flaviomoura/Zotero/storage/9KS8PDXR/Curien et al. - 1996 - Confluence properties of weak and strong calculi o.pdf}
}

@inproceedings{curienStrongNormalizationSubstitutions1992,
  title = {Strong {{Normalization}} of {{Substitutions}}},
  booktitle = {Mathematical {{Foundations}} of {{Computer Science}} 1992, 17th {{International Symposium}}, {{MFCS}}'92, {{Prague}}, {{Czechoslovakia}}, {{August}} 24-28, 1992, {{Proceedings}}},
  author = {Curien, Pierre-Louis and Hardin, Th{\'e}r{\`e}se and R{\'i}os, Alejandro},
  year = {1992},
  pages = {209--217},
  doi = {10.1007/3-540-55808-X_19}
}

@misc{curienTermRewritingNestohedra2024,
  title = {Term Rewriting on Nestohedra},
  author = {Curien, Pierre-Louis and {Laplante-Anfossi}, Guillaume},
  year = {2024},
  month = mar,
  number = {arXiv:2403.15987},
  eprint = {2403.15987},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2403.15987},
  urldate = {2024-03-27},
  abstract = {We define term rewriting systems on the vertices and faces of nestohedra, and show that the former are confluent and terminating. While the associated poset on vertices generalizes Barnard--McConville's flip order for graph-associahedra, the preorder on faces likely generalizes the facial weak order for permutahedra. Moreover, we define and study contextual families of nestohedra, whose local confluence diagrams satisfy a certain uniformity condition. Among them are associahedra and operahedra, whose associated proofs of confluence for their rewriting systems reproduce proofs of categorical coherence theorems for monoidal categories and categorified operads.},
  archiveprefix = {arXiv},
  keywords = {68Q42 (Primary) 18N20 52B11 (Secondary),Computer Science - Logic in Computer Science,Mathematics - Algebraic Topology,Mathematics - Category Theory,Mathematics - Combinatorics},
  file = {/home/flaviomoura/Zotero/storage/PKTFKJ8N/Curien e Laplante-Anfossi - 2024 - Term rewriting on nestohedra.pdf;/home/flaviomoura/Zotero/storage/CMF3FDPZ/2403.html}
}

@book{curryCombinatoryLogic1958,
  title = {Combinatory {{Logic}}},
  author = {Curry, H. B. and Feys, R.},
  year = {1958},
  volume = {1},
  publisher = {North Holland}
}

@misc{CurryHowardCorrespondenceIntuitive,
  title = {{Curry-Howard Correspondence: An Intuitive Language for Mathematics - ProQuest}},
  shorttitle = {{Curry-Howard Correspondence}},
  urldate = {2021-07-09},
  abstract = {Explore millions of resources from scholarly journals, books, newspapers, videos and more, on the ProQuest Platform.},
  howpublished = {https://www.proquest.com/openview/94ddb1ddc15cf03deb6f69926f467ff2/1?pq-origsite=gscholar\&cbl=18750\&diss=y},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/7DIG7KBZ/1.html}
}

@unpublished{cursosPropostaCoordenacoesBCC2020,
  title = {Proposta Das {{Coordena{\c c}{\~o}es}} Do {{BCC}}, Da {{LC}} e Do {{BEngComp}}},
  author = {de {cursos}, Coordena{\c c}{\~o}es},
  year = {2020}
}

@article{curtisClassificationGreedyAlgorithms2003,
  title = {The {{Classification}} of {{Greedy Algorithms}}},
  author = {Curtis, S. A.},
  year = {2003},
  journal = {Science of Computer Programming},
  volume = {49},
  number = {1-3},
  pages = {125--157},
  doi = {10.1016/j.scico.2003.09.001}
}

@misc{czajkaCoinductionElementaryApproach2019,
  title = {Coinduction: An Elementary Approach},
  shorttitle = {Coinduction},
  author = {Czajka, {\L}ukasz},
  year = {2019},
  month = may,
  number = {arXiv:1501.04354},
  eprint = {1501.04354},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-10-07},
  abstract = {The main aim of this paper is to promote a certain style of doing coinductive proofs, similar to inductive proofs as commonly done by mathematicians. For this purpose, we provide a reasonably direct justification for coinductive proofs written in this style, i.e., converting a coinductive proof into a non-coinductive argument is purely a matter of routine. In this way, we provide an elementary explanation of how to interpret coinduction in set theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/EM6PMFX4/Czajka - 2019 - Coinduction an elementary approach.pdf;/home/flaviomoura/Zotero/storage/GTF59Z9Y/1501.html}
}

@article{czajkaConfluenceExtensionCombinatory2013,
  title = {Confluence of an Extension of {{Combinatory Logic}} by {{Boolean Constants}}},
  author = {Czajka, {\textbackslash}L.},
  year = {2013},
  month = jun,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@misc{czajkaNewCoinductiveConfluence2018,
  title = {A New Coinductive Confluence Proof for Infinitary Lambda Calculus},
  author = {Czajka, {\L}ukasz},
  year = {2018},
  month = aug,
  journal = {arXiv.org},
  doi = {10.23638/LMCS-16(1:31)2020},
  urldate = {2024-10-08},
  abstract = {We present a new and formal coinductive proof of confluence and normalisation of B{\textbackslash}"ohm reduction in infinitary lambda calculus. The proof is simpler than previous proofs of this result. The technique of the proof is new, i.e., it is not merely a coinductive reformulation of any earlier proofs. We formalised the proof in the Coq proof assistant.},
  howpublished = {https://arxiv.org/abs/1808.05481v4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/6WU49ZMA/Czajka - 2018 - A new coinductive confluence proof for infinitary .pdf}
}

@book{d.m.gabbayWhatNegation1999,
  title = {What Is {{Negation}}?},
  author = {D. M. Gabbay, H. Wansing (eds.)},
  year = {1999},
  series = {Applied {{Logic Series}} 13},
  edition = {1},
  publisher = {Springer Netherlands},
  isbn = {978-90-481-5169-1 978-94-015-9309-0},
  file = {/home/flaviomoura/Zotero/storage/BEJYJD5I/D. M. Gabbay - 1999 - What is Negation.pdf}
}

@book{daeppReadingWritingProving2011,
  title = {Reading, {{Writing}}, and {{Proving}}: {{A Closer Look}} at {{Mathematics}}},
  author = {Daepp, U. and Gorkin, P.},
  year = {2011},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  edition = {2},
  publisher = {Springer-Verlag New York},
  isbn = {1-4419-9478-5 978-1-4419-9478-3}
}

@article{dagandDependentPearlNormalization2020,
  title = {Dependent {{Pearl}}: {{Normalization}} by Realizability},
  shorttitle = {Dependent {{Pearl}}},
  author = {Dagand, Pierre-{\'E}variste and Rieg, Lionel and Scherer, Gabriel},
  year = {2020},
  month = jul,
  journal = {arXiv:1908.09123 [cs]},
  eprint = {1908.09123},
  primaryclass = {cs},
  urldate = {2020-07-28},
  abstract = {For those of us who generally live in the world of syntax, semantic proof techniques such as reducibility, realizability or logical relations seem somewhat magical despite -- or perhaps due to -- their seemingly unreasonable effectiveness. Why do they work? At which point in the proof is "the real work" done? Hoping to build a programming intuition of these proofs, we implement a normalization argument for the simply-typed lambda-calculus with sums: instead of a proof, it is described as a program in a dependently-typed meta-language. The semantic technique we set out to study is Krivine's classical realizability, which amounts to a proof-relevant presentation of reducibility arguments -- unary logical relations. Reducibility assigns a predicate to each type, realizability assigns a set of realizers, which are abstract machines that extend lambda-terms with a first-class notion of contexts. Normalization is a direct consequence of an adequacy theorem or "fundamental lemma", which states that any well-typed term translates to a realizer of its type. We show that the adequacy theorem, when written as a dependent program, corresponds to an evaluation procedure. In particular, a weak normalization proof precisely computes a series of reduction from the input term to a normal form. Interestingly, the choices that we make when we define the reducibility predicates -- truth and falsity witnesses for each connective -- determine the evaluation order of the proof, with each datatype constructor behaving in a lazy or strict fashion. While most of the ideas in this presentation are folklore among specialists, our dependently-typed functional program provides an accessible presentation to a wider audience. In particular, our work provides a gentle introduction to abstract machine calculi which have recently been used as an effective research vehicle.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/LJPKU9BD/Dagand et al. - 2020 - Dependent Pearl Normalization by realizability.pdf;/home/flaviomoura/Zotero/storage/PAB4Q297/1908.html}
}

@article{daiNonexistenceUniversalAlgorithm2021,
  title = {Nonexistence of a {{Universal Algorithm}} for {{Traveling Salesman Problems}} in {{Constructive Mathematics}}},
  author = {Dai, Linglong},
  year = {2021},
  month = aug,
  journal = {arXiv:2108.05231 [cs, math]},
  eprint = {2108.05231},
  primaryclass = {cs, math},
  urldate = {2021-08-13},
  abstract = {Proposed initially from a practical circumstance, the traveling salesman problem caught the attention of numerous economists, computer scientists, and mathematicians. These theorists were instead intrigued by seeking a systemic way to find the optimal route. Many attempts have been made along the way and all concluded the nonexistence of a general algorithm that determines optimal solution to all traveling salesman problems alike. In this study, we present proof for the nonexistence of such an algorithm for both asymmetric (with oriented roads) and symmetric (with unoriented roads) traveling salesman problems in the setup of constructive mathematics.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Discrete Mathematics,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/XIVDQRT9/Dai - 2021 - Nonexistence of a Universal Algorithm for Travelin.pdf;/home/flaviomoura/Zotero/storage/K8GUAHY2/2108.html}
}

@book{dalenBrouwerTopologistIntuitionist2013,
  title = {L.{{E}}.{{J}}. {{Brouwer}} - {{Topologist}}, {{Intuitionist}}, {{Philosopher}}},
  author = {van Dalen, D.},
  year = {2013},
  series = {Nil},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-1-4471-4616-2},
  file = {/home/flaviomoura/Zotero/storage/NHJ6P7E2/Dalen - 2013 - L.E.J. Brouwer - Topologist, Intuitionist, Philoso.pdf}
}

@unpublished{dalenKolmogorovBrowerConstructive2004,
  title = {Kolmogorov and {{Brower}} on Constructive Implication and the {{Ex Falso}} Rule},
  author = {van Dalen, Dirk},
  year = {2004},
  annotation = {Published: Russian Math Surveys, 59, 247-257}
}

@book{dalenLogicStructure2013,
  title = {Logic and {{Structure}}},
  author = {van Dalen, D.},
  year = {2013},
  series = {Universitext},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-4558-5}
}

@book{dalenLogicStructureEd2008,
  title = {Logic and Structure (4. Ed.)},
  author = {van Dalen, D.},
  year = {2008},
  series = {Universitext},
  publisher = {Springer},
  file = {/home/flaviomoura/Zotero/storage/9CRQ6X3A/Dalen - 2008 - Logic and structure (4. ed.).pdf}
}

@book{dalenSelectedCorrespondenceBrouwer2011,
  title = {The {{Selected Correspondence}} of {{L}}.{{E}}.{{J}}. {{Brouwer}}},
  author = {van Dalen, D.},
  year = {2011},
  series = {Nil},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-0-85729-537-8},
  file = {/home/flaviomoura/Zotero/storage/8MVIMFMS/Dalen - 2011 - The Selected Correspondence of L.E.J. Brouwer.pdf}
}

@book{danavrajitoruPracticalAnalysisAlgorithms2014,
  title = {Practical {{Analysis}} of {{Algorithms}}},
  author = {Dana Vrajitoru, William Knight (auth.)},
  year = {2014},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  edition = {1},
  publisher = {Springer International Publishing},
  isbn = {978-3-319-09887-6 978-3-319-09888-3}
}

@book{danielsson18thInternationalWorkshop2013,
  title = {18th {{International Workshop}} on {{Types}} for {{Proofs}} and {{Programs}}, {{TYPES}} 2011, {{September}} 8-11, 2011, {{Bergen}}, {{Norway}}},
  editor = {Danielsson, Nils Anders and Nordstr{\"o}m, Bengt},
  year = {2013},
  series = {{{LIPIcs}}},
  volume = {19},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik},
  isbn = {978-3-939897-49-1}
}

@inproceedings{danosGameSemanticsAbstract1996,
  title = {Game Semantics and Abstract Machines},
  booktitle = {Proceedings 11th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Danos, V. and Herbelin, H. and Regnier, L.},
  year = {1996},
  month = jul,
  pages = {394--405},
  issn = {1043-6871},
  doi = {10.1109/LICS.1996.561456},
  urldate = {2024-06-07},
  abstract = {The interaction processes at work by M. Hyland and L. Ong (1994) (HO) and S. Abramsky et al. (1994) (AJM) new game semantics are two preexisting paradigmatic implementations of linear head reduction: respectively Krivine's abstract machine and Girard's interaction abstract machine. There is a simple and natural embedding of AJM-games to HO-games, mapping strategies to strategies and reducing AJM definability (or full abstraction) property to HO's one.},
  keywords = {Calculus,Concrete,Game theory,Geometry,History,Machinery,Magnetic heads,Utility programs},
  file = {/home/flaviomoura/Zotero/storage/GH8BGN8S/Danos et al. - 1996 - Game semantics and abstract machines.pdf;/home/flaviomoura/Zotero/storage/NXHJVUFK/561456.html}
}

@article{dasCOMPLEXITYNORMALIZATIONPLANAR,
  title = {{{ON THE COMPLEXITY OF NORMALIZATION FOR THE PLANAR}} {$\lambda$}-{{CALCULUS}}},
  author = {Das, Anupam and Mazza, Damiano and D{\~u}ng, L{\^e} Th{\`a}nh and Zeilberger, Noam},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/L43CXPXX/Das et al. - ON THE COMPLEXITY OF NORMALIZATION FOR THE PLANAR .pdf}
}

@misc{dasComplexityNormalizationPlanar2024,
  title = {On the Complexity of Normalization for the Planar \${\textbackslash}lambda\$-Calculus},
  author = {Das, Anupam and Mazza, Damiano and Nguy{\^e}n, L{\^e} Th{\`a}nh D{\~u}ng and Zeilberger, Noam},
  year = {2024},
  month = apr,
  number = {arXiv:2404.05276},
  eprint = {2404.05276},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.05276},
  urldate = {2024-04-09},
  abstract = {We sketch a tentative proof of P-completeness for the \${\textbackslash}beta\$-convertibility problem on untyped planar (a.k.a. ordered or non-commutative) \${\textbackslash}lambda\$-terms.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/RT9DX93Z/Das et al. - 2024 - On the complexity of normalization for the planar .pdf;/home/flaviomoura/Zotero/storage/A4AMYM6G/2404.html}
}

@book{dasgupta2008algorithms,
  title = {Algorithms},
  author = {Dasgupta, Sanjoy and Papadimitriou, Christos H and Vazirani, Umesh Virkumar},
  year = {2008},
  publisher = {McGraw-Hill Higher Education New York},
  file = {/home/flaviomoura/Zotero/storage/SKRUW2E9/Dasgupta et al. - 2008 - Algorithms.pdf}
}

@article{dasIntuitionisticGodelLobLogic2024,
  title = {Intuitionistic {{G{\"o}del-L{\"o}b Logic}}, {\`a} La {{Simpson}}: {{Labelled Systems}} and {{Birelational Semantics}}},
  shorttitle = {Intuitionistic {{G{\"o}del-L{\"o}b Logic}}, {\`a} La {{Simpson}}},
  author = {Das, Anupam and {van der Giessen}, Iris and Marin, Sonia},
  year = {2024},
  pages = {18 pages, 819879 bytes},
  publisher = {[object Object]},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.CSL.2024.22},
  urldate = {2024-03-04},
  abstract = {We derive an intuitionistic version of G{\"o}del-L{\"o}b modal logic (GL) in the style of Simpson, via proof theoretic techniques. We recover a labelled system, {$\ell$}IGL, by restricting a non-wellfounded labelled system for GL to have only one formula on the right. The latter is obtained using techniques from cyclic proof theory, sidestepping the barrier that GL's usual frame condition (converse wellfoundedness) is not first-order definable. While existing intuitionistic versions of GL are typically defined over only the box (and not the diamond), our presentation includes both modalities. Our main result is that {$\ell$}IGL coincides with a corresponding semantic condition in birelational semantics: the composition of the modal relation and the intuitionistic relation is conversely wellfounded. We call the resulting logic IGL. While the soundness direction is proved using standard ideas, the completeness direction is more complex and necessitates a detour through several intermediate characterisations of IGL.},
  collaborator = {Murano, Aniello and Silva, Alexandra},
  copyright = {Creative Commons Attribution 4.0 International license, info:eu-repo/semantics/openAccess},
  isbn = {9783959773102},
  langid = {english},
  keywords = {cut-elimination,cyclic proofs,intuitionistic modal logic,labelled sequents,non-wellfounded proofs,proof search,proof theory,provability logic,Theory of computation  Proof theory},
  file = {/home/flaviomoura/Zotero/storage/RHU28ZQZ/Das et al. - 2024 - Intuitionistic GÃ¶del-LÃ¶b Logic, Ã  la Simpson Labe.pdf}
}

@article{dasLinearRewritingSystems2016,
  title = {On Linear Rewriting Systems for {{Boolean}} Logic and Some Applications to Proof Theory},
  author = {Das, A. and Stra{\ss}burger, L.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,I.2.3}
}

@book{dathanObjectOrientedAnalysisDesign2015,
  title = {Object-{{Oriented Analysis}}, {{Design}} and {{Implementation}}},
  author = {Dathan, Brahma and Ramnath, Sarnath},
  year = {2015},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-24280-4}
}

@book{dattaLaTeX24Hours2017,
  title = {{{LaTeX}} in 24 {{Hours}}},
  author = {Datta, Dilip},
  year = {2017},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-47831-9}
}

@inproceedings{davenportProvingExecutionAlgorithm2023,
  title = {Proving an~{{Execution}} of~an~{{Algorithm Correct}}?},
  booktitle = {Intelligent {{Computer Mathematics}}},
  author = {Davenport, James Harold},
  editor = {Dubois, Catherine and Kerber, Manfred},
  year = {2023},
  pages = {255--269},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-42753-4_17},
  abstract = {Many algorithms in computer algebra and beyond produce answers. For some of these, we have formal proofs of the correctness of the algorithm, and for others it is easy to verify that the answer is correct. Other algorithms produce either an answer or a proof that no such answer exists. It may still be easy to verify that the answer is correct, but what about the ``no such answer'' case. The claim of this paper is that, at least in some cases, it is possible for the algorithm to produce ``hints'' such that a theorem prover can prove that, in this case, there is no such answer. This leads to the paradigm of ``ad hoc UNSAT verification''.},
  isbn = {978-3-031-42753-4},
  langid = {english}
}

@article{davidLambdacalculusExplicitWeakening2001,
  title = {A Lambda-Calculus with Explicit Weakening and Explicit Substitution},
  author = {David, R. and Guillaume, B.},
  year = {2001},
  journal = {Mathematical Structures in Computer Science},
  volume = {11},
  number = {1},
  pages = {169--206},
  doi = {10.1017/S0960129500003224}
}

@article{daviesTheoremProvingClassical2021,
  title = {Theorem {{Proving}} in {{Classical Logic}}},
  author = {Davies, David},
  year = {2021},
  pages = {110},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/433AN6EN/Davies - Theorem Proving in Classical Logic.pdf}
}

@article{daviesWorkingMachinesMathematics2024,
  title = {Working with Machines in Mathematics},
  author = {Davies, Alex},
  year = {2024},
  month = may,
  journal = {Bulletin of the American Mathematical Society},
  volume = {61},
  number = {3},
  pages = {387--394},
  issn = {0273-0979, 1088-9485},
  doi = {10.1090/bull/1843},
  urldate = {2024-07-10},
  abstract = {Machine learning is making significant contributions to many fields but how can it be used as a tool for mathematicians? This article explores the emerging role of machine learning in mathematical research, highlighting how its perceptual capabilities can augment human intuition and lead to new discoveries.},
  copyright = {https://www.ams.org/publications/copyright-and-permissions},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/LHBPNWYT/Davies - 2024 - Working with machines in mathematics.pdf}
}

@incollection{davisSeventyYearsComputer2020,
  title = {Seventy {{Years}} of {{Computer Science}}},
  booktitle = {Fields of {{Logic}} and {{Computation III}}},
  author = {Davis, Martin},
  year = {2020},
  series = {Fields of {{Logic}} and {{Computation III}}},
  pages = {105--117},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-48006-6_8}
}

@book{davisUndecidableBasicPapers2004,
  title = {The {{Undecidable}}: {{Basic Papers}} on {{Undecidable Propositions}}, {{Unsolvable Problems}} and {{Computable Functions}}},
  author = {Davis, M.},
  year = {2004},
  publisher = {Dover Publications, Incorporated},
  isbn = {0-486-43228-9}
}

@book{davisUniversalComputerRoad2018,
  title = {The Universal Computer : The Road from {{Leibniz}} to {{Turing}}},
  author = {Davis, Martin},
  year = {2018},
  edition = {Third edition},
  publisher = {CRC Press},
  isbn = {978-1-351-38482-7 978-1-138-50208-6 978-0-8153-8402-1 978-1-315-14472-6 1-315-14472-7 1-351-38482-1}
}

@book{deanTeachingFormalMethods2004,
  title = {Teaching {{Formal Methods}}},
  editor = {Dean, C. Neville and Boute, Raymond T.},
  year = {2004},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/b102075}
}

@book{decapuaGrammarTeachers2017,
  title = {Grammar for {{Teachers}}},
  author = {DeCapua, Andrea},
  year = {2017},
  series = {Springer {{Texts}} in {{Education}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-33916-0}
}

@misc{deepseek-aiDeepSeekR1IncentivizingReasoning2025,
  title = {{{DeepSeek-R1}}: {{Incentivizing Reasoning Capability}} in {{LLMs}} via {{Reinforcement Learning}}},
  shorttitle = {{{DeepSeek-R1}}},
  author = {{DeepSeek-AI} and Guo, Daya and Yang, Dejian and Zhang, Haowei and Song, Junxiao and Zhang, Ruoyu and Xu, Runxin and Zhu, Qihao and Ma, Shirong and Wang, Peiyi and Bi, Xiao and Zhang, Xiaokang and Yu, Xingkai and Wu, Yu and Wu, Z. F. and Gou, Zhibin and Shao, Zhihong and Li, Zhuoshu and Gao, Ziyi and Liu, Aixin and Xue, Bing and Wang, Bingxuan and Wu, Bochao and Feng, Bei and Lu, Chengda and Zhao, Chenggang and Deng, Chengqi and Zhang, Chenyu and Ruan, Chong and Dai, Damai and Chen, Deli and Ji, Dongjie and Li, Erhang and Lin, Fangyun and Dai, Fucong and Luo, Fuli and Hao, Guangbo and Chen, Guanting and Li, Guowei and Zhang, H. and Bao, Han and Xu, Hanwei and Wang, Haocheng and Ding, Honghui and Xin, Huajian and Gao, Huazuo and Qu, Hui and Li, Hui and Guo, Jianzhong and Li, Jiashi and Wang, Jiawei and Chen, Jingchang and Yuan, Jingyang and Qiu, Junjie and Li, Junlong and Cai, J. L. and Ni, Jiaqi and Liang, Jian and Chen, Jin and Dong, Kai and Hu, Kai and Gao, Kaige and Guan, Kang and Huang, Kexin and Yu, Kuai and Wang, Lean and Zhang, Lecong and Zhao, Liang and Wang, Litong and Zhang, Liyue and Xu, Lei and Xia, Leyi and Zhang, Mingchuan and Zhang, Minghua and Tang, Minghui and Li, Meng and Wang, Miaojun and Li, Mingming and Tian, Ning and Huang, Panpan and Zhang, Peng and Wang, Qiancheng and Chen, Qinyu and Du, Qiushi and Ge, Ruiqi and Zhang, Ruisong and Pan, Ruizhe and Wang, Runji and Chen, R. J. and Jin, R. L. and Chen, Ruyi and Lu, Shanghao and Zhou, Shangyan and Chen, Shanhuang and Ye, Shengfeng and Wang, Shiyu and Yu, Shuiping and Zhou, Shunfeng and Pan, Shuting and Li, S. S. and Zhou, Shuang and Wu, Shaoqing and Ye, Shengfeng and Yun, Tao and Pei, Tian and Sun, Tianyu and Wang, T. and Zeng, Wangding and Zhao, Wanjia and Liu, Wen and Liang, Wenfeng and Gao, Wenjun and Yu, Wenqin and Zhang, Wentao and Xiao, W. L. and An, Wei and Liu, Xiaodong and Wang, Xiaohan and Chen, Xiaokang and Nie, Xiaotao and Cheng, Xin and Liu, Xin and Xie, Xin and Liu, Xingchao and Yang, Xinyu and Li, Xinyuan and Su, Xuecheng and Lin, Xuheng and Li, X. Q. and Jin, Xiangyue and Shen, Xiaojin and Chen, Xiaosha and Sun, Xiaowen and Wang, Xiaoxiang and Song, Xinnan and Zhou, Xinyi and Wang, Xianzu and Shan, Xinxia and Li, Y. K. and Wang, Y. Q. and Wei, Y. X. and Zhang, Yang and Xu, Yanhong and Li, Yao and Zhao, Yao and Sun, Yaofeng and Wang, Yaohui and Yu, Yi and Zhang, Yichao and Shi, Yifan and Xiong, Yiliang and He, Ying and Piao, Yishi and Wang, Yisong and Tan, Yixuan and Ma, Yiyang and Liu, Yiyuan and Guo, Yongqiang and Ou, Yuan and Wang, Yuduan and Gong, Yue and Zou, Yuheng and He, Yujia and Xiong, Yunfan and Luo, Yuxiang and You, Yuxiang and Liu, Yuxuan and Zhou, Yuyang and Zhu, Y. X. and Xu, Yanhong and Huang, Yanping and Li, Yaohui and Zheng, Yi and Zhu, Yuchen and Ma, Yunxian and Tang, Ying and Zha, Yukun and Yan, Yuting and Ren, Z. Z. and Ren, Zehui and Sha, Zhangli and Fu, Zhe and Xu, Zhean and Xie, Zhenda and Zhang, Zhengyan and Hao, Zhewen and Ma, Zhicheng and Yan, Zhigang and Wu, Zhiyu and Gu, Zihui and Zhu, Zijia and Liu, Zijun and Li, Zilin and Xie, Ziwei and Song, Ziyang and Pan, Zizheng and Huang, Zhen and Xu, Zhipeng and Zhang, Zhongyu and Zhang, Zhen},
  year = {2025},
  month = jan,
  number = {arXiv:2501.12948},
  eprint = {2501.12948},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2501.12948},
  urldate = {2025-01-27},
  abstract = {We introduce our first-generation reasoning models, DeepSeek-R1-Zero and DeepSeek-R1. DeepSeek-R1-Zero, a model trained via large-scale reinforcement learning (RL) without supervised fine-tuning (SFT) as a preliminary step, demonstrates remarkable reasoning capabilities. Through RL, DeepSeek-R1-Zero naturally emerges with numerous powerful and intriguing reasoning behaviors. However, it encounters challenges such as poor readability, and language mixing. To address these issues and further enhance reasoning performance, we introduce DeepSeek-R1, which incorporates multi-stage training and cold-start data before RL. DeepSeek-R1 achieves performance comparable to OpenAI-o1-1217 on reasoning tasks. To support the research community, we open-source DeepSeek-R1-Zero, DeepSeek-R1, and six dense models (1.5B, 7B, 8B, 14B, 32B, 70B) distilled from DeepSeek-R1 based on Qwen and Llama.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computation and Language,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/NWSS2LAV/DeepSeek-AI et al. - 2025 - DeepSeek-R1 Incentivizing Reasoning Capability in.pdf;/home/flaviomoura/Zotero/storage/D6FRLA5N/2501.html}
}

@inproceedings{degrooteStrongNormalizationClassical2001,
  title = {Strong {{Normalization}} of {{Classical Natural Deduction}} with {{Disjunction}}},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}},
  author = {{de Groote}, Philippe},
  editor = {Abramsky, Samson},
  year = {2001},
  pages = {182--196},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-45413-6_17},
  abstract = {We introduce {$\lambda\mu\rightarrow\wedge\vee\perp$} an extension of Parigot's {$\lambda\mu$}-calculus where disjunction is taken as a primitive. The associated reduction rela- tion, which includes the permutative conversions related to disjunction, is Church-Rosser, strongly normalizing, and such that the normal de- ductions satisfy the subformula property. From a computer science point of view, {$\lambda\mu\rightarrow\wedge\vee\perp$} may be seen as the core of a typed cbn functional language featuring product, coproduct, and control operators.},
  isbn = {978-3-540-45413-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/L95B6QPI/de Groote - 2001 - Strong Normalization of Classical Natural Deductio.pdf}
}

@incollection{degtyarevEqualityReasoningSequentBased2001,
  title = {Equality {{Reasoning}} in {{Sequent-Based Calculi}}},
  booktitle = {Handbook of {{Automated Reasoning}} (in 2 Volumes)},
  author = {Degtyarev, A. and Voronkov, A.},
  year = {2001},
  pages = {611--706}
}

@article{dehornoy2008z,
  title = {Z, Proving Confluence by Monotonic Single-Step Upperbound Functions},
  author = {Dehornoy, P and {van Oostrom}, V},
  year = {2008},
  journal = {Logical Models of Reasoning and Computation (LMRC-08)},
  pages = {85}
}

@book{dehornoyBraidsSelfDistributivity2000,
  title = {Braids and {{Self-Distributivity}}},
  author = {Dehornoy, Patrick},
  year = {2000},
  series = {[]},
  publisher = {Birkh{\"a}user Basel},
  doi = {10.1007/978-3-0348-8442-6}
}

@article{deIntroductionProofTheory,
  title = {Introduction to {{Proof Theory}}},
  author = {De, Abhishek},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/3KCHJDTV/De - Introduction to Proof Theory.pdf}
}

@article{dejongDomainTheoryConstructive2020,
  ids = {dejongDomainTheoryConstructive2020a},
  title = {Domain {{Theory}} in {{Constructive}} and {{Predicative Univalent Foundations}}},
  author = {{de Jong}, Tom and Escard{\'o}, Mart{\'i}n H{\"o}tzel},
  year = {2020},
  month = oct,
  journal = {arXiv:2008.01422 [cs, math]},
  eprint = {2008.01422},
  primaryclass = {cs, math},
  urldate = {2020-10-14},
  abstract = {We develop domain theory in constructive univalent foundations without Voevodsky's resizing axioms. In previous work in this direction, we constructed the Scott model of PCF and proved its computational adequacy, based on directed complete posets (dcpos). Here we further consider algebraic and continuous dcpos, and construct Scott's \$D\_{\textbackslash}infty\$ model of the untyped \${\textbackslash}lambda\$-calculus. A common approach to deal with size issues in a predicative foundation is to work with information systems or abstract bases or formal topologies rather than dcpos, and approximable relations rather than Scott continuous functions. Here we instead accept that dcpos may be large and work with type universes to account for this. For instance, in the Scott model of PCF, the dcpos have carriers in the second universe \${\textbackslash}mathcal\{U\}\_1\$ and suprema of directed families with indexing type in the first universe \${\textbackslash}mathcal\{U\}\_0\$. Seeing a poset as a category in the usual way, we can say that these dcpos are large, but locally small, and have small filtered colimits. In the case of algebraic dcpos, in order to deal with size issues, we proceed mimicking the definition of accessible category. With such a definition, our construction of Scott's \$D\_{\textbackslash}infty\$ again gives a large, locally small, algebraic dcpo with small directed suprema.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/3HH875SK/de Jong e EscardÃ³ - 2020 - Domain Theory in Constructive and Predicative Univ.pdf;/home/flaviomoura/Zotero/storage/Z4JVBSQ9/de Jong e EscardÃ³ - 2020 - Domain Theory in Constructive and Predicative Univ.pdf;/home/flaviomoura/Zotero/storage/3PQUVIAM/2008.html;/home/flaviomoura/Zotero/storage/76TRHNLD/2008.html}
}

@misc{dejongDomainTheoryConstructive2022,
  title = {Domain {{Theory}} in {{Constructive}} and {{Predicative Univalent Foundations}}},
  author = {{de Jong}, Tom and Escard{\'o}, Mart{\'i}n H{\"o}tzel},
  year = {2022},
  month = jun,
  number = {arXiv:2008.01422},
  eprint = {2008.01422},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-06-18},
  abstract = {We develop domain theory in constructive univalent foundations without Voevodsky's resizing axioms. In previous work in this direction, we constructed the Scott model of PCF and proved its computational adequacy, based on directed complete posets (dcpos). Here we further consider algebraic and continuous dcpos, and construct Scott's D{$\infty$} model of the untyped {$\lambda$}-calculus. A common approach to deal with size issues in a predicative foundation is to work with information systems or abstract bases or formal topologies rather than dcpos, and approximable relations rather than Scott continuous functions. Here we instead accept that dcpos may be large and work with type universes to account for this. For instance, in the Scott model of PCF, the dcpos have carriers in the second universe U1 and suprema of directed families with indexing type in the first universe U0. Seeing a poset as a category in the usual way, we can say that these dcpos are large, but locally small, and have small filtered colimits. In the case of algebraic dcpos, in order to deal with size issues, we proceed mimicking the definition of accessible category. With such a definition, our construction of Scott's D{$\infty$} again gives a large, locally small, algebraic dcpo with small directed suprema.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/EXHUDY8U/de Jong and EscardÃ³ - 2022 - Domain Theory in Constructive and Predicative Univ.pdf}
}

@misc{dejongFormalizingEquivalencesTears2024,
  title = {Formalizing Equivalences without Tears},
  author = {{de Jong}, Tom},
  year = {2024},
  month = aug,
  number = {arXiv:2408.11501},
  eprint = {2408.11501},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2408.11501},
  urldate = {2024-08-22},
  abstract = {This expository note describes two convenient techniques in the context of homotopy type theory for proving and formalizing that a given map is an equivalence. The first technique decomposes the map as a series of basic equivalences, while the second refines this approach using the 3-for-2 property of equivalences. The techniques are illustrated by proving a basic result in synthetic homotopy theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/QHC7UTAA/de Jong - 2024 - Formalizing equivalences without tears.pdf;/home/flaviomoura/Zotero/storage/PP99S4VB/2408.html}
}

@article{dejongRelatingOrdinalsSet,
  title = {Relating Ordinals in Set Theory to Ordinals in Type Theory},
  author = {{de Jong}, Tom and Kraus, Nicolai and Forsberg, Fredrik Nordvall and Xu, Chuangjie},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NY94XSW4/de Jong et al. - Relating ordinals in set theory to ordinals in typ.pdf}
}

@book{dekkingModernIntroductionProbability2005,
  title = {A {{Modern Introduction}} to {{Probability}} and {{Statistics}}},
  author = {Dekking, Frederik Michel and Kraaikamp, Cornelis and Lopuha{\"a}, Hendrik Paul and Meester, Ludolf Erwin},
  year = {2005},
  series = {Springer {{Texts}} in {{Statistics}}},
  publisher = {Springer London},
  doi = {10.1007/1-84628-168-7}
}

@article{deliguoroIntersectionTypesComputational2021,
  title = {Intersection {{Types}} for a {{Computational Lambda-Calculus}} with {{Global State}}},
  author = {{de'Liguoro}, Ugo and Treglia, Riccardo},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.01358 [cs]},
  eprint = {2104.01358},
  primaryclass = {cs},
  urldate = {2021-04-06},
  abstract = {We study the semantics of an untyped lambda-calculus equipped with operators representing read and write operations from and to a global state. We adopt the monadic approach to model side effects and treat read and write as algebraic operations over a computational monad. We introduce an operational semantics and a type assignment system of intersection types, and prove that types are invariant under reduction and expansion of term and state configurations, and characterize convergent terms via their typings.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/TAQRYCKU/de'Liguoro e Treglia - 2021 - Intersection Types for a Computational Lambda-Calc.pdf;/home/flaviomoura/Zotero/storage/JE3UQUL2/2104.html}
}

@inproceedings{deliguoroRetractsSimplyType-nil,
  title = {Retracts in Simply Type Lambda Beta Eta -Calculus},
  booktitle = {[1992] {{Proceedings}} of the {{Seventh Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {{de'Liguoro}, U. and Piperno, A. and Statman, R.},
  year = {- nil},
  pages = {nil},
  doi = {10.1109/lics.1992.185557}
}

@article{delimaFormalizingFactorizationEuclidean2024,
  title = {Formalizing {{Factorization}} on {{Euclidean Domains}} and {{Abstract Euclidean Algorithms}}},
  author = {{de Lima}, Thaynara Arielly and Avelar, Andr{\'e}ia Borges and Galdino, Andr{\'e} Luiz and {Ayala-Rinc{\'o}n}, Mauricio},
  year = {2024},
  month = apr,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {402},
  eprint = {2404.14920},
  primaryclass = {cs},
  pages = {18--33},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.402.5},
  urldate = {2024-04-24},
  abstract = {This paper discusses the extension of the Prototype Verification System (PVS) sub-theory for rings, part of the PVS algebra theory, with theorems related to the division algorithm for Euclidean rings and Unique Factorization Domains that are general structures where an analog of the Fundamental Theorem of Arithmetic holds. First, we formalize the general abstract notions of divisibility, prime, and irreducible elements in commutative rings, essential to deal with unique factorization domains. Then, we formalize the landmark theorem, establishing that every principal ideal domain is a unique factorization domain. Finally, we specify the theory of Euclidean domains and formally verify that the rings of integers, the Gaussian integers, and arbitrary fields are Euclidean domains. To highlight the benefits of such a general abstract discipline of formalization, we specify a Euclidean gcd algorithm for Euclidean domains and formalize its correctness. Also, we show how this correctness is inherited under adequate parameterizations for the structures of integers and Gaussian integers.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/SHNCVZM5/de Lima et al. - 2024 - Formalizing Factorization on Euclidean Domains and.pdf;/home/flaviomoura/Zotero/storage/GLV3N7SZ/2404.html}
}

@article{dellapennaAddressingMachinesModels2021,
  title = {Addressing {{Machines}} as Models of Lambda-Calculus},
  author = {Della Penna, Giuseppe and Intrigila, Benedetto and Manzonetto, Giulio},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.00319 [cs]},
  eprint = {2107.00319},
  primaryclass = {cs},
  urldate = {2021-07-04},
  abstract = {Turing machines and register machines have been used for decades in theoretical computer science as abstract models of computation. Also the \${\textbackslash}lambda\$-calculus has played a central role in this domain as it allows to focus on the notion of functional computation, based on the substitution mechanism, while abstracting away from implementation details. The present article starts from the observation that the equivalence between these formalisms is based on the Church-Turing Thesis rather than an actual encoding of \${\textbackslash}lambda\$-terms into Turing (or register) machines. The reason is that these machines are not well-suited for modelling {\textbackslash}lam-calculus programs. We study a class of abstract machines that we call {\textbackslash}emph\{addressing machine\} since they are only able to manipulate memory addresses of other machines. The operations performed by these machines are very elementary: load an address in a register, apply a machine to another one via their addresses, and call the address of another machine. We endow addressing machines with an operational semantics based on leftmost reduction and study their behaviour. The set of addresses of these machines can be easily turned into a combinatory algebra. In order to obtain a model of the full untyped \${\textbackslash}lambda\$-calculus, we need to introduce a rule that bares similarities with the \${\textbackslash}omega\$-rule and the rule \${\textbackslash}zeta\_{\textbackslash}beta\$ from combinatory logic.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/2C7GIAMT/Della Penna et al. - 2021 - Addressing Machines as models of lambda-calculus.pdf;/home/flaviomoura/Zotero/storage/CP7MBAT8/2107.html}
}

@misc{demainePlayingGamesAlgorithms2008,
  title = {Playing {{Games}} with {{Algorithms}}: {{Algorithmic Combinatorial Game Theory}}},
  shorttitle = {Playing {{Games}} with {{Algorithms}}},
  author = {Demaine, Erik D. and Hearn, Robert A.},
  year = {2008},
  month = apr,
  number = {arXiv:cs/0106019},
  eprint = {cs/0106019},
  publisher = {arXiv},
  doi = {10.48550/arXiv.cs/0106019},
  urldate = {2024-08-27},
  abstract = {Combinatorial games lead to several interesting, clean problems in algorithms and complexity theory, many of which remain open. The purpose of this paper is to provide an overview of the area to encourage further research. In particular, we begin with general background in Combinatorial Game Theory, which analyzes ideal play in perfect-information games, and Constraint Logic, which provides a framework for showing hardness. Then we survey results about the complexity of determining ideal play in these games, and the related problems of solving puzzles, in terms of both polynomial-time algorithms and computational intractability results. Our review of background and survey of algorithmic results are by no means complete, but should serve as a useful primer.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Data Structures and Algorithms,Computer Science - Discrete Mathematics,F.1.3,F.2.2,G.2.1,Mathematics - Combinatorics},
  file = {/home/flaviomoura/Zotero/storage/RKKU4TGY/Demaine and Hearn - 2008 - Playing Games with Algorithms Algorithmic Combina.pdf;/home/flaviomoura/Zotero/storage/ET9UJLUA/0106019.html}
}

@misc{demeoAgdaUniversalAlgebra2021,
  title = {The {{Agda Universal Algebra Library}}, {{Part}} 1: {{Foundation}}},
  shorttitle = {The {{Agda Universal Algebra Library}}, {{Part}} 1},
  author = {DeMeo, William},
  year = {2021},
  month = apr,
  number = {arXiv:2103.05581},
  eprint = {2103.05581},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2103.05581},
  urldate = {2024-04-23},
  abstract = {The Agda Universal Algebra Library (UALib) is a library of types and programs (theorems and proofs) we developed to formalize the foundations of universal algebra in dependent type theory using the Agda programming language and proof assistant. The UALib includes a substantial collection of definitions, theorems, and proofs from general algebra and equational logic, including many examples that exhibit the power of inductive and dependent types for representing and reasoning about relations, algebraic structures, and equational theories. In this paper we discuss the logical foundations on which the library is built, and describe the types defined in the first 13 modules of the library. Special attention is given to aspects of the library that seem most interesting or challenging from a type theory or mathematical foundations perspective.},
  archiveprefix = {arXiv},
  keywords = {68V20 (Primary) 03C05 (Secondary),Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/G6R44JJ6/DeMeo - 2021 - The Agda Universal Algebra Library, Part 1 Founda.pdf;/home/flaviomoura/Zotero/storage/9VPRMYU6/2103.html}
}

@misc{demeoAgdaUniversalAlgebra2021a,
  title = {The {{Agda Universal Algebra Library}}, {{Part}} 2: {{Structure}}},
  shorttitle = {The {{Agda Universal Algebra Library}}, {{Part}} 2},
  author = {DeMeo, William},
  year = {2021},
  month = mar,
  number = {arXiv:2103.09092},
  eprint = {2103.09092},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2024-04-23},
  abstract = {The Agda Universal Algebra Library (UALib) is a library of types and programs (theorems and proofs) we developed to formalize the foundations of universal algebra in dependent type theory using the Agda programming language and proof assistant. The UALib includes a substantial collection of definitions, theorems, and proofs from universal algebra, equational logic, and model theory, and as such provides many examples that exhibit the power of inductive and dependent types for representing and reasoning about mathematical structures and equational theories. In this paper, we describe the the types and proofs of the UALib that concern homomorphisms, terms, and subalgebras.},
  archiveprefix = {arXiv},
  keywords = {68V20 (Primary) 03C05 (Secondary),Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/Z49SQU55/DeMeo - 2021 - The Agda Universal Algebra Library, Part 2 Struct.pdf;/home/flaviomoura/Zotero/storage/PKMV6Q4E/2103.html}
}

@article{denizFormalizationTelegrapherEquations2024,
  title = {Formalization of the {{Telegrapher}}'s {{Equations}} Using {{Higher-Order-Logic Theorem Proving}}},
  author = {Deniz, Elif and Rashid, Adnan and Hasan, Osman and Tahar, Sofi{\`e}ne},
  year = {2024},
  month = mar,
  volume = {11},
  pages = {197--236},
  abstract = {The telegrapher's equations constitute a set of linear partial differential equations that establish a mathematical correspondence between the electrical current and voltage within transmission lines, taking into account factors, such as distance and time. These equations find wide applications in the design and analysis of various systems, including integrated circuits and antennas. This paper proposes the utilization of higher-order-logic theorem proving for a formal analysis of the telegrapher's equations, also referred to as the transmission line equations. Specifically, we present a formal model of the telegrapher's equations in both time and phasor domains. Subsequently, we employ the HOL Light theorem prover to formally verify the solutions of the telegrapher's equations in the phasor domain. Furthermore, we established a connection between phasor and time-domain functions to formally verify the general solutions for the time-domain partial differential equations for the current and voltage in an electric transmission line. To demonstrate the practical effectiveness of our proposed formalization, we conduct a formal analysis of a terminated transmission line and its special cases, i.e., short-and open-circuited transmission lines commonly used in antenna design, by formally verifying the load impedance and the voltage reflection coefficient.},
  file = {/home/flaviomoura/Zotero/storage/GJDUZ4MG/Deniz et al. - 2024 - Formalization of the Telegrapher's Equations using.pdf}
}

@article{depaivaKolgomorovVelosoProblemsDialectica2021,
  title = {Kolgomorov-{{Veloso Problems}} and {{Dialectica Categories}}},
  author = {{de Paiva}, Valeria and {da Silva}, Samuel G.},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.07854 [math]},
  eprint = {2107.07854},
  primaryclass = {math},
  urldate = {2021-07-19},
  abstract = {We investigate the categorical connection between Dialectica constructions, Kolmogorov problems, Veloso problems and Blass problems. We show that the work of Kolmogorov can be regarded as a bridge between Veloso's abstract notion of a problem and the conceptual problems Blass discussed in his questions-and-answers framework. This bridge can be seen by means of the categorical Dialectica constructions introduced in de Paiva's dissertation and reformulated by da Silva to account for set-theoretical foundational assumptions. The use of categorical concepts allows us to provide several examples, connecting extremely different areas of mathematics, and using simple methods. This paper also shows that while Blass and Kolmogorov notions of problem can be investigated using the Zermelo-Fraenkel (ZF) set-theoretical framework, Veloso problems require the Axiom of Choice (AC). Moreover, weaker notions of choice (dependent choice and countable choice) can also be accounted for in the problems' framework.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/W6CLJ2TS/de Paiva e da Silva - 2021 - Kolgomorov-Veloso Problems and Dialectica Categori.pdf;/home/flaviomoura/Zotero/storage/S46KYAKH/2107.html}
}

@incollection{dershowitzRewriteSystems1990,
  title = {Rewrite {{Systems}}},
  booktitle = {Handbook of {{Theoretical Computer Science}}, {{Volume B}}: {{Formal Models}} and {{Sematics}} ({{B}})},
  author = {Dershowitz, Nachum and Jouannaud, Jean-Pierre},
  year = {1990},
  pages = {243--320},
  publisher = {MIT Press}
}

@article{dershowitzTerminationRewriting1987,
  title = {Termination of Rewriting},
  author = {Dershowitz, Nachum},
  year = {1987},
  month = feb,
  journal = {Journal of Symbolic Computation},
  volume = {3},
  number = {1},
  pages = {69--115},
  issn = {0747-7171},
  doi = {10.1016/S0747-7171(87)80022-6},
  urldate = {2024-03-13},
  abstract = {This survey describes methods for proving that systems of rewrite rules are terminating programs. We illustrate the use in termination proofs of various kinds of orderings on terms, including polynomial interpretations and path orderings. The effect of restrictions, such as linearity, on the form of rules is also considered. In general, however, termination is an undecidable property of rewrite systems.},
  file = {/home/flaviomoura/Zotero/storage/AT7LIN7D/Dershowitz - 1987 - Termination of rewriting.pdf;/home/flaviomoura/Zotero/storage/LEPTMS4N/S0747717187800226.html}
}

@article{deslauriersMeasuringActualLearning2019,
  title = {Measuring {{Actual Learning Versus Feeling}} of {{Learning}} in {{Response To Being Actively Engaged}} in the {{Classroom}}},
  author = {Deslauriers, Louis and McCarty, Logan S. and Miller, Kelly and Callaghan, Kristina and Kestin, Greg},
  year = {2019},
  journal = {Proceedings of the National Academy of Sciences},
  volume = {nil},
  number = {nil},
  pages = {201821936},
  doi = {10.1073/pnas.1821936116}
}

@article{devriesLocallyNamelessPermutation2017,
  title = {Locally {{Nameless Permutation Types}}},
  author = {{de Vries}, E. and Koutavas, V.},
  year = {2017},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages}
}

@article{diaconescuAxiomChoiceComplementation1975,
  title = {Axiom of {{Choice}} and {{Complementation}}},
  author = {Diaconescu, Radu},
  year = {1975},
  journal = {Proceedings of the American Mathematical Society},
  volume = {51},
  number = {1},
  eprint = {2039868},
  eprinttype = {jstor},
  pages = {176--178},
  publisher = {American Mathematical Society},
  issn = {0002-9939},
  doi = {10.2307/2039868},
  urldate = {2023-09-20},
  abstract = {It is shown that an intuitionistic model of set theory with the axiom of choice has to be a classical one.},
  file = {/home/flaviomoura/Zotero/storage/YNJNRVR2/Diaconescu - 1975 - Axiom of Choice and Complementation.pdf}
}

@article{diaz-caroLinearLinearLambdacalculus2024,
  title = {A Linear Linear Lambda-Calculus},
  author = {{D{\'i}az-Caro}, Alejandro and Dowek, Gilles},
  year = {2024},
  month = may,
  journal = {Mathematical Structures in Computer Science},
  pages = {1--35},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129524000197},
  urldate = {2024-06-02},
  abstract = {We present a linearity theorem for a proof language of intuitionistic multiplicative additive linear logic, incorporating addition and scalar multiplication. The proofs in this language are linear in the algebraic sense. This work is part of a broader research program aiming to define a logic with a proof language that forms a quantum programming language.},
  langid = {english},
  keywords = {lambda calculus,linear logic,Proof theory,quantum computing}
}

@article{diaz-caroNewConnectiveNatural2021,
  title = {A {{New Connective}} in {{Natural Deduction}}, and Its {{Application}} to {{Quantum Computing}}},
  author = {{D{\'i}az-Caro}, Alejandro and Dowek, Gilles},
  year = {2021},
  month = may,
  journal = {arXiv:2012.08994 [cs]},
  eprint = {2012.08994},
  primaryclass = {cs},
  urldate = {2021-05-12},
  abstract = {We investigate an unsuspected connection between non harmonious logical connectives, such as Prior's tonk, and quantum computing. We defend that non harmonious connectives model the information erasure, the non-reversibility, and the non-determinism that occur, among other places, in quantum measurement. More concretely, we introduce a propositional logic with a non harmonious connective \${\textbackslash}odot\$ (read: "sup", for "superposition") and show that its proof language forms the core of a quantum programming language.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/KQ3N7TNT/DÃ­az-Caro e Dowek - 2021 - A New Connective in Natural Deduction, and its App.pdf;/home/flaviomoura/Zotero/storage/GVI2MTJX/2012.html;/home/flaviomoura/Zotero/storage/QY63MUGJ/2012.html}
}

@inproceedings{diaz-caroRealizabilityUnitarySphere2019,
  title = {Realizability in the {{Unitary Sphere}}},
  booktitle = {2019 34th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}})},
  author = {{Diaz-Caro}, Alejandro and Guillermo, Mauricio and Miquel, Alexandre and Valiron, Benoit},
  year = {2019},
  month = jun,
  pages = {1--13},
  publisher = {IEEE},
  address = {Vancouver, BC, Canada},
  doi = {10.1109/LICS.2019.8785834},
  urldate = {2021-04-27},
  isbn = {978-1-72813-608-0},
  file = {/home/flaviomoura/Zotero/storage/SYIJQBIT/Diaz-Caro et al. - 2019 - Realizability in the Unitary Sphere.pdf}
}

@article{dietrichBeginnerGuideIris2021,
  title = {A Beginner Guide to {{Iris}}, {{Coq}} and Separation Logic},
  author = {Dietrich, Elizabeth},
  year = {2021},
  month = may,
  journal = {arXiv:2105.12077 [cs]},
  eprint = {2105.12077},
  primaryclass = {cs},
  urldate = {2021-05-29},
  abstract = {Creating safe concurrent algorithms is challenging and error-prone. For this reason, a formal verification framework is necessary especially when those concurrent algorithms are used in safety-critical systems. The goal of this guide is to provide resources for beginners to get started in their journey of formal verification using the powerful tool Iris. The difference between this guide and many others is that it provides (i) an in-depth explanation of examples and tactics, (ii) an explicit discussion of separation logic, and (iii) a thorough coverage of Iris and Coq. References to other guides and to papers are included throughout to provide readers with resources through which to continue their learning.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/ASNP46A3/2105.html}
}

@book{dietzfelbingerPrimalityTestingPolynomial2004,
  title = {Primality {{Testing}} in {{Polynomial Time}}},
  author = {Dietzfelbinger, Martin},
  year = {2004},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/b12334}
}

@article{dileepInductionModelsMathbb,
  title = {Induction {{Models}} on {\textbackslash}mathbb\{\vphantom\}{{N}}\vphantom\{\}},
  author = {Dileep, A. and Meel, Kuldeep S. and Sabili, Ammar F.},
  journal = {arXiv:2008.06410 [cs]},
  eprint = {2008.06410},
  primaryclass = {cs},
  pages = {169--146},
  doi = {10.29007/kvp3},
  urldate = {2020-08-17},
  abstract = {Mathematical induction is a fundamental tool in computer science and mathematics. Henkin initiated the study of formalization of mathematical induction restricted to the setting when the base case B is set to singleton set containing 0 and a unary generating function S. The usage of mathematical induction often involves wider set of base cases and k-ary generating functions with different structural restrictions. While subsequent studies have shown several Induction Models to be equivalent, there does not exist precise logical characterization of reduction and equivalence among different Induction Models. In this paper, we generalize the definition of Induction Model and demonstrate existence and construction of S for given B and vice versa. We then provide a formal characterization of the reduction among different Induction Models that can allow proofs in one Induction Models to be expressed as proofs in another Induction Models. The notion of reduction allows us to capture equivalence among Induction Models.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/NV2NDKP5/Dileep et al. - Induction Models on mathbb N .pdf;/home/flaviomoura/Zotero/storage/D8YW4SBW/2008.html}
}

@inproceedings{dillingerACL2sACL2Sedan2007,
  title = {{{ACL2s}}: "{{The ACL2 Sedan}}"},
  booktitle = {{{ICSE}}},
  author = {Dillinger, P. C. and Manolios, P. and Vroon, D. and Moore, J. S.},
  year = {2007},
  pages = {59--60}
}

@article{doczkalGraphTheoryCoq2020,
  title = {Graph {{Theory}} in {{Coq}}: {{Minors}}, {{Treewidth}}, and {{Isomorphisms}}},
  shorttitle = {Graph {{Theory}} in {{Coq}}},
  author = {Doczkal, Christian and Pous, Damien},
  year = {2020},
  month = jun,
  journal = {Journal of Automated Reasoning},
  volume = {64},
  number = {5},
  pages = {795--825},
  issn = {0168-7433, 1573-0670},
  doi = {10.1007/s10817-020-09543-2},
  urldate = {2022-01-13},
  abstract = {We present a library for graph theory in Coq/Ssreflect. This library covers various notions on simple graphs, directed graphs, and multigraphs. We use it to formalize several results from the literature: Menger's theorem, the excludedminor characterization of treewidth-two graphs, and a correspondence between multigraphs of treewidth at most two and terms of certain algebras.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/4P5YWRXI/Doczkal e Pous - 2020 - Graph Theory in Coq Minors, Treewidth, and Isomor.pdf;/home/flaviomoura/Zotero/storage/A3DRPPSY/Doczkal e Pous - 2020 - Graph Theory in Coq Minors, Treewidth, and Isomor.pdf}
}

@article{dolanSyntaxShiftedNames,
  title = {Syntax with {{Shifted Names}}},
  author = {Dolan, Stephen and White, Leo},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/C4K2HUNC/Dolan e White - Syntax with Shifted Names.pdf}
}

@inproceedings{dolanSyntaxShiftedNames2019,
  title = {Syntax with {{Shifted Names}}},
  booktitle = {Workshop on {{Type-driven Development}} ({{TyDe}})},
  author = {Dolan, Stephen and White, Leo},
  year = {2019}
}

@misc{DomesticaLegalHarmonia,
  title = {Dom{\'e}stica {{Legal}} - {{Harmonia}} No Emprego Dom{\'e}stico},
  urldate = {2021-03-05},
  howpublished = {https://sistema.domesticalegal.com.br/sistema/departamento-pessoal/},
  file = {/home/flaviomoura/Zotero/storage/47DLI6L4/departamento-pessoal.html}
}

@misc{donatoDraganddropProofTactic2022,
  title = {A Drag-and-Drop Proof Tactic},
  author = {Donato, Pablo and Strub, Pierre-Yves and Werner, Benjamin},
  year = {2022},
  month = nov,
  eprint = {2210.11820},
  primaryclass = {cs},
  doi = {10.1145/3497775.3503692},
  urldate = {2022-11-08},
  abstract = {We explore the features of a user interface where formal proofs can be built through gestural actions. In particular, we show how proof construction steps can be associated to drag-and-drop actions. We argue that this can provide quick and intuitive proof construction steps. This work builds on theoretical tools coming from deep inference. It also resumes and integrates some ideas of the former proof-by-pointing project.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Human-Computer Interaction,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/5TGXJVMX/Donato et al. - 2022 - A drag-and-drop proof tactic.pdf}
}

@misc{donatoFlowerCalculus2024,
  title = {The {{Flower Calculus}}},
  author = {Donato, Pablo},
  year = {2024},
  month = feb,
  number = {arXiv:2402.15174},
  eprint = {2402.15174},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-02-26},
  abstract = {We introduce the flower calculus, a deep inference proof system for intuitionistic first-order logic inspired by Peirce's existential graphs. It works as a rewriting system over inductive objects called ``flowers'', that enjoy both a graphical interpretation as topological diagrams, and a textual presentation as nested sequents akin to coherent formulas. Importantly, the calculus dispenses completely with the traditional notion of symbolic connective, operating solely on nested flowers containing atomic predicates. We prove both the soundness of the full calculus and the completeness of an analytic fragment with respect to Kripke semantics. This provides to our knowledge the first analyticity result for a proof system based on existential graphs, adapting semantic cut-elimination techniques to a deep inference setting. Furthermore, the kernel of rules targetted by completeness is fully invertible, a desirable property for both automated and interactive proof search.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4R7GF4Z6/Donato - 2024 - The Flower Calculus.pdf}
}

@article{dosenBackslashOdelDeduction2016,
  title = {G\${\textbackslash}backslash\$''odel on {{Deduction}}},
  author = {Dosen, K. and Adzic, M.},
  year = {2016},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {03A05 (Philosophical and critical),03F03 (Proof theory,general),Mathematics - History and Overview,Mathematics - Logic}
}

@article{dosenBackslashOdelNatural2016,
  title = {G\${\textbackslash}backslash\$''odel's {{Natural Deduction}}},
  author = {Dosen, K. and Adzic, M.},
  year = {2016},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {01A60 (History of mathematics and mathematicians,03-03 (Mathematical logic and foundations,03F03 (Proof theory,20th century),general),historical),Mathematics - History and Overview,Mathematics - Logic}
}

@article{doughertyHigherOrderUnificationCombinators1993,
  title = {Higher-{{Order Unification}} via {{Combinators}}},
  author = {Dougherty, D. J.},
  year = {1993},
  journal = {TCS},
  volume = {114},
  number = {2},
  pages = {273--298}
}

@article{doughertyIMPROVEDSYSTEMINTERSECTION,
  title = {{{AN IMPROVED SYSTEM OF INTERSECTION TYPES FOR EXPLICIT SUBSTITUTIONS}}},
  author = {Dougherty, Dan and Lengrand, Stephane and Lescanne, Pierre},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2MXP72EZ/Dougherty et al. - AN IMPROVED SYSTEM OF INTERSECTION TYPES FOR EXPLI.pdf}
}

@unpublished{doughertyProofFunctionalLogicInspired2016,
  title = {A {{Proof-Functional Logic Inspired}} by {{Set Types}}},
  author = {Dougherty, D. J. and De 'liguoro, U. and Liquori, L. and Stolze, C.},
  year = {2016},
  month = apr,
  doi = {10.4230/LIPIcs},
  keywords = {Church-style vs. Curry-style,explicitely typed calculi vs. implicitely typed calculi,Intersection and union types,proof-functional logics}
}

@article{dovicchiFunctionalProceduralLanguages,
  title = {Functional and {{Procedural Languages}} and {{Data Structures Learning}}},
  author = {Dovicchi, Joao},
  pages = {13},
  abstract = {In this paper authors present a didactic method for teaching Data Structures on Computer Science undergraduate course. An approach using functional along with procedural languages (Haskell and ANSI C) is presented, and adequacy of such a method is discussed. Authors are also concerned on how functional language can help students to learn fundamental concepts and acquire competence on data typing and structure for real programming.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PB327QPX/Dovicchi - Functional and Procedural Languages and Data Struc.pdf}
}

@article{dowek2021confluence,
  title = {Confluence of Non-Terminating Left-Linear Higher-Order Rewrite Theories},
  author = {Dowek, Gilles and Ferey, Gaspard and Jouannaud, Jean-Pierre and Liu, Jiaxiang},
  year = {2021}
}

@misc{dowekBindingLogicProofs2023,
  title = {Binding {{Logic}}: Proofs and Models},
  shorttitle = {Binding {{Logic}}},
  author = {Dowek, Gilles and Hardin, Th{\'e}r{\`e}se and Kirchner, Claude},
  year = {2023},
  month = may,
  number = {arXiv:2305.15782},
  eprint = {2305.15782},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-26},
  abstract = {We define an extension of predicate logic, called Binding Logic, where variables can be bound in terms and in propositions. We introduce a notion of model for this logic and prove a soundness and completeness theorem for it. This theorem is obtained by encoding this logic back into predicate logic and using the classical soundness and completeness theorem there.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/A6UT9BYQ/Dowek et al. - 2023 - Binding Logic proofs and models.pdf}
}

@misc{dowekComplementationBridgeFinite2023,
  title = {Complementation: A Bridge between Finite and Infinite Proofs},
  shorttitle = {Complementation},
  author = {Dowek, Gilles and Jiang, Ying},
  year = {2023},
  month = apr,
  number = {arXiv:2304.05085},
  eprint = {2304.05085},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-12},
  abstract = {When a proposition has no proof in an inference system, it is sometimes useful to build a counter-proof explaining, step by step, the reason of this non-provability. In general, this counter-proof is a (possibly) infinite co-inductive proof in a different inference system. In this paper, we show that, for some decidable inference systems, this (possibly) infinite proof has a representation as a finite proof in yet another system, equivalent to the previous one. Conversely, to better explain the reason of the non-provability, we introduce an efficient method to transform a finite proof into a (possibly) infinite one. The method is illustrated with an application to non-reachability proofs in Alternating pushdown systems.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/P3SWM9V6/Dowek e Jiang - 2023 - Complementation a bridge between finite and infin.pdf}
}

@misc{dowekCompleteProofSynthesis2023,
  title = {A {{Complete Proof Synthesis Method}} for the {{Cube}} of {{Type Systems}}},
  author = {Dowek, Gilles},
  year = {2023},
  month = jun,
  number = {arXiv:2306.05835},
  eprint = {2306.05835},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-12},
  abstract = {We present a complete proof synthesis method for the eight type systems of Barendregt's cube extended with {$\eta$}-conversion. Because these systems verify the proofs-as-objects paradigm, the proof synthesis method is a one level process merging unification and resolution. Then we present a variant of this method, which is incomplete but much more efficient. At last we show how to turn this algorithm into a unification algorithm.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/7Z59MWX9/Dowek - 2023 - A Complete Proof Synthesis Method for the Cube of .pdf}
}

@misc{dowekConfluenceCutElimination2023,
  title = {Confluence as a Cut Elimination Property},
  author = {Dowek, Gilles},
  year = {2023},
  month = may,
  number = {arXiv:2305.13790},
  eprint = {2305.13790},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-24},
  abstract = {The goal of this note is to compare two notions, one coming from the theory of rewrite systems and the other from proof theory: confluence and cut elimination. We show that to each rewrite system on terms, we can associate a logical system: asymmetric deduction modulo this rewrite system and that the confluence property of the rewrite system is equivalent to the cut elimination property of the associated logical system. This equivalence, however, does not extend to rewrite systems directly rewriting atomic propositions.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/LZVZTZLA/Dowek - 2023 - Confluence as a cut elimination property.pdf}
}

@misc{dowekDefinitionEtalongNormal2023,
  title = {On the {{Definition}} of the {{Eta-long Normal Form}} in {{Type Systems}} of the {{Cube}}},
  author = {Dowek, Gilles and Huet, G{\'e}rard and Werner, Benjamin},
  year = {2023},
  month = jul,
  number = {arXiv:2307.00854},
  eprint = {2307.00854},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-07-04},
  abstract = {The smallest transitive relation {$<$} on well-typed normal terms such that if t is a strict subterm of u then t {$<$} u and if T is the normal form of the type of t and the term t is not a sort then T {$<$} t is well-founded in the type systems of the cube. Thus every term admits a {$\eta$}-long normal form.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/RNMSJRP2/Dowek et al. - 2023 - On the Definition of the Eta-long Normal Form in T.pdf}
}

@misc{dowekExecutionTracesReduction2023,
  title = {Execution Traces and Reduction Sequences},
  author = {Dowek, Gilles},
  year = {2023},
  month = apr,
  number = {arXiv:2304.05039},
  eprint = {2304.05039},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-12},
  abstract = {In this note, we defend that the notion of algorithm as a set of execution traces is somewhat independent of the notion of abstract state machine. It can be reformulated in the more general framework of small step operational semantics.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/92D63UJ8/Dowek - 2023 - Execution traces and reduction sequences.pdf}
}

@misc{dowekExplanationEthicsLogic2023,
  title = {Explanation: From Ethics to Logic},
  shorttitle = {Explanation},
  author = {Dowek, Gilles},
  year = {2023},
  month = apr,
  number = {arXiv:2304.00821},
  eprint = {2304.00821},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-04},
  abstract = {When a decision, such as the approval or denial of a bank loan, is delegated to a computer, an explanation of that decision ought to be given with it. This ethical need to explain the decisions leads to the search for a formal definition of the notion of explanation. This question meets older questions in logic regarding the explanatory nature of proof.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4LLRZLPM/Dowek - 2023 - Explanation from ethics to logic.pdf}
}

@misc{dowekExpressivePowerSchemes2023,
  title = {On the {{Expressive Power}} of {{Schemes}}},
  author = {Dowek, Gilles and Jiang, Ying},
  year = {2023},
  month = apr,
  number = {arXiv:2304.11892},
  eprint = {2304.11892},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-25},
  abstract = {We present a calculus, called the scheme-calculus, that permits to express natural deduction proofs in various theories. Unlike {$\lambda$}-calculus, the syntax of this calculus sticks closely to the syntax of proofs, in particular, no names are introduced for the hypotheses. We show that despite its non-determinism, some typed scheme-calculi have the same expressivity as the corresponding typed {$\lambda$}-calculi.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4LJZRHN3/Dowek e Jiang - 2023 - On the Expressive Power of Schemes.pdf}
}

@article{dowekHigherOrderUnification2000,
  title = {Higher {{Order Unification}} via {{Explicit Substitutions}}},
  author = {Dowek, G. and Hardin, T. and Kirchner, C.},
  year = {2000},
  journal = {Inf. Comput.},
  volume = {157},
  number = {1-2},
  pages = {183--235}
}

@incollection{dowekHigherOrderUnificationMatching2001,
  title = {Higher-{{Order Unification}} and {{Matching}}},
  booktitle = {Handbook of {{Automated Reasoning}}},
  author = {Dowek, G.},
  editor = {Robinson, A. and Voronkov, A.},
  year = {2001},
  volume = {II},
  pages = {1009--1062},
  publisher = {{MIT press and Elsevier}},
  chapter = {16}
}

@article{dowekInteractingSafelyUnsafe2021,
  title = {Interacting {{Safely}} with an {{Unsafe Environment}}},
  author = {Dowek, Gilles},
  year = {2021},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {337},
  eprint = {2107.07662},
  pages = {30--38},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.337.3},
  urldate = {2021-07-19},
  abstract = {We give a presentation of Pure type systems where contexts need not be well-formed and show that this presentation is equivalent to the usual one. The main motivation for this presentation is that, when we extend Pure type systems with computation rules, like in the logical framework Dedukti, we want to declare the constants before the computation rules that are needed to check the well-typedness of their type.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/GYH7C3HR/Dowek - 2021 - Interacting Safely with an Unsafe Environment.pdf;/home/flaviomoura/Zotero/storage/GCPCHPVK/2107.html}
}

@book{dowekIntroductionProofTheory2014,
  title = {Introduction to {{Proof Theory}}},
  author = {Dowek, G.},
  year = {2014}
}

@book{dowekIntroductionTheoryProgramming2011,
  title = {Introduction to the {{Theory}} of {{Programming Languages}}},
  author = {Dowek, G. and L{\'e}vy, J.-J.},
  year = {2011},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  doi = {10.1007/978-0-85729-076-2},
  file = {/home/flaviomoura/Zotero/storage/ANEV7PHS/Dowek e LÃ©vy - 2011 - Introduction to the Theory of Programming Language.pdf}
}

@article{dowekPNLHOLLogic2012,
  title = {{{PNL}} to {{HOL}}: From the Logic of Nominal Sets to the Logic of Higher-Order Functions},
  shorttitle = {{{PNL}} to {{HOL}}},
  author = {Dowek, Gilles and Gabbay, Murdoch J.},
  year = {2012},
  month = sep,
  journal = {Theoretical Computer Science},
  volume = {451},
  eprint = {2312.16239},
  primaryclass = {cs},
  pages = {38--69},
  issn = {03043975},
  doi = {10.1016/j.tcs.2012.06.007},
  urldate = {2023-12-29},
  abstract = {Permissive-Nominal Logic (PNL) extends first-order predicate logic with term-formers that can bind names in their arguments. It takes a semantics in (permissive-)nominal sets. In PNL, the forall-quantifier or lambda-binder are just term-formers satisfying axioms, and their denotation is functions on nominal atoms-abstraction. Then we have higher-order logic (HOL) and its models in ordinary (i.e. Zermelo-Fraenkel) sets; the denotation of forall or lambda is functions on full or partial function spaces. This raises the following question: how are these two models of binding connected? What translation is possible between PNL and HOL, and between nominal sets and functions? We exhibit a translation of PNL into HOL, and from models of PNL to certain models of HOL. It is natural, but also partial: we translate a restricted subsystem of full PNL to HOL. The extra part which does not translate is the symmetry properties of nominal sets with respect to permutations. To use a little nominal jargon: we can translate names and binding, but not their nominal equivariance properties. This seems reasonable since HOL -- and ordinary sets -- are not equivariant. Thus viewed through this translation, PNL and HOL and their models do different things, but they enjoy non-trivial and rich subsystems which are isomorphic.},
  archiveprefix = {arXiv},
  keywords = {03B70 (primary) 68Q55 (secondary),Computer Science - Logic in Computer Science,F.3.0,F.3.2},
  file = {/home/flaviomoura/Zotero/storage/65C7VZDL/Dowek e Gabbay - 2012 - PNL to HOL from the logic of nominal sets to the .pdf;/home/flaviomoura/Zotero/storage/QJGZMMC4/2312.html}
}

@misc{dowekPreliminaryInvestigationsInduction2023,
  title = {Preliminary Investigations on Induction over Real Numbers},
  author = {Dowek, Gilles},
  year = {2023},
  month = may,
  number = {arXiv:2305.14803},
  eprint = {2305.14803},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-25},
  abstract = {The induction principle for natural numbers expresses that when a property holds for some natural number a and is hereditary, then it holds for all numbers greater than or equal to a. We present a similar principle for real numbers.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/9J9UVCR2/Dowek - 2023 - Preliminary investigations on induction over real .pdf}
}

@book{dowekProofsAlgorithms2011,
  title = {Proofs and {{Algorithms}}},
  author = {Dowek, Gilles},
  year = {2011},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  address = {London},
  doi = {10.1007/978-0-85729-121-9},
  urldate = {2020-07-07},
  isbn = {978-0-85729-120-2 978-0-85729-121-9},
  file = {/home/flaviomoura/Zotero/storage/W2K9IPEU/Dowek - 2011 - Proofs and Algorithms.pdf}
}

@book{dowekProofsTheories2015,
  title = {Proofs in {{Theories}}},
  author = {Dowek, G.},
  year = {2015},
  file = {/home/flaviomoura/Zotero/storage/QPNIMK5R/Dowek - 2015 - Proofs in Theories.pdf}
}

@misc{dowekSimpleProofThat2023,
  title = {A {{Simple Proof That Super-Consistency Implies Cut Elimination}}},
  author = {Dowek, Gilles and Hermant, Olivier},
  year = {2023},
  month = apr,
  number = {arXiv:2304.10975},
  eprint = {2304.10975},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-24},
  abstract = {We give a simple and direct proof that super-consistency implies the cut elimination property in deduction modulo. This proof can be seen as a simplification of the proof that super-consistency implies proof normalization. It also takes ideas from the semantic proofs of cut elimination that proceed by proving the completeness of the cut-free calculus. As an application, we compare our work with the cut elimination theorems in higher-order logic that involve V-complexes.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/87XWUZKV/Dowek e Hermant - 2023 - A Simple Proof That Super-Consistency Implies Cut .pdf}
}

@misc{dowekStratifiedFoundationsTheory2023,
  title = {The {{Stratified Foundations}} as a Theory Modulo},
  author = {Dowek, Gilles},
  year = {2023},
  month = may,
  number = {arXiv:2305.18837},
  eprint = {2305.18837},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-31},
  abstract = {The Stratified Foundations are a restriction of naive set theory where the comprehension scheme is restricted to stratifiable propositions. It is known that this theory is consistent and that proofs strongly normalize in this theory. Deduction modulo is a formulation of first-order logic with a general notion of cut. It is known that proofs normalize in a theory modulo if it has some kind of many-valued model called a pre-model. We show in this paper that the Stratified Foundations can be presented in deduction modulo and that the method used in the original normalization proof can be adapted to construct a pre-model for this theory.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/LZYXPYKR/Dowek - 2023 - The Stratified Foundations as a theory modulo.pdf}
}

@misc{dowekTeachingIncompletenessTheorems2023,
  title = {Teaching {{G}}\{{\textbackslash}"o\}del's Incompleteness Theorems},
  author = {Dowek, Gilles},
  year = {2023},
  month = mar,
  number = {arXiv:2303.18099},
  eprint = {2303.18099},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2023-04-04},
  abstract = {The basic notions of logic-predicate logic, Peano arithmetic, incompleteness theorems, etc.-have for long been an advanced topic. In the last decades, they became more widely taught, inphilosophy, mathematics, and computer science departments, to graduate and to undergraduate students. Many textbooks now present these notions, in particular the incompleteness theorems. Having taught these notions for several decades, our community can now stand back and analyze the choices faced when designing such a course. In this note, we attempt to analyze the choices faced when teaching the incompleteness theorems.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - History and Overview},
  file = {/home/flaviomoura/Zotero/storage/CQMDC3BF/Dowek - 2023 - Teaching G o del's incompleteness theorems.pdf}
}

@article{dowekThirdOrderMatching1994,
  title = {Third Order Matching Is Decidable},
  author = {Dowek, G.},
  year = {1994},
  journal = {APAL},
  volume = {69},
  pages = {135--155}
}

@misc{dowekThirdOrderMatching2023,
  title = {Third {{Order Matching}} Is {{Decidable}}},
  author = {Dowek, Gilles},
  year = {2023},
  month = jun,
  number = {arXiv:2306.01473},
  eprint = {2306.01473},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-05},
  abstract = {The higher order matching problem is the problem of determining whether a term is an instance of another in the simply typed {$\lambda$}-calculus, i.e. to solve the equation a = b where a and b are simply typed {$\lambda$}-terms and b is ground. The decidability of this problem is still open. We prove the decidability of the particular case in which the variables occurring in the problem are at most third order.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/XEQQAQEH/Dowek - 2023 - Third Order Matching is Decidable.pdf}
}

@misc{dowekUndecidabilityPatternMatching2023,
  title = {The {{Undecidability}} of {{Pattern Matching}} in {{Calculi}} Where {{Primitive Recursive Functions}} Are {{Representable}}},
  author = {Dowek, Gilles},
  year = {2023},
  month = jun,
  number = {arXiv:2306.05876},
  eprint = {2306.05876},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-12},
  abstract = {We prove that the pattern matching problem is undecidable in polymorphic lambda-calculi (as Girard's system F) and calculi supporting inductive types (as G\{{\textbackslash}"o\}del's system T) by reducing Hilbert's tenth problem to it. More generally pattern matching is undecidable in all the calculi in which primitive recursive functions can be fairly represented in a precised sense.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/HSBS56WY/Dowek - 2023 - The Undecidability of Pattern Matching in Calculi .pdf}
}

@misc{dowekUndecidabilityThirdOrder2023,
  title = {The {{Undecidability}} of {{Third Order Pattern Matching}} in {{Calculi}} with {{Dependent Types}} or {{Type Constructors}}},
  author = {Dowek, Gilles},
  year = {2023},
  month = sep,
  number = {arXiv:2309.11819},
  eprint = {2309.11819},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-09-22},
  abstract = {We prove the undecidability of the third order pattern matching problem in typed lambda-calculi with dependent types and in those with type constructors by reducing the second order unification problem to them.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/UAFX6RI9/Dowek - 2023 - The Undecidability of Third Order Pattern Matching.pdf;/home/flaviomoura/Zotero/storage/7K4XLN8S/2309.html}
}

@misc{dowekUnificationAlgorithmSecondOrder2023,
  title = {A {{Unification Algorithm}} for {{Second-Order Linear Terms}}},
  author = {Dowek, Gilles},
  year = {2023},
  month = sep,
  number = {arXiv:2309.02024},
  eprint = {2309.02024},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-09-06},
  abstract = {We give an algorithm for the class of second order unification problems in which second order variables have at most one occurrence.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4IXPVHHI/Dowek - 2023 - A Unification Algorithm for Second-Order Linear Te.pdf;/home/flaviomoura/Zotero/storage/CTEPTRV4/2309.html}
}

@inproceedings{dowekUnificationExplicitSubstitutions1996,
  ids = {dowek1996unification},
  title = {Unification via {{Explicit Substitutions}}: {{The Case}} of {{Higher-Order Patterns}}},
  booktitle = {Logic {{Programing}}, {{Proceedings}} of the 1996 {{Joint International Conference}} and {{Syposium}} on {{Logic Programming}}, {{Bonn}}, {{Germany}}, {{September}} 2-6, 1996},
  author = {Dowek, G. and Hardin, T. and Kirchner, C. and Pfenning, F.},
  year = {1996},
  pages = {259--273}
}

@misc{dowekWhatTheory2023,
  title = {What Is a {{Theory}} ?},
  author = {Dowek, Gilles},
  year = {2023},
  month = may,
  number = {arXiv:2305.15780},
  eprint = {2305.15780},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-26},
  abstract = {Deduction modulo is a way to express a theory using computation rules instead of axioms. We present in this paper an extension of deduction modulo, called Polarized deduction modulo, where some rules can only be used at positive occurrences, while others can only be used at negative ones. We show that all theories in propositional calculus can be expressed in this framework and that cuts can always be eliminated with such theories.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/YGWKQJ6M/Dowek - 2023 - What is a Theory .pdf}
}

@article{downenTutorialComputationalClassical2018,
  title = {A Tutorial on Computational Classical Logic and the Sequent Calculus},
  author = {Downen, Paul and Ariola, Zena M.},
  year = {2018},
  journal = {Journal of Functional Programming},
  volume = {28},
  pages = {e3},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796818000023},
  urldate = {2023-07-05},
  abstract = {We present a model of computation that heavily emphasizes the concept of duality and the interaction between opposites---production interacts with consumption. The symmetry of this framework naturally explains more complicated features of programming languages through relatively familiar concepts. For example, binding a value to a variable is dual to manipulating the flow of control in a program. By looking at the computational interpretation of the sequent calculus, we find a language that lets us speak about duality, control flow, and evaluation order in programs as first-class concepts. We begin by reviewing Gentzen's LK sequent calculus and show how the Curry-Howard isomorphism still applies to give us a different basis for expressing computation. We then illustrate how the fundamental dilemma of computation in the sequent calculus gives rise to a duality between evaluation strategies: strict languages are dual to lazy languages. Finally, we discuss how the concept of focusing, developed in the setting of proof search, is related to the idea of type safety for computation expressed in the sequent calculus. In this regard, we compare and contrast two different methods of focusing that have appeared in the literature, static and dynamic focusing, and illustrate how they are two means to the same end.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/J3GQJSF7/Downen e Ariola - 2018 - A tutorial on computational classical logic and th.pdf}
}

@article{dowsonArianeSoftwareFailure1997,
  title = {The {{Ariane}} 5 {{Software Failure}}},
  author = {Dowson, Mark},
  year = {1997},
  journal = {ACM SIGSOFT Software Engineering Notes},
  volume = {22},
  number = {2},
  pages = {84},
  doi = {10.1145/251880.251992}
}

@article{drabentCorrectnessQueensProgram2019,
  title = {On {{Correctness}} of an {{N Queens Program}}},
  author = {Drabent, W{\l}odzimierz},
  year = {2019},
  journal = {CoRR},
  abstract = {Thom Fr{\"u}hwirth presented a short, elegant and efficient Prolog program for the n queens problem. However the program may be seen as rather tricky and one may be not convinced about its correctness. This paper explains the program in a declarative way, and provides proofs of its correctness and completeness. The specification and the proofs are declarative, i.e. they abstract from any operational semantics. The specification is approximate, it is unnecessary to describe the program's semantics exactly. Despite the program works on non-ground terms, this work employs the standard semantics, based on Herbrand interpretations and logical consequence. Another purpose of the paper is to present an example of precise declarative reasoning about the semantics of a logic program.}
}

@article{drabentSLDresolutionOccurcheckExample2021,
  title = {{{SLD-resolution}} without Occur-Check, an Example},
  author = {Drabent, W{\l}odzimierz},
  year = {2021},
  month = mar,
  journal = {arXiv:2103.01911 [cs]},
  eprint = {2103.01911},
  primaryclass = {cs},
  urldate = {2021-03-04},
  abstract = {We prove that the occur-check is not needed for a certain definite clause logic program, independently from the selection rule. First we prove that the program is occur-check free. Then we consider a more general class of queries, under which the program is not occur-check free; however we show that it will be correctly executed under Prolog without occur-check. The main result of this report states that the occur-check may be skipped for the cases in which a single run of a standard nondeterministic unification algorithm does not fail due to the occur-check. The usual approaches are based on the notion of NSTO (not subject to occur-check), which considers all the runs. To formulate the result, it was necessary to introduce an abstraction of a "unification" algorithm without the occur-check.},
  archiveprefix = {arXiv},
  keywords = {68N17 03B10,Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.1.6,F.3.3},
  file = {/home/flaviomoura/Zotero/storage/EP566M4V/Drabent - 2021 - SLD-resolution without occur-check, an example.pdf;/home/flaviomoura/Zotero/storage/JQMZHK5J/2103.html}
}

@article{dragoTuringChurchThesisConstructve2021,
  title = {Turing-{{Church}} Thesis, Constructve Mathematics and Intuitionist Logic},
  author = {Drago, Antonino},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.05387 [math]},
  eprint = {2101.05387},
  primaryclass = {math},
  urldate = {2021-01-15},
  abstract = {At a first glance the Theory of computation relies on potential infinity and an organization aimed at solving a problem. Under such aspect it is like Mendeleev theory of chemistry. Also its theoretical development reiterates that of this scientific theory: it makes use of doubly negated propositions and its reasoning proceeds through ad absurdum proofs; a final, universal predicate of equivalence of all definitions of a computations is translated into an equality one, and at the same time intuitionist logic into classical logic. Yet, the last step of this development of current theory includes both a misleading notion of thesis and intuitive notions (e.g. the partial computable function, as stressed by some scholars). A program for a rational re-construction of the theory according to the theoretical development of the above mentioned theories is sketchy suggested.},
  archiveprefix = {arXiv},
  keywords = {68Q01,F.1.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/5UIA7R97/Drago - 2021 - Turing-Church thesis, constructve mathematics and .pdf;/home/flaviomoura/Zotero/storage/3XZ2RNBJ/2101.html}
}

@book{dresselhausGroupTheory2008,
  title = {Group {{Theory}}},
  author = {Dresselhaus, Mildred S and Dresselhaus, Gene and Jorio, Ado},
  year = {2008},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-32899-5}
}

@article{dreyerBeingPhDStudent2022,
  title = {On Being a {{PhD}} Student of {{Robert Harper}}},
  author = {Dreyer, Derek and Pierce, Benjamin C.},
  year = {2022},
  journal = {Journal of Functional Programming},
  volume = {32},
  pages = {e3},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796821000289},
  urldate = {2023-10-03},
  abstract = {The Robert Harper Festschrift includes articles by three of Bob's students and colleagues---Karl Crary, Andrzej Filinski, and Jonathan Sterling. Each of these articles touches on themes that are central to Bob's research: module system design, proof-directed program development, and (to use Bob's term) ``computational trinitarianism''.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/X6AFP46W/Dreyer e Pierce - 2022 - On being a PhD student of Robert Harper.pdf}
}

@article{duboisMechanizedProofTextbook2020,
  title = {A {{Mechanized Proof}} of a {{Textbook Type Unification Algorithm}}},
  author = {Du Bois, Andr{\'e} Rauber and Ribeiro, Rodrigo and Amaro, Maycon},
  year = {2020},
  journal = {Revista de Inform{\'a}tica Te{\'o}rica e Aplicada},
  volume = {27},
  number = {3},
  pages = {13--24}
}

@article{dudenhefnerIntersectionTypeUnification2016,
  title = {The {{Intersection Type Unification Problem}}},
  author = {Dudenhefner, A. and Martens, M. and Rehof, J.},
  year = {2016},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,F.4.1}
}

@article{dudenhefnerUndecidabilitySystemTypability,
  title = {The {{Undecidability}} of {{System F Typability}} and {{Type Checking}} for {{Reductionists}}},
  author = {Dudenhefner, Andrej},
  pages = {10},
  abstract = {The undecidability of both typability and type checking for System F (polymorphic lambda-calculus) was established by Wells in the 1990s. For type checking Wells gave an astonishingly simple reduction from semi-unification (first-order unification combined with first-order matching). For typability Wells developed an intricate calculus to control the shape of type assumptions across type derivations via term structure. This calculus of invariant type assumptions allows for a reduction from type checking to typability. Unfortunately, this approach relies on heavy machinery that complicates surveyability of the overall argument.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7Q8GXMUH/Dudenhefner - The Undecidability of System F Typability and Type.pdf}
}

@inproceedings{dunchevCutEliminationProofSchemata2015,
  title = {Cut-{{Elimination}} and {{Proof Schemata}}},
  booktitle = {Logic, {{Language}}, and {{Computation}}},
  author = {Dunchev, Cvetan and Leitsch, Alexander and Rukhaia, Mikheil and Weller, Daniel},
  editor = {Aher, Martin and Hole, Daniel and Je{\v r}{\'a}bek, Emil and Kupke, Clemens},
  year = {2015},
  pages = {117--136},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-662-46906-4_8},
  abstract = {By Gentzen's famous Hauptsatz (the cut-elimination theorem) every proof in sequent calculus for first-order logic with cuts can be transformed into a cut-free proof; cut-free proofs are analytic and consist entirely of syntactic material of the end-sequent (the proven theorem). But in systems with induction rules, cut-elimination is either impossible or does not produce proofs with the subformula property. One way to overcome this problem is to formulate induction proofs as infinite sequences of proofs in a uniform way and to develop a method, which yields a uniform description of the corresponding cut-free proofs. We present such a formalism, as an alternative to systems with induction rules, and define a corresponding cut-elimination method (based on the CERES-method for first-order logic). The basic tools of proof theory, such as sequent- and resolution calculi are enriched with inductive definitions and schemata of terms, formulas, proofs, etc. We define a class of inductive proofs which can be transformed into this formalism and subjected to schematic cut-elimination.},
  isbn = {978-3-662-46906-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VDE55NTB/Dunchev et al. - 2015 - Cut-Elimination and Proof Schemata.pdf}
}

@article{dunnSyntaxMonadsWorking,
  title = {Syntax {{Monads}} for the {{Working Metatheorist}}},
  author = {Dunn, L and Tannen, V and Zdancewic, S},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/8LUV986Q/Dunn et al. - Syntax Monads for the Working Metatheorist.pdf}
}

@book{duparcComputerScienceLogic2007,
  title = {Computer {{Science Logic}}, 21st {{International Workshop}}, {{CSL}} 2007, 16th {{Annual Conference}} of the {{EACSL}}, {{Lausanne}}, {{Switzerland}}, {{September}} 11-15, 2007, {{Proceedings}}},
  editor = {Duparc, Jacques and Henzinger, Thomas A.},
  year = {2007},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {4646},
  publisher = {Springer},
  doi = {10.1007/978-3-540-74915-8},
  isbn = {978-3-540-74914-1}
}

@book{dybjerEpistemologyOntologyEssays2012,
  title = {Epistemology versus {{Ontology}}: {{Essays}} on the {{Philosophy}} and {{Foundations}} of {{Mathematics}} in {{Honour}} of {{Per Martin-L{\"o}f}}},
  author = {Dybjer, P. and Lindstr{\"o}m, S. and Palmgren, E. and Sundholm (eds.), G.},
  year = {2012},
  series = {Logic, {{Epistemology}}, and the {{Unity}} of {{Science}}},
  publisher = {Springer Nature},
  doi = {10.1007/978-94-007-4435-6}
}

@article{dzamonjaNewFoundationalCrisis2018,
  title = {A {{New Foundational Crisis}} in {{Mathematics}}, {{Is It Really Happening}}?},
  author = {D{\v z}amonja, Mirna},
  year = {2018},
  journal = {CoRR},
  abstract = {The article reconsiders the position of the foundations of mathematics after the discovery of HoTT. Discussion that this discovery has generated in the community of mathematicians, philosophers and computer scientists might indicate a new crisis in the foundation of mathematics. By examining the mathematical facts behind HoTT and their relation with the existing foundations, we conclude that the present crisis is not one. We reiterate a pluralist vision of the foundations of mathematics. The article contains a short survey of the mathematical and historical background needed to understand the main tenets of the foundational issues.}
}

@book{ebbinghausMathematicalLogic1984,
  title = {Mathematical Logic},
  author = {Ebbinghaus, H.-D. and Flum, J. and Thomas, W.},
  year = {1984},
  series = {Undergraduate Texts in Mathematics},
  publisher = {Springer},
  file = {/home/flaviomoura/Zotero/storage/YNRLW76I/Ebbinghaus et al. - 1984 - Mathematical logic.pdf}
}

@article{ecarnotWritingScientificArticle2015,
  title = {Writing a Scientific Article: {{A}} Step-by-Step Guide for Beginners},
  shorttitle = {Writing a Scientific Article},
  author = {Ecarnot, F. and Seronde, M. -F. and Chopard, R. and Schiele, F. and Meneveau, N.},
  year = {2015},
  month = dec,
  journal = {European Geriatric Medicine},
  volume = {6},
  number = {6},
  pages = {573--579},
  issn = {1878-7649},
  doi = {10.1016/j.eurger.2015.08.005},
  urldate = {2024-01-17},
  abstract = {Many young researchers find it extremely difficult to write scientific articles, and few receive specific training in the art of presenting their research work in written format. Yet, publication is often vital for career advancement, to obtain funding, to obtain academic qualifications, or for all these reasons. We describe here the basic steps to follow in writing a scientific article. We outline the main sections that an average article should contain; the elements that should appear in these sections, and some pointers for making the overall result attractive and acceptable for publication.},
  keywords = {Article,Research,Scientific publications,Writing}
}

@book{edmondsHowThinkAlgorithms2008,
  title = {How to {{Think About Algorithms}}},
  author = {Edmonds, Jeff},
  year = {2008},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {0-521-61410-4 978-0-521-61410-8}
}

@article{ehleSequentCalculusTrainer2015,
  title = {The {{Sequent Calculus Trainer}} - {{Helping Students}} to {{Correctly Construct Proofs}}},
  author = {Ehle, A. and Hundeshagen, N. and Lange, M.},
  year = {2015},
  journal = {CoRR}
}

@inproceedings{ehrhardBangCalculusUntyped2016,
  title = {The {{Bang Calculus}}: An Untyped Lambda-Calculus Generalizing {{Call-By-Name}} and {{Call-By-Value}}},
  booktitle = {18th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}} - {{PPDP}} 2016},
  author = {Ehrhard, T. and Guerrieri, G.},
  year = {2016}
}

@article{ehrhardDifferentialLambdaCalculus2003,
  title = {The {{Differential Lambda-Calculus}}},
  author = {Ehrhard, T. and Regnier, L.},
  year = {2003},
  journal = {Theoretical Computer Science},
  volume = {309},
  number = {1-3},
  pages = {1--41},
  doi = {10.1016/s0304-3975(03)00392-x}
}

@article{eliottProgramLogicFresh2021,
  title = {A Program Logic for Fresh Name Generation},
  author = {Eliott, Harold Pancho and Berger, Martin},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.10720 [cs]},
  eprint = {2101.10720},
  primaryclass = {cs},
  urldate = {2021-01-30},
  abstract = {We present a program logic for Pitts and Stark's \{{\textbackslash}nu\}-calculus, an extension of the call-by-value simply-typed \{{\textbackslash}lambda\}-calculus with a mechanism for the generation of fresh names. Names can be compared for (in)-equality, producing programs with subtle observable properties. Hidden names produced by interactions between generation and abstraction are captured logically with a second-order quantifier over type contexts. We illustrate usage of the logic through reasoning about well-known difficult cases from the literature.},
  archiveprefix = {arXiv},
  keywords = {68N17 (primary) 68Q60 (secondary),Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.3,F.4},
  file = {/home/flaviomoura/Zotero/storage/3QCDRF3X/Eliott e Berger - 2021 - A program logic for fresh name generation.pdf;/home/flaviomoura/Zotero/storage/5RTMZI49/2101.html}
}

@article{ellermanHowCategoryTheory2020,
  title = {How {{Category Theory Works}}: {{The Elements}} \& {{Distinctions Analysis}} of the {{Morphisms}}, {{Duality}}, and {{Universal Constructions}} in {{Sets}}},
  shorttitle = {How {{Category Theory Works}}},
  author = {Ellerman, David},
  year = {2020},
  month = jul,
  journal = {arXiv:2007.05733 [math]},
  eprint = {2007.05733},
  primaryclass = {math},
  urldate = {2020-07-14},
  abstract = {The purpose of this paper is to show that the dual notions of elements \& distinctions are the basic analytical concepts needed to unpack and analyze morphisms, duality, and universal constructions in the Sets, the category of sets and functions. The analysis extends directly to other concrete categories (groups, rings, vector spaces, etc.) where the objects are sets with a certain type of structure and the morphisms are functions that preserve that structure. Then the elements \& distinctions-based definitions can be abstracted in purely arrow-theoretic way for abstract category theory. In short, the language of elements \& distinctions is the conceptual language in which the category of sets is written, and abstract category theory gives the abstract arrows version of those definitions.},
  archiveprefix = {arXiv},
  keywords = {18-02,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/UQI7TUE5/Ellerman - 2020 - How Category Theory Works The Elements & Distinct.pdf;/home/flaviomoura/Zotero/storage/I2DB8GIU/2007.html}
}

@misc{eloundouGPTsAreGPTs2023,
  title = {{{GPTs}} Are {{GPTs}}: {{An Early Look}} at the {{Labor Market Impact Potential}} of {{Large Language Models}}},
  shorttitle = {{{GPTs}} Are {{GPTs}}},
  author = {Eloundou, Tyna and Manning, Sam and Mishkin, Pamela and Rock, Daniel},
  year = {2023},
  month = mar,
  number = {arXiv:2303.10130},
  eprint = {2303.10130},
  primaryclass = {cs, econ, q-fin},
  publisher = {arXiv},
  urldate = {2023-03-29},
  abstract = {We investigate the potential implications of large language models (LLMs), such as Generative Pretrained Transformers (GPTs), on the U.S. labor market, focusing on the increased capabilities arising from LLM-powered software compared to LLMs on their own. Using a new rubric, we assess occupations based on their alignment with LLM capabilities, integrating both human expertise and GPT-4 classifications. Our findings reveal that around 80\% of the U.S. workforce could have at least 10\% of their work tasks affected by the introduction of LLMs, while approximately 19\% of workers may see at least 50\% of their tasks impacted. We do not make predictions about the development or adoption timeline of such LLMs. The projected effects span all wage levels, with higher-income jobs potentially facing greater exposure to LLM capabilities and LLM-powered software. Significantly, these impacts are not restricted to industries with higher recent productivity growth. Our analysis suggests that, with access to an LLM, about 15\% of all worker tasks in the US could be completed significantly faster at the same level of quality. When incorporating software and tooling built on top of LLMs, this share increases to between 47 and 56\% of all tasks. This finding implies that LLM-powered software will have a substantial effect on scaling the economic impacts of the underlying models. We conclude that LLMs such as GPTs exhibit traits of general-purpose technologies, indicating that they could have considerable economic, social, and policy implications.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computers and Society,Economics - General Economics},
  file = {/home/flaviomoura/Zotero/storage/8M7HLA7F/Eloundou et al. - 2023 - GPTs are GPTs An Early Look at the Labor Market I.pdf}
}

@book{endertonElementsSetTheory1977,
  title = {Elements of {{Set Theory}}},
  author = {Enderton, H.},
  year = {1977},
  publisher = {Academic Press},
  file = {/home/flaviomoura/Zotero/storage/48KE37X6/1977 - Elements of Set Theory.pdf}
}

@book{endertonMathematicalIntroductionLogic2001,
  title = {A {{Mathematical Introduction}} to {{Logic}}},
  author = {Enderton, H.B.},
  year = {2001},
  publisher = {Elsevier Science},
  isbn = {978-0-08-049646-7},
  lccn = {00110670},
  file = {/home/flaviomoura/Zotero/storage/ZSR3L8QM/Enderton - 2001 - A Mathematical Introduction to Logic.pdf}
}

@article{endrullisDecreasingDiagramsConfluence2019,
  title = {Decreasing {{Diagrams}} for {{Confluence}} and {{Commutation}}},
  author = {Endrullis, J{\"o}rg and Klop, Jan Willem and Overbeek, Roy},
  year = {2019},
  journal = {CoRR},
  abstract = {Like termination, confluence is a central property of rewrite systems. Unlike for termination, however, there exists no known complexity hierarchy for confluence. In this paper we investigate whether the decreasing diagrams technique can be used to obtain such a hierarchy. The decreasing diagrams technique is one of the strongest and most versatile methods for proving confluence of abstract rewrite systems. It is complete for countable systems, and it has many well-known confluence criteria as corollaries. So what makes decreasing diagrams so powerful? In contrast to other confluence techniques, decreasing diagrams employ a labelling of the steps with labels from a well-founded order in order to conclude confluence of the underlying unlabelled relation. Hence it is natural to ask how the size of the label set influences the strength of the technique. In particular, what class of abstract rewrite systems can be proven confluent using decreasing diagrams restricted to 1 label, 2 labels, 3 labels, and so on? Surprisingly, we find that two labels suffice for proving confluence for every abstract rewrite system having the cofinality property, thus in particular for every confluent, countable system. Secondly, we show that this result stands in sharp contrast to the situation for commutation of rewrite relations, where the hierarchy does not collapse. Thirdly, investigating the possibility of a confluence hierarchy, we determine the first-order (non-)definability of the notion of confluence and related properties, using techniques from finite model theory. We find that in particular Hanf's theorem is fruitful for elegant proofs of undefinability of properties of abstract rewrite systems.}
}

@book{engelProblemSolvingStrategies1998,
  title = {Problem-{{Solving Strategies}}},
  author = {Engel, A.},
  year = {1998},
  series = {Problem {{Books}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/b97682}
}

@article{englanderAnotherBijectionSequent2015,
  title = {Yet {{Another Bijection Between Sequent Calculus}} and {{Natural Deduction}}},
  author = {Englander, C. and Dowek, G. and Haeusler, E. H.},
  year = {2015},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {312},
  number = {nil},
  pages = {107--124},
  doi = {10.1016/j.entcs.2015.04.007},
  keywords = {Correspondence,Intuitionistic propositional logic,Natural Deduction,Proof Theory,Sequent Calculus},
  file = {/home/flaviomoura/Zotero/storage/TRQYVJWE/Englander et al. - 2015 - Yet Another Bijection Between Sequent Calculus and.pdf;/home/flaviomoura/Zotero/storage/3X7M7WFZ/S1571066115000110.html}
}

@book{englandJointProceedingsMathUI2014,
  title = {Joint {{Proceedings}} of the {{MathUI}}, {{OpenMath}} and {{ThEdu Workshops}} and {{Work}} in {{Progress}} Track at {{CICM}} Co-Located with {{Conferences}} on {{Intelligent Computer Mathematics}} ({{CICM}} 2014), {{Coimbra}}, {{Portugal}}, {{July}} 7-11, 2014},
  editor = {England, Matthew and Davenport, James H. and Kohlhase, Andrea and Kohlhase, Michael and Libbrecht, Paul and Neuper, Walther and Quaresma, Pedro and Sexton, Alan P. and Sojka, Petr and Urban, Josef and Watt, Stephen M.},
  year = {2014},
  series = {{{CEUR Workshop Proceedings}}},
  volume = {1186},
  publisher = {CEUR-WS.org}
}

@book{eppDiscreteMathematicsApplications2010,
  title = {Discrete {{Mathematics}} with {{Applications}}},
  author = {Epp, S. S.},
  year = {2010},
  edition = {4th},
  publisher = {Brooks/Cole Publishing Co.},
  address = {Pacific Grove, CA, USA},
  isbn = {0-495-39132-8 978-0-495-39132-6}
}

@book{epsteinSemanticFoundationsLogic1990,
  title = {The {{Semantic Foundations}} of {{Logic}}},
  author = {Epstein, R. L.},
  year = {1990},
  journal = {The Semantic Foundations of Logic Volume 1: Propositional Logics},
  series = {The {{Semantic Foundations}} of {{Logic Volume}} 1: {{Propositional Logics}}},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-94-009-0525-2_11}
}

@book{epsteinSemanticFoundationsLogic1990a,
  title = {The {{Semantic Foundations}} of {{Logic Volume}} 1: {{Propositional Logics}}},
  author = {Epstein, R. L.},
  year = {1990},
  series = {Nijhoff {{International Philosophy Series}} 35},
  edition = {1},
  publisher = {Springer Netherlands},
  isbn = {978-94-010-6722-5 978-94-009-0525-2 0-7923-0622-8}
}

@inproceedings{EPTCS328.1,
  title = {Teaching Interactive Proofs to Mathematicians},
  booktitle = {Proceedings 9th International Workshop on Theorem Proving Components for Educational Software, Paris, France, 29th June 2020},
  author = {{Ayala-Rinc{\'o}n}, Mauricio and {de Lima}, Thaynara Arielly},
  editor = {Quaresma, Pedro and Neuper, Walther and Marcos, Jo{\~a}o},
  year = {2020},
  series = {Electronic Proceedings in Theoretical Computer Science},
  volume = {328},
  pages = {1--17},
  publisher = {Open Publishing Association},
  doi = {10.4204/EPTCS.328.1}
}

@book{erciyesGuideGraphAlgorithms2018,
  title = {Guide to {{Graph Algorithms Sequential}}, {{Parallel}} and {{Distributed}}},
  author = {Erciyes, K.},
  year = {2018},
  series = {Texts in {{Computer Science}}},
  publisher = {Springer},
  isbn = {978-3-319-73235-0}
}

@book{ericksonAlgorithms2009,
  title = {Algorithms},
  author = {Erickson, Jeff},
  year = {2009}
}

@book{ertelIntroductionArtificialIntelligence2017,
  title = {Introduction to {{Artificial Intelligence}}},
  author = {Ertel, Wolfgang},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-58487-4}
}

@article{escardoIntroductionUnivalentFoundations2020,
  title = {Introduction to {{Univalent Foundations}} of {{Mathematics}} with {{Agda}}},
  author = {Escard{\'o}, Mart{\'i}n H{\"o}tzel},
  year = {2020},
  month = nov,
  journal = {arXiv:1911.00580 [cs, math]},
  eprint = {1911.00580},
  primaryclass = {cs, math},
  urldate = {2020-11-17},
  abstract = {We introduce Voevodsky's univalent foundations and univalent mathematics, and explain how to develop them with the computer system Agda, which is based on Martin-L{\textbackslash}"of type theory. Agda allows us to write mathematical definitions, constructions, theorems and proofs, for example in number theory, analysis, group theory, topology, category theory or programming language theory, checking them for logical and mathematical correctness. Agda is a constructive mathematical system by default, which amounts to saying that it can also be considered as a programming language for manipulating mathematical objects. But we can assume the axiom of choice or the principle of excluded middle for pieces of mathematics that require them, at the cost of losing the implicit programming-language character of the system. For a fully constructive development of univalent mathematics in Agda, we would need to use its new cubical flavour, and we hope these notes provide a base for researchers interested in learning cubical type theory and cubical Agda as the next step. Compared to most expositions of the subject, we work with explicit universe levels.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/5YW58G9F/EscardÃ³ - 2020 - Introduction to Univalent Foundations of Mathemati.pdf;/home/flaviomoura/Zotero/storage/9R3KCR4U/1911.html}
}

@misc{espejo-boixStudyActionsAtomic2024,
  title = {A {{Study}} on {{Actions}} for {{Atomic Logics}}},
  author = {{Espejo-Boix}, Ra{\"u}l},
  year = {2024},
  month = mar,
  number = {arXiv:2403.07948},
  eprint = {2403.07948},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2024-03-14},
  abstract = {Nowadays there is a large number of non-classical logics, each one best suited for reasoning about some issues in abstract fields, such as linguistics or epistemology, among others. Proving interesting properties for each one of them supposes a big workload for logicians and computer scientists. We want an approach into this problematic that is modular. To adress this issue, the report shows new insights in the construction of Atomic Logics introduced by Guillaume Aucher. Atomic Logics let us represent very general left and right introduction rules and they come along a new kind of rules based on display logics and residuation. A new approach is taken into the definition of Atomic Logics, which is now built on a class of actions for which we prove cut-elimination. We show that some of them are equivalent to Aucher's Atomic Logics and we prove cut-elimination and Craig Interpolation for a class of them. The introduced theory is applied to the non-associative Lambek Calculus throughout the report. It is accompanied by a computer-checked formalisation of the original syntax in the proof assistant Coq.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/Q45DAMGR/Espejo-Boix - 2024 - A Study on Actions for Atomic Logics.pdf;/home/flaviomoura/Zotero/storage/CA2SAGNM/2403.html}
}

@article{espiritosantoCurryHowardSequentCalculus2015,
  title = {Curry-{{Howard}} for {{Sequent Calculus}} at {{Last}}!},
  author = {Esp{\'i}rito Santo, Jos{\'e}},
  year = {2015},
  pages = {15 pages},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany},
  doi = {10.4230/LIPICS.TLCA.2015.165},
  urldate = {2023-11-17},
  abstract = {This paper tries to remove what seems to be the remaining stumbling blocks in the way to a full understanding of the Curry-Howard isomorphism for sequent calculus, namely the questions: What do variables in proof terms stand for? What is co-control and a co-continuation? How to define the dual of Parigot's mu-operator so that it is a co-control operator? Answering these questions leads to the interpretation that sequent calculus is a formal vector notation with first-class co-control. But this is just the "internal" interpretation, which has to be developed simultaneously with, and is justified by, an equivalent, "external" interpretation, offered by natural deduction: the sequent calculus corresponds to a bi-directional, agnostic (w.r.t. the call strategy), computational lambda-calculus. Next, the formal duality between control and co-control is studied, in the context of classical logic. The duality cannot be observed in the sequent calculus, but rather in a system unifying sequent calculus and natural deduction.},
  collaborator = {Herbstritt, Marc},
  langid = {english},
  keywords = {000 Computer science knowledge general works,Computer Science},
  file = {/home/flaviomoura/Zotero/storage/7T4GTTRJ/EspÃ­rito Santo - 2015 - Curry-Howard for Sequent Calculus at Last!.pdf}
}

@article{espiritosantoInhabitationSimplyTyped2019,
  title = {Inhabitation in Simply Typed Lambda-Calculus through a Lambda-Calculus for Proof Search},
  author = {Esp{\'i}rito Santo, Jos{\'e} and Matthes, Ralph and Pinto, Lu{\'i}s},
  year = {2019},
  month = sep,
  journal = {Mathematical Structures in Computer Science},
  volume = {29},
  number = {8},
  pages = {1092--1124},
  publisher = {Cambridge University Press (CUP)},
  doi = {10.1017/S0960129518000099},
  urldate = {2023-10-01},
  abstract = {A new approach to inhabitation problems in simply typed lambda-calculus is shown, dealing with both decision and counting problems. This approach works by exploiting a representation of the search space generated by a given inhabitation problem, which is in terms of a lambda-calculus for proof search that the authors developed recently. The representation may be seen as extending the Curry-Howard representation of proofs by lambda terms. Our methodology reveals inductive descriptions of the decision problems, driven by the syntax of the proof-search expressions, and produces simple, recursive decision procedures and counting functions. These allow to predict the number of inhabitants by testing the given type for syntactic criteria. This new approach is comprehensive and robust: based on the same syntactic representation, we also derive the state-of-the-art coherence theorems ensuring uniqueness of inhabitants.},
  file = {/home/flaviomoura/Zotero/storage/LXPD44CT/EspÃ­rito Santo et al. - 2019 - Inhabitation in simply typed lambda-calculus throu.pdf}
}

@article{faggianFactorizationCallbyNameCallbyValue2021,
  title = {Factorization in {{Call-by-Name}} and {{Call-by-Value Calculi}} via {{Linear Logic}} (Long Version)},
  author = {Faggian, Claudia and Guerrieri, Giulio},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.08364 [cs]},
  eprint = {2101.08364},
  primaryclass = {cs},
  urldate = {2021-01-26},
  abstract = {In each variant of the lambda-calculus, factorization and normalization are two key-properties that show how results are computed. Instead of proving factorization/normalization for the call-by-name (CbN) and call-by-value (CbV) variants separately, we prove them only once, for the bang calculus (an extension of the lambda-calculus inspired by linear logic and subsuming CbN and CbV), and then we transfer the result via translations, obtaining factorization/normalization for CbN and CbV. The approach is robust: it still holds when extending the calculi with operators and extra rules to model some additional computational features.},
  archiveprefix = {arXiv},
  keywords = {03B40 68N18 03B70,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/7VEDUQZ7/Faggian e Guerrieri - 2021 - Factorization in Call-by-Name and Call-by-Value Ca.pdf;/home/flaviomoura/Zotero/storage/AEZU897I/2101.html}
}

@misc{faggianReductionNormalizationComputational2022,
  title = {On Reduction and Normalization in the Computational Core},
  author = {Faggian, Claudia and Guerrieri, Giulio and {de'Liguoro}, Ugo and Treglia, Riccardo},
  year = {2022},
  month = jun,
  number = {arXiv:2104.10267},
  eprint = {2104.10267},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-06-13},
  abstract = {We study the reduction in a {$\lambda$}-calculus derived from Moggi's computational one, that we call the computational core. The reduction relation consists of rules obtained by orienting three monadic laws. Such laws, in particular associativity and identity, introduce intricacies in the operational analysis. We investigate the central notions of returning a value versus having a normal form, and address the question of normalizing strategies. Our analysis relies on factorization results.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {68N18,Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/QVGIEGMD/Faggian et al. - 2022 - On reduction and normalization in the computationa.pdf}
}

@misc{faggianRewritingTheoryQuantum2024,
  title = {A {{Rewriting Theory}} for {{Quantum Lambda-Calculus}}},
  author = {Faggian, Claudia and Lopez, Gaetan and Valiron, Beno{\^i}t},
  year = {2024},
  month = nov,
  number = {arXiv:2411.14856},
  eprint = {2411.14856},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2411.14856},
  urldate = {2024-11-29},
  abstract = {Quantum lambda calculus has been studied mainly as an idealized programming language -- the evaluation essentially corresponds to a deterministic abstract machine. Very little work has been done to develop a rewriting theory for quantum lambda calculus. Recent advances in the theory of probabilistic rewriting give us a way to tackle this task with tools unavailable a decade ago. Our primary focus is standardization and normalization results.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/JAQ87IFQ/Faggian et al. - 2024 - A Rewriting Theory for Quantum Lambda-Calculus.pdf;/home/flaviomoura/Zotero/storage/577Q5ETL/2411.html}
}

@inproceedings{fairweatherDependentTypesNominal2015,
  title = {Dependent {{Types}} for {{Nominal Terms}} with {{Atom Substitutions}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{TLCA}}.2015.180},
  author = {Fairweather, Elliot and Fern{\'a}ndez, Maribel and Szasz, Nora and Tasistro, Alvaro},
  year = {2015},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.TLCA.2015.180},
  urldate = {2024-04-23},
  abstract = {Nominal terms are an extended first-order language for specifying and verifying properties of syntax with binding. Founded upon the semantics of nominal sets, the success of nominal terms with regard to systems of equational reasoning is already well established. This work first extends the untyped language of nominal terms with a notion of non-capturing atom substitution for object-level names and then proposes a dependent type system for this extended language. Both these contributions are intended to serve as a prelude to a future nominal logical framework based upon nominal equational reasoning and thus an extended example is given to demonstrate that this system is capable of encoding various other formal systems of interest.},
  copyright = {https://creativecommons.org/licenses/by/3.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ILWFRZ23/Fairweather et al. - 2015 - Dependent Types for Nominal Terms with Atom Substi.pdf}
}

@article{farmerFormalMathematicsMasses,
  title = {Formal {{Mathematics}} for the {{Masses}}},
  author = {Farmer, William M},
  pages = {12},
  abstract = {The campaign to transform traditional mathematical practice into a formal discipline appears to have been a great success. Several sophisticated proof assistants have been developed, a great deal of mathematical knowledge has been formalized, a growing number of researchers in computing and mathematics are now using proof assistants to check the theorems they prove, and a new area of computing called formal methods has been established in which formal mathematics is used in the development of hardware and software. However, the campaign has largely been a failure when viewed from a broader perspective. It has had almost no impact on mathematical practice. Far less than 1\% of all mathematics practitioners have ever used a formal logic or a proof assistant in their work. We propose an alternative approach to formal mathematics that is characterized by (1) proofs are written in a traditional (informal) style, (2) the underlying logic is as close to mathematical practice as possible, (3) mathematics is organized in accordance with the little theories method as a theory graph, and (4) supporting software systems are easy to build and use. We are pursuing a research program called Formal Mathematics for the Masses to make formal mathematics more useful, accessible, and natural to a wider range of mathematics practitioners by implementing this alternative approach.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Y5BDVAKM/Farmer - Formal Mathematics for the Masses.pdf}
}

@book{farmerSimpleTypeTheory2023,
  title = {Simple {{Type Theory}}: {{A Practical Logic}} for {{Expressing}} and {{Reasoning About Mathematical Ideas}}},
  shorttitle = {Simple {{Type Theory}}},
  author = {Farmer, William M.},
  year = {2023},
  series = {Computer {{Science Foundations}} and {{Applied Logic}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-031-21112-6},
  urldate = {2023-08-25},
  isbn = {978-3-031-21111-9 978-3-031-21112-6},
  langid = {english}
}

@book{fefermanTrotskyGodelLife2000,
  title = {From {{Trotsky}} to {{G{\"o}del}}: {{The Life}} of {{Jean}} van {{Heijenoort}}},
  author = {Feferman, Anita Burdman},
  year = {2000},
  edition = {1},
  publisher = {A K Peters/CRC Press},
  isbn = {1-56881-148-9 978-1-56881-148-2}
}

@article{felgenhauerProperty2016,
  title = {The {{Z Property}}},
  author = {Felgenhauer, B. and Nagele, J. and van Oostrom, V. and Sternagel, C.},
  year = {2016},
  journal = {Archive of Formal Proofs},
  volume = {2016}
}

@article{felicissimoRepresentingAgdaCoinduction,
  title = {Representing {{Agda}} and Coinduction in the {{$\lambda\Pi$-calculus}} modulo Rewriting},
  author = {Felicissimo, Thiago},
  pages = {29},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HDHV6AMS/Felicissimo - Representing Agda and coinduction in the Î»Î -calcul.pdf}
}

@misc{felicissimoSharingProofsPredicative2023,
  title = {Sharing Proofs with Predicative Theories through Universe Polymorphic Elaboration},
  author = {Felicissimo, Thiago and Blanqui, Fr{\'e}d{\'e}ric},
  year = {2023},
  month = aug,
  number = {arXiv:2308.15465},
  eprint = {2308.15465},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-08-30},
  abstract = {As the development of formal proofs is a time-consuming task, it is important to devise ways of sharing the already written proofs to prevent wasting time redoing them. One of the challenges in this domain is to translate proofs written in proof assistants based on impredicative logics to proof assistants based on predicative logics, whenever impredicativity is not used in an essential way. In this paper we present a transformation for sharing proofs with a core predicative system supporting prenex universe polymorphism (like in Agda). It consists in trying to elaborate a potentially impredicative term into a predicative universe polymorphic term as general as possible. The use of universe polymorphism is justified by the fact that mapping each universe to a fixed one in the target theory is not sufficient in most cases. During the algorithm, we need to solve unification problems in the equational theory of universe levels. In order to do this, we give a complete characterization of when a single equation admits a most general unifier. This characterization is then employed in an algorithm which uses a constraint-postponement strategy to solve unification problems. The proposed translation is of course partial, but in practice allows one to translate many proofs that do not use impredicativity in an essential way. Indeed, it was implemented in the tool Predicativize and then used to translate semi-automatically many non-trivial developments from Matita's arithmetic library to Agda, including proofs of Bertrand's Postulate and Fermat's Little Theorem, which (as far as we know) were not available in Agda yet.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/GPQLQRVC/Felicissimo e Blanqui - 2023 - Sharing proofs with predicative theories through u.pdf;/home/flaviomoura/Zotero/storage/VYLZM6ZN/2308.html}
}

@article{fellinGlivenkoSequentClasses2023,
  title = {Glivenko Sequent Classes and Constructive Cut Elimination in Geometric Logics},
  author = {Fellin, Giulio and Negri, Sara and Orlandelli, Eugenio},
  year = {2023},
  month = jul,
  journal = {Archive for Mathematical Logic},
  volume = {62},
  number = {5},
  pages = {657--688},
  issn = {1432-0665},
  doi = {10.1007/s00153-022-00857-z},
  urldate = {2024-08-12},
  abstract = {A constructivisation of the cut-elimination proof for sequent calculi for classical, intuitionistic and minimal infinitary logics with geometric rules---given in earlier work by the second author---is presented. This is achieved through a procedure where the non-constructive transfinite induction on the commutative sum of ordinals is replaced by two instances of Brouwer's Bar Induction. The proof of admissibility of the structural rules is made ordinal-free by introducing a new well-founded relation based on a notion of embeddability of derivations. Additionally, conservativity for classical over intuitionistic/minimal logic for the seven (finitary) Glivenko sequent classes is here shown to hold also for the corresponding infinitary classes.},
  langid = {english},
  keywords = {03B20,03F05,18B15,18C10,Conservativity,Constructive cut elimination,Geometric theories,Glivenko sequent classes,Infinitary logic}
}

@book{feltyAutomatedDeductionCADE252015,
  title = {Automated {{Deduction}} - {{CADE-25}} - 25th {{International Conference}} on {{Automated Deduction}}, {{Berlin}}, {{Germany}}, {{August}} 1-7, 2015, {{Proceedings}}},
  editor = {Felty, Amy P. and Middeldorp, Aart},
  year = {2015},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {9195},
  publisher = {Springer},
  doi = {10.1007/978-3-319-21401-6},
  isbn = {978-3-319-21400-9}
}

@article{feltyBenchmarksReasoningSyntax2018,
  title = {Benchmarks for Reasoning with Syntax Trees Containing Binders and Contexts of Assumptions},
  author = {Felty, Amy and Momigliano, Alberto and Pientka, Brigitte},
  year = {2018},
  month = oct,
  journal = {Mathematical Structures in Computer Science},
  volume = {28},
  number = {9},
  pages = {1507--1540},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129517000093},
  urldate = {2024-02-19},
  abstract = {A variety of logical frameworks supports the use of higher order abstract syntax in representing formal systems. Although these systems seem superficially the same, they differ in a variety of ways, for example, how they handle a context of assumptions and which theorems about a given formal system can be concisely expressed and proved. Our contributions in this paper are two-fold: (1) We develop a common infrastructure and language for describing benchmarks for systems supporting reasoning with binders, and (2) we present several concrete benchmarks, which highlight a variety of different aspects of reasoning within a context of assumptions. Our work provides the background for the qualitative comparison of different systems that we have completed in a separate paper. It also allows us to outline future fundamental research questions regarding the design and implementation of meta-reasoning systems.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IUPP2HZ4/Felty et al. - 2018 - Benchmarks for reasoning with syntax trees contain.pdf}
}

@misc{fereeMechanisedUniformInterpolation2024,
  title = {Mechanised Uniform Interpolation for Modal Logics {{K}}, {{GL}} and {{iSL}}},
  author = {F{\'e}r{\'e}e, Hugo and {van der Giessen}, Iris and {van Gool}, Sam and Shillito, Ian},
  year = {2024},
  month = feb,
  number = {arXiv:2402.10494},
  eprint = {2402.10494},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2024-03-14},
  abstract = {The uniform interpolation property in a given logic can be understood as the definability of propositional quantifiers. We mechanise the computation of these quantifiers and prove correctness in the Coq proof assistant for three modal logics, namely: (1) the modal logic K, for which a pen-and-paper proof exists; (2) G{\textbackslash}"odel-L{\textbackslash}"ob logic GL, for which our formalisation clarifies an important point in an existing, but incomplete, sequent-style proof; and (3) intuitionistic strong L{\textbackslash}"ob logic iSL, for which this is the first proof-theoretic construction of uniform interpolants. Our work also yields verified programs that allow one to compute the propositional quantifiers on any formula in this logic.},
  archiveprefix = {arXiv},
  keywords = {03B45 03B20 03F45 68V20,Computer Science - Logic in Computer Science,F.4.1,I.2.3,I.2.4,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/P76VJFDN/FÃ©rÃ©e et al. - 2024 - Mechanised uniform interpolation for modal logics .pdf;/home/flaviomoura/Zotero/storage/2EVX2LP4/2402.html}
}

@inproceedings{fernandesFormaFuncaoDos2024,
  title = {{A forma e a fun{\c c}{\~a}o dos laborat{\'o}rios de computa{\c c}{\~a}o nas escolas de educa{\c c}{\~a}o b{\'a}sica: plataformas para uma revolu{\c c}{\~a}o contra-hegem{\^o}nica?}},
  shorttitle = {{A forma e a fun{\c c}{\~a}o dos laborat{\'o}rios de computa{\c c}{\~a}o nas escolas de educa{\c c}{\~a}o b{\'a}sica}},
  booktitle = {{Simp{\'o}sio Brasileiro de Educa{\c c}{\~a}o em Computa{\c c}{\~a}o (EDUCOMP)}},
  author = {Fernandes, Jorge Henrique Cabral},
  year = {2024},
  month = apr,
  pages = {384--394},
  publisher = {SBC},
  issn = {0000-0000},
  doi = {10.5753/educomp.2024.237547},
  urldate = {2024-04-29},
  abstract = {O ensaio discute sobre a forma e fun{\c c}{\~a}o dos laborat{\'o}rios de computa{\c c}{\~a}o nas escolas de educa{\c c}{\~a}o b{\'a}sica do Brasil. Apoiado por pesquisas bibliogr{\'a}ficas predominantemente feitas na base de dadosWeb of Science s{\~a}o tra{\c c}adas cr{\'i}ticas aos argumentos contr{\'a}rios e favor{\'a}veis aos Laborat{\'o}rios e ao acesso {\`a} Internet nas escolas, tendo em vista os fundamentos da Computa{\c c}{\~a}o e Tecnologias Digitais de Informa{\c c}{\~a}o e Comunica{\c c}{\~a}o - TDICs, o hist{\'o}rico dos projetos de informatiza{\c c}{\~a}o de escolas no Brasil e no Mundo, e a BNCC da Computa{\c c}{\~a}o. O arcabou{\c c}o metodol{\'o}gico da Ci{\^e}ncia do Projeto (Design Science) {\'e} brevemente adotado para uso de abordagens indutivas, dedutivas e abdutivas, culminando com a proposi{\c c}{\~a}o de fun{\c c}{\~o}es e princ{\'i}pios estruturais que devem estar presentes nos Laborat{\'o}rios, a prescri{\c c}{\~a}o dos efeitos poss{\'i}veis de serem gerados por essas interven{\c c}{\~o}es tecnol{\'o}gicas, seja sobre os curr{\'i}culos de forma{\c c}{\~a}o docente, sobre a carreira e identidade docentes, bem como sobre o papel da escola na promo{\c c}{\~a}o da literacia e de servi{\c c}os digitais junto {\`a}s comunidades e territ{\'o}rios. {\'E} correto propagar uma suposta neutralidade do conhecimento computacional que transmitimos e que gera tanto impacto social, ou precisamos ser revolucion{\'a}rios?},
  copyright = {Copyright (c)},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/9D62P33I/Fernandes - 2024 - A forma e a funÃ§Ã£o dos laboratÃ³rios de computaÃ§Ã£o .pdf}
}

@inproceedings{fernandezNominalRewritingSystems2004,
  title = {Nominal Rewriting Systems},
  booktitle = {Proceedings of the 6th {{ACM SIGPLAN}} International Conference on {{Principles}} and Practice of Declarative Programming  - {{PPDP}} '04},
  author = {Fern{\'a}ndez, Maribel and Gabbay, Murdoch J. and Mackie, Ian},
  year = {2004},
  pages = {108--119},
  publisher = {ACM Press},
  address = {Verona, Italy},
  doi = {10.1145/1013963.1013978},
  urldate = {2021-07-22},
  isbn = {978-1-58113-819-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NGRL434T/FernÃ¡ndez et al. - 2004 - Nominal rewriting systems.pdf}
}

@book{fernandezProgrammingLanguagesOperational2014,
  title = {Programming {{Languages}} and {{Operational Semantics}}},
  author = {Fern{\'a}ndez, Maribel},
  year = {2014},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-6368-8}
}

@book{ferreiraElementosLogicaMatematica2001,
  title = {Elementos de {{L{\'o}gica Matem{\'a}tica}} e {{Teoria}} Dos {{Conjuntos}}},
  author = {Ferreira, J. C.},
  year = {2001},
  address = {Departamento de Matem{\'a}tica},
  annotation = {Published: Instituto Superior T{\'e}cnico}
}

@inproceedings{ferreiraLambdaCalculiExplicitSubstitutions1996,
  title = {Lambda-{{Calculi}} with {{Explicit Substitutions}} and {{Composition}} Which {{Preserve Beta-Strong Normalisation}}},
  booktitle = {Algebraic and {{Logic Programming}}, {{ALP}}'96},
  author = {Ferreira, M. C. F. and Kesner, D. and Puel, L.},
  year = {1996},
  series = {{{LNCS}}},
  volume = {1139},
  pages = {284--298},
  publisher = {Springer}
}

@misc{ferreiraVariousTranslationsClassical2024,
  title = {On the {{Various Translations}} between {{Classical}}, {{Intuitionistic}} and {{Linear Logic}}},
  author = {Ferreira, Gilda and Oliva, Paulo and Protin, Clarence Lewis},
  year = {2024},
  month = sep,
  journal = {arXiv.org},
  urldate = {2024-09-05},
  abstract = {Several different proof translations exist between classical and intuitionistic logic (negative translations), and intuitionistic and linear logic (Girard translations). Our aims in this paper are (1) to show that all these systems can be expressed as extensions of a basic logical system (essentially intuitionistic linear logic), and that (2) with this common logical basis, a common approach to devising and simplifying such proof translations can be formalised. Via this process of ``simplification'' we get the most well-known translations in the literature.},
  howpublished = {https://arxiv.org/abs/2409.02249v1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HLGKZJHV/Ferreira et al. - 2024 - On the Various Translations between Classical, Int.pdf}
}

@article{fervari2021verification,
  title = {Verification of Dynamic Bisimulation Theorems in {{Coq}}},
  author = {Fervari, Raul and Trucco, Francisco and Ziliani, Beta},
  year = {2021},
  journal = {Journal of Logical and Algebraic Methods in Programming},
  pages = {100642},
  publisher = {Elsevier}
}

@techreport{filliatreFiniteAutomataTheory1997,
  type = {Research {{Report}}},
  title = {Finite {{Automata Theory}} in {{Coq}}: {{A}} Constructive Proof of {{Kleene}}'s Theorem},
  author = {Filli{\^a}tre, J.-C.},
  year = {1997},
  month = feb,
  number = {97--04},
  institution = {LIP - ENS Lyon},
  abstract = {We describe here a development in the system Coq of a piece of Finite Automata Theory. The main result is the Kleene's theorem, expressing that regular expressions and finite automata define the same languages. From a constructive proof of this result, we automatically obtain a functional program that compiles any regular expression into a finite automata, which constitutes the main part of the implementation of {\textbackslash}tt grep-like programs. This functional program is obtained by the automatic method of {\textbackslash}em extraction which removes the logical parts of the proof to keep only its informative contents. Starting with an idea of what we would have written in ML, we write the specification and do the proofs in such a way that we obtain the expected program, which is therefore efficient.}
}

@book{filliatreTypesProofsPrograms2006,
  title = {Types for {{Proofs}} and {{Programs}}, {{International Workshop}}, {{TYPES}} 2004, {{Jouy-en-Josas}}, {{France}}, {{December}} 15-18, 2004, {{Revised Selected Papers}}},
  editor = {Filli{\^a}tre, Jean-Christophe and {Paulin-Mohring}, Christine and Werner, Benjamin},
  year = {2006},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {3839},
  publisher = {Springer},
  isbn = {3-540-31428-8}
}

@inproceedings{finsterTypesAreInternal2021,
  title = {Types {{Are Internal}} {$\infty$}-{{Groupoids}}},
  booktitle = {2021 36th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}})},
  author = {Finster, Eric and Allioux, Antoine and Sozeau, Matthieu},
  year = {2021},
  month = jun,
  pages = {1--13},
  publisher = {IEEE},
  address = {Rome, Italy},
  doi = {10.1109/LICS52264.2021.9470541},
  urldate = {2021-09-18},
  abstract = {By extending type theory with a universe of definitionally associative and unital polynomial monads, we show how to arrive at a definition of opetopic type which is able to encode a number of fully coherent algebraic structures. In particular, our approach leads to a definition of {$\infty$}-groupoid internal to type theory and we prove that the type of such {$\infty$}-groupoids is equivalent to the universe of types. That is, every type admits the structure of an {$\infty$}-groupoid internally, and this structure is unique.},
  isbn = {978-1-66544-895-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/P9WMQB8Y/Finster et al. - 2021 - Types Are Internal â-Groupoids.pdf}
}

@book{fioreDenotationalSemantics2016,
  title = {Denotational {{Semantics}}},
  author = {Fiore, M.},
  year = {2016}
}

@article{fioreFormalMetatheorySecondOrder,
  title = {Formal {{Metatheory}} of {{Second-Order Abstract Syntax}}},
  author = {Fiore, Marcelo and Szamozvancev, Dmitrij},
  pages = {29},
  abstract = {MARCELO FIORE{$\ast$} and DMITRIJ SZAMOZVANCEV{\dag}, University of Cambridge, UK Despite extensive research both on the theoretical and practical fronts, formalising, reasoning about, and implementing languages with variable binding is still a daunting endeavour -- repetitive boilerplate and the overly complicated metatheory of capture-avoiding substitution often get in the way of progressing on to the actually interesting properties of a language. Existing developments offer some relief, however at the expense of inconvenient and error-prone term encodings and lack of formal foundations. We present a mathematically-inspired language-formalisation framework implemented in Agda. The system translates the description of a syntax signature with variable-binding operators into an intrinsicallyencoded, inductive data type equipped with syntactic operations such as weakening and substitution, along with their correctness properties. The generated metatheory further incorporates metavariables and their associated operation of metasubstitution, which enables second-order equational/rewriting reasoning. The underlying mathematical foundation of the framework -- initial algebra semantics -- derives compositional interpretations of languages into their models satisfying the semantic substitution lemma by construction. CCS Concepts: {$\bullet$} Software and its engineering {$\rightarrow$} Formal software verification; Functional languages; {$\bullet$} Theory of computation {$\rightarrow$} Type theory; Equational logic and rewriting.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/V3EV9MIH/Fiore e Szamozvancev - Formal Metatheory of Second-Order Abstract Syntax.pdf}
}

@article{fioreQuotientsInductiveTypes2021,
  title = {Quotients, Inductive Types, and Quotient Inductive Types},
  author = {Fiore, Marcelo P. and Pitts, Andrew M. and Steenkamp, S. C.},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.02994 [cs]},
  eprint = {2101.02994},
  primaryclass = {cs},
  urldate = {2021-01-11},
  abstract = {This paper introduces an expressive class of indexed quotient-inductive types, called QWI types, within the framework of constructive type theory. They are initial algebras for indexed families of equational theories with possibly infinitary operators and equations. We prove that QWI types can be derived from quotient types and inductive types in the type theory of toposes with natural number object and universes, provided those universes satisfy the Weakly Initial Set of Covers (WISC) axiom. We do so by constructing QWI types as colimits of a family of approximations to them defined by well-founded recursion over a suitable notion of size, whose definition involves the WISC axiom. We developed the proof and checked it using the Agda theorem prover.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/PB996AGH/Fiore et al. - 2021 - Quotients, inductive types, and quotient inductive.pdf;/home/flaviomoura/Zotero/storage/YMXTQMRE/2101.html}
}

@misc{fioreSemanticAnalysisNormalisation2022,
  title = {Semantic {{Analysis}} of {{Normalisation}} by {{Evaluation}} for {{Typed Lambda Calculus}}},
  author = {Fiore, Marcelo},
  year = {2022},
  month = jul,
  number = {arXiv:2207.08777},
  eprint = {2207.08777},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {This paper studies normalisation by evaluation for typed lambda calculus from a categorical and algebraic viewpoint. The first part of the paper analyses the lambda definability result of Jung and Tiuryn via Kripke logical relations and shows how it can be adapted to unify definability and normalisation, yielding an extensional normalisation result. In the second part of the paper the analysis is refined further by considering intensional Kripke relations (in the form of Artin glueing) and shown to provide a function for normalising terms, casting normalisation by evaluation in the context of categorical glueing. The technical development includes an algebraic treatment of the syntax and semantics of the typed lambda calculus that allows the definition of the normalisation function to be given within a simply typed metatheory. A normalisation-by-evaluation program in a dependently-typed functional programming language is synthesised.},
  archiveprefix = {arXiv},
  keywords = {03B40 03B38 68N18,Computer Science - Logic in Computer Science,F.3.2,F.4.1,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/LJJWEDWQ/Fiore - 2022 - Semantic Analysis of Normalisation by Evaluation f.pdf;/home/flaviomoura/Zotero/storage/2FCXSD4F/2207.html}
}

@inproceedings{firsovCertifiedNormalizationContextFree2015,
  title = {Certified {{Normalization}} of {{Context-Free Grammars}}},
  booktitle = {Proceedings of the 2015 {{Conference}} on {{Certified Programs}} and {{Proofs}}, {{CPP}} 2015, {{Mumbai}}, {{India}}, {{January}} 15-17, 2015},
  author = {Firsov, D. and Uustalu, T.},
  year = {2015},
  pages = {167--174},
  doi = {10.1145/2676724.2693177}
}

@article{fissoreHigherOrderUnificationFree2017,
  title = {Higher-{{Order}} Unification for Free!},
  author = {Fissore, Davide and Tassi, Enrico},
  year = {2017},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/X5URQFNZ/Fissore e Tassi - 2017 - Higher-Order unification for free!.pdf}
}

@book{fittingRaymondSmullyanSelf2017,
  title = {Raymond {{Smullyan}} on {{Self Reference}}},
  author = {Fitting, Melvin and Rayman, Brian},
  year = {2017},
  publisher = {Springer},
  file = {/home/flaviomoura/Zotero/storage/33S67GF7/Fitting and Rayman - 2017 - Raymond Smullyan on Self Reference.pdf}
}

@misc{flachNeuralLambdaCalculus2023,
  title = {A {{Neural Lambda Calculus}}: {{Neurosymbolic AI}} Meets the Foundations of Computing and Functional Programming},
  shorttitle = {A {{Neural Lambda Calculus}}},
  author = {Flach, Jo{\~a}o and Lamb, Luis C.},
  year = {2023},
  month = apr,
  number = {arXiv:2304.09276},
  eprint = {2304.09276},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-20},
  abstract = {Over the last decades, deep neural networks based-models became the dominant paradigm in machine learning. Further, the use of artificial neural networks in symbolic learning has been seen as increasingly relevant recently. To study the capabilities of neural networks in the symbolic AI domain, researchers have explored the ability of deep neural networks to learn mathematical constructions, such as addition and multiplication, logic inference, such as theorem provers, and even the execution of computer programs. The latter is known to be too complex a task for neural networks. Therefore, the results were not always successful, and often required the introduction of biased elements in the learning process, in addition to restricting the scope of possible programs to be executed. In this work, we will analyze the ability of neural networks to learn how to execute programs as a whole. To do so, we propose a different approach. Instead of using an imperative programming language, with complex structures, we use the Lambda Calculus ({$\lambda$}-Calculus), a simple, but Turing-Complete mathematical formalism, which serves as the basis for modern functional programming languages and is at the heart of computability theory. We will introduce the use of integrated neural learning and lambda calculi formalization. Finally, we explore execution of a program in {$\lambda$}-Calculus is based on reductions, we will show that it is enough to learn how to perform these reductions so that we can execute any program.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computation and Language,Computer Science - Logic in Computer Science,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/JSJ2GPE2/Flach e Lamb - 2023 - A Neural Lambda Calculus Neurosymbolic AI meets t.pdf}
}

@misc{flatenUnivalentCategoriesModules2022,
  title = {Univalent Categories of Modules},
  author = {Flaten, Jarl G. Taxer{\aa}s},
  year = {2022},
  month = jul,
  number = {arXiv:2207.03261},
  eprint = {2207.03261},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2022-07-08},
  abstract = {We show that categories of modules over a ring in Homotopy Type Theory (HoTT) satisfy the internal versions of the AB axioms from homological algebra. The main subtlety lies in proving AB4, which is that coproducts indexed by arbitrary sets are left-exact. To prove this, we replace a set with its strict category of (ordered) finite sub-multisets. From showing that the latter is filtered, we deduce left-exactness of the coproduct. More generally, we show that exactness of filtered colimits (AB5) implies AB4 for any abelian category in HoTT. Our approach is heavily inspired by Roswitha Harting's construction of the internal coproduct of abelian groups in an elementary topos with a natural numbers object [Har82].},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {18E10 (Primary) 03B38 18D40 18N50 18N60 (Secondary),Mathematics - Algebraic Topology,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/DMN8FWBJ/Flaten - 2022 - Univalent categories of modules.pdf}
}

@article{fleuriotSocialNetworkProcesses2016,
  title = {Social {{Network Processes}} in the {{Isabelle}} and {{Coq Theorem Proving Communities}}},
  author = {Fleuriot, J. and Obua, S. and Scott, P.},
  year = {2016},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Social and Information Networks,Physics - Physics and Society}
}

@inproceedings{fmm2021,
  title = {A Formalization of the (Compositional) z Property},
  booktitle = {Fifth Workshop on Formal Mathematics for Mathematicians},
  author = {{de Moura}, Fl{\'a}vio L. C. and Rezende, Leandro O.},
  year = {2021},
  file = {/home/flaviomoura/Zotero/storage/ATFRYMDF/de Moura e Rezende - 2021 - A formalization of the (compositional) z property.pdf}
}

@inproceedings{fontaineAnalyseFormelleCoq2013,
  title = {Une {{Analyse Formelle}} En {{Coq}} d'un {{Algorithme Distribu}}{\textbackslash}'e {{Probabiliste}} R{\textbackslash}'esolvant Le {{Probl{\`e}me}} Du {{Rendez-Vous}}},
  booktitle = {{{JFLA}} -- {{Journ}}{\textbackslash}'ees Francophones Des Langages Applicatifs},
  author = {Fontaine, A. and Zemmari, A.},
  editor = {Pous, Damien and Tasson, Christine},
  year = {2013},
  month = feb,
  publisher = {{Damien Pous and Christine Tasson}},
  address = {Aussois, France},
  keywords = {Algorithme distribu\'e probabiliste,Coq,Rendez-vous}
}

@phdthesis{fontaineAnalysesPreuvesFormelles2016,
  title = {Analyses et {{Preuves Formelles}} d'{{Algorithmes Distribu{\'e}s Probabilistes}}},
  author = {Fontaine, A.},
  year = {2016},
  school = {Universit{\'e} de Bordeaux}
}

@unpublished{fontaineCerifiedImpossibilityResults2016,
  title = {Cerified {{Impossibility Results}} and {{Analyses}} in {{Coq}} of Some {{Randomised Distributed Algorithms}}},
  author = {Fontaine, A. and Zemmari, A.},
  year = {2016}
}

@book{fontaineDocumentationRDALibrary2014,
  title = {Documentation of {{RDA Library}}},
  author = {Fontaine, A. and Zemmari, A.},
  year = {2014}
}

@inproceedings{fontaineFaultTolerantHandshakeAlgorithm2016,
  title = {A {{Fault-Tolerant Handshake Algorithm}} for {{Local Computations}}},
  booktitle = {{{IEE AINA}} 2016 {{Workshop}} -- {{The}} 30th {{IEEE International Conference}} on {{Advanced Information Networking}} and {{Applications}}, {{Le R{\'e}gent Congress Centre}}, {{Crans-Montana}}, {{Switzerland}}, {{March}} 23 -- 25, 2016},
  author = {Fontaine, A. and Mosbah, M. and Tounsi, M. and Zemmari, A.},
  year = {2016}
}

@book{FormalMethodsComputer2008,
  title = {Formal {{Methods}} in {{Computer Science Education}} - {{FORMED}}'08},
  year = {2008}
}

@inproceedings{forsterCallbypushvalueCoqOperational2019,
  title = {Call-by-Push-Value in {{Coq}}: Operational, Equational, and Denotational Theory},
  shorttitle = {Call-by-Push-Value in {{Coq}}},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Forster, Yannick and Sch{\"a}fer, Steven and Spies, Simon and Stark, Kathrin},
  year = {2019},
  month = jan,
  pages = {118--131},
  publisher = {ACM},
  address = {Cascais Portugal},
  doi = {10.1145/3293880.3294097},
  urldate = {2023-03-07},
  isbn = {978-1-4503-6222-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/6TE2YKZ2/Forster et al. - 2019 - Call-by-push-value in Coq operational, equational.pdf}
}

@article{forsterCallbyValueLambdaCalculus2019,
  title = {Call-by-{{Value Lambda Calculus}} as a {{Model}} of {{Computation}} in {{Coq}}},
  author = {Forster, Yannick and Smolka, Gert},
  year = {2019},
  month = aug,
  journal = {Journal of Automated Reasoning},
  volume = {63},
  number = {2},
  pages = {393--413},
  issn = {1573-0670},
  doi = {10.1007/s10817-018-9484-2},
  urldate = {2024-06-14},
  abstract = {We formalise a (weak) call-by-value \$\${\textbackslash}lambda \$\$-calculus we call L in the constructive type theory of Coq and study it as a minimal functional programming language and as a model of computation. We show key results including (1) semantic properties of procedures are undecidable, (2) the class of total procedures is not recognisable, (3) a class is decidable if it is recognisable, corecognisable, and logically decidable, and (4) a class is recognisable if and only if it is enumerable. Most of the results require a step-indexed self-interpreter. All results are verified formally and constructively, which is the challenge of the project. The verification techniques we use for procedures will apply to call-by-value functional programming languages formalised in Coq in general.},
  langid = {english},
  keywords = {Computability theory,Coq,Lambda calculus,Type theory}
}

@article{forsterChurchThesisRelated2020,
  ids = {forsterChurchThesisRelated2020a},
  title = {Church's Thesis and Related Axioms in {{Coq}}'s Type Theory},
  author = {Forster, Yannick},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.00416 [cs]},
  eprint = {2009.00416},
  primaryclass = {cs},
  urldate = {2020-09-05},
  abstract = {"Church's thesis" (\${\textbackslash}mathsf\{CT\}\$) as an axiom in constructive logic states that every total function of type \${\textbackslash}mathbb\{N\} {\textbackslash}to {\textbackslash}mathbb\{N\}\$ is computable, i.e. definable in a model of computation. \${\textbackslash}mathsf\{CT\}\$ is inconsistent in both classical mathematics and in Brouwer's intuitionism since it contradicts Weak K{\textbackslash}"onig's Lemma and the fan theorem, respectively. Recently, \${\textbackslash}mathsf\{CT\}\$ was proved consistent for (univalent) constructive type theory. Since neither Weak K{\textbackslash}"onig's Lemma nor the fan theorem are a consequence of just logical axioms or just choice-like axioms assumed in constructive logic, it seems likely that \${\textbackslash}mathsf\{CT\}\$ is only inconsistent with a combination of classical logic and choice axioms. We study consequences of \${\textbackslash}mathsf\{CT\}\$ and its relation to several classes of axioms in Coq's type theory, a constructive type theory with a universe of propositions which does neither prove classical logical axioms nor strong choice axioms. We thereby provide a partial answer to the question which axioms may preserve computational intuitions inherent to type theory, and which certainly do not. The paper can also be read as a broad survey of axioms in type theory, with all results mechanised in the Coq proof assistant.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/AN77BAPX/Forster - 2020 - Church's thesis and related axioms in Coq's type t.pdf;/home/flaviomoura/Zotero/storage/Y9F3RQF8/Forster - 2020 - Church's thesis and related axioms in Coq's type t.pdf;/home/flaviomoura/Zotero/storage/N995PK3E/2009.html;/home/flaviomoura/Zotero/storage/XTYJBEIJ/2009.html}
}

@article{forsterCompletenessTheoremsFirstOrder2020,
  title = {Completeness {{Theorems}} for {{First-Order Logic Analysed}} in {{Constructive Type Theory}} ({{Extended Version}})},
  author = {Forster, Yannick and Kirst, Dominik and Wehr, Dominik},
  year = {2020},
  journal = {CoRR},
  abstract = {We study various formulations of the completeness of first-order logic phrased in constructive type theory and mechanised in the Coq proof assistant. Specifically, we examine the completeness of variants of classical and intuitionistic natural deduction and sequent calculi with respect to model-theoretic, algebraic, and game-theoretic semantics. As completeness with respect to the standard model-theoretic semantics {\`a} la Tarski and Kripke is not readily constructive, we analyse connections of completeness theorems to Markov's Principle and Weak K{\"o}nig's Lemma and discuss non-standard semantics admitting assumption-free completeness. We contribute a reusable Coq library for first-order logic containing all results covered in this paper.}
}

@inproceedings{forsterComputationalCantorBernsteinMyhill2023,
  title = {A {{Computational Cantor-Bernstein}} and {{Myhill}}'s {{Isomorphism Theorem}} in {{Constructive Type Theory}} ({{Proof Pearl}})},
  booktitle = {Proceedings of the 12th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Forster, Yannick and Jahn, Felix and Smolka, Gert},
  year = {2023},
  month = jan,
  series = {{{CPP}} 2023},
  pages = {159--166},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3573105.3575690},
  urldate = {2024-06-14},
  abstract = {The Cantor-Bernstein theorem (CB) from set theory, stating that two sets which can be injectively embedded into each other are in bijection, is inherently classical in its full generality, i.e. implies the law of excluded middle, a result due to Pradic and Brown. Recently, Escard{\'o} has provided a proof of CB in univalent type theory, assuming the law of excluded middle. It is a natural question to ask which restrictions of CB can be proved without axiomatic assumptions. We give a partial answer to this question contributing an assumption-free proof of CB restricted to enumerable discrete types, i.e. types which can be computationally treated. In fact, we construct several bijections from injections: The first is by translating a proof of the Myhill isomorphism theorem from computability theory -- stating that 1-equivalent predicates are recursively isomorphic -- to constructive type theory, where the bijection is constructed in stages and an algorithm with an intricate termination argument is used to extend the bijection in every step. The second is also constructed in stages, but with a simpler extension algorithm sufficient for CB. The third is constructed directly in such a way that it only relies on the given enumerations of the types, not on the given injections. We aim at keeping the explanations simple, accessible, and concise in the style of a ``proof pearl''. All proofs are machine-checked in Coq but should transport to other foundations -- they do not rely on impredicativity, on choice principles, or on large eliminations.},
  isbn = {9798400700262},
  keywords = {computability theory,constructive logic,constructive mathematics,Coq,type theory},
  file = {/home/flaviomoura/Zotero/storage/28SP3QQH/Forster et al. - 2023 - A Computational Cantor-Bernstein and Myhillâs Isom.pdf}
}

@inproceedings{forsterCoqCartePractical2020,
  title = {Coq {\`a} La Carte: A Practical Approach to Modular Syntax with Binders},
  booktitle = {Proceedings of the 9th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Forster, Yannick and Stark, Kathrin},
  year = {2020},
  month = jan,
  pages = {nil},
  doi = {10.1145/3372885.3373817}
}

@article{forsterKleenePostPostTheorem2024a,
  title = {The {{Kleene-Post}} and {{Post}}'s {{Theorem}} in the {{Calculus}} of {{Inductive Constructions}}},
  author = {Forster, Yannick and Kirst, Dominik and M{\"u}ck, Niklas},
  year = {2024},
  pages = {20 pages, 926821 bytes},
  publisher = {[object Object]},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.CSL.2024.29},
  urldate = {2024-03-23},
  abstract = {The Kleene-Post theorem and Post's theorem are two central and historically important results in the development of oracle computability theory, clarifying the structure of Turing reducibility degrees. They state, respectively, that there are incomparable Turing degrees and that the arithmetical hierarchy is connected to the relativised form of the halting problem defined via Turing jumps. We study these two results in the calculus of inductive constructions (CIC), the constructive type theory underlying the Coq proof assistant. CIC constitutes an ideal foundation for the formalisation of computability theory for two reasons: First, like in other constructive foundations, computable functions can be treated via axioms as a purely synthetic notion rather than being defined in terms of a concrete analytic model of computation such as Turing machines. Furthermore and uniquely, CIC allows consistently assuming classical logic via the law of excluded middle or weaker variants on top of axioms for synthetic computability, enabling both fully classical developments and taking the perspective of constructive reverse mathematics on computability theory.},
  collaborator = {Murano, Aniello and Silva, Alexandra},
  copyright = {Creative Commons Attribution 4.0 International license, info:eu-repo/semantics/openAccess},
  isbn = {9783959773102},
  langid = {english},
  keywords = {Computability theory,Constructive mathematics,Constructive type theory,Coq proof assistant,Interactive theorem proving,Logical foundations,Theory of computation  Constructive mathematics,Theory of computation  Type theory},
  file = {/home/flaviomoura/Zotero/storage/QHHZZJK2/Forster et al. - 2024 - The Kleene-Post and Postâs Theorem in the Calculus.pdf}
}

@article{forsterMachinecheckedUndecidabilityProofs,
  title = {Machine-Checked Undecidability Proofs Regarding Contextual Equivalence in {{PCF}}},
  author = {Forster, Yannick and Jaber, Guilhem},
  pages = {3},
  abstract = {Laboratoire, institution / Laboratory, institution: Inria, Universit{\'e} de Nantes (LS2N). Lieu du stage / Location: LS2N, UFR Sciences et Techniques, 2, rue de la Houssini{\`e}re, Nantes. {\'E}quipe d'accueil / Host team: {\'E}quipe-projet Inria Gallinette. Contact: Yannick Forster and Guilhem Jaber (e-mail) Encadrement / Supervision: The internship will take place in the Inria Gallinette team. It will be co-supervised by Yannick Forster and Guilhem Jaber.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/JAJDRLHK/Forster e Jaber - Machine-checked undecidability proofs regarding co.pdf}
}

@article{forstermechanised,
  title = {A Mechanised Proof of the Time Invariance Thesis for the Weak Call-by-Value {{$\lambda$}}-{{Calculus}}},
  author = {Forster, Yannick and Kunze, Fabian and Smolka, Gert and Wuttke, Maximilian}
}

@article{forsterMechanisedProofTime,
  title = {A {{Mechanised Proof}} of the {{Time Invariance Thesis}} for the {{Weak Call-by-value}} {$\lambda$}-{{Calculus}}},
  author = {Forster, Yannick and Kunze, Fabian and Smolka, Gert and Wuttke, Maximilian},
  pages = {22},
  abstract = {The weak call-by-value {$\lambda$}-calculus L and Turing machines can simulate each other with a polynomial overhead in time. This time invariance thesis for L, where the number of {$\beta$}-reductions of a computation is taken as its time complexity, is the culmination of a 25-years line of research, combining work by Blelloch, Greiner, Dal Lago, Martini, Accattoli, Forster, Kunze, Roth, and Smolka. The present paper presents a mechanised proof of the time invariance thesis for L, constituting the first mechanised equivalence proof between two standard models of computation covering time complexity.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XGAYAWDP/Forster et al. - A Mechanised Proof of the Time Invariance Thesis f.pdf}
}

@inproceedings{forsterMechanisedProofTime2021,
  title = {A {{Mechanised Proof}} of the {{Time Invariance Thesis}} for the {{Weak Call-By-Value}} {$\lambda$}-{{Calculus}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{ITP}}.2021.19},
  author = {Forster, Yannick and Kunze, Fabian and Smolka, Gert and Wuttke, Maximilian},
  year = {2021},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.ITP.2021.19},
  urldate = {2024-06-14},
  abstract = {The weak call-by-value {$\lambda$}-calculus {\L}and Turing machines can simulate each other with a polynomial overhead in time. This time invariance thesis for L, where the number of {$\beta$}-reductions of a computation is taken as its time complexity, is the culmination of a 25-years line of research, combining work by Blelloch, Greiner, Dal Lago, Martini, Accattoli, Forster, Kunze, Roth, and Smolka. The present paper presents a mechanised proof of the time invariance thesis for L, constituting the first mechanised equivalence proof between two standard models of computation covering time complexity. The mechanisation builds on an existing framework for the extraction of Coq functions to L and contributes a novel Hoare logic framework for the verification of Turing machines. The mechanised proof of the time invariance thesis establishes {\L}as model for future developments of mechanised computational complexity theory regarding time. It can also be seen as a non-trivial but elementary case study of time-complexity-preserving translations between a functional language and a sequential machine model. As a by-product, we obtain a mechanised many-one equivalence proof of the halting problems for {\L}and Turing machines, which we contribute to the Coq Library of Undecidability Proofs.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/MITWTPTB/Forster et al. - 2021 - A Mechanised Proof of the Time Invariance Thesis f.pdf}
}

@article{forsterMyhillIsomorphismTheorem,
  title = {Myhill {{Isomorphism Theorem}} and a {{Computational Cantor-Bernstein Theorem}} in {{Constructive Type Theory}}},
  author = {Forster, Yannick and Jahn, Felix and Smolka, Gert},
  pages = {3},
  abstract = {Two enumerable discrete types which can be embedded into each other in constructive type theory are isomorphic. Furthermore, the isomomorphism can be constructed to preserve a reduction property regarding predicates on the types. This (novel) result can be interpreted in two ways: First, it is a computational form of the Cantor-Bernstein theorem [2, 1] from set theory, stating that two sets which can be embedded into each other are in bijection, which is is inherently classical in its full generality [8]. Secondly, it is a synthetic form of the Myhill isomorphism theorem [7] from computability theory stating that 1-equivalent predicates are recursively isomorphic.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PQKF6T6Q/Forster et al. - Myhill Isomorphism Theorem and a Computational Can.pdf}
}

@inproceedings{forsterWeakCallbyValueLambda2017,
  title = {Weak {{Call-by-Value Lambda Calculus}} as a {{Model}} of {{Computation}} in {{Coq}}},
  booktitle = {Interactive {{Theorem Proving}} - 8th {{International Conference}}, {{ITP}} 2017, {{Bras{\'i}lia}}, {{Brazil}}, {{September}} 26-29, 2017, {{Proceedings}}},
  author = {Forster, Yannick and Smolka, Gert},
  year = {2017},
  pages = {189--206},
  doi = {10.1007/978-3-319-66107-0_13}
}

@techreport{forsterWeakCallByValueLCalculus2019,
  type = {Techincal {{Report}}},
  title = {The {{Weak Call-By-Value}} {$\lambda$}-{{Calculus}} Is {{Reasonable}} for {{Both Time}} and {{Space}}},
  author = {Forster, Yannick and Kunze, Fabian and Roth, Marc},
  year = {2019},
  month = feb,
  institution = {Saarland University}
}

@article{forsytheAlgorithms1964,
  title = {Algorithms},
  author = {Forsythe, G. E.},
  year = {1964},
  month = jun,
  journal = {Commun. ACM},
  volume = {7},
  number = {6},
  pages = {347--349},
  issn = {0001-0782},
  doi = {10.1145/512274.512284},
  urldate = {2024-07-15}
}

@book{forsythProbabilityStatisticsComputer2018,
  title = {Probability and {{Statistics}} for {{Computer Science}}},
  author = {Forsyth, David},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-64410-3}
}

@article{fortnowStatusNPProblem2009,
  title = {The Status of the {{P}} versus {{NP}} Problem},
  author = {Fortnow, Lance},
  year = {2009},
  month = sep,
  journal = {Communications of the ACM},
  volume = {52},
  number = {9},
  pages = {78--86},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/1562164.1562186},
  urldate = {2021-07-19},
  abstract = {It's one of the fundamental mathematical problems of our time, and its importance grows with the rise of powerful computers.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/JBWZJJHQ/Fortnow - 2009 - The status of the P versus NP problem.pdf}
}

@book{FoundationsSoftwareScience,
  title = {Foundations of {{Software Science}} and {{Computation Structures}}},
  urldate = {2024-04-16},
  abstract = {The open access FOSSACS 2024 proceedings deal with software science and computation structures, focusing on programming languages; logic and proofs, etc.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9JLKJAHF/Foundations of Software Science and Computation St.pdf;/home/flaviomoura/Zotero/storage/YGIYU72X/978-3-031-57228-9.html}
}

@misc{fourmentMechanizedTheoryBox2023,
  title = {A {{Mechanized Theory}} of the {{Box Calculus}}},
  author = {Fourment, Joseph and Xu, Yichen},
  year = {2023},
  month = sep,
  number = {arXiv:2309.05362},
  eprint = {2309.05362},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-09-12},
  abstract = {The capture calculus is an extension of System F{$<$}: that tracks free variables of terms in their type, allowing one to represent capabilities while limiting their scope. While previous calculi had mechanized soundness proofs -- notably System CF{$<$}: -- the latest version, namely the box calculus (System CC{$<$}:box), only had a paper proof. We present here our work on mechanizing the theory of the box calculus in Coq, and the challenges encountered along the way. While doing so, we motivate the current design of capture calculus, in particular the concept of boxes, from both user and metatheoretical standpoints. Our mechanization is complete and available on GitHub.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.3.1},
  file = {/home/flaviomoura/Zotero/storage/4ZJ8Z5FI/Fourment e Xu - 2023 - A Mechanized Theory of the Box Calculus.pdf;/home/flaviomoura/Zotero/storage/AWMWT4WB/2309.html}
}

@unpublished{francaLemaYonedaUma2018,
  title = {Lema de {{Yoneda}} - {{Uma Introdu{\c c}{\~a}o}} {\`a} {{Teoria}} de {{Categorias}}},
  author = {de Fran{\c c}a, M{\'a}rcio Palmares Pinto},
  year = {2018}
}

@article{frankCoqProofScript2021,
  title = {The {{Coq Proof Script Visualiser}} (Coq-Psv)},
  author = {Frank, Mario},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.07761 [cs]},
  eprint = {2101.07761},
  primaryclass = {cs},
  urldate = {2021-01-20},
  abstract = {In this work, we present a visualisation tool that is able to process Coq proof scripts and generate a table representation of the contained proofs as \${\textbackslash}LaTeX\$ or PDF files. This tool has the aim to support both education and review processes as all proof steps can be visualised. Thus, there is no need to use Coq in order to review proofs or use them as examples in teaching. In contrast to the usual approach of visualising proofs as hypertext or markdown documents, the generated files can be easily printed.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computers and Society,Computer Science - Logic in Computer Science,F.3.1,H.5.2,K.3.0},
  file = {/home/flaviomoura/Zotero/storage/EWJG7RLR/Frank - 2021 - The Coq Proof Script Visualiser (coq-psv).pdf;/home/flaviomoura/Zotero/storage/LGC29CA2/2101.html}
}

@book{franzenGodelTheoremIncomplete2005,
  title = {G{\"o}del's {{Theorem}}: {{An Incomplete Guide}} to {{Its Use}} and {{Abuse}}},
  author = {Franz{\'e}n, Torkel},
  year = {2005},
  publisher = {A K Peters, Ltd.},
  isbn = {1-56881-238-8 978-1-56881-238-0}
}

@article{fraserWillMachinesChange2024,
  title = {Will Machines Change Mathematics?},
  author = {Fraser, Maia and Granville, Andrew and Harris, Michael and McLarty, Colin and Riehl, Emily and Venkatesh, Akshay},
  year = {2024},
  month = feb,
  journal = {Bulletin of the American Mathematical Society},
  issn = {0273-0979, 1088-9485},
  doi = {10.1090/bull/1836},
  urldate = {2024-04-01},
  copyright = {https://www.ams.org/publications/copyright-and-permissions},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/MDXS5KLQ/Fraser et al. - 2024 - Will machines change mathematics.pdf}
}

@article{freemanActiveLearningIncreases2014,
  title = {Active {{Learning Increases Student Performance}} in {{Science}}, {{Engineering}}, and {{Mathematics}}},
  author = {Freeman, S. and Eddy, S. L. and McDonough, M. and Smith, M. K. and Okoroafor, N. and Jordt, H. and Wenderoth, M. P.},
  year = {2014},
  journal = {Proceedings of the National Academy of Sciences},
  volume = {111},
  number = {23},
  pages = {8410--8415},
  doi = {10.1073/pnas.1319030111}
}

@book{freireTopicosEmLogica2019,
  title = {T{\'o}picos Em {{L{\'o}gica}} de {{Primeira Ordem}}},
  author = {Freire, Rodrigo},
  year = {2019},
  volume = {1},
  publisher = {L{\'o}gica no Avi{\~a}o},
  isbn = {978-65-900390-0-2}
}

@inproceedings{friedmanAdventuresVerificationMathematics2006,
  title = {Adventures in the {{Verification}} of {{Mathematics}}},
  booktitle = {Computer {{Science Colloquium}}},
  author = {Friedman, Harvey M.},
  year = {2006},
  publisher = {Ohio State University}
}

@incollection{friezeProbabilisticAnalysisGraph1990,
  title = {Probabilistic {{Analysis}} of {{Graph Algorithms}}},
  booktitle = {Computing {{Supplementum}}},
  author = {Frieze, A. M.},
  year = {1990},
  series = {Computing {{Supplementum}}},
  pages = {209--233},
  publisher = {Springer Vienna},
  doi = {10.1007/978-3-7091-9076-0_11}
}

@article{fromIsabelleHOLMetaLanguage2020,
  title = {Isabelle/{{HOL}} as a {{Meta-Language}} for {{Teaching Logic}}},
  author = {From, Asta Halkj{\ae}r and Villadsen, J{\o}rgen and Blackburn, Patrick},
  year = {2020},
  month = oct,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {328},
  eprint = {2010.16014},
  pages = {18--34},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.328.2},
  urldate = {2020-11-09},
  abstract = {Proof assistants are important tools for teaching logic. We support this claim by discussing three formalizations in Isabelle/HOL used in a recent course on automated reasoning. The first is a formalization of System W (a system of classical propositional logic with only two primitive symbols), the second is the Natural Deduction Assistant (NaDeA), and the third is a one-sided sequent calculus that uses our Sequent Calculus Verifier (SeCaV). We describe each formalization in turn, concentrating on how we used them in our teaching, and commenting on features that are interesting or useful from a logic education perspective. In the conclusion, we reflect on the lessons learned and where they might lead us next.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/FKWIXIAG/From et al. - 2020 - IsabelleHOL as a Meta-Language for Teaching Logic.pdf;/home/flaviomoura/Zotero/storage/RBKYVNZK/2010.html}
}

@inproceedings{fromTeachingFormalizedLogical2020,
  title = {Teaching a {{Formalized Logical Calculus}}},
  booktitle = {{\textbackslash}rm {{Proceedings}} 8th {{International Workshop}} on {{Theorem Proving Components}} for {{Educational Software}}, {\textbackslash}rm {{Natal}}, {{Brazil}}, 25th {{August}} 2019},
  author = {From, Asta Halkj{\ae}r and Jensen, Alexander Birch and Schlichtkrull, Anders and Villadsen, J{\o}rgen},
  editor = {Quaresma, Pedro and Neuper, Walther and Marcos, Jo{\~a}o},
  year = {2020},
  series = {Electronic {{Proceedings}} in {{Theoretical Computer Science}}},
  volume = {313},
  pages = {73--92},
  publisher = {Open Publishing Association},
  doi = {10.4204/EPTCS.313.5}
}

@article{fromTeachingFormalizedLogical2020a,
  title = {Teaching a {{Formalized Logical Calculus}}},
  author = {From, Asta Halkj{\ae}r and Jensen, Alexander Birch and Schlichtkrull, Anders and Villadsen, J{\o}rgen},
  year = {2020},
  month = feb,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {313},
  eprint = {2002.12555},
  pages = {73--92},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.313.5},
  urldate = {2021-07-28},
  abstract = {Classical first-order logic is in many ways central to work in mathematics, linguistics, computer science and artificial intelligence, so it is worthwhile to define it in full detail. We present soundness and completeness proofs of a sequent calculus for first-order logic, formalized in the interactive proof assistant Isabelle/HOL. Our formalization is based on work by Stefan Berghofer, which we have since updated to use Isabelle's declarative proof style Isar (Archive of Formal Proofs, Entry FOL-Fitting, August 2007 / July 2018). We represent variables with de Bruijn indices; this makes substitution under quantifiers less intuitive for a human reader. However, the nature of natural numbers yields an elegant solution when compared to implementations of substitution using variables represented by strings. The sequent calculus considered has the special property of an always empty antecedent and a list of formulas in the succedent. We obtain the proofs of soundness and completeness for the sequent calculus as a derived result of the inverse duality of its tableau counterpart. We strive to not only present the results of the proofs of soundness and completeness, but also to provide a deep dive into a programming-like approach to the formalization of first-order logic syntax, semantics and the sequent calculus. We use the formalization in a bachelor course on logic for computer science and discuss our experiences.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/PT8983V7/From et al. - 2020 - Teaching a Formalized Logical Calculus.pdf;/home/flaviomoura/Zotero/storage/YSCJ6E5B/2002.html}
}

@inproceedings{frontullAlphaAvoidance2023,
  title = {{\textbackslash}alpha-{{Avoidance}}},
  booktitle = {8th {{International Conference}} on {{Formal Structures}} for {{Computation}} and {{Deduction}} ({{FSCD}} 2023)},
  author = {Frontull, Samuel and Moser, Georg and {van Oostrom}, Vincent},
  editor = {Gaboardi, Marco and {van Raamsdonk}, Femke},
  year = {2023},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  volume = {260},
  pages = {22:1--22:22},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.FSCD.2023.22},
  isbn = {978-3-95977-277-8},
  file = {/home/flaviomoura/Zotero/storage/E5YGMIWZ/LIPIcs-FSCD-2023-22.pdf}
}

@article{fruminSemanticCutElimination2021,
  title = {Semantic {{Cut Elimination}} for the {{Logic}} of {{Bunched Implications}}, {{Formalized}} in {{Coq}}},
  author = {Frumin, Dan},
  year = {2021},
  month = dec,
  journal = {arXiv:2112.05515 [cs, math]},
  eprint = {2112.05515},
  primaryclass = {cs, math},
  urldate = {2021-12-16},
  abstract = {The logic of bunched implications (BI) is a substructural logic that forms the backbone of separation logic, the much studied logic for reasoning about heap-manipulating programs. Although the proof theory and metatheory of BI are mathematically involved, the formalization of important metatheoretical results is still incipient. In this paper we present a self-contained formalized, in the Coq proof assistant, proof of a central metatheoretical property of BI: cut elimination for its sequent calculus.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/MV7HG8UQ/Frumin - 2021 - Semantic Cut Elimination for the Logic of Bunched .pdf}
}

@book{FSCD2016Formal2016,
  title = {{{FSCD}} 2016 - {{Formal Structures}} in {{Computation}} and {{Deduction}}},
  year = {2016}
}

@misc{fuInductionPrincipleNested2023,
  title = {Towards an Induction Principle for Nested Data Types},
  author = {Fu, Peng and Selinger, Peter},
  year = {2023},
  month = jun,
  number = {arXiv:2306.10124},
  eprint = {2306.10124},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-21},
  abstract = {A well-known problem in the theory of dependent types is how to handle so-called nested data types. These data types are difficult to program and to reason about in total dependently typed languages such as Agda and Coq. In particular, it is not easy to derive a canonical induction principle for such types. Working towards a solution to this problem, we introduce dependently typed folds for nested data types. Using the nested data type Bush as a guiding example, we show how to derive its dependently typed fold and induction principle. We also discuss the relationship between dependently typed folds and the more traditional higher-order folds.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/KRNX4WEG/Fu e Selinger - 2023 - Towards an induction principle for nested data typ.pdf}
}

@inproceedings{fuInductionPrincipleNested2023a,
  title = {Towards an~{{Induction Principle}} for~{{Nested Data Types}}},
  booktitle = {Logic, {{Language}}, {{Information}}, and {{Computation}}},
  author = {Fu, Peng and Selinger, Peter},
  editor = {Hansen, Helle Hvid and Scedrov, Andre and {de Queiroz}, Ruy J.G.B.},
  year = {2023},
  pages = {244--255},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-39784-4_15},
  abstract = {A well-known problem in the theory of dependent types is how to handle so-called nested data types. These data types are difficult to program and to reason about in total dependently typed languages such as Agda and Coq. In particular, it is not easy to derive a canonical induction principle for such types. Working towards a solution to this problem, we introduce dependently typed folds for nested data types. Using the nested data type \$\${\textbackslash}texttt \{Bush\}\$\$Bushas a guiding example, we show how to derive its dependently typed fold and induction principle. We also discuss the relationship between dependently typed folds and the more traditional higher-order folds.},
  isbn = {978-3-031-39784-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7PUZRJCV/Fu and Selinger - 2023 - Towards anÂ Induction Principle forÂ Nested Data Typ.pdf}
}

@article{fujitaExistentialFragmentSecondorder2024,
  title = {The Existential Fragment of Second-Order Propositional Intuitionistic Logic Is Undecidable},
  author = {Fujita, Ken-etsu and Schubert, Aleksy and Urzyczyn, Pawe{\l} and Zdanowski, Konrad},
  year = {2024},
  journal = {Journal of Applied Non-Classical Logics},
  volume = {0},
  number = {0},
  pages = {1--20},
  publisher = {Taylor \& Francis},
  issn = {1166-3081},
  doi = {10.1080/11663081.2024.2312774},
  urldate = {2024-03-11},
  abstract = {The provability problem in intuitionistic propositional second-order logic with existential quantifier and implication ({$\exists$},{$\rightarrow$}) is proved to be undecidable in presence of free type variables (constants). This contrasts with the result that inutitionistic propositional second-order logic with existential quantifier, conjunction and negation is decidable.},
  keywords = {existential quantification,lambda calculus,propositional logic,Second-order logic,second-order type system},
  file = {/home/flaviomoura/Zotero/storage/GZKUSJDL/Fujita et al. - 2024 - The existential fragment of second-order propositi.pdf}
}

@article{fujitaFormalSystemReduction2020,
  title = {A Formal System of Reduction Paths for Parallel Reduction},
  author = {Fujita, Ken-etsu},
  year = {2020},
  month = apr,
  journal = {Theoretical Computer Science},
  volume = {813},
  pages = {327--340},
  issn = {03043975},
  doi = {10.1016/j.tcs.2020.01.002},
  urldate = {2021-04-06},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ZRZBXN2F/Fujita - 2020 - A formal system of reduction paths for parallel re.pdf}
}

@article{fujitaUpperBoundsChurchRosser2017,
  title = {On {{Upper Bounds}} on the {{Church-Rosser Theorem}}},
  author = {Fujita, Ken-etsu},
  year = {2017},
  month = jan,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {235},
  eprint = {1701.00637},
  pages = {16--31},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.235.2},
  urldate = {2021-03-26},
  abstract = {The Church-Rosser theorem in the type-free lambda-calculus is well investigated both for beta-equality and beta-reduction. We provide a new proof of the theorem for beta-equality with no use of parallel reductions, but simply with Takahashi's translation (Gross-Knuth strategy). Based on this, upper bounds for reduction sequences on the theorem are obtained as the fourth level of the Grzegorczyk hierarchy.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/3GTFHPM6/Fujita - 2017 - On Upper Bounds on the Church-Rosser Theorem.pdf;/home/flaviomoura/Zotero/storage/2ZDRLYRY/1701.html}
}

@article{fukudaLinearLogicalReconstructionIntuitionistic2019,
  title = {A {{Linear-Logical Reconstruction}} of {{Intuitionistic Modal Logic S4}}},
  author = {Fukuda, Yosuke and Yoshimizu, Akira},
  year = {2019},
  journal = {CoRR},
  abstract = {We propose a "modal linear logic" to reformulate intuitionistic modal logic S4 (IS4) in terms of linear logic, establishing an S4-version of Girard translation from IS4 to it. While the Girard translation from intuitionistic logic to linear logic is well-known, its extension to modal logic is non-trivial since a naive combination of the S4 modality and the exponential modality causes an undesirable interaction between the two modalities. To solve the problem, we introduce an extension of intuitionistic multiplicative exponential linear logic with a modality combining the S4 modality and the exponential modality, and show that it admits a sound translation from IS4. Through the Curry-Howard correspondence we further obtain a Geometry of Interaction Machine semantics of the modal lambda-calculus by Pfenning and Davies for staged computation.}
}

@inproceedings{g.huetHigherOrderUnification2002,
  title = {Higher {{Order Unification}} 30 Years {{Later}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}} - {{TPHOLs}} 2002},
  author = {{G. Huet}},
  editor = {Carre{\~n}o, V. A. and Mu{\~n}oz, C. A. and {S. Tahar}},
  year = {2002},
  series = {{{LNCS}}},
  volume = {2410},
  pages = {3--12},
  publisher = {Springer}
}

@article{g.huetUndecidabilityUnificationThird1973,
  title = {The Undecidability of Unification in Third Order Logic},
  author = {{G. Huet}},
  year = {1973},
  month = apr,
  journal = {Information and Control},
  volume = {22},
  number = {3},
  pages = {257--267}
}

@article{gabbayCaptureavoidingSubstitutionNominal2008,
  title = {Capture-Avoiding Substitution as a Nominal Algebra},
  author = {Gabbay, Murdoch J. and Mathijssen, Aad},
  year = {2008},
  month = jul,
  journal = {Formal Aspects of Computing},
  volume = {20},
  number = {4-5},
  pages = {451--479},
  issn = {0934-5043, 1433-299X},
  doi = {10.1007/s00165-007-0056-1},
  urldate = {2023-03-19},
  abstract = {Abstract             Substitution is fundamental to the theory of logic and computation. Is substitution something that we define on syntax on a case-by-case basis, or can we turn the idea of substitution into a mathematical object? We give axioms for substitution and prove them sound and complete with respect to a canonical model. As corollaries we obtain a useful conservativity result, and prove that equality-up-to-substitution is a decidable relation on terms. These results involve subtle use of techniques both from rewriting and algebra. A special feature of our method is the use of nominal techniques. These give us access to a stronger assertion language, which includes so-called `freshness' or `capture-avoidance' conditions. This means that the sense in which we axiomatise substitution (and prove soundness and completeness) is particularly strong, while remaining quite general.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ENEV6ST6/Gabbay e Mathijssen - 2008 - Capture-avoiding substitution as a nominal algebra.pdf;/home/flaviomoura/Zotero/storage/LIKQ8IH9/capture-avoiding-substitution-nominal.pdf}
}

@article{gabbayHttpWwwGabbay2009,
  title = {{{http://www.gabbay.org.uk/papers.html\#lamcceThe}} Lambda-Context Calculus (Extended Version)},
  author = {Gabbay, J. M. and Lengrand, S.},
  year = {2009},
  month = dec,
  journal = {Information and Computation},
  volume = {207},
  number = {12},
  pages = {1369--1400},
  publisher = {Elsevier},
  doi = {10.1016/j.ic.2009.06.004}
}

@inproceedings{gabbayNewApproachAbstract1999,
  title = {A {{New Approach}} to {{Abstract Syntax Involving Binders}}},
  booktitle = {14th {{Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}}'99)},
  author = {Gabbay, M. and Pitts, A.},
  year = {1999},
  pages = {214--224},
  publisher = {IEEE},
  address = {Washington - Brussels - Tokyo},
  doi = {10.1109/LICS.1999.782617},
  file = {/home/flaviomoura/Zotero/storage/4BQJ8IC3/Gabbay e Pitts - 1999 - A New Approach to Abstract Syntax Involving Binder.pdf}
}

@article{gabbayNewApproachAbstract2002,
  title = {A {{New Approach}} to {{Abstract Syntax}} with {{Variable Binding}}},
  author = {Gabbay, Murdoch J. and Pitts, Andrew M.},
  year = {2002},
  month = jul,
  journal = {Formal Aspects of Computing},
  volume = {13},
  number = {3-5},
  pages = {341--363},
  issn = {0934-5043, 1433-299X},
  doi = {10.1007/s001650200016},
  urldate = {2023-09-08},
  abstract = {Abstract.             The permutation model of set theory with atoms (FM-sets), devised by Fraenkel and Mostowski in the 1930s, supports notions of `name-abstraction' and `fresh name' that provide a new way to represent, compute with, and reason about the syntax of formal systems involving variable-binding operations. Inductively defined FM-sets involving the name-abstraction set former (together with Cartesian product and disjoint union) can correctly encode syntax modulo renaming of bound variables. In this way, the standard theory of algebraic data types can be extended to encompass signatures involving binding operators. In particular, there is an associated notion of structural recursion for defining syntax-manipulating functions (such as capture avoiding substitution, set of free variables, etc.) and a notion of proof by structural induction, both of which remain pleasingly close to informal practice in computer science.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NYAS22FK/Gabbay e Pitts - 2002 - A New Approach to Abstract Syntax with Variable Bi.pdf}
}

@article{gabbayNominalTechniquesAgda,
  title = {Nominal Techniques as an {{Agda}} Library},
  author = {Gabbay, Murdoch J and Melkonian, Orestis},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/FB2P8CHR/Gabbay e Melkonian - Nominal techniques as an Agda library.pdf}
}

@article{gacekNominalAbstraction2011,
  title = {Nominal Abstraction},
  author = {Gacek, Andrew and Miller, Dale and Nadathur, Gopalan},
  year = {2011},
  month = jan,
  journal = {Information and Computation},
  volume = {209},
  number = {1},
  pages = {48--73},
  issn = {08905401},
  doi = {10.1016/j.ic.2010.09.004},
  urldate = {2023-09-22},
  abstract = {Recursive relational specifications are commonly used to describe the computational structure of formal systems. Recent research in proof theory has identified two features that facilitate direct, logic-based reasoning about such descriptions: the interpretation of atomic judgments through recursive definitions and an encoding of binding constructs via generic judgments. However, logics encompassing these two features do not currently allow for the definition of relations that embody dynamic aspects related to binding, a capability needed in many reasoning tasks. We propose a new relation between terms called nominal abstraction as a means for overcoming this deficiency. We incorporate nominal abstraction into a rich logic also including definitions, generic quantification, induction, and co-induction that we then prove to be consistent. We present examples to show that this logic can provide elegant treatments of binding contexts that appear in many proofs, such as those establishing properties of typing calculi and of arbitrarily cascading substitutions that play a role in reducibility arguments.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/86TCE7ZA/Gacek et al. - 2011 - Nominal abstraction.pdf}
}

@misc{gacekSimplifiedSuspensionCalculus2007,
  title = {A {{Simplified Suspension Calculus}} and Its {{Relationship}} to {{Other Explicit Substitution Calculi}}},
  author = {Gacek, Andrew and Nadathur, Gopalan},
  year = {2007},
  month = feb,
  number = {arXiv:cs/0702152},
  eprint = {cs/0702152},
  publisher = {arXiv},
  urldate = {2023-09-20},
  abstract = {This paper concerns the explicit treatment of substitutions in the lambda calculus. One of its contributions is the simplification and rationalization of the suspension calculus that embodies such a treatment. The earlier version of this calculus provides a cumbersome encoding of substitution composition, an operation that is important to the efficient realization of reduction. This encoding is simplified here, resulting in a treatment that is easy to use directly in applications. The rationalization consists of the elimination of a practically inconsequential flexibility in the unravelling of substitutions that has the inadvertent side effect of losing contextual information in terms; the modified calculus now has a structure that naturally supports logical analyses, such as ones related to the assignment of types, over lambda terms. The overall calculus is shown to have pleasing theoretical properties such as a strongly terminating sub-calculus for substitution and confluence even in the presence of term meta variables that are accorded a grafting interpretation. Another contribution of the paper is the identification of a broad set of properties that are desirable for explicit substitution calculi to support and a classification of a variety of proposed systems based on these. The suspension calculus is used as a tool in this study. In particular, mappings are described between it and the other calculi towards understanding the characteristics of the latter.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4AB65F7Y/Gacek e Nadathur - 2007 - A Simplified Suspension Calculus and its Relations.pdf;/home/flaviomoura/Zotero/storage/UTW45AJ8/0702152.html}
}

@article{galdinoFormalizationKnuthBendixHuet2010,
  title = {A {{Formalization}} of the {{Knuth-Bendix}}(-{{Huet}}) {{Critical Pair Theorem}}},
  author = {Galdino, A. L. and {Ayala-Rinc{\'o}n}, M.},
  year = {2010},
  journal = {Journal of Automated Reasoning},
  volume = {45},
  number = {3},
  pages = {301--325}
}

@inproceedings{galdinoPVSTheoryTerm2009,
  title = {A {{PVS}} Theory for Term Rewriting Systems},
  booktitle = {Proc. 3rd {{Workshop}} on {{Logical}} and {{Semantical Frameworks}} with {{Applications}} - {{LSFA}} 2009},
  author = {Galdino, A. L. and {Ayala-Rinc{\'o}n}, M.},
  year = {2009},
  series = {{{ENTCS}}},
  volume = {247},
  pages = {67--83}
}

@article{galdinoVerificationNewmanYokouchi2008,
  title = {Verification of {{Newman}}'s and {{Yokouchi Lemmas}} in a {{Higher-Order Language}}},
  author = {Galdino, A. L. and {Ayala-Rinc{\'o}n}, M.},
  year = {2008},
  journal = {Journal of Formalized Reasoning},
  volume = {1},
  number = {1},
  pages = {39--50}
}

@article{gallierConstructiveLogicsPart1993,
  title = {Constructive {{Logics Part I}}: {{A Tutorial}} on {{Proof Systems}} and {{Typed}} Gamma-{{Calculi}}},
  author = {Gallier, Jean H.},
  year = {1993},
  journal = {Theor. Comput. Sci.},
  volume = {110},
  number = {2},
  pages = {249--339},
  doi = {10.1016/0304-3975(93)90011-H}
}

@book{gareyComputersIntractabilityGuide1979,
  title = {Computers and {{Intractability}}: {{A Guide}} to the {{Theory}} of {{NP-Completeness}}},
  author = {Garey, Michael R. and Johnson, David S.},
  year = {1979},
  publisher = {W. H. Freeman \& Co.},
  address = {New York, NY, USA},
  isbn = {0-7167-1044-7},
  file = {/home/flaviomoura/Zotero/storage/A3CGFK8R/Garey e Johnson - 1979 - Computers and Intractability A Guide to the Theor.pdf}
}

@incollection{garillotPackagingMathematicalStructures2009,
  title = {Packaging {{Mathematical Structures}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Garillot, Fran{\c c}ois and Gonthier, Georges and Mahboubi, Assia and Rideau, Laurence},
  editor = {Berghofer, Stefan and Nipkow, Tobias and Urban, Christian and Wenzel, Makarius},
  year = {2009},
  volume = {5674},
  pages = {327--342},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-03359-9_23},
  urldate = {2024-06-14},
  abstract = {This paper proposes generic design patterns to define and combine algebraic structures, using dependent records, coercions and type inference, inside the Coq system. This alternative to telescopes in particular allows multiple inheritance, maximal sharing of notations and theories, and automated structure inference. Our methodology is robust enough to support a hierarchy comprising a broad variety of algebraic structures, from types with a choice operator to algebraically closed fields. Interfaces for the structures enjoy the handiness of a classical setting, without requiring any axiom. Finally, we show how externally extensible some of these instances are by discussing a lemma seminal in defining the discrete logarithm, and a matrix decomposition problem.},
  isbn = {978-3-642-03358-2 978-3-642-03359-9},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2NDCNB9W/Garillot et al. - 2009 - Packaging Mathematical Structures.pdf}
}

@article{gasarchHilbertTenthProblem2021,
  title = {Hilbert's {{Tenth Problem}}: {{Refinements}} and {{Variants}}},
  shorttitle = {Hilbert's {{Tenth Problem}}},
  author = {Gasarch, William},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.07220 [math]},
  eprint = {2104.07220},
  primaryclass = {math},
  urldate = {2021-04-16},
  abstract = {Hilbert's 10th problem, stated in modern terms, is: Find an algorithm that will, given \$p {\textbackslash}in {\textbackslash}mathbb\{Z\}[x\_1,{\textbackslash}ldots,x\_n]\$ determine if there exists \$a\_1, a\_2, {\textbackslash}ldots, a\_n {\textbackslash}in {\textbackslash}mathbb\{Z\}\$ such that \$p(a\_1,{\textbackslash}ldots,a\_n)=0\$. Davis, Putnam, Robinson, and Matijasevic showed that there is no such algorithm. We look at what happens (1) for fixed degree and number of variables, (2) for particular equations, and (3) for variants which reduce the number of variables needed for undecidability results.},
  archiveprefix = {arXiv},
  keywords = {03D05,F.4,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/YAI39GVG/Gasarch - 2021 - Hilbert's Tenth Problem Refinements and Variants.pdf;/home/flaviomoura/Zotero/storage/YEQ6B82G/2104.html}
}

@inproceedings{gasquetPandaProofAssistant2011,
  title = {Panda: {{A Proof Assistant}} in {{Natural Deduction}} for {{All}}. {{A Gentzen Style Proof Assistant}} for {{Undergraduate Students}}},
  booktitle = {{{TICTTL}}},
  author = {Gasquet, O. and Schwarzentruber, F. and Martin, M.},
  year = {2011},
  pages = {85--92},
  publisher = {Springer}
}

@misc{gauthierFormalProof252024,
  title = {A {{Formal Proof}} of {{R}}(4,5)=25},
  author = {Gauthier, Thibault and Brown, Chad E.},
  year = {2024},
  month = apr,
  number = {arXiv:2404.01761},
  eprint = {2404.01761},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.01761},
  urldate = {2024-04-03},
  abstract = {In 1995, McKay and Radziszowski proved that the Ramsey number R(4,5) is equal to 25. Their proof relies on a combination of high-level arguments and computational steps. The authors have performed the computational parts of the proof with different implementations in order to reduce the possibility of an error in their programs. In this work, we prove this theorem in the interactive theorem prover HOL4 limiting the uncertainty to the small HOL4 kernel. Instead of verifying their algorithms directly, we rely on a verified SAT solver to prove gluing lemmas. To reduce the number of such lemmas and thus make the computational part of the proof feasible, we implement a generalization algorithm and verify that its output covers all the possible cases.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Combinatorics},
  file = {/home/flaviomoura/Zotero/storage/79EYR6TZ/Gauthier e Brown - 2024 - A Formal Proof of R(4,5)=25.pdf;/home/flaviomoura/Zotero/storage/C73T6GSX/2404.html}
}

@inproceedings{gavazzoMonadicIntersectionTypes2024,
  title = {Monadic {{Intersection Types}}, {{Relationally}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Gavazzo, Francesco and Treglia, Riccardo and Vanoni, Gabriele},
  editor = {Weirich, Stephanie},
  year = {2024},
  pages = {22--51},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-57262-3_2},
  abstract = {We extend intersection types to a computational \$\${\textbackslash}lambda \$\${$\lambda$}-calculus with algebraic operations {\`a} la Plotkin and Power. We achieve this by considering monadic intersections---whereby computational effects appear not only in the operational semantics, but also in the type system. Since in the effectful setting termination is not anymore the only property of interest, we want to analyze the interactive behavior of typed programs with the environment. Indeed, our type system is able to characterize the natural notion of observation, both in the finite and in the infinitary setting, and for a wide class of effects, such as output, cost, pure and probabilistic nondeterminism, and combinations thereof. The main technical tool is a novel combination of syntactic techniques with abstract relational reasoning, which allows us to lift all the required notions, e.g. of typability and logical relation, to the monadic setting.},
  isbn = {978-3-031-57262-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2DS8LM4Q/Gavazzo et al. - 2024 - Monadic Intersection Types, Relationally.pdf}
}

@article{gazzariCalculusNaturalCalculation2021,
  title = {The {{Calculus}} of {{Natural Calculation}}},
  author = {Gazzari, Ren{\'e}},
  year = {2021},
  month = dec,
  journal = {Studia Logica},
  volume = {109},
  number = {6},
  pages = {1375--1411},
  issn = {0039-3215, 1572-8730},
  doi = {10.1007/s11225-020-09938-7},
  urldate = {2023-10-25},
  abstract = {Abstract             The calculus of Natural Calculation is introduced as an extension of Natural Deduction by proper term rules. Such term rules provide the capacity of dealing directly with terms in the calculus instead of the usual reasoning based on equations, and therefore the capacity of a natural representation of informal mathematical calculations. Basic proof theoretic results are communicated, in particular completeness and soundness of the calculus; normalisation is briefly investigated. The philosophical impact on a proof theoretic account of the notion of meaning is considered.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/C5DWMEXU/Gazzari - 2021 - The Calculus of Natural Calculation.pdf}
}

@article{gazzariFormalTheoriesOccurrences2022,
  title = {Formal {{Theories}} of {{Occurrences}} and {{Substitutions}}},
  author = {Gazzari, Ren{\'e}},
  year = {2022},
  month = jun,
  journal = {The Bulletin of Symbolic Logic},
  volume = {28},
  number = {2},
  pages = {261--263},
  issn = {1079-8986, 1943-5894},
  doi = {10.1017/bsl.2021.53},
  urldate = {2023-11-13},
  abstract = {Abstract             Gazzari provides a mathematical theory of occurrences and of substitutions, which are a generalisation of occurrences constituting substitution functions. The dissertation focusses on term occurrences in terms of a first order language, but the methods and results obtained there can easily be carried over to arbitrary kinds of occurrences in arbitrary kinds of languages.             The aim of the dissertation is twofold: first, Gazzari intends to provide an adequate formal representation of philosophically relevant concepts (not only of occurrences and substitutions, but also of substitution functions, of calculations as well as of intuitively given properties of the discussed entities) and to improve this way our understanding of these concepts; second, he intends to provide a formal exploration of the introduced concepts including the detailed development of the methods needed for their adequate treatment.             The dissertation serves as a methodological fundament for consecutive research on topics demanding a precise treatment of occurrences and as a foundation for all scientific work dealing with occurrences only informally; the formal investigations are complemented by a brief survey of the development of the notion of occurrences in mathematics, philosophy and computer science.                            The notion of occurrences.               Occurrences are determined by three aspects: an occurrence is always an occurrence               of               a syntactic entity (its               shape               )               in               a syntactic entity (its               context               )               at               a specific               position               . Context and shape can be any meaningful combination of well-known syntactic entities as, in logic, terms, formulae or formula trees. Gazzari's crucial idea is to represent the position of occurrences by               nominal forms               , essentially as introduced by Sch{\"u}tte [2]. The nominal forms are a generalisation of standard syntactic entities in which so called               nominal symbols                                                                      \$*\_k\$                                               may occur. The position of an occurrence is obtained by eliminating the intended shape in the context, which means to replace the intended shape by suitable nominal symbols.                                         Standard occurrences.               Central tool of the theory of nominal terms (nominal forms generalising standard terms) is the               general substitution function               mapping a nominal term                                                                      \${\textbackslash}mathtt \{t\}\$                                               and a sequence                                                                      \${\textbackslash}vec \{{\textbackslash}mathtt \{t\}\}\$                                               of them to the result                                                                      \${\textbackslash}mathtt \{t\}[{\textbackslash}vec \{{\textbackslash}mathtt \{t\}\}]\$                                               of replacing simultaneously the nominal symbols                                                                      \$*\_k\$                                               in the first argument by the respective entries                                                                      \${\textbackslash}mathtt \{t\}\_k\$                                               of the second argument.                                         A triple                                                                      \${\textbackslash}mathfrak \{o\}={\textbackslash}langle \{t,s,{\textbackslash}mathtt \{t\}\} {\textbackslash}rangle \$                                               is a               standard occurrence               , if an application of the general substitution function on the position                                                                      \${\textbackslash}mathtt \{t\}\$                                               and the shape               s               results in the context               t               of that occurrence. As                                                                      \$*\_0\$                                               can occur more than once in                                                                      \${\textbackslash}mathtt \{t\}\$                                               , arbitrary many single occurrences in the context               t               of the common shape               s               can be subsumed in                                                                      \${\textbackslash}mathfrak \{o\}\$                                               .               1               Gazzari illustrates the appropriateness of his approach by solving typical problems (counting formally the number of specific occurrences, deciding whether an occurrence lies within another) which are not solvable without a good theory of occurrences.                                         Multi-shape occurrences.               The               multi-shape occurrences                                                                      \${\textbackslash}mathfrak \{o\}={\textbackslash}langle \{t,{\textbackslash}vec s,{\textbackslash}mathtt \{t\}\} {\textbackslash}rangle \$                                               are the generalisation of standard occurrences, where the shape                                                                      \${\textbackslash}vec s\$                                               is a sequence of standard terms. Such occurrences subsume arbitrary non-overlapping single occurrences in the context               t               .                          Gazzari addresses the non-trivial identity of such occurrences and their independence. The latter represents formally the idea of non-overlapping occurrences and is a far-reaching generalisation of disjointness as discussed by Huet with respect to single occurrences. Independent occurrences can be merged into one occurrence; an occurrence can be split up into independent occurrences.                            Substitutions.               A substitution                                                                      \${\textbackslash}mathbf s={\textbackslash}langle \{t,{\textbackslash}vec s,{\textbackslash}mathtt \{t\},\{{\textbackslash}vec s\}',t'\} {\textbackslash}rangle \$                                               satisfies that both                                                                      \${\textbackslash}mathfrak \{o\}={\textbackslash}langle \{t,{\textbackslash}vec s,{\textbackslash}mathtt \{t\}\} {\textbackslash}rangle \$                                               and                                                                      \${\textbackslash}mathfrak \{o\}'={\textbackslash}langle \{t',\{{\textbackslash}vec s\}',{\textbackslash}mathtt \{t\}\} {\textbackslash}rangle \$                                               are occurrences such that the shapes have the same length. Such a substitution represents the replacement of                                                                      \${\textbackslash}vec s\$                                               in               t               at                                                                      \${\textbackslash}mathtt \{t\}\$                                               by                                                                      \${\textbackslash}vec s'\$                                               resulting in                                                                      \$t'\$                                               . This means that a substitution is understood as a process and not as a (specific type of a) function.                          Identity and independence are addressed again, using and extending the methods developed for occurrences; as before, independent substitutions can be merged and substitutions can be split up into sequences of independent substitutions. Substitutions are used to represent formally calculations (as found in everyday mathematics) and to investigate them.                            Sets of substitutions turn out to be set-theoretic functions mapping the affected occurrences                                                                      \${\textbackslash}mathfrak \{o\}\$                                               and the inserted shapes                                                                      \$\{{\textbackslash}vec s\}'\$                                               to the result                                                                      \$t'\$                                               of a substitution                                                                      \${\textbackslash}mathbf s\$                                               . Such sets are called               explicit substitution functions               . In order to qualify functions which are usually understood as substitution functions (and which are not formulated in a theory of occurrences) as substitution functions, Gazzari develops the concept of an               explication method               transforming such functions into explicit substitution functions. The appropriateness and the (philosophical) limitations of this concept are illustrated with example functions.                                         Conclusion.               Gazzari's theory of occurrences is strong (not restricted to single occurrences), canonical (nominal forms are a canonical generalisation of the underlying syntactic entities) and general (presupposing the grammar for the underlying syntactic entities, suitable nominal forms are easily defined and the theory of occurrences is immediately carried over). Another advantage is a kind of methodological pureness: positions are generalised syntactic entities (and not extraneous, as sequences of natural numbers) and can be treated, in particular, with the well-known methods developed for the underlying syntactic entities.                          Abstract prepared by Ren{\'e} Gazzari.                            E-mail               :               rene.gazzari@uni-tuebingen.de                                         URL               :               http://doi.org/10.15496/publikation-47553},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/FVU4DAY9/Gazzari - 2022 - Formal Theories of Occurrences and Substitutions.pdf}
}

@article{geckIltisTeachingLogic2021,
  title = {Iltis: {{Teaching Logic}} in the {{Web}}},
  shorttitle = {Iltis},
  author = {Geck, Gaetano and Quenkert, Christine and Schmellenkamp, Marko and Schmidt, Jonas and Tschirbs, Felix and Vehlken, Fabian and Zeume, Thomas},
  year = {2021},
  month = may,
  journal = {arXiv:2105.05763 [cs]},
  eprint = {2105.05763},
  primaryclass = {cs},
  urldate = {2021-05-13},
  abstract = {The Iltis project provides an interactive, web-based system for teaching the foundations of formal methods. It is designed to allow modular addition of educational tasks as well as to provide immediate and comprehensive feedback. Currently, exercises for various aspects of typical automated reasoning workflows for propositional logic, modal logic, and first-order logic are covered. Recently, Iltis has reached a level of maturity where large parts of introductory logic courses can be supplemented with interactive exercises. Sample interactive course material has been designed and used in such courses with more than 200 students. We invite all readers to give it a try!},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/B7U9FM4P/2105.html}
}

@article{gehPOLYNOMIALTIMEREDUCTION3SAT,
  title = {A {{POLYNOMIAL-TIME REDUCTION OF THE}} 3-{{SAT TO THE QUADRATIC CONGRUENCE AND OTHER RELATED PROBLEMS}}},
  author = {Geh, Renato Lui},
  pages = {24},
  abstract = {In this term paper for MAC6927 --- Computational Number Theory, we explore the history behind the quadratic congruence problem (QCP) and other related number theoric problems; show a polynomial-time reduction from the 3-SAT to the QCP quoting Adleman and Manders' 1978 theorem [MA78], implying that quadratic congruence is NP-complete; and show some solved and unsolved problems in Number Theory that are directly (or indirectly) related to the QCP problem and its membership in NP.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/R5IKQQUZ/Geh - A POLYNOMIAL-TIME REDUCTION OF THE 3-SAT TO THE QU.pdf}
}

@article{geneserethIntroductionLogicThird2016,
  title = {Introduction {{To Logic}}, {{Third Edition}}},
  author = {Genesereth, M. and Kao, E. J.},
  year = {2016},
  journal = {Synthesis Lectures on Computer Science},
  volume = {5},
  number = {1},
  pages = {1--177},
  doi = {10.2200/s00734ed2v01y201609csl008}
}

@article{georgeIntuitionismExcludedMiddle1988,
  title = {Intuitionism, {{Excluded Middle}} and {{Decidability}}: {{A Response}} to {{Weir}} on {{Dummett}}},
  shorttitle = {Intuitionism, {{Excluded Middle}} and {{Decidability}}},
  author = {George, Alexander},
  year = {1988},
  journal = {Mind},
  volume = {97},
  number = {388},
  eprint = {2255195},
  eprinttype = {jstor},
  pages = {597--602},
  publisher = {[Oxford University Press, Mind Association]},
  issn = {0026-4423},
  urldate = {2024-04-21},
  file = {/home/flaviomoura/Zotero/storage/KZ6VIN5T/George - 1988 - Intuitionism, Excluded Middle and Decidability A .pdf}
}

@misc{georgiouSaturatingSortingSorts2024,
  title = {Saturating {{Sorting}} without {{Sorts}}},
  author = {Georgiou, Pamina and Hajdu, M{\'a}rton and Kov{\'a}cs, Laura},
  year = {2024},
  month = mar,
  number = {arXiv:2403.03712},
  eprint = {2403.03712},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2403.03712},
  urldate = {2024-03-07},
  abstract = {We present a first-order theorem proving framework for establishing the correctness of functional programs implementing sorting algorithms with recursive data structures. We formalize the semantics of recursive programs in many-sorted first-order logic and integrate sortedness/permutation properties within our first-order formalization. Rather than focusing on sorting lists of elements of specific first-order theories, such as integer arithmetic, our list formalization relies on a sort parameter abstracting (arithmetic) theories and hence concrete sorts. We formalize the permutation property of lists in first-order logic so that we automatically prove verification conditions of such algorithms purely by superpositon-based first-order reasoning. Doing so, we adjust recent efforts for automating inducion in saturation. We advocate a compositional approach for automating proofs by induction required to verify functional programs implementing and preserving sorting and permutation properties over parameterized list structures. Our work turns saturation-based first-order theorem proving into an automated verification engine by (i) guiding automated inductive reasoning with manual proof splits and (ii) fully automating inductive reasoning in saturation. We showcase the applicability of our framework over recursive sorting algorithms, including Mergesort and Quicksort.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Symbolic Computation},
  file = {/home/flaviomoura/Zotero/storage/VQCZAT7B/Georgiou et al. - 2024 - Saturating Sorting without Sorts.pdf;/home/flaviomoura/Zotero/storage/VLWFULMZ/2403.html}
}

@inproceedings{gerardFunctionalProgrammingLtree2019,
  title = {Functional Programming with {$\lambda$}-Tree Syntax},
  booktitle = {Proceedings of the 21st {{International Symposium}} on {{Principles}} and {{Practice}} of {{Programming Languages}} 2019 - {{PPDP}} '19},
  author = {G{\'e}rard, Ulysse and Miller, Dale and Scherer, Gabriel},
  year = {- 2019},
  pages = {nil},
  doi = {10.1145/3354166.3354177}
}

@book{gersteinIntroductionMathematicalStructures2012,
  title = {Introduction to {{Mathematical Structures}} and {{Proofs}}},
  author = {Gerstein, Larry J.},
  year = {2012},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  address = {New York, NY},
  doi = {10.1007/978-1-4614-4265-3},
  urldate = {2020-11-06},
  isbn = {978-1-4614-4264-6 978-1-4614-4265-3}
}

@article{geuversClassicalNaturalDeduction2022,
  title = {Classical {{Natural Deduction}} from {{Truth Tables}}},
  author = {Geuvers, Herman and Hurkens, Tonny},
  year = {2022},
  abstract = {In earlier articles we have introduced truth table natural deduction which allows one to extract natural deduction rules for a propositional logic connective from its truth table definition. This works for both intuitionistic logic and classical logic. We have studied the proof theory of the intuitionistic rules in detail, giving rise to a general Kripke semantics and general proof term calculus with reduction rules that are strongly normalizing. In the present paper we study the classical rules and give a term interpretation to classical deductions with reduction rules. As a variation we define a multi-conclusion variant of the natural deduction rules as it simplifies the study of proof term reduction. We show that the reduction is normalizing and gives rise to the sub-formula property. We also compare the logical strength of the classical rules with the intuitionistic ones and we show that if one non-monotone connective is classical, then all connectives become classical.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/QXQ89LS6/Geuvers e Hurkens - 2022 - Classical Natural Deduction from Truth Tables.pdf}
}

@incollection{geuversInductionNotDerivable2001,
  title = {Induction {{Is Not Derivable}} in {{Second Order Dependent Type Theory}}},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}},
  author = {Geuvers, Herman},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Abramsky, Samson},
  year = {2001},
  volume = {2044},
  pages = {166--181},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-45413-6_16},
  urldate = {2021-07-30},
  isbn = {978-3-540-41960-0 978-3-540-45413-7},
  file = {/home/flaviomoura/Zotero/storage/TAQS75LZ/Geuvers - 2001 - Induction Is Not Derivable in Second Order Depende.pdf}
}

@incollection{geuversIntroductionTypeTheory2009,
  title = {Introduction to {{Type Theory}}},
  booktitle = {Language {{Engineering}} and {{Rigorous Software Development}}},
  author = {Geuvers, Herman},
  editor = {Bove, Ana and Barbosa, Lu{\'i}s Soares and Pardo, Alberto and Pinto, Jorge Sousa},
  year = {2009},
  volume = {5520},
  pages = {1--56},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-03153-3_1},
  urldate = {2021-07-05},
  isbn = {978-3-642-03152-6 978-3-642-03153-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/256PF84V/Geuvers - 2009 - Introduction to Type Theory.pdf}
}

@article{geuversModularProofStrong1991,
  title = {Modular {{Proof}} of {{Strong Normalization}} for the {{Calculus}} of {{Constructions}}},
  author = {Geuvers, H. and Nederhof, M.-J.},
  year = {1991},
  journal = {J. Funct. Program.},
  volume = {1},
  number = {2},
  pages = {155--189}
}

@article{geuversProofAssistantsHistory2009,
  title = {Proof {{Assistants}}: {{History}}, {{Ideas}} and {{Future}}},
  author = {Geuvers, H.},
  year = {2009},
  journal = {Sadhana},
  volume = {34},
  number = {1},
  pages = {3--25},
  doi = {10.1007/s12046-009-0001-5}
}

@article{geuversRelatingApartnessBisimulation2020,
  ids = {geuversRelatingApartnessBisimulation2021},
  title = {Relating {{Apartness}} and {{Bisimulation}}},
  author = {Geuvers, Herman and Jacobs, Bart},
  year = {2020},
  month = jul,
  journal = {arXiv:2002.02512 [cs]},
  eprint = {2002.02512},
  primaryclass = {cs},
  urldate = {2020-07-24},
  abstract = {A bisimulation for a coalgebra of a functor on the category of sets can be described via a coalgebra in the category of relations, of a lifted functor. A final coalgebra then gives rise to the coinduction principle, which states that two bisimilar elements are equal. For polynomial functors, this leads to well-known descriptions. In the present paper we look at the dual notion of "apartness". Intuitively, two elements are apart if there is a positive way to distinguish them. Phrased differently: two elements are apart if and only if they are not bisimilar. Since apartness is an inductive notion, described by a least fixed point, one can look for proof rules. We study this in two separate ways. First, for weak forms of bisimulation on labelled transition systems, where silent (tau) steps are included, we define an apartness notion that corresponds to weak bisimulation and another apartness that corresponds to branching bisimulation. The rules for apartness can be used to show that two states of a labelled transition system are not branching bismilar. To support the apartness view on labelled transition systems, we cast a number of well-known properties of branching bisimulation in terms of branching apartness and prove them. Next, we also study the more general categorical situation and show that indeed, apartness is the dual of bisimilarity in a precise categorical sense: apartness is an initial algebra and gives rise to an induction principle. In this analogy, we include the powerset functor, which gives a semantics to non-deterministic choice in process-theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science,D.2.4,D.3.1,F.3.1},
  file = {/home/flaviomoura/Zotero/storage/SZMZC4EY/Geuvers e Jacobs - 2020 - Relating Apartness and Bisimulation.pdf;/home/flaviomoura/Zotero/storage/XGLUC774/Geuvers e Jacobs - 2021 - Relating Apartness and Bisimulation.pdf;/home/flaviomoura/Zotero/storage/JRQ55LCV/2002.html;/home/flaviomoura/Zotero/storage/QKEI8MRI/2002.html}
}

@book{gFormalizingConstructiveProjective2017,
  title = {Formalizing {{Constructive Projective Geometry}} in {{Agda}}},
  author = {G, Calder{\'o}n},
  year = {2017},
  annotation = {Published: Submitted to LSFA 2017}
}

@article{ghalayiniExplicitRefinementTypes2023,
  title = {Explicit {{Refinement Types}}},
  author = {Ghalayini, Jad Elkhaleq and Krishnaswami, Neel},
  year = {2023},
  month = aug,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {ICFP},
  pages = {187--214},
  issn = {2475-1421},
  doi = {10.1145/3607837},
  urldate = {2023-11-20},
  abstract = {We present {$\lambda$}                                ert                              , a type theory supporting refinement types with {$<$}em{$>$}explicit proofs{$<$}/em{$>$}. Instead of solving refinement constraints with an SMT solver like DML and Liquid Haskell, our system requires and permits programmers to embed proofs of properties within the program text, letting us support a rich logic of properties including quantifiers and induction. We show that the type system is sound by showing that every refined program erases to a simply-typed program, and by means of a denotational semantics, we show that every erased program has all of the properties demanded by its refined type. All of our proofs are formalised in Lean 4.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WBE8UQWV/Ghalayini e Krishnaswami - 2023 - Explicit Refinement Types.pdf}
}

@article{ghaniExplicitSubstitutionsHigherorder2006,
  title = {Explicit Substitutions and Higher-Order Syntax},
  author = {Ghani, Neil and Uustalu, Tarmo and Hamana, Makoto},
  year = {2006},
  month = sep,
  journal = {Higher-Order and Symbolic Computation},
  volume = {19},
  number = {2-3},
  pages = {263--282},
  issn = {1388-3690, 1573-0557},
  doi = {10.1007/s10990-006-8748-4},
  urldate = {2021-09-25},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VRL9XH5U/Ghani et al. - 2006 - Explicit substitutions and higher-order syntax.pdf}
}

@article{gheriCaseStudiesFormal2021,
  title = {Case {{Studies}} in {{Formal Reasoning About Lambda-Calculus}}: {{Semantics}}, {{Church-Rosser}}, {{Standardization}} and {{HOAS}}},
  shorttitle = {Case {{Studies}} in {{Formal Reasoning About Lambda-Calculus}}},
  author = {Gheri, Lorenzo and Popescu, Andrei},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.11674 [cs]},
  eprint = {2107.11674},
  primaryclass = {cs},
  urldate = {2021-07-27},
  abstract = {We have previously published the Isabelle/HOL formalization of a general theory of syntax with bindings. In this companion paper, we instantiate the general theory to the syntax of lambda-calculus and formalize the development leading to several fundamental constructions and results: sound semantic interpretation, the Church-Rosser and standardization theorems, and higher-order abstract syntax (HOAS) encoding. For Church-Rosser and standardization, our work covers both the call-by-name and call-by-value versions of the calculus, following classic papers by Takahashi and Plotkin. During the formalization, we were able to stay focused on the high-level ideas of the development -- thanks to the arsenal provided by our general theory: a wealth of basic facts about the substitution, swapping and freshness operators, as well as recursive-definition and reasoning principles, including a specialization to semantic interpretation of syntax.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.3.1,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/FWZECEHK/Gheri e Popescu - 2021 - Case Studies in Formal Reasoning About Lambda-Calc.pdf;/home/flaviomoura/Zotero/storage/V4IRGUNH/2107.html}
}

@misc{gheriCaseStudiesFormal2021a,
  title = {Case {{Studies}} in {{Formal Reasoning About Lambda-Calculus}}: {{Semantics}}, {{Church-Rosser}}, {{Standardization}} and {{HOAS}}},
  shorttitle = {Case {{Studies}} in {{Formal Reasoning About Lambda-Calculus}}},
  author = {Gheri, Lorenzo and Popescu, Andrei},
  year = {2021},
  month = jul,
  number = {arXiv:2107.11674},
  eprint = {2107.11674},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-23},
  abstract = {We have previously published the Isabelle/HOL formalization of a general theory of syntax with bindings. In this companion paper, we instantiate the general theory to the syntax of lambda-calculus and formalize the development leading to several fundamental constructions and results: sound semantic interpretation, the Church-Rosser and standardization theorems, and higher-order abstract syntax (HOAS) encoding. For Church-Rosser and standardization, our work covers both the call-by-name and call-by-value versions of the calculus, following classic papers by Takahashi and Plotkin. During the formalization, we were able to stay focused on the high-level ideas of the development -- thanks to the arsenal provided by our general theory: a wealth of basic facts about the substitution, swapping and freshness operators, as well as recursive-definition and reasoning principles, including a specialization to semantic interpretation of syntax.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.3.1,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/LZQDFHXH/Gheri e Popescu - 2021 - Case Studies in Formal Reasoning About Lambda-Calc.pdf;/home/flaviomoura/Zotero/storage/USG3DH7N/2107.html}
}

@inproceedings{gheriFormalizedGeneralTheory2017,
  title = {A {{Formalized General Theory}} of {{Syntax}} with~{{Bindings}}},
  booktitle = {Interactive {{Theorem Proving}}},
  author = {Gheri, Lorenzo and Popescu, Andrei},
  editor = {{Ayala-Rinc{\'o}n}, Mauricio and Mu{\~n}oz, C{\'e}sar A.},
  year = {2017},
  pages = {241--261},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-66107-0_16},
  abstract = {We present the formalization of a theory of syntax with bindings that has been developed and refined over the last decade to support several large formalization efforts. Terms are defined for an arbitrary number of constructors of varying numbers of inputs, quotiented to alpha-equivalence and sorted according to a binding signature. The theory includes a rich collection of properties of the standard operators on terms, such as substitution and freshness. It also includes induction and recursion principles and support for semantic interpretation, all tailored for smooth interaction with the bindings and the standard operators.},
  isbn = {978-3-319-66107-0},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9SW3USBS/Gheri e Popescu - 2017 - A Formalized General Theory of Syntax withÂ Binding.pdf}
}

@article{gheriFormalizedGeneralTheory2020,
  title = {A {{Formalized General Theory}} of {{Syntax}} with {{Bindings}}: {{Extended Version}}},
  shorttitle = {A {{Formalized General Theory}} of {{Syntax}} with {{Bindings}}},
  author = {Gheri, Lorenzo and Popescu, Andrei},
  year = {2020},
  month = apr,
  journal = {Journal of Automated Reasoning},
  volume = {64},
  number = {4},
  pages = {641--675},
  issn = {0168-7433, 1573-0670},
  doi = {10.1007/s10817-019-09522-2},
  urldate = {2023-08-25},
  langid = {english},
  keywords = {Isabelle/HOL,Recursion and induction principles,Syntax with bindings},
  file = {/home/flaviomoura/Zotero/storage/M4LUXBID/Gheri e Popescu - 2020 - A Formalized General Theory of Syntax with Binding.pdf;/home/flaviomoura/Zotero/storage/QPXXQD8V/Gheri e Popescu - 2020 - A Formalized General Theory of Syntax with Binding.pdf}
}

@article{gheriFormalizedGeneralTheory2020a,
  title = {A {{Formalized General Theory}} of {{Syntax}} with {{Bindings}}: {{Extended Version}}},
  shorttitle = {A {{Formalized General Theory}} of {{Syntax}} with {{Bindings}}},
  author = {Gheri, Lorenzo and Popescu, Andrei},
  year = {2020},
  month = apr,
  journal = {Journal of Automated Reasoning},
  volume = {64},
  number = {4},
  pages = {641--675},
  issn = {1573-0670},
  doi = {10.1007/s10817-019-09522-2},
  urldate = {2025-02-10},
  abstract = {We present the formalization of a theory of syntax with bindings that has been developed and refined over the last decade to support several large formalization efforts. Terms are defined for an arbitrary number of constructors of varying numbers of inputs, quotiented to alpha-equivalence and sorted according to a binding signature. The theory contains a rich collection of properties of the standard operators on terms, including substitution, swapping and freshness---namely, there are lemmas showing how each of the operators interacts with all the others and with the syntactic constructors. The theory also features induction and recursion principles and support for semantic interpretation, all tailored for smooth interaction with the bindings and the standard operators.},
  langid = {english},
  keywords = {Artificial Intelligence,Isabelle/HOL,Recursion and induction principles,Syntax with bindings}
}

@incollection{gieslTerminationComplexityCompetition2019,
  title = {The {{Termination}} and {{Complexity Competition}}},
  booktitle = {Modeling {{Biomolecular Site Dynamics}}},
  author = {Giesl, J{\"u}rgen and Rubio, Albert and Sternagel, Christian and Waldmann, Johannes and Yamada, Akihisa},
  year = {2019},
  series = {Modeling {{Biomolecular Site Dynamics}}},
  pages = {156--166},
  publisher = {Springer New York},
  doi = {10.1007/978-3-030-17502-3_10}
}

@book{gieslTermRewritingApplications2005,
  ids = {gieslTermRewritingApplications2005a},
  title = {Term {{Rewriting}} and {{Applications}}, 16th {{International Conference}}, {{RTA}} 2005, {{Nara}}, {{Japan}}, {{April}} 19-21, 2005, {{Proceedings}}},
  editor = {Giesl, J{\"u}rgen},
  year = {2005},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {3467},
  publisher = {Springer},
  doi = {10.1007/b135673},
  isbn = {3-540-25596-6}
}

@article{gilbertFormalisingRealNumbers2016,
  title = {Formalising {{Real Numbers}} in {{Homotopy Type Theory}}},
  author = {Gilbert, G.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@book{gimenezTutorialCoInductive2007y,
  title = {A {{Tutorial}} on [{{Co-}}]{{Inductive Types}} in {{Coq}}},
  author = {Gim{\'e}nez, E. and Cast{\'e}ran, P.},
  year = {2007y}
}

@book{girardBlindSpotLectures2011,
  title = {The {{Blind Spot}}: {{Lectures}} on {{Logic}}},
  shorttitle = {The {{Blind Spot}}},
  author = {Girard, Jean-Yves},
  year = {2011},
  month = sep,
  edition = {1},
  publisher = {EMS Press},
  doi = {10.4171/088},
  urldate = {2024-07-30},
  isbn = {978-3-03719-088-3 978-3-03719-588-8},
  file = {/home/flaviomoura/Zotero/storage/XHNFQT9P/Girard - 2011 - The Blind Spot Lectures on Logic.pdf}
}

@article{girardLinearLogic1987,
  title = {Linear {{Logic}}},
  author = {Girard, J.-Y.},
  year = {1987},
  journal = {Theor. Comput. Sci.},
  volume = {50},
  pages = {1--102}
}

@book{girardProofsTypes1989,
  title = {Proofs and {{Types}}},
  author = {Girard, J.-Y. and Taylor, P. and Lafont, Y.},
  year = {1989},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {0-521-37181-3},
  file = {/home/flaviomoura/Zotero/storage/EH5C9SG7/Girard et al. - 1989 - Proofs and Types.pdf}
}

@book{girardProofTheoryLogical1987,
  title = {Proof Theory and Logical Complexity. 1},
  author = {Girard, Jean-Yves},
  year = {1987},
  series = {Studies in Proof Theory {{Monographs}}},
  number = {1},
  publisher = {Bibliopolis},
  address = {Napoli},
  isbn = {978-88-7088-123-3 978-0-444-98715-0},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SELWNNS8/Girard - 1987 - Proof theory and logical complexity. 1.pdf}
}

@misc{gladshteinSmallScaleReflection2024,
  title = {Small {{Scale Reflection}} for the {{Working Lean User}}},
  author = {Gladshtein, Vladimir and P{\^i}rlea, George and Sergey, Ilya},
  year = {2024},
  month = mar,
  number = {arXiv:2403.12733},
  eprint = {2403.12733},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2403.12733},
  urldate = {2024-03-20},
  abstract = {We present the design and implementation of the Small Scale Reflection proof methodology and tactic language (a.k.a. SSR) for the Lean 4 proof assistant. Like its Coq predecessor SSReflect, our Lean 4 implementation, dubbed LeanSSR, provides powerful rewriting principles and means for effective management of hypotheses in the proof context. Unlike SSReflect for Coq, LeanSSR does not require explicit switching between the logical and symbolic representation of a goal, allowing for even more concise proof scripts that seamlessly combine deduction steps with proofs by computation. In this paper, we first provide a gentle introduction to the principles of structuring mechanised proofs using LeanSSR. Next, we show how the native support for metaprogramming in Lean 4 makes it possible to develop LeanSSR entirely within the proof assistant, greatly improving the overall experience of both tactic implementers and proof engineers. Finally, we demonstrate the utility of LeanSSR by conducting two case studies: (a) porting a collection of Coq lemmas about sequences from the widely used Mathematical Components library and (b) reimplementing proofs in the finite set library of Lean's mathlib4. Both case studies show significant reduction in proof sizes.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Mathematical Software,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/GLRJK6RS/Gladshtein et al. - 2024 - Small Scale Reflection for the Working Lean User.pdf;/home/flaviomoura/Zotero/storage/ADI6I5CC/2403.html}
}

@book{glasman-dealScienceResearchWriting2010,
  title = {Science Research Writing for Non-Native Speakers of {{English}}},
  author = {{Glasman-Deal}, Hilary},
  year = {2010},
  publisher = {Imperial College Press},
  address = {London ; Hackensack, NJ},
  isbn = {978-1-84816-309-6 978-1-84816-310-2},
  lccn = {PE1475 .G57 2010},
  keywords = {English language,Handbooks manuals etc,Technical English,Technical writing,Textbooks for foreign speakers}
}

@book{goethalsMathematicsCyberResearch2022,
  title = {Mathematics in {{Cyber Research}}},
  author = {Goethals, Paul L. and Scala, Natalie M. and Bennett, Daniel T.},
  year = {2022},
  month = feb,
  publisher = {CRC Press},
  abstract = {In the last decade, both scholars and practitioners have sought novel ways to address the problem of cybersecurity. Innovative outcomes have included applications such as blockchain as well as creative methods for cyber forensics, software development, and intrusion prevention. Accompanying these technological advancements, discussion on cyber matters at national and international levels has focused primarily on the topics of law, policy, and strategy. The objective of these efforts is typically to promote security by establishing agreements among stakeholders on regulatory activities. Varying levels of investment in cyberspace, however, comes with varying levels of risk; in some ways, this can translate directly to the degree of emphasis for pushing substantial change.  At the very foundation or root of cyberspace systems and processes are tenets and rules governed by principles in mathematics. Topics such as encrypting or decrypting file transmissions, modeling networks, performing data analysis, quantifying uncertainty, measuring risk, and weighing decisions or adversarial courses of action represent a very small subset of activities highlighted by mathematics. To facilitate education and a greater awareness of the role of mathematics in cyber systems and processes, a description of research in this area is needed.  Mathematics in Cyber Research aims to familiarize educators and young researchers with the breadth of mathematics in cyber-related research. Each chapter introduces a mathematical sub-field, describes relevant work in this field associated with the cyber domain, provides methods and tools, as well as details cyber research examples or case studies. Features    One of the only books to bring together such a diverse and comprehensive range of topics within mathematics and apply them to cyber research.    Suitable for college undergraduate students or educators that are either interested in learning about cyber-related mathematics or intend to perform research within the cyber domain. The book may also appeal to practitioners within the commercial or government industry sectors.    Most national and international venues for collaboration and discussion on cyber matters have focused primarily on the topics of law, policy, strategy, and technology. This book is among the first to address the underpinning mathematics.},
  googlebooks = {1TlZEAAAQBAJ},
  isbn = {978-1-00-054271-4},
  langid = {english},
  keywords = {Business & Economics / Operations Research,Computers / Machine Theory,Computers / Security / Cryptography & Encryption,Mathematics / Applied,Mathematics / General,Mathematics / Graphic Methods,Mathematics / Number Systems,Mathematics / Probability & Statistics / Bayesian Analysis}
}

@misc{gogiosoTopologyCausality2023,
  title = {The {{Topology}} of {{Causality}}},
  author = {Gogioso, Stefano and Pinzani, Nicola},
  year = {2023},
  month = mar,
  number = {arXiv:2303.07148},
  eprint = {2303.07148},
  primaryclass = {quant-ph},
  publisher = {arXiv},
  urldate = {2023-03-14},
  abstract = {We provide a unified operational framework for the study of causality, non-locality and contextuality, in a fully device-independent and theory-independent setting. Our work has its roots in the sheaf-theoretic framework for contextuality by Abramsky and Brandenburger, which it extends to include arbitrary causal orders---be they definite, dynamical or indefinite. This paper is the second instalment in a trilogy: spaces of input histories, our dynamical generalisation of causal orders, were introduced in ``The Combinatorics of Causality'', while the polytopes formed by empirical models will be studied in ``The Geometry of Causality''.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory,Quantum Physics},
  file = {/home/flaviomoura/Zotero/storage/ARLWAUAQ/Gogioso e Pinzani - 2023 - The Topology of Causality.pdf}
}

@incollection{goguenEliminatingDependentPattern2006,
  title = {Eliminating {{Dependent Pattern Matching}}},
  booktitle = {Algebra, {{Meaning}}, and {{Computation}}},
  author = {Goguen, H. and McBride, C. and McKinna, J.},
  year = {2006},
  series = {Algebra, {{Meaning}}, and {{Computation}}},
  pages = {521--540},
  publisher = {Springer Nature},
  doi = {10.1007/11780274_27}
}

@article{goguenSequentCombinatorsHilbert2000,
  title = {Sequent Combinators: A {{Hilbert}} System for the Lambda Calculus},
  author = {Goguen, Healfdene and {Goubault-Larrecq}, Jean},
  year = {2000},
  journal = {Mathematical Structures in Computer Science},
  volume = {10},
  number = {1},
  pages = {1--79}
}

@article{goguenTheoremProvingAlgebra2021,
  title = {Theorem {{Proving}} and {{Algebra}}},
  author = {Goguen, Joseph A.},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.02690 [cs]},
  eprint = {2101.02690},
  primaryclass = {cs},
  urldate = {2021-01-08},
  abstract = {This book can be seen either as a text on theorem proving that uses techniques from general algebra, or else as a text on general algebra illustrated and made concrete by practical exercises in theorem proving. The book considers several different logical systems, including first-order logic, Horn clause logic, equational logic, and first-order logic with equality. Similarly, several different proof paradigms are considered. However, we do emphasize equational logic, and for simplicity we use only the OBJ3 software system, though it is used in a rather flexible manner. We do not pursue the lofty goal of mechanizing proofs like those of which mathematicians are justly so proud; instead, we seek to take steps towards providing mechanical assistance for proofs that are useful for computer scientists in developing software and hardware. This more modest goal has the advantage of both being achievable and having practical benefits. The following topics are covered: many-sorted signature, algebra and homomorphism; term algebra and substitution; equation and satisfaction; conditional equations; equational deduction and its completeness; deduction for conditional equations; the theorem of constants; interpretation and equivalence of theories; term rewriting, termination, confluence and normal form; abstract rewrite systems; standard models, abstract data types, initiality, and induction; rewriting and deduction modulo equations; first-order logic, models, and proof planning; second-order algebra; order-sorted algebra and rewriting; modules; unification and completion; and hidden algebra. In parallel with these are a gradual introduction to OBJ3, applications to group theory, various abstract data types (such as number systems, lists, and stacks), propositional calculus, hardware verification, the \{{\textbackslash}lambda\}-calculus, correctness of functional programs, and other topics.},
  archiveprefix = {arXiv},
  keywords = {68Q65 03B70 (Primary),Computer Science - Logic in Computer Science,Computer Science - Programming Languages,Computer Science - Symbolic Computation,F.1.1,F.3.1,F.3.2,F.4.1,I.1.3},
  file = {/home/flaviomoura/Zotero/storage/YWNSXNNH/Goguen - 2021 - Theorem Proving and Algebra.pdf;/home/flaviomoura/Zotero/storage/36WLU3AJ/2101.html}
}

@article{goldfarbUndecidabilitySecondOrderUnification1981,
  title = {The {{Undecidability}} of the {{Second-Order Unification Problem}}},
  author = {Goldfarb, W.},
  year = {1981},
  journal = {Theoretical Computer Science},
  volume = {13},
  number = {2},
  pages = {225--230}
}

@book{goldreiPropositionalPredicateCalculus2005,
  title = {Propositional and {{Predicate Calculus A Model}} of {{Argument}}},
  author = {Goldrei, D.},
  year = {2005},
  series = {Nil},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/1-84628-229-2}
}

@inproceedings{goldwasserAlmostAllPrimes1986,
  title = {Almost All Primes Can Be Quickly Certified},
  booktitle = {Annual {{ACM Symposium}} on the {{Theory}} of {{Computing}}},
  author = {Goldwasser, S. and Kilian, J.},
  year = {1986},
  pages = {316--329}
}

@inproceedings{gomesEmparelhamentoDesconexoNPCompleto2021,
  title = {{Emparelhamento Desconexo {\'e} NP-Completo}},
  booktitle = {{Anais do Encontro de Teoria da Computa{\c c}{\~a}o (ETC)}},
  author = {Gomes, Guilherme de C. M. and Masquio, Bruno P. and Pinto, Paulo E. D. and Santos, Vinicius F. and Szwarcfiter, Jayme L.},
  year = {2021},
  month = jul,
  pages = {26--29},
  publisher = {SBC},
  issn = {2595-6116},
  doi = {10.5753/etc.2021.16372},
  urldate = {2021-07-20},
  abstract = {A subsetset M {$\subseteq$} E of edges of a graph G = (V,E) is a matching if no two edges of M share a common vertex. Recently, subgraph-restricted matchings have been proposed, which require some properties from the subgraph induced by M-saturated vertices of G. We treat the disconnected matching problem, whose property is that the referred induced subgraph is disconnected. Although some efficient algorithms have already been shown for some classes, the complexity of the general problem remained opened. We present a proof that the disconnected matching is NP-complete, even for bipartite graphs with limited diameter.},
  copyright = {Copyright (c)},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/92S25F62/Gomes et al. - 2021 - Emparelhamento Desconexo Ã© NP-Completo.pdf}
}

@misc{goncharovAbstractOperationalMethods2024,
  title = {Abstract {{Operational Methods}} for {{Call-by-Push-Value}}},
  author = {Goncharov, Sergey and Tsampas, Stelios and Urbat, Henning},
  year = {2024},
  month = oct,
  number = {arXiv:2410.17045},
  eprint = {2410.17045},
  publisher = {arXiv},
  urldate = {2024-10-28},
  abstract = {Levy's call-by-push-value is a comprehensive programming paradigm that combines elements from functional and imperative programming, supports computational effects and subsumes both call-by-value and call-by-name evaluation strategies. In the present work, we develop modular methods to reason about program equivalence in call-by-push-value, and in fine-grain call-by-value, which is a popular lightweight call-by-value sublanguage of the former. Our approach is based on the fundamental observation that presheaf categories of sorted sets are suitable universes to model call-by-(push)-value languages, and that natural, coalgebraic notions of program equivalence such as applicative similarity and logical relations can be developed within. Starting from this observation, we formalize fine-grain call-by-value and call-by-push-value in the higher-order abstract GSOS framework, reduce their key congruence properties to simple syntactic conditions by leveraging existing theory and argue that introducing changes to either language incurs minimal proof overhead.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/SHEEKS82/Goncharov et al. - 2024 - Abstract Operational Methods for Call-by-Push-Valu.pdf;/home/flaviomoura/Zotero/storage/27G2LLVC/2410.html}
}

@misc{goncharovHigherOrderMathematicalOperational2024,
  title = {Higher-{{Order Mathematical Operational Semantics}}},
  author = {Goncharov, Sergey and Milius, Stefan and Schr{\"o}der, Lutz and Tsampas, Stelios and Urbat, Henning},
  year = {2024},
  month = may,
  number = {arXiv:2405.16708},
  eprint = {2405.16708},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.16708},
  urldate = {2024-05-29},
  abstract = {Compositionality proofs in higher-order languages are notoriously involved, and general semantic frameworks guaranteeing compositionality are hard to come by. In particular, Turi and Plotkin's bialgebraic abstract GSOS framework, which provides off-the-shelf compositionality results for first-order languages, so far does not apply to higher-order languages. In the present work, we develop a theory of abstract GSOS specifications for higher-order languages, in effect transferring the core principles of Turi and Plotkin's framework to a higher-order setting. In our theory, the operational semantics of higher-order languages is represented by certain dinatural transformations that we term {\textbackslash}emph\{(pointed) higher-order GSOS laws\}. We give a general compositionality result that applies to all systems specified in this way and discuss how compositionality of combinatory logics and the \${\textbackslash}lambda\$-calculus w.r.t.{\textbackslash} a strong variant of Abramsky's applicative bisimilarity are obtained as instances.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/NRPGP7BE/Goncharov et al. - 2024 - Higher-Order Mathematical Operational Semantics.pdf;/home/flaviomoura/Zotero/storage/LUDJL7YF/2405.html}
}

@article{goncharovRepresentingGuardednessCallByValue2023,
  title = {Representing {{Guardedness}} in {{Call-By-Value}}},
  author = {Goncharov, Sergey},
  year = {2023},
  abstract = {Like the notion of computation via (strong) monads serves to classify various flavours of impurity, including exceptions, non-determinism, probability, local and global store, the notion of guardedness classifies well-behavedness of cycles in various settings. In its most general form, the guardedness discipline applies to general symmetric monoidal categories and further specializes to Cartesian and co-Cartesian categories, where it governs guarded recursion and guarded iteration respectively. Here, even more specifically, we deal with the semantics of call-by-value guarded iteration. It was shown by Levy, Power and Thielecke that call-by-value languages can be generally interpreted in Freyd categories, but in order to represent effectful function spaces, such a category must canonically arise from a strong monad. We generalize this fact by showing that representing guarded effectful function spaces calls for certain parametrized monads (in the sense of Uustalu). This provides a description of guardedness as an intrinsic categorical property of programs, complementing the existing description of guardedness as a predicate on a category.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ISK5G7AD/Goncharov - 2023 - Representing Guardedness in Call-By-Value.pdf}
}

@book{gondimOsAtoresConhecidos2016,
  title = {Os {{Atores}} ({{Des}})Conhecidos Dos {{C{\'a}lculos}}},
  author = {Gondim, D. and Sapunaru, R. A.},
  year = {2016},
  publisher = {Editora Fi}
}

@inproceedings{gonthierAbstractStandardisationTheorem1992,
  title = {An Abstract Standardisation Theorem},
  booktitle = {Proceedings of the {{Seventh Annual Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}} '92), {{Santa Cruz}}, {{California}}, {{USA}}, {{June}} 22-25, 1992},
  author = {Gonthier, G. and L{\'e}vy, J.-J. and Melli{\`e}s, P.-A.},
  year = {1992},
  pages = {72--81},
  doi = {10.1109/LICS.1992.185521},
  keywords = {Arithmetic,Calculus,Stability},
  file = {/home/flaviomoura/Zotero/storage/KSHRZVXS/Gonthier et al. - 1992 - An abstract standardisation theorem.pdf;/home/flaviomoura/Zotero/storage/S8KRQAUB/185521.html}
}

@techreport{gonthierComputercheckedProofFour2008,
  title = {A Computer-Checked Proof of the {{Four Colour Theorem}}},
  author = {Gonthier, G.},
  year = {2008},
  institution = {Microsoft Research Cambridge}
}

@article{gonthierIntroductionSmallScale2010,
  title = {An Introduction to Small Scale Reflection in {{Coq}}},
  author = {Gonthier, Georges and Mahboubi, Assia},
  year = {2010},
  journal = {Journal of Formalized Reasoning},
  volume = {3},
  number = {2},
  pages = {95--152},
  issn = {1972-5787},
  doi = {10.6092/issn.1972-5787/1979},
  urldate = {2024-06-14},
  abstract = {This tutorial presents the SSReflect extension to the Coq system. This extension consists of an extension to the Coq language of script, and of a set of libraries, originating from the formal proof of the Four Color theorem. This tutorial proposes a guided tour in some of the basic libraries distributed in the SSReflect package. It focuses on the application of the small scale reflection methodology to the formalization of finite objects in intuitionistic type theory.},
  copyright = {Copyright (c) 2010 Georges Gonthier, Assia Mahboubi},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/UIGNIUX4/Gonthier e Mahboubi - 2010 - An introduction to small scale reflection in Coq.pdf}
}

@incollection{gonthierMachineCheckedProofOdd2013,
  title = {A {{Machine-Checked Proof}} of the {{Odd Order Theorem}}},
  booktitle = {Interactive {{Theorem Proving}}},
  author = {Gonthier, Georges and Asperti, Andrea and Avigad, Jeremy and Bertot, Yves and Cohen, Cyril and Garillot, Fran{\c c}ois and Le Roux, St{\'e}phane and Mahboubi, Assia and O'Connor, Russell and Ould Biha, Sidi and Pasca, Ioana and Rideau, Laurence and Solovyev, Alexey and Tassi, Enrico and Th{\'e}ry, Laurent},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Blazy, Sandrine and {Paulin-Mohring}, Christine and Pichardie, David},
  year = {2013},
  volume = {7998},
  pages = {163--179},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-39634-2_14},
  urldate = {2023-06-06},
  isbn = {978-3-642-39633-5 978-3-642-39634-2},
  file = {/home/flaviomoura/Zotero/storage/QZV5SABN/Gonthier et al. - 2013 - A Machine-Checked Proof of the Odd Order Theorem.pdf}
}

@inproceedings{gonthierModularFormalisationFinite2007,
  title = {A {{Modular Formalisation}} of {{Finite Group Theory}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Gonthier, Georges and Mahboubi, Assia and Rideau, Laurence and Tassi, Enrico and Th{\'e}ry, Laurent},
  editor = {Schneider, Klaus and Brandt, Jens},
  year = {2007},
  pages = {86--101},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-74591-4_8},
  abstract = {In this paper, we present a formalisation of elementary group theory done in Coq. This work is the first milestone of a long-term effort to formalise the Feit-Thompson theorem. As our further developments will heavily rely on this initial base, we took special care to articulate it in the most compositional way.},
  isbn = {978-3-540-74591-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/P7LAZLPH/Gonthier et al. - 2007 - A Modular Formalisation of Finite Group Theory.pdf}
}

@techreport{gonthierSsreflectTutorial2009,
  type = {Technical {{Report}}},
  title = {An {{Ssreflect Tutorial}}},
  author = {Gonthier, Georges and St{\'e}phane Le, Roux},
  year = {2009},
  number = {RT-0367},
  pages = {33},
  institution = {INRIA},
  keywords = {Coq,formal proofs,proof assistants,small scale reflection,tactics}
}

@book{gontijoAvaliacaoEmMatematica2020,
  title = {Avalia{\c c}{\~a}o Em Matem{\'a}tica: {{Contribui{\c c}{\~o}es}} Do Feedback Para as Aprendizagens},
  shorttitle = {Avalia{\c c}{\~a}o Em Matem{\'a}tica},
  year = {2020},
  month = sep,
  publisher = {Editora Universidade de Bras{\'i}lia},
  doi = {10.26512/9786558460367},
  urldate = {2023-04-07},
  abstract = {O livro "Avalia{\c c}{\~a}o em matem{\'a}tica: contribui{\c c}{\~o}es do feedback para as aprendizagens" tem como objetivo problematizar a tem{\'a}tica da avalia{\c c}{\~a}o, buscando evidenciar o papel do feedback fornecido pelo professor aos estudantes como suporte para as aprendizagens no campo da matem{\'a}tica. Ao enfatizar o feedback, explora um tema pouco presente na literatura sobre avalia{\c c}{\~a}o no campo da educa{\c c}{\~a}o matem{\'a}tica, ressaltando o seu potencial para a autorregula{\c c}{\~a}o e para o monitoramento das aprendizagens por parte dos estudantes. Discutir o papel da autoavalia{\c c}{\~a}o associada ao feedback na constru{\c c}{\~a}o da autonomia estudantil tamb{\'e}m {\'e} um dos objetivos dessa obra. Constitui-se por treze cap{\'i}tulos, sendo quatro dedicados a pesquisas no {\^a}mbito dos anos iniciais do ensino fundamental, outros quatro cap{\'i}tulos focalizando as pr{\'a}ticas avaliativas nos anos finais do ensino fundamental, tr{\^e}s t{\^e}m o ensino m{\'e}dio como campo de investiga{\c c}{\~a}o e dois cap{\'i}tulos analisam pr{\'a}ticas de avalia{\c c}{\~a}o na educa{\c c}{\~a}o superior. Ressalta-se que o livro {\'e} resultado de um esfor{\c c}o coletivo que nasceu em um espa{\c c}o privilegiado de produ{\c c}{\~a}o de conhecimento nos cursos de mestrado acad{\^e}mico e doutorado do Programa de P{\'o}s-Gradua{\c c}{\~a}o em Educa{\c c}{\~a}o da Universidade de Bras{\'i}lia, reunindo pesquisas de professores e estudantes. Espera-se que o seu conte{\'u}do contribua para o avan{\c c}o da pesquisa no campo da avalia{\c c}{\~a}o em matem{\'a}tica e colabore com a forma{\c c}{\~a}o dos professores e estudantes de gradua{\c c}{\~a}o e de p{\'o}s-gradua{\c c}{\~a}o acerca dessa tem{\'a}tica.},
  collaborator = {Gontijo, Cleyton H{\'e}rcules and de Oliveira, Deire L{\'u}cia and Costa, Ildenice Lima and Bezerra, Wescley Well Vicente},
  isbn = {9786558460367},
  file = {/home/flaviomoura/Zotero/storage/3AIMYFTY/Gontijo et al. - 2020 - AvaliaÃ§Ã£o em matemÃ¡tica ContribuiÃ§Ãµes do feedback.pdf}
}

@book{goodrich2006algorithm,
  title = {Algorithm Design: Foundation, Analysis and Internet Examples},
  author = {Goodrich, Michael T and Tamassia, Roberto},
  year = {2006},
  publisher = {John Wiley \& Sons}
}

@article{gordeevNP2020,
  title = {On {{P Versus NP}}},
  author = {Gordeev, Lev},
  year = {2020},
  month = dec,
  journal = {arXiv:2005.00809 [cs]},
  eprint = {2005.00809},
  primaryclass = {cs},
  urldate = {2020-12-31},
  abstract = {I generalize a well-known result that P = NP fails for monotone polynomial circuits - more precisely, that the clique problem CLIQUE(k{\textasciicircum}4,k) is not solvable by Boolean (AND,OR)-circuits of the size polynomial in k. In the other words, there is no Boolean (AND,OR)-formula F expressing that a given graph with k{\textasciicircum}4 vertices contains a clique of k elements, provided that the circuit length of F, cl(F), is polynomial in k. In fact, for any solution F in question, cl(F) must be exponential in k. Moreover this holds also for DeMorgan normal (abbr.: DMN) (AND,OR)-formulas F that allow negated variables. Based on the latter observation I consider an arbitrary (AND,OR,NOT)-formula F and recall that standard NOT-conversions to DMN at most double its circuit length. Hence for any Boolean solution F of CLIQUE(k{\textasciicircum}4,k), cl(F) is exponential in k. I conclude that CLIQUE(k{\textasciicircum}4,k) is not solvable by polynomial-size Boolean circuits, and hence P is not NP. The entire proof is formalizable by standard methods in the exponential function arithmetic EFA.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity},
  file = {/home/flaviomoura/Zotero/storage/6WHQLMLF/Gordeev - 2020 - On P Versus NP.pdf;/home/flaviomoura/Zotero/storage/F22UEIGN/2005.html}
}

@unpublished{gordeevNPPSPACE2016,
  title = {{{NP}} = {{PSPACE}}},
  author = {Gordeev, L. and Haeusler, E. H.},
  year = {2016}
}

@article{gordeevProofCompressionNp2019,
  title = {Proof {{Compression}} and {{Np Versus Pspace}}: {{Addendum}}},
  author = {Gordeev, Lev},
  year = {2019},
  journal = {CoRR},
  abstract = {We upgrade [1] to a complete proof of the conjecture NP = PSPACE. [1]: L. Gordeev, E. H. Haeusler, Proof Compression and NP Versus PSPACE, Studia Logica (107) (1): 55-83 (2019)}
}

@article{gordeevProofCompressionNP2020,
  title = {Proof {{Compression}} and {{NP Versus PSPACE II}}},
  author = {Gordeev, Lew and Haeusler, Edward Hermann},
  year = {2020},
  month = nov,
  journal = {Bulletin of the Section of Logic},
  volume = {49},
  number = {3},
  pages = {213--230},
  issn = {2449-836X},
  doi = {10.18778/0138-0680.2020.16},
  urldate = {2021-07-24},
  copyright = {Copyright (c) 2020},
  langid = {english},
  keywords = {computational complexity},
  file = {/home/flaviomoura/Zotero/storage/BZ8KPYPZ/Gordeev e Haeusler - 2020 - Proof Compression and NP Versus PSPACE II.pdf}
}

@inproceedings{gordonIntegrationHOLACL22006,
  title = {An {{Integration}} of {{HOL}} and {{ACL2}}},
  booktitle = {{{FMCAD}} '06: {{Proceedings}} of the {{Formal Methods}} in {{Computer Aided Design}}},
  author = {Gordon, Michael J. C. and Reynolds, James and Hunt, Warren A. and Kaufmann, Matt},
  year = {2006},
  pages = {153--160},
  publisher = {IEEE Computer Society},
  address = {Washington, DC, USA},
  doi = {http://dx.doi.org/10.1109/FMCAD.2006.6},
  isbn = {0-7695-2707-8}
}

@misc{gorrieriPlaceBisimilarityDecidable2023,
  title = {Place {{Bisimilarity}} Is {{Decidable}}, {{Indeed}}!},
  author = {Gorrieri, Roberto},
  year = {2023},
  month = mar,
  number = {arXiv:2104.01392},
  eprint = {2104.01392},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-03-09},
  abstract = {Place bisimilarity {$\sim$}p is a behavioral equivalence for finite Petri nets, originally proposed in [2], that, differently from all the other behavioral relations proposed so far, is not defined over the markings of a finite net, rather over its places, which are finitely many. Place bisimilarity {$\sim$}p was claimed decidable in [2], but its decidability was not really proved. We show that it is possible to decide {$\sim$}p with a simple algorithm, which essentially scans all the place relations (which are finitely many) to check whether they are place bisimulations. We also show that {$\sim$}p does respect the intended causal semantics of Petri nets, as it is finer than causal-net bisimilarity [19]. Moreover, we propose a slightly coarser variant, we call d-place bisimilarity {$\sim$}d , that we conjecture to be the coarsest equivalence, fully respecting causality and branching time (as it is finer than fully-concurrent bisimilarity [5]), to be decidable on finite Petri nets. Finally, two even coarser variants are discussed, namely i-place and i-d-place bisimilarities, which are still decidable, do preserve the concurrent behavior of Petri nets, but do not respect causality. These results open the way towards formal verification (by equivalence checking) of distributed systems modeled by finite Petri nets.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {68Q85,Computer Science - Logic in Computer Science,F.1.1},
  file = {/home/flaviomoura/Zotero/storage/JHBCDW58/Gorrieri - 2023 - Place Bisimilarity is Decidable, Indeed!.pdf}
}

@article{goubault-larrecqGeometryIntuitionisticS42003,
  title = {On the Geometry of Intuitionistic {{S4}} Proofs.},
  author = {{Goubault-Larrecq}, Jean, Goubault, {\'E}ric},
  year = {2003},
  journal = {Homology, Homotopy and Applications},
  volume = {5},
  number = {2},
  pages = {137--209},
  publisher = {International Press, Somerville},
  langid = {english},
  keywords = {Curry-Howard isomorphism,intuitionistic modal logic S4,lambda-calculus,monoidal comonad,presheaves,proofs-as-programs,resolution functors,semantics,simplicial sets,spaces of proofs,subcone categories}
}

@inproceedings{goubault-larrecqSimpleSequentSystem1999,
  title = {A {{Simple Sequent System}} for {{First-Order Logic}} with {{Free Constructors}}},
  booktitle = {Automated {{Reasoning}} with {{Analytic Tableaux}} and {{Related Methods}}, {{International Conference}}, {{TABLEAUX}} '99, {{Saratoga Springs}}, {{NY}}, {{USA}}, {{June}} 7-11, 1999, {{Proceedings}}},
  author = {{Goubault-Larrecq}, Jean},
  year = {1999},
  pages = {202--216},
  doi = {10.1007/3-540-48754-9_19}
}

@article{gouwProofPearlKey2014,
  title = {Proof {{Pearl}}: {{The Key To Correct}} and {{Stable Sorting}}},
  author = {de Gouw, Stijn and de Boer, Frank and Rot, Jurriaan},
  year = {2014},
  journal = {J Autom Reasoning},
  volume = {53},
  number = {2},
  pages = {129--139},
  doi = {10.1007/s10817-013-9300-y}
}

@misc{gowersConjectureMarton2023,
  title = {On a Conjecture of {{Marton}}},
  author = {Gowers, W. T. and Green, Ben and Manners, Freddie and Tao, Terence},
  year = {2023},
  month = nov,
  number = {arXiv:2311.05762},
  eprint = {2311.05762},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2023-12-05},
  abstract = {We prove a conjecture of K. Marton, widely known as the polynomial Freiman--Ruzsa conjecture, in characteristic \$2\$. The argument extends to odd characteristic, with details to follow in a subsequent paper.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Combinatorics,Mathematics - Number Theory},
  file = {/home/flaviomoura/Zotero/storage/2BDU5ZMW/Gowers et al. - 2023 - On a conjecture of Marton.pdf;/home/flaviomoura/Zotero/storage/BU8FKN8D/2311.html}
}

@book{grahamConcreteMathematicsFoundation2004,
  title = {Concrete Mathematics : A Foundation for Computer Science},
  author = {Graham, R. L. and Knuth, D. E. and Patashnik, O.},
  year = {2004},
  publisher = {Addison-Wesley},
  isbn = {0-201-55802-5},
  lccn = {[93040325]},
  file = {/home/flaviomoura/Zotero/storage/VUAKN5EF/Graham et al. - 2004 - Concrete mathematics  a foundation for computer s.pdf}
}

@article{gramlichModularityTermRewriting2012,
  title = {Modularity in {{Term Rewriting Revisited}}},
  author = {Gramlich, Bernhard},
  year = {2012},
  journal = {Theoretical Computer Science},
  volume = {464},
  number = {nil},
  pages = {3--19},
  doi = {10.1016/j.tcs.2012.09.008}
}

@book{granstromTreatiseIntuitionisticType2011,
  title = {Treatise on {{Intuitionistic Type Theory}}},
  author = {Granstr{\"o}m, Johan Georg and Granstr{\"o}m, Johan Georg},
  year = {2011},
  series = {Nil},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-94-007-1736-7}
}

@book{grassmannLogicDiscreteMathematics1996,
  title = {Logic and {{Discrete Mathematics}}: {{A Computer Science Perspective}}},
  author = {Grassmann, W. K. and Tremblay, J.-P.},
  year = {1996},
  publisher = {Prentice Hall Press},
  address = {Upper Saddle River, NJ, USA},
  isbn = {0-13-501206-6}
}

@book{greeneMathematicsAnalysisAlgorithms2007,
  title = {Mathematics for the {{Analysis}} of {{Algorithms}}: {{Modern Birkhuser Classics}}},
  author = {Greene, D. H. and Knuth, D. E.},
  year = {2007},
  edition = {3rd},
  publisher = {Birkh\&\#228;user Basel},
  isbn = {0-8176-4728-7 978-0-8176-4728-5},
  file = {/home/flaviomoura/Zotero/storage/SZJNHXM8/greenemathematicsanalysisalgorithms2007.pdf;/home/flaviomoura/Zotero/storage/XZQYXZPQ/Greene e Knuth - 2007 - Mathematics for the Analysis of Algorithms Modern.pdf}
}

@book{gregorychaitinGoedelWayExploits2011,
  title = {Goedel's {{Way}}: {{Exploits}} into an Undecidable World},
  author = {Gregory Chaitin, Francisco A Doria, Newton C.A. da Costa},
  year = {2011},
  publisher = {CRC Press},
  isbn = {0-415-69085-4 978-0-415-69085-0}
}

@book{griesLogicalApproachDiscrete1993,
  title = {A {{Logical Approach}} to {{Discrete Math}}},
  author = {Gries, D. and Schneider, F. B.},
  year = {1993},
  series = {Nil},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4757-3837-7}
}

@book{griesScienceProgramming1981,
  title = {The {{Science}} of {{Programming}}},
  author = {Gries, D.},
  year = {1981},
  series = {[]},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4612-5983-1}
}

@incollection{griffioenComparisonPVSIsabelle1998,
  title = {A Comparison of {{PVS}} and {{Isabelle}}/{{HOL}}},
  booktitle = {Lecture {{Notes}} in {{Computer Science}}},
  author = {Griffioen, David and Huisman, Marieke},
  year = {1998},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {123--142},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/bfb0055133}
}

@book{grifforHandbookComputabilityTheory1999,
  title = {Handbook of Computability Theory},
  author = {Griffor, E. R.},
  year = {1999},
  series = {Studies in Logic and the Foundations of Mathematics},
  publisher = {Elsevier},
  address = {Amsterdam},
  isbn = {0-444-89882-4}
}

@misc{grodinAmortizedAnalysisCoalgebra2024,
  title = {Amortized {{Analysis}} via {{Coalgebra}}},
  author = {Grodin, Harrison and Harper, Robert},
  year = {2024},
  month = apr,
  number = {arXiv:2404.03641},
  eprint = {2404.03641},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.03641},
  urldate = {2024-05-08},
  abstract = {Amortized analysis is a cost analysis technique for data structures in which cost is studied in aggregate, rather than considering the maximum cost of a single operation. Traditionally, amortized analysis has been phrased inductively, in terms of finite sequences of operations. Connecting to prior work on coalgebraic semantics for data structures, we develop the perspective that amortized analysis is naturally viewed coalgebraically in the category of algebras for a cost monad, where a morphism of coalgebras serves as a first-class generalization of potential function suitable for integrating cost and behavior. Using this simple definition, we consider amortization of other effects, such as randomization, and we compose amortization arguments in the indexed category of coalgebras. We generalize this to parallel data structure usage patterns by using coalgebras for an endoprofunctor instead of an endofunctor, combining potential using a monoidal structure on the underlying category. Finally, we adapt our discussion to the bicategorical setting, supporting imprecise amortized upper bounds.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Programming Languages,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/6DEHIQF2/Grodin and Harper - 2024 - Amortized Analysis via Coalgebra.pdf;/home/flaviomoura/Zotero/storage/2CJTSEJX/2404.html}
}

@inproceedings{grodinAmortizedAnalysisCoinduction2023,
  title = {Amortized {{Analysis}} via {{Coinduction}} ({{Early Ideas}})},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{CALCO}}.2023.23},
  author = {Grodin, Harrison and Harper, Robert},
  year = {2023},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.CALCO.2023.23},
  urldate = {2024-05-08},
  abstract = {Amortized analysis is a program cost analysis technique for data structures in which the cost of operations is specified in aggregate, under the assumption of continued sequential use. Typically, amortized analyses are presented inductively, in terms of finite sequences of operations. We give an alternative coinductive formulation and prove that it is equivalent to the standard inductive definition. We describe a classic amortized data structure, the batched queue, and outline a coinductive proof of its amortized efficiency in calf, a dependent type theory for cost analysis.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/R88KMK5W/Grodin and Harper - 2023 - Amortized Analysis via Coinduction (Early Ideas).pdf}
}

@article{grossmanProgramAuthorizedOffer,
  title = {Program {{Authorized}} to {{Offer Degree}}: {{Computer Science}} \& {{Engineering}}},
  author = {Grossman, Dan and Tatlock, Zachary and Bodik, Rastislav},
  pages = {164},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HV6K6L49/Grossman et al. - Program Authorized to Offer Degree Computer Scien.pdf}
}

@misc{grossScalableProofEngine2023,
  title = {Towards a {{Scalable Proof Engine}}: {{A Performant Prototype Rewriting Primitive}} for {{Coq}}},
  shorttitle = {Towards a {{Scalable Proof Engine}}},
  author = {Gross, Jason and Erbsen, Andres and Philipoom, Jade and Agrawal, Rajashree and Chlipala, Adam},
  year = {2023},
  month = may,
  number = {arXiv:2305.02521},
  eprint = {2305.02521},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-09},
  abstract = {We address the challenges of scaling verification efforts to match the increasing complexity and size of systems. We propose a research agenda aimed at building a performant proof engine by studying the asymptotic performance of proof engines and redesigning their building blocks. As a case study, we explore equational rewriting and introduce a novel prototype proof engine building block for rewriting in Coq, utilizing proof by reflection for enhanced performance. Our prototype implementation can significantly improve the development of verified compilers, as demonstrated in a case study with the Fiat Cryptography toolchain. The resulting extracted commandline compiler is about 1000{\texttimes} faster while featuring simpler compilerspecific proofs. This work lays some foundation for scaling verification efforts and contributes to the broader goal of developing a proof engine with good asymptotic performance, ultimately aimed at enabling the verification of larger and more complex systems.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/9DBWNQBM/Gross et al. - 2023 - Towards a Scalable Proof Engine A Performant Prot.pdf}
}

@book{gruberAlfredTarskiConcept2016,
  title = {Alfred {{Tarski}} and the "{{Concept}} of {{Truth}} in {{Formalized Languages}}"},
  author = {Gruber, M.},
  year = {2016},
  series = {Logic, {{Epistemology}}, and the {{Unity}} of {{Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-32616-0}
}

@article{gruetterLiveVerificationInteractive,
  title = {Live {{Verification}} in an {{Interactive Proof Assistant}}},
  author = {Gruetter, Samuel and Fukala, Viktor and Chlipala, Adam},
  volume = {8},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/E7YNDD4R/Gruetter et al. - Live Verification in an Interactive Proof Assistan.pdf}
}

@incollection{gueneauFistfulDollarsFormalizing2018,
  title = {A {{Fistful}} of {{Dollars}}: {{Formalizing Asymptotic Complexity Claims}} via {{Deductive Program Verification}}},
  shorttitle = {A {{Fistful}} of {{Dollars}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Gu{\'e}neau, Arma{\"e}l and Chargu{\'e}raud, Arthur and Pottier, Fran{\c c}ois},
  editor = {Ahmed, Amal},
  year = {2018},
  volume = {10801},
  pages = {533--560},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-89884-1_19},
  urldate = {2022-01-13},
  abstract = {We present a framework for simultaneously verifying the functional correctness and the worst-case asymptotic time complexity of higher-order imperative programs. We build on top of Separation Logic with Time Credits, embedded in an interactive proof assistant. We formalize the O notation, which is key to enabling modular specifications and proofs. We cover the subtleties of the multivariate case, where the complexity of a program fragment depends on multiple parameters. We propose a way of integrating complexity bounds into specifications, present lemmas and tactics that support a natural reasoning style, and illustrate their use with a collection of examples.},
  isbn = {978-3-319-89883-4 978-3-319-89884-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/6CG45HYR/GuÃ©neau et al. - 2018 - A Fistful of Dollars Formalizing Asymptotic Compl.pdf}
}

@article{guerrieriBangCalculusTwo2019,
  title = {The {{Bang Calculus}} and the {{Two Girard}}'s {{Translations}}},
  author = {Guerrieri, Giulio and Manzonetto, Giulio},
  year = {2019},
  journal = {CoRR},
  abstract = {We study the two Girard's translations of intuitionistic implication into linear logic by exploiting the bang calculus, a paradigmatic functional language with an explicit box-operator that allows both call-by-name and call-by-value lambda-calculi to be encoded in. We investigate how the bang calculus subsumes both call-by-name and call-by-value lambda-calculi from a syntactic and a semantic viewpoint.}
}

@article{guerrieriPostponementMathsfRaa2019,
  title = {Postponement of \$\${\textbackslash}mathsf \{raa\}\$\$ Raa and {{Glivenko}}'s {{Theorem}}, {{Revisited}}},
  author = {Guerrieri, Giulio and Naibo, Alberto},
  year = {2019},
  month = feb,
  journal = {Studia Logica},
  volume = {107},
  number = {1},
  pages = {109--144},
  issn = {0039-3215, 1572-8730},
  doi = {10.1007/s11225-017-9781-5},
  urldate = {2023-06-25},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/FTNC6D6K/Guerrieri e Naibo - 2019 - Postponement of $$mathsf raa $$ raa and Glivenko.pdf}
}

@inproceedings{guerrieriStandardizationCallByValueLambdaCalculus2015,
  title = {Standardization of a {{Call-By-Value Lambda-Calculus}}},
  booktitle = {13th {{International Conference}} on {{Typed Lambda Calculi}} and {{Applications}} ({{TLCA}} 2015)},
  author = {Guerrieri, G. and Paolini, L. and Rocca, S. Ronchi Della},
  editor = {Altenkirch, Thorsten},
  year = {2015},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  volume = {38},
  pages = {211--225},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address = {Dagstuhl, Germany},
  issn = {1868-8969},
  doi = {http://dx.doi.org/10.4230/LIPIcs.TLCA.2015.211},
  isbn = {978-3-939897-87-3}
}

@article{guerrieriStandardizationCallByValueLambdaCalculus2015a,
  title = {Standardization of a {{Call-By-Value Lambda-Calculus}}},
  author = {Guerrieri, Giulio and Paolini, Luca and Ronchi Della Rocca, Simona},
  year = {2015},
  pages = {15 pages},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany},
  doi = {10.4230/LIPICS.TLCA.2015.211},
  urldate = {2021-05-07},
  abstract = {We study an extension of Plotkin's call-by-value lambda-calculus by means of two commutation rules (sigma-reductions). Recently, it has been proved that this extended calculus provides elegant characterizations of many semantic properties, as for example solvability. We prove a standardization theorem for this calculus by generalizing Takahashi's approach of parallel reductions. The standardization property allows us to prove that our calculus is conservative with respect to the Plotkin's one. In particular, we show that the notion of solvability for this calculus coincides with that for Plotkin's call-by-value lambda-calculus.},
  collaborator = {Herbstritt, Marc},
  langid = {english},
  keywords = {000 Computer science knowledge general works,Computer Science},
  file = {/home/flaviomoura/Zotero/storage/9JSLVLHU/Guerrieri et al. - 2015 - Standardization of a Call-By-Value Lambda-Calculus.pdf}
}

@article{guerrieriStandardizationConservativityRefined2016,
  ids = {guerrieriStandardizationConservativityRefined2017},
  title = {Standardization and Conservativity of a Refined Call-by-Value Lambda-Calculus},
  author = {Guerrieri, G. and Paolini, L. and Rocca, S. Ronchi Della},
  year = {2016},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {03B40,68N18,Computer Science - Logic in Computer Science,D.3.1,F.3.2,F.4.1}
}

@book{guestConferencingPresentationEnglish2018,
  title = {Conferencing and {{Presentation English}} for {{Young Academics}}},
  author = {Guest, Michael},
  year = {2018},
  series = {Springer {{Texts}} in {{Education}}},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-2475-8}
}

@article{guidiStandardizationConfluencePure2012a,
  title = {Standardization and {{Confluence}} in {{Pure Lambda-Calculus Formalized}} for the {{Matita Theorem Prover}}},
  author = {Guidi, Ferruccio},
  year = {2012},
  month = dec,
  journal = {Journal of Formalized Reasoning},
  volume = {5},
  number = {1},
  pages = {1--25},
  issn = {1972-5787},
  doi = {10.6092/issn.1972-5787/3392},
  urldate = {2024-10-08},
  abstract = {We present a formalization of pure ?-calculus for the Matita interactive theorem prover, including the proofs of two relevant results in reduction theory: the confluence theorem and the standardization theorem. The proof of the latter is based on a new approach recently introduced by Xi and refined by Kashima that, avoiding the notion of development and having a neat inductive structure, is particularly suited for formalization in theorem provers.},
  copyright = {Copyright (c) 2012 Ferruccio Guidi},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ELFTTRA2/Guidi - 2012 - Standardization and Confluence in Pure Lambda-Calc.pdf}
}

@article{guillaumeCalculusDoesNot2000,
  title = {The {$\lambda$} {\emph{s}} {\textsubscript{ {\emph{e}} }} -Calculus Does Not Preserve Strong Normalisation},
  author = {Guillaume, Bruno},
  year = {2000},
  month = jul,
  journal = {Journal of Functional Programming},
  volume = {10},
  number = {4},
  pages = {321--325},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796800003695},
  urldate = {2023-09-08},
  abstract = {Kamareddine, F., \& R{\textasciiacute}{\i}os (1997) conjecture that the {$\lambda$}se-calculus preserves the strong normalisation of the {$\lambda$}-calculus. We prove here that this conjecture is false.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ADY9GGZN/Guillaume - 2000 - The Î» s  e  -calculus doe.pdf}
}

@misc{guillemetMachineCheckedCategoricalDiagrammatic2024,
  title = {Machine-{{Checked Categorical Diagrammatic Reasoning}}},
  author = {Guillemet, Beno{\^i}t and Mahboubi, Assia and Piquerez, Matthieu},
  year = {2024},
  month = feb,
  number = {arXiv:2402.14485},
  eprint = {2402.14485},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2402.14485},
  urldate = {2024-02-26},
  abstract = {This paper describes a formal proof library, developed using the Coq proof assistant, designed to assist users in writing correct diagrammatic proofs, for 1-categories. This library proposes a deep-embedded, domain-specific formal language, which features dedicated proof commands to automate the synthesis, and the verification, of the technical parts often eluded in the literature.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,G.4},
  file = {/home/flaviomoura/Zotero/storage/X3QK2HVV/Guillemet et al. - 2024 - Machine-Checked Categorical Diagrammatic Reasoning.pdf;/home/flaviomoura/Zotero/storage/XPAE34QW/2402.html}
}

@article{guoComprehensiveFormalizationPropositional2023,
  title = {A {{Comprehensive Formalization}} of {{Propositional Logic}} in {{Coq}}: {{Deduction Systems}}, {{Meta-Theorems}}, and {{Automation Tactics}}},
  shorttitle = {A {{Comprehensive Formalization}} of {{Propositional Logic}} in {{Coq}}},
  author = {Guo, Dakai and Yu, Wensheng},
  year = {2023},
  month = jan,
  journal = {Mathematics},
  volume = {11},
  number = {11},
  pages = {2504},
  publisher = {Multidisciplinary Digital Publishing Institute},
  issn = {2227-7390},
  doi = {10.3390/math11112504},
  urldate = {2024-03-23},
  abstract = {The increasing significance of theorem proving-based formalization in mathematics and computer science highlights the necessity for formalizing foundational mathematical theories. In this work, we employ the Coq interactive theorem prover to methodically formalize the language, semantics, and syntax of propositional logic, a fundamental aspect of mathematical reasoning and proof construction. We construct four Hilbert-style axiom systems and a natural deduction system for propositional logic, and establish their equivalences through meticulous proofs. Moreover, we provide formal proofs for essential meta-theorems in propositional logic, including the Deduction Theorem, Soundness Theorem, Completeness Theorem, and Compactness Theorem. Importantly, we present an exhaustive formal proof of the Completeness Theorem in this paper. To bolster the proof of the Completeness Theorem, we also formalize concepts related to mappings and countability, and deliver a formal proof of the Cantor--Bernstein--Schr{\"o}der theorem. Additionally, we devise automated Coq tactics explicitly designed for the propositional logic inference system delineated in this study, enabling the automatic verification of all tautologies, all internal theorems, and the majority of syntactic and semantic inferences within the system. This research contributes a versatile and reusable Coq library for propositional logic, presenting a solid foundation for numerous applications in mathematics, such as the accurate expression and verification of properties in software programs and digital circuits. This work holds particular importance in the domains of mathematical formalization, verification of software and hardware security, and in enhancing comprehension of the principles of logical reasoning.},
  copyright = {http://creativecommons.org/licenses/by/3.0/},
  langid = {english},
  keywords = {automated tactics,completeness theorem,Coq,formalization,Hilbert-style axiom system,natural deduction system,propositional logic,theorem proving},
  file = {/home/flaviomoura/Zotero/storage/MERCUK6I/Guo e Yu - 2023 - A Comprehensive Formalization of Propositional Log.pdf}
}

@misc{guoVerifiedCompletenessHenkinstyle2023,
  title = {Verified Completeness in {{Henkin-style}} for Intuitionistic Propositional Logic},
  author = {Guo, Huayu and Chen, Dongheng and Bentzen, Bruno},
  year = {2023},
  month = oct,
  number = {arXiv:2310.01916},
  eprint = {2310.01916},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-10-04},
  abstract = {This paper presents a formalization of the classical proof of completeness in Henkin-style developed by Troelstra and van Dalen for intuitionistic logic with respect to Kripke models. The completeness proof incorporates their insights in a fresh and elegant manner that is better suited for mechanization. We discuss details of our implementation in the Lean theorem prover with emphasis on the prime extension lemma and construction of the canonical model. Our implementation is restricted to a system of intuitionistic propositional logic with implication, conjunction, disjunction, and falsity given in terms of a Hilbert-style axiomatization. As far as we know, our implementation is the first verified Henkin-style proof of completeness for intuitionistic logic following Troelstra and van Dalen's method in the literature. The full source code can be found online at https://github.com/bbentzen/ipl.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/UDGLTMWR/Guo et al. - 2023 - Verified completeness in Henkin-style for intuitio.pdf;/home/flaviomoura/Zotero/storage/APCG7CRA/2310.html}
}

@book{gusfieldAlgorithmsStringsTrees1997,
  title = {Algorithms on {{Strings}}, {{Trees}}, and {{Sequences}}: {{Computer Science}} and {{Computational Biology}}},
  author = {Gusfield, D.},
  year = {1997},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {0-521-58519-8}
}

@misc{gutlebenSUBSETSUMCharacterisationAHierarchy2024,
  title = {A {{SUBSET-SUM Characterisation}} of the {{A-Hierarchy}}},
  author = {Gutleben, Jan and Meier, Arne},
  year = {2024},
  month = sep,
  number = {arXiv:2409.07996},
  eprint = {2409.07996},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2409.07996},
  urldate = {2024-09-13},
  abstract = {The A-hierarchy is a parametric analogue of the polynomial hierarchy in the context of paramterised complexity theory. We give a new characterisation of the A-hierarchy in terms of a generalisation of the SUBSET-SUM problem.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/25V62EL5/Gutleben e Meier - 2024 - A SUBSET-SUM Characterisation of the A-Hierarchy.pdf;/home/flaviomoura/Zotero/storage/IM2TJPKC/2409.html}
}

@article{gylterudMultisetsSetsHotmotopy2016,
  title = {From {{Multisets}} to {{Sets}} in {{Hotmotopy Type Theory}}},
  author = {Gylterud, H. Robbestad},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {03B15,03B70,03F65,F.4.1,Mathematics - Logic}
}

@article{gylterudMultisetsTypeTheory2016,
  title = {Multisets in {{Type Theory}}},
  author = {Gylterud, H. R.},
  year = {2016},
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages}
}

@book{haaparantaDevelopmentModernLogic2009,
  title = {The {{Development}} of {{Modern Logic}}},
  author = {Haaparanta, Leila},
  year = {2009},
  series = {[]},
  publisher = {Oxford University Press},
  doi = {10.1093/acprof:oso/9780195137316.001.0001}
}

@article{habermehlPresburgerArithmeticExtended2023,
  title = {On {{Presburger}} Arithmetic Extended with Non-Unary Counting Quantifiers},
  author = {Habermehl, Peter and Kuske, Dietrich},
  year = {2023},
  month = jul,
  journal = {Logical Methods in Computer Science},
  volume = {Volume 19, Issue 3},
  pages = {9329},
  issn = {1860-5974},
  doi = {10.46298/lmcs-19(3:4)2023},
  urldate = {2024-07-11},
  abstract = {We consider a first-order logic for the integers with addition. This logic extends classical first-order logic by modulo-counting, threshold-counting and exact-counting quantifiers, all applied to tuples of variables (here, residues are given as terms while moduli and thresholds are given explicitly). Our main result shows that satisfaction for this logic is decidable in two-fold exponential space. If only threshold- and exact-counting quantifiers are allowed, we prove an upper bound of alternating two-fold exponential time with linearly many alternations. This latter result almost matches Berman's exact complexity of first-order logic without counting quantifiers.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/33689QD8/Habermehl e Kuske - 2023 - On Presburger arithmetic extended with non-unary c.pdf}
}

@book{hackstaffSystemsFormalLogic1966,
  title = {Systems of {{Formal Logic}}},
  author = {Hackstaff, L. H.},
  year = {1966},
  series = {Nil},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-010-3547-7}
}

@misc{haeuplerFastSimpleSorting2024,
  title = {Fast and {{Simple Sorting Using Partial Information}}},
  author = {Haeupler, Bernhard and Hlad{\'i}k, Richard and Iacono, John and Rozhon, Vaclav and Tarjan, Robert and T{\v e}tek, Jakub},
  year = {2024},
  month = apr,
  number = {arXiv:2404.04552},
  eprint = {2404.04552},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-04-12},
  abstract = {We consider the problem of sorting a set of items having an unknown total order by doing binary comparisons of the items, given the outcomes of some pre-existing comparisons. We present a simple algorithm with a running time of \$O(m+n+{\textbackslash}log T)\$, where \$n\$, \$m\$, and \$T\$ are the number of items, the number of pre-existing comparisons, and the number of total orders consistent with the outcomes of the pre-existing comparisons, respectively. The algorithm does \$O({\textbackslash}log T)\$ comparisons. Our running time and comparison bounds are best possible up to constant factors, thus resolving a problem that has been studied intensely since 1976 (Fredman, Theoretical Computer Science). The best previous algorithm with a bound of \$O({\textbackslash}log T)\$ on the number of comparisons has a time bound of \$O(n{\textasciicircum}\{2.5\})\$ and is significantly more complicated. Our algorithm combines three classic algorithms: topological sort, heapsort with the right kind of heap, and efficient insertion into a sorted list.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Data Structures and Algorithms,F.2.2,G.2.2},
  file = {/home/flaviomoura/Zotero/storage/LRGGR6VA/Haeupler et al. - 2024 - Fast and Simple Sorting Using Partial Information.pdf;/home/flaviomoura/Zotero/storage/WBCZRTUF/2404.html}
}

@article{haeuslerAnotherArgumentFavour2020,
  title = {Yet Another Argument in Favour of {{NP}}={{CoNP}}},
  author = {Haeusler, Edward Hermann},
  year = {2020},
  month = dec,
  journal = {arXiv:2101.00003 [cs]},
  eprint = {2101.00003},
  primaryclass = {cs},
  urldate = {2021-01-05},
  abstract = {This article shows yet another proof of NP=CoNP\$. In a previous article, we proved that NP=PSPACE and from it we can conclude that NP=CoNP immediately. The former proof shows how to obtain polynomial and, polynomial in time checkable Dag-like proofs for all purely implicational Minimal logic tautologies. From the fact that Minimal implicational logic is PSPACE-complete we get the proof that NP=PSPACE. This first proof of NP=CoNP uses Hudelmaier linear upper-bound on the height of Sequent Calculus minimal implicational logic proofs. In an addendum to the proof of NP=PSPACE, we observe that we do not need to use Hudelmaier upper-bound since any proof of non-hamiltonicity for any graph is linear upper-bounded. By the CoNP-completeness of non-hamiltonicity, we obtain NP=CoNP as a corollary of the first proof. In this article we show the third proof of CoNP=NP, also providing polynomial size and polynomial verifiable certificates that are Dags. They are generated from normal Natural Deduction proofs, linear height upper-bounded too, by removing redundancy, i.e., repeated parts. The existence of repeated parts is a consequence of the redundancy theorem for a family of super-polynomial proofs in the purely implicational Minimal logic. It is mandatory to read at least two previous articles to get the details of the proof presented here. The article that proves the redundancy theorem and the article that shows how to remove the repeated parts of a normal Natural Deduction proof to have a polynomial Dag certificate for minimal implicational logic tautologies.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/T3XX4GTT/Haeusler - 2020 - Yet another argument in favour of NP=CoNP.pdf;/home/flaviomoura/Zotero/storage/JQH6SJFB/2101.html}
}

@article{haeuslerEverySuperpolynomialProof2015,
  title = {Every Super-Polynomial Proof in Purely Implicational Minimal Logic Has a Polynomially Sized Proof in Classical Implicational Propositional Logic},
  author = {Haeusler, E. H.},
  year = {2015},
  month = may,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science,F.2.2,F.4.1}
}

@article{haeuslerGoingHugeSmall2020,
  title = {Going from the Huge to the Small: {{Efficient}} Succinct Representation of Proofs in {{Minimal}} Implicational Logic},
  shorttitle = {Going from the Huge to the Small},
  author = {Haeusler, Edward Hermann},
  year = {2020},
  month = dec,
  journal = {arXiv:2012.07833 [cs]},
  eprint = {2012.07833},
  primaryclass = {cs},
  urldate = {2020-12-16},
  abstract = {A previous article shows that any linear height bounded normal proof of a tautology in the Natural Deduction for Minimal implicational logic \$M\_\{{\textbackslash}supset\}\$ is as huge as it is redundant. More precisely, any proof in a family of super-polynomially sized and linearly height bounded proofs have a sub-derivation that occurs super-polynomially many times in it. In this article, we show that by collapsing all the repeated sub-derivations we obtain a smaller structure, a rooted Directed Acyclic Graph (r-DAG), that is polynomially upper-bounded on the size of \${\textbackslash}alpha\$ and it is a certificate that \${\textbackslash}alpha\$ is a tautology that can be verified in polynomial time. In other words, for every huge proof of a tautology in \$M\_\{{\textbackslash}supset\}\$, we obtain a succinct certificate for its validity. Moreover, we show an algorithm able to check this validity in polynomial time on the certificate's size. Comments on how the results in this article are related to a proof of the conjecture \$NP=CoNP\$ appears in conclusion.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/K9A5XE9V/Haeusler - 2020 - Going from the huge to the small Efficient succin.pdf;/home/flaviomoura/Zotero/storage/LNC6T4AQ/2012.html}
}

@misc{haeuslerHorizontalCompressionDagderivations2022,
  title = {On the Horizontal Compression of Dag-Derivations in Minimal Purely Implicational Logic},
  author = {Haeusler, Edward Hermann and Junior, Jos{\'e} Fl{\'a}vio Cavalcante Barros},
  year = {2022},
  month = jul,
  number = {arXiv:2206.02300},
  eprint = {2206.02300},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {In this report, we define (plain) Dag-like derivations in the purely implicational fragment of minimal logic \$M\_\{{\textbackslash}imply\}\$. Introduce the horizontal collapsing set of rules and the algorithm \{{\textbackslash}bf HC\}. Explain why \{{\textbackslash}bf HC\} can transform any polynomial height-bounded tree-like proof of a \$M\_\{{\textbackslash}imply\}\$ tautology into a smaller dag-like proof. Sketch a proof that \{{\textbackslash}bf HC\} preserves the soundness of any tree-like ND in \$M\_\{{\textbackslash}imply\}\$ in its dag-like version after the horizontal collapsing application. We show some experimental results about applying the compression method to a class of (huge) propositional proofs and an example, with non-hamiltonian graphs, for qualitative analysis. The contributions include the comprehensive presentation of the set of horizontal compression (HC), the (sketch) of a proof that HC rules preserve soundness and the demonstration that the compressed dag-like proofs are polynomially upper-bounded when the submitted tree-like proof is height and foundation poly-bounded. Finally, in the appendix, we show an algorithm that verifies in polynomial time on the size of the dag-like proofs whether they are valid proofs of their conclusions.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/AFY9ALWG/Haeusler et al. - 2023 - On the horizontal compression of dag-derivations i.pdf;/home/flaviomoura/Zotero/storage/VUSCY7QP/Haeusler and Junior - 2022 - On the horizontal compression of dag-derivations i.pdf;/home/flaviomoura/Zotero/storage/H6GY636R/2206.html}
}

@misc{haeuslerHorizontalCompressionDagderivations2025,
  title = {On the Horizontal Compression of Dag-Derivations in Minimal Purely Implicational Logic},
  author = {Haeusler, Edward Hermann and Junior, Jos{\'e} Fl{\'a}vio Cavalcante Barros and Robinson},
  year = {2025},
  month = jan,
  number = {arXiv:2206.02300},
  eprint = {2206.02300},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2206.02300},
  urldate = {2025-02-03},
  abstract = {This report defines (plain) Dag-like derivations in the purely implicational fragment of minimal logic \$M\_\{{\textbackslash}supset\}\$. Introduce the horizontal collapsing set of rules and the algorithm \{{\textbackslash}bf HC\}. Explain why \{{\textbackslash}bf HC\} can transform any polynomial height-bounded tree-like proof of a \$M\_\{{\textbackslash}supset\}\$ tautology into a smaller dag-like proof. Sketch a proof that \{{\textbackslash}bf HC\} preserves the soundness of any tree-like ND in \$M\_\{{\textbackslash}supset\}\$ in its dag-like version after the horizontal collapsing application. We show some experimental results about applying the compression method to a class of (huge) propositional proofs and an example, with non-hamiltonian graphs, for qualitative analysis. The contributions include the comprehensive presentation of the set of horizontal compression (HC), the (sketch) of the proof that HC rules preserve soundness and the demonstration that the compressed dag-like proofs are polynomially upper-bounded when the submitted tree-like proof is height and foundation poly-bounded. Finally, in the appendix, we outline an algorithm that verifies in polynomial time on the size of the dag-like proofs whether they are valid proofs of their conclusions.In the conclusion we discuss what part of the formal results on the HC-compressed dag-like proofs have been proved with the use of Interactive Theorem Prover assistance.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/WYISLHHW/Haeusler et al. - 2025 - On the horizontal compression of dag-derivations in minimal purely implicational logic.pdf;/home/flaviomoura/Zotero/storage/KJCFERZB/2206.html}
}

@article{haeuslerHowManyTimes2015,
  title = {How {{Many Times Do We Need}} an {{Assumption To Prove}} a {{Tautology}} in {{Minimal Logic}}? {{Examples}} on the {{Compression Power}} of {{Classical Reasoning}}},
  author = {Haeusler, E. H.},
  year = {2015},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {315},
  number = {nil},
  pages = {31--46},
  doi = {10.1016/j.entcs.2015.06.004}
}

@article{haeuslerIntrinsicRedundancyHuge2020,
  title = {On the {{Intrinsic Redundancy}} in {{Huge Natural Deduction}} Proofs {{II}}: {{Analysing}} \${{M}}\_\{{\textbackslash}imply\}\$ {{Super-Polynomial Proofs}}},
  shorttitle = {On the {{Intrinsic Redundancy}} in {{Huge Natural Deduction}} Proofs {{II}}},
  author = {Haeusler, Edward Hermann},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.09802 [cs]},
  eprint = {2009.09802},
  primaryclass = {cs},
  urldate = {2020-09-24},
  abstract = {This article precisely defines huge proofs within the system of Natural Deduction for the Minimal implicational propositional logic {\textbackslash}mil. This is what we call an unlimited family of super-polynomial proofs. We consider huge families of expanded normal form mapped proofs, a device to explicitly help to count the E-parts of a normal proof in an adequate way. Thus, we show that for almost all members of a super-polynomial family there at least one sub-proof or derivation of each of them that is repeated super-polynomially many times. This last property we call super-polynomial redundancy. Almost all, precisely means that there is a size of the conclusion of proofs that every proof with conclusion bigger than this size and that is huge is highly redundant too. This result points out to a refinement of compression methods previously presented and an alternative and simpler proof that CoNP=NP.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/8L8YCL9K/Haeusler - 2020 - On the Intrinsic Redundancy in Huge Natural Deduct.pdf;/home/flaviomoura/Zotero/storage/H2XQ9CFN/2009.html}
}

@inproceedings{hajduRewritingInductiveReasoning,
  title = {Rewriting and {{Inductive Reasoning}}},
  booktitle = {Proceedings of 25th {{Conference}} on {{Logic}} for {{Programming}}, {{Artificial Intelligence}} and {{Reasoning}}},
  author = {Hajdu, Marton and Kov{\'a}cs, Laura and Rawson, Michael},
  pages = {278--260},
  doi = {10.29007/vbfp},
  urldate = {2024-09-10},
  abstract = {Rewriting techniques based on reduction orderings generate ``just enough'' consequences to retain first-order completeness. This is ideal for superposition-based first-order theorem proving, but for at least one approach to inductive reasoning we show that we are miss- ing crucial consequences. We therefore extend the superposition calculus with rewriting- based techniques to generate sufficient consequences for automating induction in satura- tion. When applying our work within the unit-equational fragment, our experiments with the theorem prover Vampire show significant improvements for inductive reasoning.},
  file = {/home/flaviomoura/Zotero/storage/3EVPG3FX/Hajdu et al. - Rewriting and Inductive Reasoning.pdf}
}

@misc{hajduRewritingInductiveReasoning2024,
  title = {Rewriting and {{Inductive Reasoning}}},
  author = {Hajdu, M{\'a}rton and Kov{\'a}cs, Laura and Rawson, Michael},
  year = {2024},
  month = feb,
  number = {arXiv:2402.19199},
  eprint = {2402.19199},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-04},
  abstract = {Rewriting techniques based on reduction orderings generate "just enough" consequences to retain first-order completeness. This is ideal for superposition-based first-order theorem proving, but for at least one approach to inductive reasoning we show that we are missing crucial consequences. We therefore extend the superposition calculus with rewriting-based techniques to generate sufficient consequences for automating induction in saturation. When applying our work within the unit-equational fragment, our experiments with the theorem prover Vampire show significant improvements for inductive reasoning.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/XM632IL8/Hajdu et al. - 2024 - Rewriting and Inductive Reasoning.pdf;/home/flaviomoura/Zotero/storage/X7TXAPSM/2402.html}
}

@inproceedings{halesFormalizingProofKepler2004,
  title = {Formalizing the {{Proof}} of the {{Kepler Conjecture}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}, 17th {{International Conference}}, {{TPHOLs}} 2004, {{Park City}}, {{Utah}}, {{USA}}, {{September}} 14-17, 2004, {{Proceedings}}},
  author = {Hales, Thomas C.},
  year = {2004},
  pages = {117},
  doi = {10.1007/978-3-540-30142-4_9}
}

@misc{halesFormalProofKepler2015,
  title = {A Formal Proof of the {{Kepler}} Conjecture},
  author = {Hales, Thomas and Adams, Mark and Bauer, Gertrud and Dang, Dat Tat and Harrison, John and Hoang, Truong Le and Kaliszyk, Cezary and Magron, Victor and McLaughlin, Sean and Nguyen, Thang Tat and Nguyen, Truong Quang and Nipkow, Tobias and Obua, Steven and Pleso, Joseph and Rute, Jason and Solovyev, Alexey and Ta, An Hoai Thi and Tran, Trung Nam and Trieu, Diep Thi and Urban, Josef and Vu, Ky Khac and Zumkeller, Roland},
  year = {2015},
  month = jan,
  number = {arXiv:1501.02155},
  eprint = {1501.02155},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2023-06-06},
  abstract = {This article describes a formal proof of the Kepler conjecture on dense sphere packings in a combination of the HOL Light and Isabelle proof assistants. This paper constitutes the official published account of the now completed Flyspeck project.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Metric Geometry},
  file = {/home/flaviomoura/Zotero/storage/CHSIPUTR/Hales et al. - 2015 - A formal proof of the Kepler conjecture.pdf}
}

@article{halesFormalProofKepler2015a,
  title = {A Formal Proof of the {{Kepler}} Conjecture},
  author = {Hales, T. and Adams, M. and Bauer, G. and Tat Dang, D. and Harrison, J. and Le Hoang, T. and Kaliszyk, C. and Magron, V. and McLaughlin, S. and Tat Nguyen, T. and Quang Nguyen, T. and Nipkow, T. and Obua, S. and Pleso, J. and Rute, J. and Solovyev, A. and Hoai Thi Ta, A. and Tran, T. N. and Thi Trieu, D. and Urban, J. and Khac Vu, K. and Zumkeller, R.},
  year = {2015},
  month = jan,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Metric Geometry}
}

@article{halesHistoricalOverviewKepler2006,
  title = {Historical {{Overview}} of the {{Kepler Conjecture}}},
  author = {Hales, Thomas C.},
  year = {2006},
  month = jul,
  journal = {Discrete \& Computational Geometry},
  volume = {36},
  number = {1},
  pages = {5--20},
  issn = {0179-5376, 1432-0444},
  doi = {10.1007/s00454-005-1210-2},
  urldate = {2023-06-06},
  abstract = {This paper is the first in a series of six papers devoted to the proof of the Kepler conjecture, which asserts that no packing of congruent balls in three dimensions has density greater than the face-centered cubic packing. After some preliminary comments about the face-centered cubic and hexagonal close packings, the history of the Kepler problem is described, including a discussion of various published bounds on the density of sphere packings. There is also a general historical discussion of various proof strategies that have been tried with this problem.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/8RBX8VCU/Hales - 2006 - Historical Overview of the Kepler Conjecture.pdf}
}

@article{halesProofKeplerConjecture2005,
  title = {A {{Proof}} of the {{Kepler Conjecture}}},
  author = {Hales, Thomas},
  year = {2005},
  journal = {Annals of Mathematics},
  volume = {162},
  number = {3},
  pages = {1065--1185},
  doi = {10.4007/annals.2005.162.1065},
  file = {/home/flaviomoura/Zotero/storage/JB9LEYCL/Hales - 2005 - A proof of the Kepler conjecture.pdf}
}

@book{hallQuantumTheoryMathematicians2013,
  title = {Quantum {{Theory}} for {{Mathematicians}}},
  author = {Hall, Brian C.},
  year = {2013},
  series = {Graduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-7116-5}
}

@book{halmosNaiveSetTheory1974,
  title = {Naive {{Set Theory}}},
  author = {Halmos, Paul R.},
  year = {1974},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4757-1645-0}
}

@inproceedings{hamana2017functional,
  title = {A Functional Implementation of Function-as-Constructor Higher-Order Unification},
  booktitle = {Proc. 31st International Workshop on Unification ({{UNIF}}'17)},
  author = {Hamana, Makoto},
  year = {2017}
}

@article{hamana2017prove,
  title = {How to Prove Your Calculus Is Decidable: Practical Applications of Second-Order Algebraic Theories and Computation},
  author = {Hamana, Makoto},
  year = {2017},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {1},
  number = {ICFP},
  pages = {1--28},
  publisher = {ACM New York, NY, USA}
}

@misc{hamidNearestNeighborsYou2023,
  title = {({{Nearest}}) {{Neighbors You Can Rely On}}: {{Formally Verified}} k-d {{Tree Construction}} and {{Search}} in {{Coq}}},
  shorttitle = {({{Nearest}}) {{Neighbors You Can Rely On}}},
  author = {Hamid, Nadeem Abdul},
  year = {2023},
  month = nov,
  number = {arXiv:2311.10965},
  eprint = {2311.10965},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-11-21},
  abstract = {The k-d tree is a classic binary space-partitioning tree used to organize points in k-dimensional space. While used in computational geometry and graphics, the data structure has a long history of application in nearest neighbor search. The objective of the nearest neighbor search problem is to efficiently find the closest point(s) to a given query point, and is the basis, in turn, of common machine learning techniques. We present in this paper a case study in the certified implementation, using the Coq proof assistant, of k-d tree construction from a set of data and the accompanying K-nearest neighbors search algorithm. Our experience demonstrates an intuitive method for specifying properties of these algorithms using the notion of list permutations.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Geometry,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/UKPJYT2Z/Hamid - 2023 - (Nearest) Neighbors You Can Rely On Formally Veri.pdf;/home/flaviomoura/Zotero/storage/AD6IAW3Y/2311.html}
}

@book{hanssonIntroductionFormalPhilosophy2018,
  title = {Introduction to {{Formal Philosophy}}},
  editor = {Hansson, Sven Ove and Hendricks, Vincent F.},
  year = {2018},
  series = {Springer {{Undergraduate Texts}} in {{Philosophy}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-77434-3},
  urldate = {2020-07-07},
  isbn = {978-3-319-77433-6 978-3-319-77434-3},
  langid = {english}
}

@book{hararyGraphTheoryDemand2018,
  title = {Graph {{Theory}} (on {{Demand Printing Of}} 02787)},
  author = {Harary, Frank},
  year = {2018},
  series = {[]},
  publisher = {CRC Press},
  doi = {10.1201/9780429493768}
}

@article{hardinProofTerminationRewriting1986,
  title = {Proof of Termination of the Rewriting System Subst on {{CCL}}},
  author = {Hardin, Th{\'e}r{\`e}se and Laville, Alain},
  year = {1986},
  journal = {Theor. Comput. Sci.},
  volume = {46},
  pages = {305--312},
  doi = {10.1016/0304-3975(86)90035-6}
}

@book{harelAlgorithmicsSpiritComputing2012,
  title = {Algorithmics: {{The Spirit}} of {{Computing}}},
  author = {Harel, David and Feldman, Yishai},
  year = {2012},
  edition = {3rd},
  publisher = {Springer Publishing Company, Incorporated},
  isbn = {3-642-27265-7 978-3-642-27265-3},
  file = {/home/flaviomoura/Zotero/storage/YSXBZLA5/Harel and Feldman - 2012 - Algorithmics The Spirit of Computing.pdf}
}

@article{harperEquationalLogicalFramework2021,
  title = {An {{Equational Logical Framework}} for {{Type Theories}}},
  author = {Harper, Robert},
  year = {2021},
  month = jun,
  journal = {arXiv:2106.01484 [cs, math]},
  eprint = {2106.01484},
  primaryclass = {cs, math},
  urldate = {2021-06-04},
  abstract = {A wide range of intuitionistic type theories may be presented as equational theories within a logical framework. This method was formulated by Per Martin-L{\textbackslash}"\{o\}f in the mid-1980's and further developed by Uemura, who used it to prove an initiality result for a class of models. Herein is presented a logical framework for type theories that includes an extensional equality type so that a type theory may be given by a signature of constants. The framework is illustrated by a number of examples of type-theoretic concepts, including identity and equality types, and a hierarchy of universes.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/5DUJEMAD/2106.html}
}

@article{harperMechanizingMetatheoryLogical2007,
  title = {Mechanizing Metatheory in a Logical Framework},
  author = {Harper, Robert and Licata, Daniel R},
  year = {2007},
  journal = {Journal of Functional Programming},
  volume = {17},
  number = {4-5},
  pages = {613--673},
  publisher = {Cambridge University Press}
}

@book{harperPracticalFoundationsProgramming2012,
  title = {Practical {{Foundations}} for {{Programming Languages}}},
  author = {Harper, R.},
  year = {2012},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {1-107-02957-0 978-1-107-02957-6},
  file = {/home/flaviomoura/Zotero/storage/SXLLS6FX/Harper - 2012 - Practical Foundations for Programming Languages.pdf}
}

@book{harrisCombinatoricsGraphTheory2008,
  title = {Combinatorics and {{Graph Theory}}},
  author = {Harris, J. and Hirst, J. L. and Mossinghoff, M.},
  year = {2008},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-0-387-79711-3}
}

@article{harrisonFrontMatterTable2019,
  title = {Front {{Matter}}, {{Table}} of {{Contents}}, {{Preface}}, {{Conference Organization}}},
  author = {Harrison, John and O'Leary, John and Tolmach, Andrew},
  year = {2019},
  pages = {14 pages, 308677 bytes},
  publisher = {[object Object]},
  issn = {1868-8969},
  doi = {10.4230/LIPICS.ITP.2019.0},
  urldate = {2024-04-17},
  abstract = {Front Matter, Table of Contents, Preface, Conference Organization},
  collaborator = {Harrison, John and O'Leary, John and Tolmach, Andrew},
  copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
  isbn = {9783959771221},
  langid = {english},
  keywords = {Conference Organization,Front Matter,Preface,Table of Contents,Theory of computation  Logic},
  file = {/home/flaviomoura/Zotero/storage/T67PMJL3/Harrison et al. - 2019 - Front Matter, Table of Contents, Preface, Conferen.pdf}
}

@incollection{harrisonHistoryInteractiveTheorem2014,
  title = {History of {{Interactive Theorem Proving}}},
  booktitle = {Computational {{Logic}}},
  author = {Harrison, John and Urban, Josef and Wiedijk, Freek},
  year = {2014},
  pages = {135--214},
  doi = {10.1016/B978-0-444-51624-4.50004-6},
  file = {/home/flaviomoura/Zotero/storage/SIUJWVTP/Harrison et al. - 2014 - History of Interactive Theorem Proving.pdf}
}

@article{harrisonPrefaceTwentyYears2016,
  title = {Preface: {{Twenty Years}} of the {{QED Manifesto}}},
  author = {Harrison, John and Urban, Josef and Wiedijk, Freek},
  year = {2016},
  journal = {J. Formalized Reasoning},
  volume = {9},
  number = {1},
  pages = {1--2},
  doi = {10.6092/issn.1972-5787/5974}
}

@misc{hasegawaBraidsTwistsTrace2024,
  title = {Braids, Twists, Trace and Duality in Combinatory Algebras},
  author = {Hasegawa, Masahito and Lechenne, Serge},
  year = {2024},
  month = may,
  eprint = {2405.10152},
  primaryclass = {cs},
  doi = {10.1145/3661814.3662098},
  urldate = {2024-05-17},
  abstract = {We investigate a class of combinatory algebras, called ribbon combinatory algebras, in which we can interpret both the braided untyped linear lambda calculus and framed oriented tangles. Any reflexive object in a ribbon category gives rise to a ribbon combinatory algebra. Conversely, From a ribbon combinatory algebra, we can construct a ribbon category with a reflexive object, from which the combinatory algebra can be recovered. To show this, and also to give the equational characterisation of ribbon combinatory algebras, we make use of the internal PRO construction developed in Hasegawa's recent work. Interestingly, we can characterise ribbon combinatory algebras in two different ways: as balanced combinatory algebras with a trace combinator, and as balanced combinatory algebras with duality.},
  archiveprefix = {arXiv},
  keywords = {03B40 (Primary) 18M15 68Q55 (Secondary),Computer Science - Logic in Computer Science,D.3.1,F.3.2},
  file = {/home/flaviomoura/Zotero/storage/56KACDTM/Hasegawa e Lechenne - 2024 - Braids, twists, trace and duality in combinatory a.pdf;/home/flaviomoura/Zotero/storage/YXG6VEWV/2405.html}
}

@article{hasegawaCategoricalReductionSystem2020,
  title = {A Categorical Reduction System for Linear Logic},
  author = {Hasegawa, Ryu},
  year = {2020},
  month = oct,
  journal = {arXiv:1912.00629 [cs]},
  eprint = {1912.00629},
  primaryclass = {cs},
  urldate = {2020-10-09},
  abstract = {Diagram chasing is not an easy task. The coherence holds in a generalized sense if we have a mechanical method to judge whether given two morphisms are equal to each other. A simple way to this end is to reform a concerned category into a calculus, where the instructions for the diagram chasing are given in the form of rewriting rules. We apply this idea to the categorical semantics of the linear logic. We build a calculus directly on the free category of the semantics. It enables us to perform diagram chasing as essentially one-way computations led by the rewriting rules. We verify the weak termination property of this calculus. This gives the first step towards the mechanization of diagram chasing.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/WI6A35IC/Hasegawa - 2020 - A categorical reduction system for linear logic.pdf;/home/flaviomoura/Zotero/storage/YURBRKKA/1912.html}
}

@article{hasegawaCompleteCallbyValueCalculi2021,
  title = {Complete {{Call-by-Value Calculi}} of {{Control Operators}}, {{I}}},
  author = {Hasegawa, Ryu},
  year = {2021},
  month = may,
  journal = {arXiv:1707.02056 [cs]},
  eprint = {1707.02056},
  primaryclass = {cs},
  urldate = {2021-05-04},
  abstract = {We give new call-by-value calculi of control operators that are complete for the continuation-passing style semantics. Various anticipated computational properties are induced from the completeness. In the first part of a series of papers, we give the characterization of termination properties using the continuation-passing style semantics as well as the union-intersection type discipline.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/M5CV6JCN/Hasegawa - 2021 - Complete Call-by-Value Calculi of Control Operator.pdf;/home/flaviomoura/Zotero/storage/UIZ7C6VQ/1707.html}
}

@book{havelMathematicalFoundationsComputer1992,
  title = {Mathematical {{Foundations}} of {{Computer Science}} 1992, 17th {{International Symposium}}, {{MFCS}}'92, {{Prague}}, {{Czechoslovakia}}, {{August}} 24-28, 1992, {{Proceedings}}},
  editor = {Havel, Ivan M. and Koubek, V{\'a}clav},
  year = {1992},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {629},
  publisher = {Springer},
  doi = {10.1007/3-540-55808-X},
  isbn = {3-540-55808-X}
}

@mastersthesis{havenAutomatedProofChecking2013,
  title = {Automated {{Proof Checking}} in {{Introductory Discrete Mathematics Classes}}},
  author = {Haven, A. J.},
  year = {2013},
  school = {Massachusetts Institute of Technology}
}

@article{hazenGentzenJaskowskiNatural2014,
  title = {Gentzen and {{Ja{\'s}kowski Natural Deduction}}: {{Fundamentally Similar}} but {{Importantly Different}}},
  shorttitle = {Gentzen and {{Ja{\'s}kowski Natural Deduction}}},
  author = {Hazen, Allen P. and Pelletier, Francis Jeffry},
  year = {2014},
  month = dec,
  journal = {Studia Logica},
  volume = {102},
  number = {6},
  pages = {1103--1142},
  issn = {0039-3215, 1572-8730},
  doi = {10.1007/s11225-014-9564-1},
  urldate = {2021-07-02},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XPKBHKJ9/Hazen e Pelletier - 2014 - Gentzen and JaÅkowski Natural Deduction Fundament.pdf}
}

@book{hazzanGuideTeachingComputer2014,
  title = {Guide to {{Teaching Computer Science}}},
  author = {Hazzan, Orit and Lapidot, Tami and Ragonis, Noa},
  year = {2014},
  publisher = {Springer London},
  address = {London},
  doi = {10.1007/978-1-4471-6630-6},
  urldate = {2020-07-07},
  isbn = {978-1-4471-6629-0 978-1-4471-6630-6},
  langid = {english}
}

@book{hedmanFirstCourseLogic2004,
  title = {A {{First Course}} in {{Logic}}: {{An Introduction}} to {{Model Theory}}, {{Proof Theory}}, {{Computability}}, and {{Complexity}} ({{Oxford Texts}} in {{Logic}})},
  author = {Hedman, S.},
  year = {2004},
  publisher = {Oxford University Press, Inc.},
  address = {New York, NY, USA},
  isbn = {0-19-852981-3}
}

@inproceedings{heijltjesIntuitionisticProofsSyntax2019,
  title = {Intuitionistic Proofs without Syntax},
  booktitle = {2019 34th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}})},
  author = {Heijltjes, Willem B. and Hughes, Dominic J. D. and StraBburger, Lutz},
  year = {2019},
  month = jun,
  pages = {1--13},
  publisher = {IEEE},
  address = {Vancouver, BC, Canada},
  doi = {10.1109/LICS.2019.8785827},
  urldate = {2021-06-10},
  abstract = {We present Intuitionistic Combinatorial Proofs (ICPs), a concrete geometric semantics of intuitionistic logic based on the principles of the second author's classical Combinatorial Proofs.},
  isbn = {978-1-72813-608-0},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IC4T8SDG/Heijltjes et al. - 2019 - Intuitionistic proofs without syntax.pdf}
}

@book{hein2011discrete,
  title = {Discrete Structures, Logic, and Computability},
  author = {Hein, James L},
  year = {2011},
  volume = {1},
  publisher = {{Jones and Bartlett}},
  file = {/home/flaviomoura/Zotero/storage/FGKHSHFJ/Hein - 2011 - Discrete structures, logic, and computability.pdf}
}

@book{hemlebenDiscreteMathematicsElementary2003,
  title = {Discrete {{Mathematics}}: {{Elementary}} and {{Beyond}}},
  author = {Hemleben, Ch L and Lovasz, Laszlo and Pelikan, Jozsef},
  year = {2003},
  publisher = {Springer-Verlag}
}

@article{hendtlassKakutaniFixedPoint2016,
  title = {Kakutani's Fixed Point Theorem in Constructive Mathematics},
  author = {Hendtlass, M.},
  year = {2016},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Logic}
}

@article{henkinCompletenessFirstOrderFunctional1949,
  title = {The {{Completeness}} of the {{First-Order Functional Calculus}}},
  author = {Henkin, L.},
  year = {1949},
  journal = {The Journal of Symbolic Logic},
  volume = {14},
  number = {03},
  pages = {159--166},
  doi = {10.2307/2267044}
}

@article{henkinDiscoveryMyCompleteness1996,
  title = {The {{Discovery}} of {{My Completeness Proofs}}},
  author = {Henkin, L.},
  year = {1996},
  journal = {Bull. symb. log.},
  volume = {2},
  number = {02},
  pages = {127--158},
  doi = {10.2307/421107}
}

@book{henzingerJointMeetingTwentyThird2014,
  title = {Joint {{Meeting}} of the {{Twenty-Third EACSL Annual Conference}} on {{Computer Science Logic}} ({{CSL}}) and the {{Twenty-Ninth Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}}), {{CSL-LICS}} '14, {{Vienna}}, {{Austria}}, {{July}} 14 - 18, 2014},
  editor = {Henzinger, T. A. and Miller, D.},
  year = {2014},
  publisher = {ACM},
  isbn = {978-1-4503-2886-9}
}

@unpublished{herbelinAnalysisConstructiveContent2016,
  title = {An Analysis of the Constructive Content of {{Henkin}}'s Proof of {{G{\"o}del}} Completeness Theorem},
  author = {Herbelin, H. and Ilik, D.},
  year = {2016}
}

@article{herbelinExplicitSubstitutionsReducibility2001,
  title = {Explicit {{Substitutions}} and {{Reducibility}}},
  author = {Herbelin, H.},
  year = {2001},
  journal = {Journal of Logic and Computation},
  volume = {11},
  number = {3},
  pages = {431--451},
  doi = {10.1093/logcom/11.3.431}
}

@inproceedings{herbelinLambdaCalculusStructureIsomorphic1995,
  title = {A {{Lambda-Calculus Structure Isomorphic}} to {{Gentzen-Style Sequent Calculus Structure}}},
  booktitle = {The 8th {{Int}}. {{Workshop}} on {{Computer Science Logic}} ({{CSL}})},
  author = {Herbelin, H.},
  year = {1995},
  series = {{{LNCS}}},
  volume = {933},
  pages = {61--75}
}

@misc{herbelinLogicalStructureMaximality2024,
  title = {On the Logical Structure of Some Maximality and Well-Foundedness Principles Equivalent to Choice Principles},
  author = {Herbelin, Hugo},
  year = {2024},
  month = may,
  number = {arXiv:2405.09946},
  eprint = {2405.09946},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.09946},
  urldate = {2024-05-17},
  abstract = {We study the logical structure of Teichm\{{\textbackslash}"u\}ller-Tukey lemma, a maximality principle equivalent to the axiom of choice and show that it corresponds to the generalisation to arbitrary cardinals of update induction, a well-foundedness principle from constructive mathematics classically equivalent to the axiom of dependent choice.From there, we state general forms of maximality and well-foundedness principles equivalent to the axiom of choice, including a variant of Zorn's lemma. A comparison with the general class of choice and bar induction principles given by Brede and the first author is initiated.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/69L6CC5Y/Herbelin - 2024 - On the logical structure of some maximality and we.pdf;/home/flaviomoura/Zotero/storage/NG5FJ7JV/2405.html}
}

@article{hetzlFixedpointTheoremHorn2021,
  title = {A {{Fixed-point Theorem}} for {{Horn Formula Equations}}},
  author = {Hetzl, Stefan and Kloibhofer, Johannes},
  year = {2021},
  month = sep,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {344},
  eprint = {2109.04633},
  pages = {65--78},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.344.5},
  urldate = {2021-09-20},
  abstract = {We consider constrained Horn clause solving from the more general point of view of solving formula equations. Constrained Horn clauses correspond to the subclass of Horn formula equations. We state and prove a fixed-point theorem for Horn formula equations which is based on expressing the fixed-point computation of a minimal model of a set of Horn clauses on the object level as a formula in first-order logic with a least fixed point operator. We describe several corollaries of this fixed-point theorem, in particular concerning the logical foundations of program verification, and sketch how to generalise it to incorporate abstract interpretations.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/L9H4GYRC/Hetzl and Kloibhofer - 2021 - A Fixed-point Theorem for Horn Formula Equations.pdf;/home/flaviomoura/Zotero/storage/GGADDCPW/2109.html}
}

@article{hewerQuotientPolymorphism,
  title = {Quotient {{Polymorphism}}},
  author = {Hewer, Brandon and Hutton, Graham},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WFTYFZU6/Hewer e Hutton - Quotient Polymorphism.pdf}
}

@inproceedings{hilaireStateoftheArtKarpMillerAlgorithm2024,
  title = {A {{State-of-the-Art Karp-Miller Algorithm Certified}} in {{Coq}}},
  booktitle = {Tools and {{Algorithms}} for the {{Construction}} and {{Analysis}} of {{Systems}}},
  author = {Hilaire, Thibault and Ilcinkas, David and Leroux, J{\'e}r{\^o}me},
  editor = {Finkbeiner, Bernd and Kov{\'a}cs, Laura},
  year = {2024},
  pages = {370--389},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-57246-3_21},
  abstract = {Petri nets constitute a well-studied model to verify and study concurrent systems, among others, and computing the coverability set is one of the most fundamental problems about Petri nets. Using the proof assistant Coq, we certified the correctness and termination of the MinCov algorithm by Finkel, Haddad, and Khmelnitsky (FOSSACS 2020). This algorithm is the most recent algorithm in the literature that computes the minimal basis of the coverability set, a problem known to be prone to subtle bugs. Apart from the intrinsic interest of a computer-checked proof, our certification provides new insights on the MinCov algorithm. In particular, we introduce as an intermediate algorithm a small-step variant of MinCov of independent interest.},
  isbn = {978-3-031-57246-3},
  langid = {english},
  keywords = {Certified decision procedure,Coq,Karp-Miller tree algorithm,Minimal coverability set,Petri net},
  file = {/home/flaviomoura/Zotero/storage/QFLQU2R3/Hilaire et al. - 2024 - A State-of-the-Art Karp-Miller Algorithm Certified.pdf}
}

@book{hindley2008lambda,
  title = {Lambda-Calculus and Combinators, an Introduction},
  author = {Hindley, J Roger and Seldin, Jonathan P},
  year = {2008},
  volume = {13},
  publisher = {Cambridge University Press Cambridge}
}

@book{hindleyBasicSimpleType1997,
  title = {Basic Simple Type Theory},
  author = {Hindley, J. Roger},
  year = {1997},
  series = {Cambridge {{Tracts}} in {{Theoretical Computer Science}}},
  number = {42},
  publisher = {Cambridge University Press},
  file = {/home/flaviomoura/Zotero/storage/Q3HT4VN6/hindley1997.pdf}
}

@article{hindleyReductionsResidualsAre1978,
  title = {Reductions of Residuals Are Finite},
  author = {Hindley, J. R.},
  year = {1978},
  journal = {Transactions of the American Mathematical Society},
  volume = {240},
  pages = {345--361}
}

@book{hinzTowerHanoiMyths2013,
  title = {The {{Tower}} of {{Hanoi}} -- {{Myths}} and {{Maths}}},
  author = {Hinz, Andreas M. and Klav{\v z}ar, Sandi and Milutinovi{\'c}, Uro{\v s} and Petr, Ciril},
  year = {2013},
  publisher = {Springer Basel},
  address = {Basel},
  doi = {10.1007/978-3-0348-0237-6},
  urldate = {2023-06-23},
  isbn = {978-3-0348-0236-9 978-3-0348-0237-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/28LYDQCJ/hinz2013.pdf;/home/flaviomoura/Zotero/storage/FTQUKHDE/Hinz et al. - 2013 - The Tower of Hanoi â Myths and Maths.pdf}
}

@article{hiraiBalancingWeightBalancedTrees2011,
  title = {Balancing {{Weight-Balanced Trees}}},
  author = {HIRAI, {\relax YOICHI} and YAMAMOTO, {\relax KAZUHIKO}},
  year = {2011},
  journal = {Journal of Functional Programming},
  volume = {21},
  number = {3},
  pages = {287--307},
  doi = {10.1017/s0956796811000104}
}

@inproceedings{hitarthLinearLoopSynthesis2024,
  title = {Linear {{Loop Synthesis}} for {{Quadratic Invariants}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{STACS}}.2024.41},
  author = {Hitarth, S. and Kenison, George and Kov{\'a}cs, Laura and Varonka, Anton},
  year = {2024},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.STACS.2024.41},
  urldate = {2024-09-10},
  abstract = {Invariants are key to formal loop verification as they capture loop properties that are valid before and after each loop iteration. Yet, generating invariants is a notorious task already for syntactically restricted classes of loops. Rather than generating invariants for given loops, in this paper we synthesise loops that exhibit a predefined behaviour given by an invariant. From the perspective of formal loop verification, the synthesised loops are thus correct by design and no longer need to be verified.  To overcome the hardness of reasoning with arbitrarily strong invariants, in this paper we construct simple (non-nested) while loops with linear updates that exhibit polynomial equality invariants. Rather than solving arbitrary polynomial equations, we consider loop properties defined by a single quadratic invariant in any number of variables. We present a procedure that, given a quadratic equation, decides whether a loop with affine updates satisfying this equation exists. Furthermore, if the answer is positive, the procedure synthesises a loop and ensures its variables achieve infinitely many different values.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/N46TBHH9/Hitarth et al. - 2024 - Linear Loop Synthesis for Quadratic Invariants.pdf}
}

@article{hofmannTypeBasedAnalysisLogarithmic2021,
  title = {Type-{{Based Analysis}} of {{Logarithmic Amortised Complexity}}},
  author = {Hofmann, Martin and Leutgeb, Lorenz and Moser, Georg and Obwaller, David and Zuleger, Florian},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.12029 [cs]},
  eprint = {2101.12029},
  primaryclass = {cs},
  urldate = {2021-01-29},
  abstract = {We introduce a novel amortised resource analysis couched in a type-and-effect system. Our analysis is formulated in terms of the physicist's method of amortised analysis, and is potential-based. The type system makes use of logarithmic potential functions and is the first such system to exhibit *logarithmic amortised complexity*. With our approach we target the automated analysis of self-adjusting data structures, like splay trees, which so far have only manually been analysed in the literature. In particular, we have implemented a semi-automated prototype, which successfully analyses the zig-zig case of *splaying*, once the type annotations are fixed.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.3.2},
  file = {/home/flaviomoura/Zotero/storage/MZ4894NB/Hofmann et al. - 2021 - Type-Based Analysis of Logarithmic Amortised Compl.pdf;/home/flaviomoura/Zotero/storage/I9ZYADYT/2101.html}
}

@misc{holeConstructibilityComputationalComplexity2024,
  title = {Constructibility, Computational Complexity and {{P}} versus {{NP}}},
  author = {Hole, Arne},
  year = {2024},
  month = nov,
  number = {arXiv:2406.16843},
  eprint = {2406.16843},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2406.16843},
  urldate = {2024-11-05},
  abstract = {If an algorithm is to be counted as a practically working solution to a decision problem, then the algorithm must must verifiable in some constructed and ``trusted'' theory such as PA or ZF. In this paper, a class of decision problems related to inconsistency proofs for a general class of formal theories is used to demonstrate that under this constructibility restriction, there are plausible arguments for the existence of decision problems which can be proved formally to be in NP, and for which there exists an explicitly constructible algorithm recognizing correct solutions in polynomial time, but for which there exists no explicitly constructible, verifiable solution algorithm. While these arguments do not solve the P versus NP problem in the classical sense of supplying a proof one way or the other in a ``trusted'' formal theory, arguably they resolve a constructive version of it.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/WBEFWAV2/Hole - 2024 - Constructibility, computational complexity and P v.pdf;/home/flaviomoura/Zotero/storage/DREZIUJQ/2406.html}
}

@article{homeierProofChurchRosserTheorem,
  title = {A {{Proof}} of the {{Church-Rosser Theorem}} for the {{Lambda Calculus}} in {{Higher Order Logic}}},
  author = {Homeier, Peter V},
  abstract = {This paper describes a proof of the Church-Rosser theorem within the Higher Order Logic (HOL) theorem prover. This follows the proof by Tait/Martin-L{\textasciidieresis}of, preserving the elegance of the classic presentation by Barendregt. We model the lambda calculus with a name-carrying syntax, as in practical languages. The proof is simplified by forming a quotient of the name-carrying syntax by the {$\alpha$}-equivalence relation, thus separating the concerns of {$\alpha$}-equivalence and {$\beta$}-reduction.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HIAG622A/Homeier - A Proof of the Church-Rosser Theorem for the Lambd.pdf}
}

@article{hondaConfluenceProofsLambdaMuCalculi2021,
  title = {Confluence {{Proofs}} of {{Lambda-Mu-Calculi}} by {{Z Theorem}}},
  author = {Honda, Yuki and Nakazawa, Koji and Fujita, Ken-etsu},
  year = {2021},
  month = oct,
  journal = {Studia Logica},
  volume = {109},
  number = {5},
  pages = {917--936},
  issn = {1572-8730},
  doi = {10.1007/s11225-020-09931-0},
  urldate = {2024-10-08},
  abstract = {This paper applies Dehornoy et al.'s Z theorem and its variant, called the compositional Z theorem, to prove confluence of Parigot's \$\${\textbackslash}lambda {\textbackslash}mu \$\$-calculi extended by the simplification rules. First, it is proved that Baba et al.'s modified complete developments for the call-by-name and the call-by-value variants of the \$\${\textbackslash}lambda {\textbackslash}mu \$\$-calculus with the renaming rule, which is one of the simplification rules, satisfy the Z property. It gives new confluence proofs for them by the Z theorem. Secondly, it is shown that the compositional Z theorem can be applied to prove confluence of the call-by-name and the call-by-value \$\${\textbackslash}lambda {\textbackslash}mu \$\$-calculi with both simplification rules, the renaming and the \$\${\textbackslash}mu {\textbackslash}eta \$\$-rules, whereas it is hard to apply the ordinary parallel reduction technique or the original Z theorem by one-pass definition of mappings for these variants.},
  langid = {english},
  keywords = {Confluence,Lambda calculus,Lambda-mu calculus,Permutative conversion},
  file = {/home/flaviomoura/Zotero/storage/KQFMDENC/Honda et al. - 2021 - Confluence Proofs of Lambda-Mu-Calculi by Z Theore.pdf}
}

@article{hondetEncodingPredicateSubtyping2020,
  title = {Encoding of {{Predicate Subtyping}} with {{Proof Irrelevance}} in the {{$\lambda\Pi$-Calculus Modulo Theory}}},
  author = {Hondet, Gabriel},
  year = {2020},
  pages = {18},
  abstract = {The {$\lambda\Pi$}-calculus modulo theory is a logical framework in which various logics and type systems can be encoded, thus helping the cross-verification and interoperability of proof systems based on those logics and type systems. In this paper, we show how to encode predicate subtyping and proof irrelevance, two important features of the PVS proof assistant. We prove that this encoding is correct and that encoded proofs can be mechanically checked by Dedukti, a type checker for the {$\lambda\Pi$}-calculus modulo theory using rewriting.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/REHTKS2V/Hondet - 2020 - Encoding of Predicate Subtyping with Proof Irrelev.pdf}
}

@article{hooverBatandballProblemStronger2019,
  title = {The Bat-and-Ball Problem: {{Stronger}} Evidence in Support of a Conscious Error Process.},
  shorttitle = {The Bat-and-Ball Problem},
  author = {Hoover, Jerome D. and Healy, Alice F.},
  year = {2019},
  month = oct,
  journal = {Decision},
  volume = {6},
  number = {4},
  pages = {369--380},
  issn = {2325-9973, 2325-9965},
  doi = {10.1037/dec0000107},
  urldate = {2023-03-15},
  abstract = {Traditional accounts of reasoning have characterized human error response to be an unconscious process whereby cognitive misers blindly neglect the critical information that would lead to problem solution, thereby substituting an easier problem for the actual problem (e.g., Kahneman \& Frederick, 2002). For the bat-and-ball problem, the unconscious substitution hypothesis is challenged on two fronts in the present study: (1) testing for conscious representation of the errorinducing semantic content of the problem (i.e., the ``more than'' phrase, ``The bat costs \$1.00 more than the ball.''); and (2) comparing experimentally response confidence differences between standard versions of the problem and isomorphic controls (without that phrase) to verify postdecision sensitivity to the errors, following De Neys, Rossi, and Houd{\'e} (2013). Crucially, even when interference questions were included between testing and memory response, incorrect reasoners largely had accurate recall and recognition of the problem's error inducing phrase. Incorrect reasoners' intra-individual error sensitivity was replicated and extended via the introduction of a social-metacognitive measurement, which was found to be correlated with intraindividual post-decision confidence and also yielded an error sensitivity effect. Finally, latency responses verify the relationship between time spent reasoning and post-decision confidence. Implications and future directions are discussed.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WUQTIGPQ/Hoover e Healy - 2019 - The bat-and-ball problem Stronger evidence in sup.pdf}
}

@misc{horiCutEliminationPropositional2024,
  title = {Cut Elimination for Propositional Cyclic Proof Systems with Fixed-Point Operators},
  author = {Hori, Hiromasa and Nakazawa, Koji and Tatsuta, Makoto},
  year = {2024},
  month = oct,
  number = {arXiv:2312.12792},
  eprint = {2312.12792},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2312.12792},
  urldate = {2024-10-30},
  abstract = {Infinitary and cyclic proof systems are proof systems for logical formulas with fixed-point operators or inductive definitions. A cyclic proof system is a restriction of the corresponding infinitary proof system. Hence, these proof systems are generally not the same, as in the cyclic system may be weaker than the infinitary system. For several logics, the infinitary proof systems are shown to be cut-free complete. However, cyclic proof systems are characterized with many unknown problems on the (cut-free) completeness or the cut-elimination property. In this study, we show that the provability of infinitary and cyclic proof systems are the same for some propositional logics with fixed-point operators or inductive definitions and that the cyclic proof systems are cut-free complete.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/PMUDLVXW/2312.html}
}

@book{hottbook,
  title = {Homotopy Type Theory: {{Univalent}} Foundations of Mathematics},
  author = {Univalent Foundations Program, The},
  year = {2013},
  publisher = {https://homotopytypetheory.org/book},
  address = {Institute for Advanced Study},
  file = {/home/flaviomoura/Zotero/storage/8RHCIJAH/Univalent Foundations Program - 2013 - Homotopy type theory Univalent foundations of mat.pdf}
}

@book{houFundamentalsLogicComputation2021,
  title = {Fundamentals of {{Logic}} and {{Computation}}: {{With Practical Automated Reasoning}} and {{Verification}}},
  shorttitle = {Fundamentals of {{Logic}} and {{Computation}}},
  author = {Hou, Zhe},
  year = {2021},
  series = {Texts in {{Computer Science}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-87882-5},
  urldate = {2021-12-16},
  isbn = {978-3-030-87881-8 978-3-030-87882-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/INY522HV/Hou - 2021 - Fundamentals of Logic and Computation With Practi.pdf}
}

@article{hrubesLowerBoundIntuitionistic2007,
  title = {A {{Lower Bound}} for {{Intuitionistic Logic}}},
  author = {Hrube{\v s}, P.},
  year = {2007},
  journal = {Annals of Pure and Applied Logic},
  volume = {146},
  number = {1},
  pages = {72--90},
  doi = {10.1016/j.apal.2007.01.001}
}

@misc{huangDefunctionalizationDependentTypes2023,
  title = {Defunctionalization with {{Dependent Types}}},
  author = {Huang, Yulong and Yallop, Jeremy},
  year = {2023},
  month = apr,
  number = {arXiv:2304.04574},
  eprint = {2304.04574},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-14},
  abstract = {YULONG HUANG, University of Cambridge, UK JEREMY YALLOP, University of Cambridge, UK The defunctionalization translation that eliminates higher-order functions from programs forms a key part of many compilers. However, defunctionalization for dependently-typed languages has not been formally studied. We present the first formally-specified defunctionalization translation for a dependently-typed language and establish key metatheoretical properties such as soundness and type preservation. The translation is suitable for incorporation into type-preserving compilers for dependently-typed languages. CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Type theory; Program semantics; {$\bullet$} Software and its engineering {$\rightarrow$} Compilers.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/ZAKDERUR/Huang e Yallop - 2023 - Defunctionalization with Dependent Types.pdf}
}

@book{huangEducationalTechnology2019,
  title = {Educational {{Technology}}},
  author = {Huang, Ronghuai and Spector, J. Michael and Yang, Junfeng},
  year = {2019},
  series = {Lecture {{Notes}} in {{Educational Technology}}},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-6643-7}
}

@misc{huCategoricalNormalizationProof2023,
  title = {A {{Categorical Normalization Proof}} for the {{Modal Lambda-Calculus}}},
  author = {Hu, Jason Z. S. and Pientka, Brigitte},
  year = {2023},
  month = feb,
  number = {arXiv:2211.12318},
  eprint = {2211.12318},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-02-07},
  abstract = {We investigate a simply typed modal {$\lambda$}-calculus, {$\lambda\rightarrow$} , due to Pfenning, Wong and Davies, where we define a well-typed term with respect to a context stack that captures the possible world semantics in a syntactic way. It provides logical foundation for multi-staged meta-programming. Our main contribution in this paper is a normalization by evaluation (NbE) algorithm for {$\lambda\rightarrow$} which we prove sound and complete. The NbE algorithm is a moderate extension to the standard presheaf model of simply typed {$\lambda$}-calculus. However, central to the model construction and the NbE algorithm is the observation of Kripke-style substitutions on context stacks which brings together two previously separate concepts, structural modal transformations on context stacks and substitutions for individual assumptions. Moreover, Kripke-style substitutions allow us to give a formulation for contextual types, which can represent open code in a meta-programming setting. Our work lays the foundation for extending the logical foundation by Pfenning, Wong, and Davies towards building a practical, dependently typed foundation for meta-programming.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.3.1,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/9WFJ9VUW/Hu e Pientka - 2023 - A Categorical Normalization Proof for the Modal La.pdf}
}

@inproceedings{huertasTenYearsComputer2011,
  title = {Ten Years of Computer- Tutors for Teaching Logic 2000-2010: Lessons Learned},
  booktitle = {{{TICTTL}}},
  author = {Huertas, A.},
  year = {2011},
  pages = {131--140},
  publisher = {Springer}
}

@article{huetConfluentReductionsAbstract1980,
  title = {Confluent {{Reductions}}: {{Abstract Properties}} and {{Applications}} to {{Term Rewriting Systems}}: {{Abstract Properties}} and {{Applications}} to {{Term Rewriting Systems}}},
  shorttitle = {Confluent {{Reductions}}},
  author = {Huet, G{\'e}rard},
  year = {1980},
  month = oct,
  journal = {Journal of the ACM},
  volume = {27},
  number = {4},
  pages = {797--821},
  issn = {0004-5411, 1557-735X},
  doi = {10.1145/322217.322230},
  urldate = {2023-03-17},
  abstract = {This paper gives new results, and presents old ones m a umfied formahsm, concerning ChurchRosser theorems for rewrmng systems Abstract confluence propentes, depending solely on axioms for a binary relatton called reduction, are first presented Results of Newman and others are presented m a unified formahsm The systemattc use of a powerful mductmn pnnciple permRs the generahzauon of results of Sethl on reduction modulo eqmvalence.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7Z484QDH/Huet - 1980 - Confluent Reductions Abstract Properties and Appl.pdf}
}

@article{huetProvingApplyingProgram1978,
  ids = {huetProvingApplyingProgram1978a},
  title = {Proving and {{Applying Program Transformations Expressed}} with {{Second Order Patterns}}},
  author = {Huet, G. and Lang, B.},
  year = {1978},
  journal = {Acta Informatica},
  volume = {11},
  pages = {31--55}
}

@phdthesis{huetResolutionEquationsDans1976,
  title = {R{\'e}solution d'{\'e}quations Dans Les Langages d'ordre 1,2,{\textbackslash}ldots,\${\o}mega\$},
  author = {Huet, G.},
  year = {1976},
  school = {University Paris-7}
}

@article{huetUndecidabilityUnificationThird1973,
  title = {The {{Undecidability}} of {{Unification}} in {{Third Order Logic}}},
  author = {Huet, G.},
  year = {1973},
  journal = {Information and Control},
  volume = {22},
  number = {3},
  pages = {257--267}
}

@article{huetUnificationAlgorithmTyped1975,
  title = {A {{Unification Algorithm}} for {{Typed}} Lambda-{{Calculus}}},
  author = {Huet, G.},
  year = {1975},
  journal = {TCS},
  volume = {1},
  number = {1},
  pages = {27--57}
}

@article{huetUnificationAlgorithmTyped1975a,
  title = {A {{Unification Algorithm}} for {{Typed}} {$\lambda$}-{{Calculus}}},
  author = {Huet, G.},
  year = {1975},
  journal = {Theoretical Computer Science},
  volume = {1},
  pages = {27--57}
}

@misc{huInvestigationKripkestyleModal2022,
  title = {An {{Investigation}} on {{Kripke-style Modal Type Theories}}},
  author = {Hu, Jason Z. S. and Pientka, Brigitte},
  year = {2022},
  month = jun,
  number = {arXiv:2206.07823},
  eprint = {2206.07823},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-06-18},
  abstract = {This technical report investigates Kripke-style modal type theories, both simply typed and dependently typed. We examine basic meta-theories of the type theories, develop their substitution calculi, and give normalization by evaluation algorithms.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/PCFD5622/Hu and Pientka - 2022 - An Investigation on Kripke-style Modal Type Theori.pdf}
}

@book{huntBeginnerGuideScala2018,
  title = {A {{Beginner}}'s {{Guide}} to {{Scala}}, {{Object Orientation}} and {{Functional Programming}}},
  author = {Hunt, John},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-75771-1}
}

@article{hutchingsWhatWhenYou2022,
  title = {2. {{What}} to {{Do When You Are Stuck}} or {{Confused}} on a {{Research Project}} by {{Michael Hutchings}}},
  author = {Hutchings, Michael},
  year = {2022},
  month = jun,
  journal = {Notices of the American Mathematical Society},
  volume = {69},
  number = {06},
  pages = {1},
  issn = {0002-9920, 1088-9477},
  doi = {10.1090/noti2499},
  urldate = {2024-03-17},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PXF2Z6TA/Hutchings - 2022 - 2. What to Do When You Are Stuck or Confused on a .pdf}
}

@book{huthLogicComputerScience2004,
  title = {Logic in {{Computer Science}}: {{Modelling}} and {{Reasoning About Systems}}},
  author = {Huth, M. and Ryan, M.},
  year = {2004},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {0-521-54310-X},
  file = {/home/flaviomoura/Zotero/storage/GS3YNQ8V/Huth e Ryan - 2004 - Logic in Computer Science Modelling and Reasoning.pdf}
}

@misc{hyvernatSizeChangePrincipleMixed2022,
  title = {The {{Size-Change Principle}} for {{Mixed Inductive}} and {{Coinductive}} Types},
  author = {Hyvernat, Pierre},
  year = {2022},
  month = jul,
  number = {arXiv:1901.07820},
  eprint = {1901.07820},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {This paper shows how to use Lee, Jones and Ben Amram's size-change principle to check correctness of arbitrary recursive definitions in an ML / Haskell like programming language with inductive and coinductive types. The size-change principle is used to check both termination and productivity, and the resulting principle is sound even if inductive and coinductive types are arbitrarily nested. A prototype has been implemented and gives a practical argument in favor of this principle. This work relies on a characterization of least and greatest fixed points as sets of winning strategies for parity games that was developed by L. Santocanale in his early work on circular proofs. The proof of correctness of the criterion relies on an extension of the language's denotational semantics to a domain of untyped values with non-deterministic sums.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/ILP35CQV/Hyvernat - 2022 - The Size-Change Principle for Mixed Inductive and .pdf;/home/flaviomoura/Zotero/storage/TLKMP63D/1901.html}
}

@book{i.wegenerauth.ProceedingsInternationalJoint1987,
  title = {Proceedings of the {{International Joint Conference}} on {{Theory}} and {{Practice}} of {{Software Development}} - {{TAPSOFT}} '87},
  author = {I. Wegener (auth.), H. Ehrig, R. Kowalski, G. Levi, U. Montanari (eds.)},
  year = {1987},
  series = {Lecture {{Notes}} in {{Computer Science}} 249},
  edition = {1},
  publisher = {Springer-Verlag Berlin Heidelberg},
  isbn = {3-540-17660-8 978-3-540-17660-2}
}

@article{iemhoffProofTheoryAdmissible2009,
  title = {Proof Theory for Admissible Rules},
  author = {Iemhoff, Rosalie and Metcalfe, George},
  year = {2009},
  month = may,
  journal = {Annals of Pure and Applied Logic},
  volume = {159},
  number = {1},
  pages = {171--186},
  issn = {0168-0072},
  doi = {10.1016/j.apal.2008.10.011},
  urldate = {2022-04-22},
  abstract = {Admissible rules of a logic are those rules under which the set of theorems of the logic is closed. In this paper, a Gentzen-style framework is introduced for analytic proof systems that derive admissible rules of non-classical logics. While Gentzen systems for derivability treat sequents as basic objects, for admissibility, the basic objects are sequent rules. Proof systems are defined here for admissible rules of classes of modal logics, including K4, S4, and GL, and also Intuitionistic Logic IPC. With minor restrictions, proof search in these systems terminates, giving decision procedures for admissibility in the logics.},
  langid = {english},
  keywords = {Admissible rules,Intuitionistic logic,Modal logic,Proof theory},
  file = {/home/flaviomoura/Zotero/storage/KYEYJG4A/Iemhoff and Metcalfe - 2009 - Proof theory for admissible rules.pdf;/home/flaviomoura/Zotero/storage/G4E9SSD5/S0168007208001851.html}
}

@misc{iemhoffUniversalProofTheory2023,
  title = {Universal {{Proof Theory}}, {{TACL}} 2022 {{Lecture Notes}}},
  author = {Iemhoff, Rosalie and Jalali, Raheleh},
  year = {2023},
  month = may,
  number = {arXiv:2305.10888},
  eprint = {2305.10888},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2023-05-23},
  abstract = {The subject of these short lecture notes is a recently emerging area within proof theory, called {\textbackslash}emph\{Universal Proof Theory\}. Here one is concerned with the existence and nonexistence of good (or useful or applicable or ...) proof systems.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/BHPMDDNJ/Iemhoff e Jalali - 2023 - Universal Proof Theory, TACL 2022 Lecture Notes.pdf}
}

@book{igarashiProgrammingLanguagesSystems2016,
  title = {Programming {{Languages}} and {{Systems}} - 14th {{Asian Symposium}}, {{APLAS}} 2016, {{Hanoi}}, {{Vietnam}}, {{November}} 21-23, 2016, {{Proceedings}}},
  editor = {Igarashi, Atsushi},
  year = {2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {10017},
  doi = {10.1007/978-3-319-47958-3},
  isbn = {978-3-319-47957-6}
}

@book{igualIntroductionDataScience2017,
  title = {Introduction to {{Data Science}}},
  author = {Igual, Laura and Segu{\'i}, Santi},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-50017-1}
}

@book{iiiGuideTeachingPuzzlebased2014,
  title = {Guide to {{Teaching Puzzle-based Learning}}},
  author = {III, Edwin F. Meyer and Falkner, Nickolas and Sooriamurthi, Raja and Michalewicz, Zbigniew},
  year = {2014},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-6476-0}
}

@article{ImprovingAKSAlgorithm2023,
  title = {Improving {{AKS Algorithm}}. {{Proving}} the {{Simplicity}} of {{Integers}}},
  year = {2023},
  month = jan,
  journal = {Applied Mathematics \& Information Sciences},
  volume = {17},
  number = {1},
  pages = {13--20},
  issn = {19350090, 23250399},
  doi = {10.18576/amis/170103},
  urldate = {2023-10-03},
  abstract = {Agrawal-Kayal-Saxena (AKS) theorem was proved, from which the above-mentioned algorithm is directly derived. The study has shown that the problem of simplicity is in the complexity class P of polynomial problems. An advanced AKS algorithm is proposed, which will simplify the initial AKS algorithm and ensure its implementation to determine the simplicity of integers. To implement this task it is necessary to reduce algorithm computational complexity. The block diagram of the algorithm for performing the advanced AKS test is presented. The theorems for prime numbers presented in the form of polynomials were formulated and proved. The AKS algorithm consisting of two phases is implemented: at the first stage, the corresponding parameters r and s were found, and at the second stage, the identity for different values of b presented in the form of consecutive squares was checked. The adequacy of the algorithm for checking numbers for simplicity is proved by the example of a generated arbitrary number of 500 orders. Comparative characterization of the improved AKS test and the Miller-Rabin test was carried out. 50,000 tests were conducted. The maximum test time was 2.3089 s.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/KD9RHS6V/2023 - Improving AKS Algorithm. Proving the Simplicity of.pdf}
}

@article{indrzejczakNovelApproachEquality2021,
  title = {A Novel Approach to Equality},
  author = {Indrzejczak, Andrzej},
  year = {2021},
  month = dec,
  journal = {Synthese},
  volume = {199},
  number = {1-2},
  pages = {4749--4774},
  issn = {0039-7857, 1573-0964},
  doi = {10.1007/s11229-020-03000-8},
  urldate = {2023-11-16},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/N7F8LA2J/Indrzejczak - 2021 - A novel approach to equality.pdf}
}

@misc{InteractiveTheoremProving,
  title = {Interactive {{Theorem Proving}} and {{Program Development}}: {{Coq}}'{{Art}}: {{The Calculus}} of {{Inductive Constructions}} {\textbar} {{SpringerLink}}},
  urldate = {2024-10-23},
  howpublished = {https://link.springer.com/book/10.1007/978-3-662-07964-5},
  file = {/home/flaviomoura/Zotero/storage/XXIDY9RQ/Interactive Theorem Proving and Program Developmen.pdf;/home/flaviomoura/Zotero/storage/RTHDHAQ6/978-3-662-07964-5.html}
}

@article{intrigilaExtendedAddressingMachines,
  title = {Extended {{Addressing Machines}} for {{PCF}}, with {{Explicit Substitutions}}},
  author = {Intrigila, Benedetto and Manzonetto, Giulio and Munnich, Nicolas},
  abstract = {Addressing machines have been introduced as a formalism to construct models of the pure, untyped {$\lambda$}-calculus. We extend the syntax of their programs by adding instructions for executing arithmetic operations on natural numbers, and introduce a reflection principle allowing certain machines to access their own address and perform recursive calls. We prove that the resulting extended addressing machines naturally model a weak call-by-name PCF with explicit substitutions. Finally, we show that they are also well-suited for representing regular PCF programs (closed terms) computing natural numbers.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/GLCE4WWX/Intrigila et al. - Extended Addressing Machines for PCF, with Explici.pdf}
}

@misc{intrigilaExtendedAddressingMachines2023,
  title = {Extended {{Addressing Machines}}, Explicit Substitutions, {{PCF}}, Definability, Full Abstraction},
  author = {Intrigila, Benedetto and Manzonetto, Giulio and Munnich, Nicolas},
  year = {2023},
  month = jun,
  number = {arXiv:2306.13756},
  eprint = {2306.13756},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-06-27},
  abstract = {Extended addressing machines (EAMs) have been introduced to represent higher-order sequential computations. Previously, we have shown that they are capable of simulating---via an easy encoding---the operational semantics of PCF, extended with explicit substitutions. In this paper we prove that the simulation is actually an equivalence: a PCF program terminates in a numeral exactly when the corresponding EAM terminates in the same numeral. It follows that the model of PCF obtained by quotienting typable EAMs by a suitable logical relation is adequate. From a definability result stating that every EAM in the model can be transformed into a PCF program with the same observational behavior, we conclude that the model is fully abstract for PCF.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/K3NX7A67/Intrigila et al. - 2023 - Extended Addressing Machines, explicit substitutio.pdf}
}

@misc{intrigilaExtendedAddressingMachines2023a,
  title = {Extended {{Addressing Machines}} for {{PCF}}, with {{Explicit Substitutions}}},
  author = {Intrigila, Benedetto and Manzonetto, Giulio and Munnich, Nicolas},
  year = {2023},
  month = feb,
  eprint = {2212.11147},
  primaryclass = {cs},
  doi = {10.46298/entics.10533},
  urldate = {2023-02-07},
  abstract = {Addressing machines have been introduced as a formalism to construct models of the pure, untyped {$\lambda$}-calculus. We extend the syntax of their programs by adding instructions for executing arithmetic operations on natural numbers, and introduce a reflection principle allowing certain machines to access their own address and perform recursive calls. We prove that the resulting extended addressing machines naturally model a weak call-by-name PCF with explicit substitutions. Finally, we show that they are also well-suited for representing regular PCF programs (closed terms) computing natural numbers.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/2CVCNFGW/Intrigila et al. - 2023 - Extended Addressing Machines for PCF, with Explici.pdf}
}

@misc{IntroducaoEstruturaDados,
  title = {Introdu{\c c}{\~a}o a {{Estrutura}} de {{Dados}} {\textbar} {{Amazon}}.Com.Br},
  urldate = {2022-03-09},
  howpublished = {https://www.amazon.com.br/Introdu\%C3\%A7\%C3\%A3o-Estrutura-Dados-Waldemar-Celes/dp/8535212280},
  file = {/home/flaviomoura/Zotero/storage/9HRNTIPY/8535212280.html}
}

@book{IntroductionDependentTypes,
  title = {Introduction to {{Dependent Types}} with {{Idris}}},
  urldate = {2024-05-09},
  abstract = {This book will teach you the mathematical foundations of Idris as well as how to use it to write software and mathematically prove properties.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DUAZUE6R/978-1-4842-9259-4.html}
}

@book{IntroductionFormalPhilosophy2018,
  title = {Introduction to {{Formal Philosophy}}},
  year = {2018},
  series = {Springer {{Undergraduate Texts}} in {{Philosophy}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-77434-3}
}

@phdthesis{iqbalFORMALIZATIONASYMPTOTICNOTATIONS2012,
  type = {{{MsC}}},
  title = {{{FORMALIZATION OF ASYMPTOTIC NOTATIONS IN HIGHER-ORDER-LOGIC}}},
  author = {IQBAL, {\relax NADEEM}},
  year = {2012},
  school = {National University of Sciences and Technology}
}

@article{ishiharaClassicalPropositionalLogic2014,
  title = {Classical Propositional Logic and Decidability of Variables in Intuitionistic Propositional Logic},
  author = {Ishihara, H.},
  year = {2014},
  month = may,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic}
}

@incollection{ishizukaCommutativeRationalTerm2021,
  title = {Commutative {{Rational Term Rewriting}}},
  booktitle = {Language and {{Automata Theory}} and {{Applications}}},
  author = {Ishizuka, Mamoru and Aoto, Takahito and Iwami, Munehiro},
  editor = {Leporati, Alberto and {Mart{\'i}n-Vide}, Carlos and Shapira, Dana and Zandron, Claudio},
  year = {2021},
  volume = {12638},
  pages = {200--212},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-68195-1_15},
  urldate = {2021-07-24},
  abstract = {Term rewriting for rational terms, i.e. infinite terms with a finite number of different subterms, has been considered e.g. in Corradini \& Gadducci (1998) and Aoto \& Ketema (2012). In this paper, we consider rational term rewriting by a set of commutativity rules i.e. rules of the form f (x, y) {$\rightarrow$} f (y, x), based on the framework of Aoto \& Ketema (2012). A rewrite step with a commutativity rule is specified via a regular set of redex positions, thus via a finite automaton. We present some finite automata constructions that correspond to (in particular) taking inverse rewrite steps, merging two branching rewrite steps, and merging two consecutive rewrite steps. As a corollary, we show that rational rewrite steps by the commutativity rules are closed under taking equivalence of the rewrite steps.},
  isbn = {978-3-030-68194-4 978-3-030-68195-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IUNPEIS2/Ishizuka et al. - 2021 - Commutative Rational Term Rewriting.pdf}
}

@book{jacobsCategoricalLogicType1999,
  title = {Categorical {{Logic}} and {{Type Theory}}},
  author = {Jacobs, B.},
  year = {1999},
  series = {Studies in {{Logic}} and the {{Foundations}} of {{Mathematics}}},
  number = {141},
  publisher = {North Holland},
  address = {Amsterdam}
}

@misc{jacobsDrawingDistance2025,
  title = {Drawing with {{Distance}}},
  author = {Jacobs, Bart},
  year = {2025},
  month = feb,
  number = {arXiv:2405.18182},
  eprint = {2405.18182},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.18182},
  urldate = {2025-02-13},
  abstract = {Drawing (a multiset of) coloured balls from an urn is one of the most basic models in discrete probability theory. Three modes of drawing are commonly distinguished: multinomial (draw-replace), hypergeometric (draw-delete), and Polya (draw-add). These drawing operations are represented as maps from urns to distributions over multisets of draws. The set of urns is a metric space via the Kantorovich distance. The set of distributions over draws is also a metric space, using Kantorovich-over-Kantorovich. It is shown that these three draw operations are all isometries, that is, they exactly preserve the Kantorovich distances. Further, drawing is studied in the limit, both for large urns and for large draws. First it is shown that, as the urn size increases, the Kantorovich distances go to zero between hypergeometric and multinomial draws, and also between P{\textbackslash}'olya and multinomial draws. Second, it is shown that, as the drawsize increases, the Kantorovich distance goes to zero (in probability) between an urn and (normalised) multinomial draws from the urn. These results are known, but here, they are formulated in a novel metric manner as limits of Kantorovich distances. We call these two limit results the law of large urns and the law of large draws.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Probability},
  file = {/home/flaviomoura/Zotero/storage/VJUNH9CS/Jacobs - 2025 - Drawing with Distance.pdf;/home/flaviomoura/Zotero/storage/NEE5USAH/2405.html}
}

@article{jacobsenExamsIsabelleProof2023,
  title = {On {{Exams}} with the {{Isabelle Proof Assistant}}},
  author = {Jacobsen, Frederik Krogsdal and Villadsen, J{\o}rgen},
  year = {2023},
  month = mar,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {375},
  pages = {63--76},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.375.6},
  urldate = {2023-05-09},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NY72IFP9/Jacobsen e Villadsen - 2023 - On Exams with the Isabelle Proof Assistant.pdf}
}

@article{jacobsenTeachingFunctionalProgrammers2022,
  title = {Teaching {{Functional Programmers Logic}} and {{Metatheory}}},
  author = {Jacobsen, Frederik Krogsdal and Villadsen, J{\o}rgen},
  year = {2022},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {363},
  eprint = {2207.12699},
  primaryclass = {cs},
  pages = {74--92},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.363.5},
  urldate = {2022-08-01},
  abstract = {We present a novel approach for teaching logic and the metatheory of logic to students who have some experience with functional programming. We define concepts in logic as a series of functional programs in the language of the proof assistant Isabelle/HOL. This allows us to make notions which are often unclear in textbooks precise, to experiment with definitions by executing them, and to prove metatheoretical theorems in full detail. We have surveyed student perceptions of our teaching approach to determine its usefulness and found that students felt that our formalizations helped them understand concepts in logic, and that they experimented with them as a learning tool. However, the approach was not enough to make students feel confident in their abilities to design and implement their own formal systems. Further studies are needed to confirm and generalize the results of our survey, but our initial results seem promising.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.1.1,F.4.1,K.3.2},
  file = {/home/flaviomoura/Zotero/storage/2CMR7DNE/Jacobsen and Villadsen - 2022 - Teaching Functional Programmers Logic and Metatheo.pdf;/home/flaviomoura/Zotero/storage/GIDBT82Y/2207.html}
}

@article{jafarrahmaniFixpointsTypesLinear,
  title = {Fixpoints of {{Types}} in {{Linear Logic}} from a {{Curry-Howard-Lambek Perspective}}},
  author = {Jafarrahmani, Farzad},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2MZ98WQE/Jafarrahmani - Fixpoints of Types in Linear Logic from a Curry-Ho.pdf}
}

@book{jagannathan41stAnnualACM2014,
  title = {The 41st {{Annual ACM SIGPLAN-SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}, {{POPL}} '14, {{San Diego}}, {{CA}}, {{USA}}, {{January}} 20-21, 2014},
  editor = {Jagannathan, S. and Sewell, P.},
  year = {2014},
  journal = {POPL},
  publisher = {ACM},
  isbn = {978-1-4503-2544-8}
}

@book{jalongoWritingPublication2016,
  title = {Writing for {{Publication}}},
  author = {Jalongo, Mary Renck and Saracho, Olivia N.},
  year = {2016},
  series = {Springer {{Texts}} in {{Education}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-31650-5}
}

@book{jamest.streibGuideDataStructures2017,
  ids = {streibGuideDataStructures2017},
  title = {Guide to {{Data Structures}}: {{A Concise Introduction Using Java}}},
  author = {James T. Streib, Takako Soma (auth.)},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  edition = {1},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-70085-4},
  isbn = {978-3-319-70083-0 978-3-319-70085-4}
}

@article{japaridzeComputabilityLogicGiving2019,
  title = {Computability {{Logic}}: {{Giving Caesar What Belongs To Caesar}}},
  author = {Japaridze, Giorgi},
  year = {2019},
  journal = {CoRR},
  abstract = {The present article is a brief informal survey of computability logic --- the game-semantically conceived formal theory of computational resources and tasks. This relatively young nonclassical logic is a conservative extension of classical first order logic but is much more expressive than the latter, yielding a wide range of new potential application areas. In a reasonable (even if not strict) sense the same holds for intuitionistic and linear logics, which allows us to say that CoL reconciles and unifies the three traditions of logical thought (and beyond) on the basis of its natural and "universal" game semantics. A comprehensive online survey of the subject can be found at http://www.csc.villanova.edu/ japaridz/CL/ .}
}

@article{japaridzeFundamentalsComputabilityLogic2019,
  title = {Fundamentals of {{Computability Logic}}},
  author = {Japaridze, Giorgi},
  year = {2019},
  journal = {CoRR},
  abstract = {This article is a semitutorial-style survey of computability logic. An extended online version of it is maintained at http://www.csc.villanova.edu/ japaridz/CL/ .}
}

@article{jaumeTeachingFormalMethods2014,
  title = {Teaching {{Formal Methods}} and {{Discrete Mathematics}}},
  author = {Jaume, M. and Laurent, T.},
  year = {2014},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Computers and Society,Computer Science - Logic in Computer Science,Computer Science - Software Engineering}
}

@book{jechSetTheory2003,
  title = {Set {{Theory}}},
  author = {Jech, Thomas},
  year = {2003},
  series = {Springer {{Monographs}} in {{Mathematics}}},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-44761-X},
  urldate = {2021-04-27},
  isbn = {978-3-540-44085-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WZ4YIAHR/2003 - Set Theory.pdf}
}

@techreport{jenkinsElaboratingInductiveDefinitions2020,
  type = {{{PhD Comprehensive}} Exam},
  title = {Elaborating Inductive Definitions in {{Curry-style}} Polymorphic Type Theory},
  author = {Jenkins, Christopher},
  year = {2020},
  institution = {The University of Iowa}
}

@misc{jerabekNoteTheoryWell2024,
  title = {A Note on the Theory of Well Orders},
  author = {Je{\v r}{\'a}bek, Emil},
  year = {2024},
  month = may,
  number = {arXiv:2405.05779},
  eprint = {2405.05779},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.05779},
  urldate = {2024-05-13},
  abstract = {We give a simple proof that the first-order theory of well orders is axiomatized by transfinite induction, and that it is decidable.},
  archiveprefix = {arXiv},
  keywords = {03B25 (Primary) 06A05 (Secondary),Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/AJERCIYQ/JeÅÃ¡bek - 2024 - A note on the theory of well orders.pdf;/home/flaviomoura/Zotero/storage/NSV4T34N/JeÅÃ¡bek - 2024 - A note on the theory of well orders.pdf;/home/flaviomoura/Zotero/storage/3HKSFPVS/2405.html}
}

@book{jeuringProceedings19thACM2014,
  title = {Proceedings of the 19th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming, {{Gothenburg}}, {{Sweden}}, {{September}} 1-3, 2014},
  editor = {Jeuring, Johan and Chakravarty, Manuel M. T.},
  year = {2014},
  publisher = {ACM},
  isbn = {978-1-4503-2873-9}
}

@article{jinExtensibleMetatheoryMechanization,
  title = {Extensible {{Metatheory Mechanization}} via {{Family Polymorphism}}: {{Technical Report}}},
  author = {Jin, Ende and Amin, Nada and Zhang, Yizhou},
  journal = {Technical Report},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SBI7Y392/Jin et al. - Extensible Metatheory Mechanization via Family Pol.pdf}
}

@article{jinExtensibleMetatheoryMechanizationa,
  title = {Extensible {{Metatheory Mechanization}} via {{Family Polymorphism}}},
  author = {Jin, Ende and Amin, Nada and Zhang, Yizhou},
  volume = {7},
  abstract = {CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Type theory; Logic; Object-oriented constructs; Functional constructs; {$\bullet$} Software and its engineering {$\rightarrow$} Language features; Compilers; Semantics; Software verification.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/YKNQMELS/Jin et al. - Extensible Metatheory Mechanization via Family Pol.pdf}
}

@book{johanssonPhilosophyScienceScientists2015,
  title = {Philosophy of Science for Scientists},
  author = {Johansson, Lars-G{\"o}ran},
  year = {2015},
  publisher = {Springer}
}

@book{johnsonbaughDiscreteMathematics2009,
  title = {Discrete {{Mathematics}}},
  author = {Johnsonbaugh, R.},
  year = {2009},
  publisher = {Pearson/Prentice Hall},
  isbn = {978-0-13-159318-3},
  lccn = {2011414417}
}

@book{jonesHaskell98Language2003,
  title = {Haskell 98 {{Language}} and {{Libraries}} - {{The Revised Report}}},
  editor = {Jones, S. P.},
  year = {2003},
  publisher = {Cambridge University Press}
}

@inproceedings{jonesTypeClassesFunctional2000,
  title = {Type {{Classes}} with {{Functional Dependencies}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Jones, Mark P.},
  editor = {Smolka, Gert},
  year = {2000},
  pages = {230--244},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-46425-5_15},
  abstract = {Type classes in Haskell allow programmers to define functions that can be used on a set of different types, with a potentially different implementation in each case. For example, type classes are used to support equality and numeric types, and for monadic programming. A commonly requested extension to support `multiple parameters' allows a more general interpretation of classes as relations on types, and has many potentially useful applications. Unfortunately, many of these examples do not work well in practice, leading to ambiguities and inaccuracies in inferred types and delaying the detection of type errors.},
  isbn = {978-3-540-46425-9},
  langid = {english},
  keywords = {Functional Dependency,Parameter Class,Relational Database,Type Class,Type Variable},
  file = {/home/flaviomoura/Zotero/storage/FWXJJBJS/Jones - 2000 - Type Classes with Functional Dependencies.pdf}
}

@inproceedings{jonghPositiveFormulasIntuitionistic2013,
  title = {Positive {{Formulas}} in {{Intuitionistic}} and {{Minimal Logic}}},
  booktitle = {Logic, {{Language}}, and {{Computation}} - 10th {{International Tbilisi Symposium}} on {{Logic}}, {{Language}}, and {{Computation}}, {{TbiLLC}} 2013, {{Gudauri}}, {{Georgia}}, {{September}} 23-27, 2013. {{Revised Selected Papers}}},
  author = {de Jongh, D. and Zhao, Z.},
  year = {2013},
  pages = {175--189},
  doi = {10.1007/978-3-662-46906-4_11}
}

@article{jouannaud2021confluence,
  title = {Confluence in Non-Left-Linear Higher-Order Theories},
  author = {Jouannaud, Jean-Pierre and Frey, Gaspard},
  year = {2021}
}

@book{jrOpenProblemsMathematics2016,
  title = {Open {{Problems}} in {{Mathematics}}},
  author = {Jr, J. F. Nash and Rassias, M.},
  year = {2016},
  series = {Nil},
  publisher = {Springer Nature},
  doi = {10.1007/978-3-319-32162-2}
}

@article{jrPeerInstructionComputing2021,
  title = {Peer {{Instruction}} in {{Computing Higher Education}}: {{A Case Study}} of a {{Logic}} in {{Computer Science Course}} in {{Brazilian Context}}},
  shorttitle = {Peer {{Instruction}} in {{Computing Higher Education}}},
  author = {Jr, Esdras L. Bispo and Lopes, Rosemara P. and Santos, Simone C.},
  year = {2021},
  month = dec,
  journal = {Revista Brasileira de Inform{\'a}tica na Educa{\c c}{\~a}o},
  volume = {29},
  pages = {1403--1432},
  issn = {2317-6121},
  doi = {10.5753/rbie.2021.2127},
  urldate = {2021-12-31},
  abstract = {One of the challenges of Computing Education Research is the proposition of new learning methods. Researches indicate active learning methods are more effective than traditional ones. Peer Instruction is one of these learning methods that promotes a student-centered class, enabling (s)he constructs his/her comprehension through a structured approach with questions and peer discussions, used in Computing in the last years. Nevertheless, researches about the use of this method are very scarce in South America. Accordingly, this research aims to discuss the impact of Peer Instruction use on higher education from a Logic in Brazilian Computer Science course. The research context is an undergraduate course in Computer Science in the first term of 2018 at the Federal University of Jata{\'i}. Sufficient evidence was found for the veracity of two propositions related to this study: (i) Peer Instruction use guarantees a learning gain of students, and (ii) Peer Instruction is well accepted by students. Therefore, it concluded that Peer Instruction use is suitable for Logic courses in Computing Higher Education in Brazil, with good acceptance from students.},
  copyright = {Copyright (c) 2021},
  langid = {english},
  keywords = {Brazil},
  file = {/home/flaviomoura/Zotero/storage/DS78V7P3/Jr et al. - 2021 - Peer Instruction in Computing Higher Education A .pdf}
}

@misc{JsCoqCoqTheorem,
  title = {{{jsCoq}} -- {{The Coq Theorem Prover Online IDE}}},
  urldate = {2020-07-16},
  howpublished = {https://jscoq.github.io/node\_modules/jscoq/examples/scratchpad.html},
  file = {/home/flaviomoura/Zotero/storage/J9W42MKL/scratchpad.html}
}

@article{juttingTypingPureType1993,
  title = {Typing in {{Pure Type Systems}}},
  author = {Jutting, L. S. van Benthem},
  year = {1993},
  journal = {Inf. Comput.},
  volume = {105},
  number = {1},
  pages = {30--41},
  doi = {10.1006/inco.1993.1038}
}

@article{kachapovaFormalizingRelationsType2021,
  ids = {kachapovaFormalizingRelationsType2021a},
  title = {Formalizing Relations in Type Theory},
  author = {Kachapova, Farida},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.08595 [math]},
  eprint = {2102.08595},
  primaryclass = {math},
  urldate = {2021-02-18},
  abstract = {Type theory plays an important role in foundations of mathematics as a framework for formalizing mathematics and a base for proof assistants providing semi-automatic proof checking and construction. Derivation of each theorem in type theory results in a formal term encapsulating the whole proof process. In this paper we use a variant of type theory, namely the Calculus of Constructions with Definitions, to formalize the standard theory of binary relations. This includes basic operations on relations, criteria for special properties of relations, invariance of these properties under the basic operations, equivalence relation, well-ordering, and transfinite induction. Definitions and proofs are presented as flag-style derivations.},
  archiveprefix = {arXiv},
  keywords = {03B30 (Primary) 03B38 (Secondary),Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/INE9UIQ3/Kachapova - 2021 - Formalizing relations in type theory.pdf;/home/flaviomoura/Zotero/storage/U3CJUGEE/Kachapova - 2021 - Formalizing relations in type theory.pdf;/home/flaviomoura/Zotero/storage/72AKSTB4/2102.html;/home/flaviomoura/Zotero/storage/GTTLFUL7/2102.html}
}

@book{kahleAdvancesProofTheory2016,
  title = {Advances in {{Proof Theory}}},
  author = {Kahle, R. and Strahm, T. and Eds, T. Studer},
  year = {2016},
  series = {Progress in {{Computer Science}} and {{Applied Logic}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-29198-7}
}

@incollection{kahnNaturalSemantics1987,
  title = {Natural Semantics},
  booktitle = {{{STACS}} 87},
  author = {Kahn, G.},
  editor = {Brandenburg, Franz J. and {Vidal-Naquet}, Guy and Wirsing, Martin},
  year = {1987},
  volume = {247},
  pages = {22--39},
  publisher = {Springer-Verlag},
  address = {Berlin/Heidelberg},
  doi = {10.1007/BFb0039592},
  urldate = {2023-06-08},
  isbn = {978-3-540-17219-2},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2YAAHA7H/Kahn - 1987 - Natural semantics.pdf}
}

@inproceedings{kaliszykCertifiedComputerAlgebra2007,
  title = {Certified {{Computer Algebra}} on {{Top}} of an {{Interactive Theorem Prover}}},
  booktitle = {Calculemus/{{MKM}}},
  author = {Kaliszyk, Cezary and Wiedijk, Freek},
  year = {2007},
  pages = {94--105}
}

@article{kaliszykSurveyLanguagesFormalizing2020,
  title = {A {{Survey}} of {{Languages}} for {{Formalizing Mathematics}}},
  author = {Kaliszyk, Cezary and Rabe, Florian},
  year = {2020},
  journal = {CoRR},
  abstract = {In order to work with mathematical content in computer systems, it is necessary to represent it in formal languages. Ideally, these are supported by tools that verify the correctness of the content, allow computing with it, and produce human-readable documents. These goals are challenging to combine and state-of-the-art tools typically have to make difficult compromises. In this paper we discuss languages that have been created for this purpose, including logical languages of proof assistants and other formal systems, semi-formal languages, intermediate languages for exchanging mathematical knowledge, and language frameworks that allow building customized languages. We evaluate their advantages based on our experience in designing and applying languages and tools for formalizing mathematics. We reach the conclusion that no existing language is truly good enough yet and derive ideas for possible future improvements.}
}

@incollection{kaliszykSystemDescription2015,
  title = {System {{Description}}: {{E}}.{{T}}. 0.1},
  shorttitle = {System {{Description}}},
  booktitle = {Automated {{Deduction}} - {{CADE-25}}},
  author = {Kaliszyk, Cezary and Schulz, Stephan and Urban, Josef and Vysko{\v c}il, Ji{\v r}{\'i}},
  editor = {Felty, Amy P. and Middeldorp, Aart},
  year = {2015},
  volume = {9195},
  pages = {389--398},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-21401-6_27},
  urldate = {2021-12-26},
  isbn = {978-3-319-21400-9 978-3-319-21401-6}
}

@inproceedings{kaliszykTeachingLogicUsing2008,
  title = {Teaching Logic Using a State-of-the-Art Proof Assistant},
  booktitle = {Formal {{Methods}} in {{Computer Science Education}} - {{FORMED}}'08},
  author = {Kaliszyk, C. and Wiedijk, F. and Hendriks, M. and van Raamsdonk, F.},
  editor = {Istenes, Z.},
  year = {2008},
  pages = {111--120}
}

@article{kaliszykWebInterfacesProof2007,
  title = {Web {{Interfaces}} for {{Proof Assistants}}},
  author = {Kaliszyk, Cezary},
  year = {2007},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {174},
  number = {2},
  pages = {49--61},
  doi = {10.1016/j.entcs.2006.09.021}
}

@article{kamareddineCanonicalTypingPiConversion1996,
  title = {Canonical {{Typing}} and {{Pi-Conversion}} in the {{Barendregt Cube}}},
  author = {Kamareddine, F. and Nederpelt, R.},
  year = {1996},
  journal = {J. Funct. Program.},
  volume = {6},
  number = {2},
  pages = {245--267},
  doi = {10.1017/S0956796800001672}
}

@article{kamareddineExtendingLcalculusExplicit1997,
  title = {Extending a {$\lambda$}-Calculus with Explicit Substitution Which Preserves Strong Normalisation into a Confluent Calculus on Open Terms},
  author = {Kamareddine, Fairouz and R{\'i}os, Alejandro},
  year = {1997},
  month = jul,
  journal = {Journal of Functional Programming},
  volume = {7},
  number = {4},
  pages = {395--420},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796897002785},
  urldate = {2023-09-08},
  abstract = {The last 15 years have seen an explosion in work on explicit substitution, most of which is done in the style of the {$\lambda\sigma$}-calculus. In Kamareddine and R{\textasciiacute}{\i}os (1995a), we extended the {$\lambda$}-calculus with explicit substitutions by turning de Bruijn's meta-operators into objectoperators offering a style of explicit substitution that differs from that of {$\lambda\sigma$}. The resulting calculus, {$\lambda$}s, remains as close as possible to the {$\lambda$}-calculus from an intuitive point of view and, while preserving strong normalisation (Kamareddine and R{\textasciiacute}{\i}os, 1995a), is extended in this paper to a confluent calculus on open terms: the {$\lambda$}se-caculus. Since the establishment of these results, another calculus, {$\lambda\zeta$}, came into being in Mun{\texttildelow}oz Hurtado (1996) which preserves strong normalisation and is itself confluent on open terms. However, we believe that {$\lambda$}se still deserves attention because, while offering a new style to work with explicit substitutions, it is able to simulate one step of classical {$\beta$}-reduction, whereas {$\lambda\zeta$} is not. To prove confluence we introduce a generalisation of the interpretation method (cf. Hardin, 1989; Curien et al., 1992) to a technique which uses weak normal forms (instead of strong ones). We consider that this extended method is a useful tool to obtain confluence when strong normalisation of the subcalculus of substitutions is not available. In our case, strong normalisation of the corresponding subcalculus of substitutions se, is still a challenging open problem to the rewrite community, but its weak normalisation is established here via an effective strategy.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VKRV43VB/Kamareddine e RÃ­os - 1997 - Extending a Î»-calculus with explicit substitution .pdf}
}

@inproceedings{kamareddineGeneralizedBetaReductionExplicit1996,
  title = {Generalized Beta-{{Reduction}} and {{Explicit Substitution}}},
  booktitle = {Programming {{Languages}}: {{Implementations}}, {{Logics}}, and {{Programs}}, 8th {{International Symposium}}, {{PLILP}}'96, {{Aachen}}, {{Germany}}, {{September}} 24-27, 1996, {{Proceedings}}},
  author = {Kamareddine, F. and R{\'i}os, A.},
  year = {1996},
  pages = {378--392},
  doi = {10.1007/3-540-61756-6_98}
}

@misc{kamareddineIntersectionTypesFiniteSet2024,
  title = {Intersection {{Types}} via {{Finite-Set Declarations}}},
  author = {Kamareddine, Fairouz and Wells, Joe},
  year = {2024},
  month = may,
  number = {arXiv:2405.00440},
  eprint = {2405.00440},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.00440},
  urldate = {2024-05-03},
  abstract = {The lambda-cube is a famous pure type system (PTS) cube of eight powerful explicit type systems that include the simple, polymorphic and dependent type theories. The lambda-cube only types Strongly Normalising (SN) terms but not all of them. It is well known that even the most powerful system of the lambda-cube can only type the same pure untyped lambda-terms that are typable by the higher-order polymorphic implicitly typed lambda-calculus Fomega, and that there is an untyped \{{\textbackslash}lambda\}-term U' that is SN but is not typable in Fomega or the lambda-cube. Hence, neither system can type all the SN terms it expresses. In this paper, we present the f-cube, an extension of the lambda-cube with finite-set declarations (FSDs) like y{\textbackslash}in\{C1,...,Cn\} : B which means that y is of type B and can only be one of C1,..., Cn. The novelty of our FSDs is that they allow to represent intersection types as Pi-types. We show how to translate and type the term U' in the f-cube using an encoding of intersection types based on FSDs. Notably, our translation works without needing anything like the usual troublesome intersection-introduction rule that proves a pure untyped lambda-term M has an intersection of k types using k independent sub-derivations. As such, our approach is useful for language implementers who want the power of intersection types without the pain of the intersection-introduction rule.},
  archiveprefix = {arXiv},
  keywords = {03 68,Computer Science - Logic in Computer Science,F.4,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/Z6XAQGYM/Kamareddine and Wells - 2024 - Intersection Types via Finite-Set Declarations.pdf;/home/flaviomoura/Zotero/storage/R9AJ3YBA/2405.html}
}

@inproceedings{kamareddineLcalculusBruijnExplicit1995,
  title = {A {$\lambda$}-Calculus {\`a} La de {{Bruijn}} with {{Explicit Substitutions}}},
  booktitle = {Proc. of {{PLILP}}'95},
  author = {Kamareddine, F. and R{\'i}os, A.},
  year = {1995},
  series = {{{LNCS}}},
  volume = {982},
  pages = {45--62},
  publisher = {Springer}
}

@misc{kamareddineParadoxesInfiniteDazzled2024,
  title = {The Paradoxes and the Infinite Dazzled Ancient Mathematics and Continue to Do so Today},
  author = {Kamareddine, Fairouz and Seldin, Jonathan},
  year = {2024},
  month = jan,
  number = {arXiv:2401.02806},
  eprint = {2401.02806},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2024-03-14},
  abstract = {This paper looks at how ancient mathematicians (and especially the Pythagorean school) were faced by problems/paradoxes associated with the infinite which led them to juggle two systems of numbers: the discrete whole/rationals which were handled arithmetically and the continuous magnitude quantities which were handled geometrically. We look at how approximations and mixed numbers (whole numbers with fractions) helped develop the arithmetization of geometry and the development of mathematical analysis and real numbers.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - History and Overview},
  file = {/home/flaviomoura/Zotero/storage/IZ8MRN73/Kamareddine e Seldin - 2024 - The paradoxes and the infinite dazzled ancient mat.pdf;/home/flaviomoura/Zotero/storage/3AF5AUVZ/2401.html}
}

@article{kamareddinePiConversionLambdaCubeCombination1999,
  title = {On {{Pi-Conversion}} in the Lambda-{{Cube}} and the {{Combination}} with {{Abbreviations}}},
  author = {Kamareddine, F. and Bloo, R. and Nederpelt, R.},
  year = {1999},
  journal = {Ann. Pure Appl. Logic},
  volume = {97},
  number = {1-3},
  pages = {27--45},
  doi = {10.1016/S0168-0072(98)00019-0}
}

@techreport{kamareddineReducibilityProofsLambda2008,
  title = {Reducibility {{Proofs}} in the {\textbackslash}({\textbackslash}lambda{\textbackslash})-{{Calculus}}},
  author = {Kamareddine, F. and Rahli, V.},
  year = {2008},
  institution = {Heriot-Watt University}
}

@article{kamareddineReducibilityProofsLambda2012,
  title = {Reducibility {{Proofs}} in the {\textbackslash}({\textbackslash}lambda{\textbackslash})-{{Calculus}}},
  author = {Kamareddine, F. and Rahli, V. and Wells, J. B.},
  year = {2012},
  journal = {Fundam. Inform.},
  volume = {121},
  number = {1-4},
  pages = {121--152},
  doi = {10.3233/FI-2012-773}
}

@misc{kamareddineSubstitutionLambdaCalculus2024,
  title = {Substitution in the Lambda {{Calculus}} and the Role of the {{Curry School}}},
  author = {Kamareddine, Fairouz},
  year = {2024},
  month = jan,
  number = {arXiv:2401.02745},
  eprint = {2401.02745},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-14},
  abstract = {Substitution plays a prominent role in the foundation and implementation of mathematics and computation. In the lambda calculus, we cannot define alpha congruence without a form of substitution but for substitution and reduction to work, we need to assume a form of alpha congruence (e.g., when we take lambda terms modulo bound variables). Students on a lambda calculus course usually find this confusing. The elegant writings and research of the Curry school have settled this problem very well. This article is an ode to the contributions of the Curry school (especially the excellent book of Hindley and Seldin) on the subject of alpha congruence and substitution.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/4PKB6VMJ/Kamareddine - 2024 - Substitution in the lambda Calculus and the role o.pdf;/home/flaviomoura/Zotero/storage/6VBNTLVK/2401.html}
}

@article{kamareddineThematicEditorialIt2024,
  title = {Thematic {{Editorial}}, {{It Is Hard To Imagine A World Without Algorithms}} and {{Data Science}}},
  author = {Kamareddine, Fairouz},
  year = {2024},
  month = jun,
  journal = {The Computer Journal},
  volume = {67},
  number = {5},
  pages = {1605--1606},
  issn = {0010-4620, 1460-2067},
  doi = {10.1093/comjnl/bxae046},
  urldate = {2025-03-17},
  copyright = {https://academic.oup.com/pages/standard-publication-reuse-rights},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ZXRKEM4G/Kamareddine - 2024 - Thematic Editorial, It Is Hard To Imagine A World Without Algorithms and Data Science.pdf}
}

@article{kamareddineTypedLambdacalculiOne2005,
  ids = {kamareddineTypedLambdacalculiOne2005a},
  title = {Typed Lambda-Calculi with One Binder},
  author = {Kamareddine, F.},
  year = {2005},
  journal = {J. Funct. Program.},
  volume = {15},
  number = {5},
  pages = {771--796},
  doi = {10.1017/S095679680500554X}
}

@misc{kaminskiMinimalPropositionalType2010,
  title = {A {{Minimal Propositional Type Theory}}},
  author = {Kaminski, Mark and Smolka, Gert},
  year = {2010},
  month = jan,
  number = {arXiv:1001.4021},
  eprint = {1001.4021},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1001.4021},
  urldate = {2025-01-29},
  abstract = {Propositional type theory, first studied by Henkin, is the restriction of simple type theory to a single base type that is interpreted as the set of the two truth values. We show that two constants (falsity and implication) suffice for denotational and deductive completeness. Denotational completeness means that every value of the full set-theoretic type hierarchy can be described by a closed term. Deductive completeness is shown for a sequent-based proof system that extends a propositional natural deduction system with lambda conversion and Boolean replacement.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/DTKDL375/Kaminski e Smolka - 2010 - A Minimal Propositional Type Theory.pdf;/home/flaviomoura/Zotero/storage/KRZNXMVZ/1001.html}
}

@book{karumanchiDataStructuresAlgorithms2017,
  title = {Data {{Structures}} and {{Algorithms Made Easy}}: {{Data Structures}} and {{Algorithmic Puzzles}}},
  author = {Karumanchi, Narasimha},
  year = {2017},
  edition = {5th},
  publisher = {CareerMonk},
  isbn = {1-4565-4988-X 978-1-4565-4988-6}
}

@article{kayeMinesweeperNPcomplete2000,
  title = {Minesweeper Is {{NP-complete}}},
  author = {Kaye, Richard},
  year = {2000},
  month = mar,
  journal = {The Mathematical Intelligencer},
  volume = {22},
  number = {2},
  pages = {9--15},
  issn = {0343-6993},
  doi = {10.1007/BF03025367},
  urldate = {2024-08-27},
  langid = {english},
  keywords = {Boolean Circuit,Boolean Formula,Important Open Problem,Mathematical Intelligencer,Polynomial Time},
  file = {/home/flaviomoura/Zotero/storage/CFKU3AW9/Kaye - 2000 - Minesweeper is NP-complete.pdf}
}

@misc{kazeminiaModularCountingCSP2025,
  title = {Modular {{Counting CSP}}: {{Reductions}} and {{Algorithms}}},
  shorttitle = {Modular {{Counting CSP}}},
  author = {Kazeminia, Amirhossein and Bulatov, Andrei A.},
  year = {2025},
  month = jan,
  number = {arXiv:2501.04224},
  eprint = {2501.04224},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2501.04224},
  urldate = {2025-01-24},
  abstract = {The Constraint Satisfaction Problem (CSP) is ubiquitous in various areas of mathematics and computer science. Many of its variations have been studied including the Counting CSP, where the goal is to find the number of solutions to a CSP instance. The complexity of finding the exact number of solutions of a CSP is well understood (Bulatov, 2013, and Dyer and Richerby, 2013) and the focus has shifted to other variations of the Counting CSP such as counting the number of solutions modulo an integer. This problem has attracted considerable attention recently. In the case of CSPs based on undirected graphs Bulatov and Kazeminia (STOC 2022) obtained a complexity classification for the problem of counting solutions modulo p for arbitrary prime p. In this paper we report on the progress made towards a similar classification for the general CSP, not necessarily based on graphs. We identify several features that make the general case very different from the graph case such as a stronger form of rigidity and the structure of automorphisms of powers of relational structures. We provide a solution algorithm in the case p=2 that works under some additional conditions and prove the hardness of the problem under some assumptions about automorphisms of the powers of the relational structure. We also reduce the general CSP to the case that only uses binary relations satisfying strong additional conditions.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/DXBKVJRV/Kazeminia and Bulatov - 2025 - Modular Counting CSP Reductions and Algorithms.pdf;/home/flaviomoura/Zotero/storage/57WNCFCE/2501.html}
}

@article{kennawaySequentialEvaluationStrategies1989,
  title = {Sequential {{Evaluation Strategies}} for {{Parallel-Or}} and {{Related Reduction Systems}}},
  author = {Kennaway, J. R.},
  year = {1989},
  journal = {Annals of Pure and Applied Logic},
  volume = {43},
  number = {1},
  pages = {31--56},
  doi = {10.1016/0168-0072(89)90024-9}
}

@misc{kerinecAlgebraicLambdaCalculus2023,
  title = {The Algebraic \${\textbackslash}lambda\$-Calculus Is a Conservative Extension of the Ordinary \${\textbackslash}lambda\$-Calculus},
  author = {Kerinec, Axel and Auclair, Lionel Vaux},
  year = {2023},
  month = may,
  number = {arXiv:2305.01067},
  eprint = {2305.01067},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-06},
  abstract = {The algebraic {$\lambda$}-calculus is an extension of the ordinary {$\lambda$}-calculus with linear combinations of terms. We establish that two ordinary {$\lambda$}-terms are equivalent in the algebraic {$\lambda$}-calculus iff they are {$\beta$}-equal. Although this result was originally stated in the early 2000's (in the setting of Ehrhard and Regnier's differential {$\lambda$}-calculus), the previously proposed proofs were wrong: we explain why previous approaches failed and develop a new proof technique to establish conservativity.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/N8TBK966/Kerinec e Auclair - 2023 - The algebraic $lambda$-calculus is a conservative.pdf}
}

@article{kerinecCallByValueAgain2021,
  title = {Call-{{By-Value}}, {{Again}}!},
  author = {Kerinec, Axel and Manzonetto, Giulio},
  year = {2021},
  pages = {18},
  abstract = {The quest for a fully abstract model of the call-by-value {$\lambda$}-calculus remains crucial in programming language theory, and constitutes an ongoing line of research. While a model enjoying this property has not been found yet, this interesting problem acts as a powerful motivation for investigating classes of models, studying the associated theories and capturing operational properties semantically. We study a relational model presented as a relevant intersection type system, where intersection is in general non-idempotent, except for an idempotent element that is injected in the system. This model is adequate, equates many {$\lambda$}-terms that are indeed equivalent in the maximal observational theory, and satisfies an Approximation Theorem w.r.t. a system of approximants representing finite pieces of call-by-value B{\"o}hm trees. We show that these tools can be used for characterizing the most significant properties of the calculus -- namely valuability, potential valuability and solvability -- both semantically, through the notion of approximants, and logically, by means of the type assignment system. We mainly focus on the characterizations of solvability, as they constitute an original result. Finally, we prove the decidability of the inhabitation problem for our type system by exhibiting a non-deterministic algorithm, which is proven sound, correct and terminating.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/5KPBYIDP/Kerinec e Manzonetto - 2021 - Call-By-Value, Again!.pdf}
}

@article{kerinecRevisitingCallbyvalueOhm2020,
  title = {Revisiting {{Call-by-value B}}{\textbackslash}"ohm Trees in Light of Their {{Taylor}} Expansion},
  author = {Kerinec, Emma and Manzonetto, Giulio and Pagani, Michele},
  year = {2020},
  month = jul,
  journal = {arXiv:1809.02659 [cs]},
  eprint = {1809.02659},
  primaryclass = {cs},
  urldate = {2020-07-15},
  abstract = {The call-by-value lambda calculus can be endowed with permutation rules, arising from linear logic proof-nets, having the advantage of unblocking some redexes that otherwise get stuck during the reduction. We show that such an extension allows to define a satisfying notion of B{\textbackslash}"ohm(-like) tree and a theory of program approximation in the call-by-value setting. We prove that all lambda terms having the same B{\textbackslash}"ohm tree are observationally equivalent, and characterize those B{\textbackslash}"ohm-like trees arising as actual B{\textbackslash}"ohm trees of lambda terms. We also compare this approach with Ehrhard's theory of program approximation based on the Taylor expansion of lambda terms, translating each lambda term into a possibly infinite set of so-called resource terms. We provide sufficient and necessary conditions for a set of resource terms in order to be the Taylor expansion of a lambda term. Finally, we show that the normal form of the Taylor expansion of a lambda term can be computed by performing a normalized Taylor expansion of its B{\textbackslash}"ohm tree. From this it follows that two lambda terms have the same B{\textbackslash}"ohm tree if and only if the normal forms of their Taylor expansions coincide.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/FRNG99R3/Kerinec et al. - 2020 - Revisiting Call-by-value Bohm trees in light of .pdf;/home/flaviomoura/Zotero/storage/AYNRWKEY/1809.html}
}

@article{keshavHowReadPaper2007,
  title = {How to Read a Paper},
  author = {Keshav, S.},
  year = {2007},
  month = jul,
  journal = {ACM SIGCOMM Computer Communication Review},
  volume = {37},
  number = {3},
  pages = {83--84},
  issn = {0146-4833},
  doi = {10.1145/1273445.1273458},
  urldate = {2020-10-12},
  langid = {english}
}

@inproceedings{kesnerExtendingExplicitSubstitution2005,
  title = {Extending the {{Explicit Substitution Paradigm}}},
  booktitle = {Term {{Rewriting}} and {{Applications}}, 16th {{International Conference}}, {{RTA}} 2005, {{Nara}}, {{Japan}}, {{April}} 19-21, 2005, {{Proceedings}}},
  author = {Kesner, Delia and Lengrand, St{\'e}phane},
  year = {2005},
  pages = {407--422},
  doi = {10.1007/978-3-540-32033-3_30}
}

@article{kesnerFinegrainedComputationalInterpretation2022,
  title = {A Fine-Grained Computational Interpretation of {{Girard}}'s Intuitionistic Proof-Nets},
  author = {Kesner, Delia},
  year = {2022},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {6},
  number = {POPL},
  pages = {1--28},
  issn = {2475-1421},
  doi = {10.1145/3498669},
  urldate = {2022-04-01},
  abstract = {This paper introduces a functional term calculus, called pn, that captures the essence of the operational semantics of Intuitionistic Linear Logic Proof-Nets with a faithful degree of granularity, both statically and dynamically. On the static side, we identify an equivalence relation on pn-terms which is sound and complete with respect to the classical notion of structural equivalence for proof-nets. On the dynamic side, we show that every single (exponential) step in the term calculus translates to a different single (exponential) step in the graphical formalism, thus capturing the original Girard's granularity of proof-nets but on the level of terms. We also show some fundamental properties of the calculus such as confluence, strong normalization, preservation of {$\beta$}-strong normalization and the existence of a strong bisimulation that captures pairs of pn-terms having the same graph reduction.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/QZGZ9M9F/Kesner - 2022 - A fine-grained computational interpretation of Gir.pdf}
}

@misc{kesnerMeaningfulnessGenericitySubsuming2024,
  title = {Meaningfulness and {{Genericity}} in a {{Subsuming Framework}}},
  author = {Kesner, Delia and Arrial, Victor and Guerrieri, Giulio},
  year = {2024},
  month = apr,
  number = {arXiv:2404.06361},
  eprint = {2404.06361},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.06361},
  urldate = {2024-04-10},
  abstract = {This paper studies the notion of meaningfulness for a unifying framework called dBang-calculus, which subsumes both call-by-name (dCbN) and call-by-value (dCbV). We first characterize meaningfulness in dBang by means of typability and inhabitation in an associated non-idempotent intersection type system previously proposed in the literature. We validate the proposed notion of meaningfulness by showing two properties (1) consistency of the theory \${\textbackslash}mathcal\{H\}\$ equating meaningless terms and (2) genericity, stating that meaningless subterms have no bearing on the significance of meaningful terms. The theory \${\textbackslash}mathcal\{H\}\$ is also shown to have a unique consistent and maximal extension. Last but not least, we show that the notions of meaningfulness and genericity in the literature for dCbN and dCbV are subsumed by the respectively ones proposed here for the dBang-calculus.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/YDL6VNU8/Kesner et al. - 2024 - Meaningfulness and Genericity in a Subsuming Frame.pdf;/home/flaviomoura/Zotero/storage/MV2WT4Z3/2404.html}
}

@unpublished{kesnerMilnerLambdaCalculus2008,
  title = {Milner's {{Lambda Calculus}} with {{Partial Substitutions}}},
  author = {Kesner, D. and Conch{\'u}ir, S. {\'O}},
  year = {2008}
}

@misc{kesnerNodeReplicationTheory2022,
  title = {Node {{Replication}}: {{Theory And Practice}}},
  shorttitle = {Node {{Replication}}},
  author = {Kesner, Delia and Peyrot, Lo{\"i}c and Ventura, Daniel},
  year = {2022},
  month = jul,
  number = {arXiv:2207.07143},
  eprint = {2207.07143},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-07-18},
  abstract = {We define and study a term calculus implementing higher-order node replication. It is used to specify two different (weak) evaluation strategies: call-by-name and fully lazy call-by-need, that are shown to be observationally equivalent by using type theoretical technical tools.},
  archiveprefix = {arXiv},
  keywords = {03B70,Computer Science - Logic in Computer Science,D.3.1,F.3.2,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/7KRM7TES/Kesner et al. - 2022 - Node Replication Theory And Practice.pdf;/home/flaviomoura/Zotero/storage/DET6DJIY/Kesner et al. - 2023 - Node Replication Theory And Practice.pdf;/home/flaviomoura/Zotero/storage/VF5TVM9N/Kesner et al. - 2023 - Node Replication Theory And Practice.pdf;/home/flaviomoura/Zotero/storage/T2G92MFM/2207.html}
}

@inproceedings{kesnerPerpetualityFullSafe2008,
  title = {Perpetuality for {{Full}} and {{Safe Composition}} (in a {{Constructive Setting}})},
  booktitle = {Automata, {{Languages}} and {{Programming}}, 35th {{International Colloquium}}, {{ICALP}} 2008, {{Reykjavik}}, {{Iceland}}, {{July}} 7-11, 2008, {{Proceedings}}, {{Part II}} - {{Track B}}: {{Logic}}, {{Semantics}}, and {{Theory}} of {{Programming}} \& {{Track C}}: {{Security}} and {{Cryptography Foundations}}},
  author = {Kesner, D.},
  year = {2008},
  pages = {311--322},
  doi = {10.1007/978-3-540-70583-3_26},
  file = {/home/flaviomoura/Zotero/storage/BINS4LSV/Kesner - 2008 - Perpetuality for Full and Safe Composition (in a C.pdf}
}

@article{kesnerPowerTightnessCallByPushValue2021,
  title = {The {{Power}} of {{Tightness}} for {{Call-By-Push-Value}}},
  author = {Kesner, Delia and Viso, Andr{\'e}s},
  year = {2021},
  month = jul,
  journal = {arXiv:2105.00564 [cs]},
  eprint = {2105.00564},
  primaryclass = {cs},
  urldate = {2021-07-12},
  abstract = {We propose tight type systems for Call-by-Name (CBN) and Call-by-Value (CBV) that can be both encoded in a tight type system for Call-by-Push-Value (CBPV). All such systems are quantitative, in the sense that they provide exact information about the length of normalization sequences to normal form (discriminated between multiplicative and exponential steps) as well as the size of these normal forms.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/WR5YTTU8/Kesner e Viso - 2021 - The Power of Tightness for Call-By-Push-Value.pdf;/home/flaviomoura/Zotero/storage/MDZQP57S/2105.html}
}

@techreport{kesnerQuantitativeTypesIntuitionistic2014,
  title = {Quantitative {{Types}} for {{Intuitionistic Calculi}}},
  author = {Kesner, D. and Ventura, D.},
  year = {2014},
  number = {hal-00980868},
  institution = {HAL},
  annotation = {Backup Publisher: Paris Cit{\'e} Sorbonne}
}

@inproceedings{kesnerQuantitativeTypesLinear2014,
  title = {Quantitative {{Types}} for the {{Linear Substitution Calculus}}},
  booktitle = {Proc. of 8th {{Int}}. {{Conference}} on {{Theoretical Computer Science}} - {{IFIP TC}} 1/{{WG}} 2.2},
  author = {Kesner, D. and Ventura, D.},
  year = {2014},
  pages = {296--310}
}

@unpublished{kesnerReasoningCallbyneedMeans2015,
  title = {Reasoning about Call-by-Need by Means of Types},
  author = {Kesner, D.},
  year = {2015}
}

@inproceedings{kesnerResourceAwareComputational2015,
  title = {A {{Resource Aware Computational Interpretation}} for {{Herbelin}}'s {{Syntax}}},
  booktitle = {Proc. 12th {{Int}}. {{Colloquium Theoretical Aspects}} of {{Computing}} - {{ICTAC}}},
  author = {Kesner, D. and Ventura, D.},
  year = {2015},
  pages = {388--403}
}

@article{kesnerResourceOperatorsLcalculus2007,
  title = {Resource Operators for the {$\lambda$}-Calculus},
  author = {Kesner, Delia and Lengrand, St{\'e}phane},
  editor = {Giesl, J{\"u}rgen},
  year = {2007},
  month = apr,
  journal = {Information and Computation},
  volume = {205},
  number = {4},
  pages = {419--473}
}

@inproceedings{kesnerTheoryCalculiExplicit2007,
  ids = {kesnerTheoryCalculiExplicit2007a},
  title = {The {{Theory}} of {{Calculi}} with {{Explicit Substitutions Revisited}}},
  booktitle = {{{CSL}}},
  author = {Kesner, D.},
  year = {2007},
  pages = {238--252},
  file = {/home/flaviomoura/Zotero/storage/VALUT6VW/Kesner - 2007 - The Theory of Calculi with Explicit Substitutions .pdf}
}

@article{kesnerTheoryExplicitSubstitutions2009,
  title = {A {{Theory}} of {{Explicit Substitutions}} with {{Safe}} and {{Full Composition}}},
  author = {Kesner, Delia},
  year = {2009},
  month = jul,
  journal = {Logical Methods in Computer Science},
  volume = {Volume 5, Issue 3},
  pages = {816},
  issn = {1860-5974},
  doi = {10.2168/LMCS-5(3:1)2009},
  urldate = {2023-09-08},
  abstract = {Many different systems with explicit substitutions have been proposed to implement a large class of higher-order languages. Motivations and challenges that guided the development of such calculi in functional frameworks are surveyed in the first part of this paper. Then, very simple technology in named variable-style notation is used to establish a theory of explicit substitutions for the lambda-calculus which enjoys a whole set of useful properties such as full composition, simulation of one-step beta-reduction, preservation of beta-strong normalisation, strong normalisation of typed terms and confluence on metaterms. Normalisation of related calculi is also discussed.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XZBVA3PE/Kesner - 2009 - A Theory of Explicit Substitutions with Safe and F.pdf}
}

@incollection{keuchelNeedleKnotBinder2016,
  title = {Needle \& {{Knot}}: {{Binder Boilerplate Tied Up}}},
  shorttitle = {Needle \& {{Knot}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Keuchel, Steven and Weirich, Stephanie and Schrijvers, Tom},
  editor = {Thiemann, Peter},
  year = {2016},
  volume = {9632},
  pages = {419--445},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-662-49498-1_17},
  urldate = {2024-04-19},
  isbn = {978-3-662-49497-4 978-3-662-49498-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/R2HAVKLN/Keuchel et al. - 2016 - Needle & Knot Binder Boilerplate Tied Up.pdf}
}

@article{kharlampovichFirstorderTheoryGroup2016,
  title = {First-Order Theory of Group Algebras},
  author = {Kharlampovich, O. and Miasnikov, A.},
  year = {2016},
  month = jul,
  journal = {ArXiv e-prints},
  keywords = {03C60,16B70,20E05,Mathematics - Logic}
}

@article{kimEquationalTheoremProving,
  title = {Equational {{Theorem Proving Modulo}}},
  author = {Kim, Dohan and Lynch, Christopher},
  pages = {22},
  abstract = {Unlike other methods for theorem proving modulo with constrained clauses [12, 13], equational theorem proving modulo with constrained clauses along with its simplification techniques has not been well studied. We introduce a basic paramodulation calculus modulo equational theories E satisfying certain properties of E and present a new framework for equational theorem proving modulo E with constrained clauses. We propose an inference rule called Generalized E-Parallel for constrained clauses, which makes our inference system completely basic, meaning that we do not need to allow any paramodulation in the constraint part of a constrained clause for refutational completeness. We present a saturation procedure for constrained clauses based on relative reducibility and show that our inference system including our contraction rules is refutationally complete.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/P5RKCZTC/Kim e Lynch - Equational Theorem Proving Modulo.pdf}
}

@inproceedings{kirchnerHigherorderEquationalUnification1997,
  title = {Higher-Order {{Equational Unification}} via {{Explicit Substitutions}}},
  booktitle = {Proc. {{Algebraic}} and {{Logic Programming}}},
  author = {Kirchner, C. and Ringeissen, C.},
  year = {1997},
  series = {{{LNCS}}},
  volume = {1298},
  pages = {61--75},
  publisher = {Springer}
}

@article{kirstTrakhtenbrotTheoremCoq2021,
  title = {Trakhtenbrot's {{Theorem}} in {{Coq}}: {{Finite Model Theory}} through the {{Constructive Lens}}},
  shorttitle = {Trakhtenbrot's {{Theorem}} in {{Coq}}},
  author = {Kirst, Dominik and {Larchey-Wendling}, Dominique},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.14445 [cs, math]},
  eprint = {2104.14445},
  primaryclass = {cs, math},
  urldate = {2021-04-30},
  abstract = {We study finite first-order satisfiability (FSAT) in the constructive setting of dependent type theory. Employing synthetic accounts of enumerability and decidability, we give a full classification of FSAT depending on the first-order signature of non-logical symbols. On the one hand, our development focuses on Trakhtenbrot's theorem, stating that FSAT is undecidable as soon as the signature contains an at least binary relation symbol. Our proof proceeds by a many-one reduction chain starting from the Post correspondence problem. On the other hand, we establish the decidability of FSAT for monadic first-order logic, i.e. where the signature only contains at most unary function and relation symbols, as well as the enumerability of FSAT for arbitrary enumerable signatures. To showcase an application of Trakthenbrot's theorem, we continue our reduction chain with a many-one reduction from FSAT to separation logic. All our results are mechanised in the framework of a growing Coq library of synthetic undecidability proofs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computation and Language,Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/4Y5M4NB6/Kirst e Larchey-Wendling - 2021 - Trakhtenbrot's Theorem in Coq Finite Model Theory.pdf;/home/flaviomoura/Zotero/storage/A9H4Q4VX/Kirst and Larchey-Wendling - Trakhtenbrot's Theorem in Coq  Finite Model Theor.pdf;/home/flaviomoura/Zotero/storage/L5XVELFY/2104.html}
}

@article{kleeneInconsistencyCertainFormal1935,
  title = {The Inconsistency of Certain Formal Logics},
  author = {Kleene, S. and Rosser, B.},
  year = {1935},
  journal = {Annals of Math.},
  volume = {36},
  number = {2},
  pages = {630--636}
}

@book{kleinbergAlgorithmDesign2006,
  title = {Algorithm Design},
  author = {Kleinberg, Jon M. and Tardos, {\'E}va},
  year = {2006},
  publisher = {Addison-Wesley},
  isbn = {978-0-321-37291-8},
  file = {/home/flaviomoura/Zotero/storage/HWBRPQD3/Kleinberg e Tardos - 2006 - Algorithm design.pdf}
}

@book{klenkeProbabilityTheory2014,
  title = {Probability {{Theory}}},
  author = {Klenke, Achim},
  year = {2014},
  series = {Universitext},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-5361-0}
}

@article{klinkenbergExactBayesianInference2024,
  title = {Exact {{Bayesian Inference}} for {{Loopy Probabilistic Programs}} Using {{Generating Functions}}},
  author = {Klinkenberg, Lutz and Blumenthal, Christian and Chen, Mingshuai and Haase, Darion and Katoen, Joost-Pieter},
  year = {2024},
  month = apr,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {8},
  number = {OOPSLA1},
  pages = {923--953},
  issn = {2475-1421},
  doi = {10.1145/3649844},
  urldate = {2024-05-09},
  abstract = {We present an exact Bayesian inference method for inferring posterior distributions encoded by probabilistic programs featuring possibly               unbounded loops               . Our method is built on a denotational semantics represented by               probability generating functions               , which resolves semantic intricacies induced by intertwining discrete probabilistic loops with               conditioning               (for encoding posterior observations). We implement our method in a tool called Prodigy; it augments existing computer algebra systems with the theory of generating functions for the (semi-)automatic inference and quantitative verification of conditioned probabilistic programs. Experimental results show that Prodigy can handle various infinite-state loopy programs and exhibits comparable performance to state-of-the-art exact inference tools over loop-free benchmarks.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/W887DMUY/Klinkenberg et al. - 2024 - Exact Bayesian Inference for Loopy Probabilistic P.pdf}
}

@phdthesis{klopCombinatoryReductionSystems1980,
  title = {Combinatory Reduction Systems},
  author = {Klop, J. W.},
  year = {1980},
  school = {Univ. Utrecht}
}

@article{klopCombinatoryReductionSystems1993,
  title = {Combinatory {{Reduction Systems}}: {{Introduction}} and {{Survey}}},
  author = {Klop, J.-W. and van Oostrom, V. and van Raamsdonk, F.},
  year = {1993},
  journal = {Theor. Comput. Sci.},
  volume = {121},
  number = {1\&2},
  pages = {279--308}
}

@inproceedings{knobelsdorfAnalyzingStudentPractices2016,
  title = {Analyzing {{Student Practices}} in {{Theory}} of {{Computation}} in {{Light}} of {{Distributed Cognition Theory}}},
  booktitle = {Proceedings of the 2016 {{ACM Conference}} on {{International Computing Education Research}} - {{ICER}} '16},
  author = {Knobelsdorf, Maria and Frede, Christiane},
  year = {- 2016},
  pages = {nil},
  doi = {10.1145/2960310.2960331}
}

@inproceedings{knothLiquidResourceTypes2020,
  title = {Liquid {{Resource Types}}},
  booktitle = {{{ICFP}}'20},
  author = {KNOTH, {\relax TRISTAN} and REYNOLDS, {\relax ADAM} and WANG, {\relax DI} and HOFFMANN, {\relax JAN} and POLIKARPOVA, {\relax NADIA}},
  year = {2020}
}

@book{knuthArtComputerProgramming1997,
  title = {The {{Art}} of {{Computer Programming}}, {{Volume}} 2: {{Seminumerical Algorithms}}},
  author = {Knuth, D. E.},
  year = {1997},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {Boston, MA, USA},
  isbn = {0-201-89684-2},
  file = {/home/flaviomoura/Zotero/storage/4GGZTCRL/Knuth - 1997 - The Art of Computer Programming, Volume 2 Seminum.pdf}
}

@book{knuthArtComputerProgramming1997a,
  title = {The {{Art}} of {{Computer Programming}}, {{Volume}} 1: {{Fundamental Algorithms}}},
  author = {Knuth, D. E.},
  year = {1997},
  publisher = {Addison Wesley Longman Publishing Co., Inc.},
  address = {Redwood City, CA, USA},
  isbn = {0-201-89683-4},
  file = {/home/flaviomoura/Zotero/storage/TSMAJH7X/Knuth - 1997 - The Art of Computer Programming, Volume 1 Fundame.pdf}
}

@book{knuthArtComputerProgramming1998,
  title = {The {{Art}} of {{Computer Programming}}, {{Volume}} 3: {{Sorting}} and {{Searching}}},
  author = {Knuth, D. E.},
  year = {1998},
  publisher = {Addison Wesley Longman Publishing Co., Inc.},
  address = {Redwood City, CA, USA},
  isbn = {0-201-89685-0},
  file = {/home/flaviomoura/Zotero/storage/FMLLY98X/Knuth - 1998 - The Art of Computer Programming, Volume 3 Sorting.pdf}
}

@book{knuthSelectedPapersAnalysis2000,
  title = {Selected Papers on Analysis of Algorithms},
  author = {Knuth, Donald Ervin},
  year = {2000},
  publisher = {{Center for the Study of Language and Information, Leland Stanford Junior University}},
  address = {Stanford, Calif.},
  isbn = {978-1-57586-211-8 978-1-57586-212-5},
  lccn = {QA9.58 .K65 2000},
  keywords = {Algorithms},
  file = {/home/flaviomoura/Zotero/storage/P9GX9TG4/Knuth - 2000 - Selected papers on analysis of algorithms.pdf}
}

@book{knuthSelectedPapersComputer1996,
  title = {Selected Papers on Computer Science},
  author = {Knuth, Donald Ervin},
  year = {1996},
  series = {{{CSLI}} Lecture Notes},
  number = {no. 59},
  publisher = {CSLI Publications ; Cambridge University Press},
  address = {Stanford, Calif.] : [Cambridge, Mass.},
  isbn = {978-1-881526-91-9 978-1-881526-92-6},
  lccn = {QA76 .K537 1996},
  keywords = {Computer science},
  file = {/home/flaviomoura/Zotero/storage/X4YKXCAI/Knuth - 1996 - Selected papers on computer science.pdf}
}

@incollection{knuthSimpleWordProblems1970,
  title = {Simple {{Word Problems}} in {{Universal Algebras}}},
  booktitle = {Computational {{Problems}} in {{Abstract Algebra}}},
  author = {Knuth, D. and Bendix, P.},
  editor = {Leech, J.},
  year = {1970},
  pages = {263--297},
  publisher = {Pergamon Press}
}

@misc{kobayashiDecidableUndecidableExtensions2024,
  title = {On {{Decidable}} and {{Undecidable Extensions}} of {{Simply Typed Lambda Calculus}}},
  author = {Kobayashi, Naoki},
  year = {2024},
  month = nov,
  number = {arXiv:2411.06086},
  eprint = {2411.06086},
  publisher = {arXiv},
  urldate = {2024-11-18},
  abstract = {The decidability of the reachability problem for finitary PCF has been used as a theoretical basis for fully automated verification tools for functional programs. The reachability problem, however, often becomes undecidable for a slight extension of finitary PCF with side effects, such as exceptions, algebraic effects, and references, which hindered the extension of the above verification tools for supporting functional programs with side effects. In this paper, we first give simple proofs of the undecidability of four extensions of finitary PCF, which would help us understand and analyze the source of undecidability. We then focus on an extension with references, and give a decidable fragment using a type system. To our knowledge, this is the first non-trivial decidable fragment that features higher-order recursive functions containing reference cells.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/9RE4Z8AX/Kobayashi - 2024 - On Decidable and Undecidable Extensions of Simply .pdf;/home/flaviomoura/Zotero/storage/G38ETMRE/2411.html}
}

@book{kobayashiFoundationsSoftwareScience2024,
  title = {Foundations of {{Software Science}} and {{Computation Structures}}: 27th {{International Conference}}, {{FoSSaCS}} 2024, {{Held}} as {{Part}} of the {{European Joint Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2024, {{Luxembourg City}}, {{Luxembourg}}, {{April}} 6--11, 2024, {{Proceedings}}, {{Part II}}},
  shorttitle = {Foundations of {{Software Science}} and {{Computation Structures}}},
  editor = {Kobayashi, Naoki and Worrell, James},
  year = {2024},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {14575},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-57231-9},
  urldate = {2024-04-16},
  copyright = {https://creativecommons.org/licenses/by/4.0},
  isbn = {978-3-031-57230-2 978-3-031-57231-9},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/42LNGXGE/Kobayashi e Worrell - 2024 - Foundations of Software Science and Computation St.pdf}
}

@article{kobayashiTerminationProblemProbabilistic2020,
  title = {On the {{Termination Problem}} for {{Probabilistic Higher-Order Recursive Programs}}},
  author = {Kobayashi, Naoki and Lago, Ugo Dal and Grellois, Charles},
  year = {2020},
  month = sep,
  journal = {arXiv:1811.02133 [cs]},
  eprint = {1811.02133},
  primaryclass = {cs},
  urldate = {2020-09-24},
  abstract = {In the last two decades, there has been much progress on model checking of both probabilistic systems and higher-order programs. In spite of the emergence of higher-order probabilistic programming languages, not much has been done to combine those two approaches. In this paper, we initiate a study on the probabilistic higher-order model checking problem, by giving some first theoretical and experimental results. As a first step towards our goal, we introduce PHORS, a probabilistic extension of higher-order recursion schemes (HORS), as a model of probabilistic higher-order programs. The model of PHORS may alternatively be viewed as a higher-order extension of recursive Markov chains. We then investigate the probabilistic termination problem -- or, equivalently, the probabilistic reachability problem. We prove that almost sure termination of order-2 PHORS is undecidable. We also provide a fixpoint characterization of the termination probability of PHORS, and develop a sound (but possibly incomplete) procedure for approximately computing the termination probability. We have implemented the procedure for order-2 PHORSs, and confirmed that the procedure works well through preliminary experiments that are reported at the end of the article.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/SJR2YCCZ/Kobayashi et al. - 2020 - On the Termination Problem for Probabilistic Highe.pdf;/home/flaviomoura/Zotero/storage/5DCXHUEL/1811.html}
}

@article{kochUndecidabilityIncompletenessCompletenessof2022,
  title = {Undecidability, {{Incompleteness}}, and {{Completenessof Second-Order Logic}} in {{Coq}}},
  author = {Koch, Mark and Kirst, Dominik},
  year = {2022},
  pages = {17},
  abstract = {We mechanise central metatheoretic results about secondorder logic (SOL) using the Coq proof assistant. Concretely, we consider undecidability via many-one reduction from Diophantine equations (Hilbert's tenth problem), incompleteness regarding full semantics via categoricity of secondorder Peano arithmetic, and completeness regarding Henkin semantics via translation to mono-sorted first-order logic (FOL). Moreover, this translation is used to transport further characteristic properties of FOL to SOL, namely the compactness and L{\"o}wenheim-Skolem theorems.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2WW8B5XN/Koch e Kirst - 2022 - Undecidability, Incompleteness, and Completenessof.pdf}
}

@article{kochUndecidabilityIncompletenessSecondOrder,
  title = {Undecidability and {{Incompleteness}} of {{Second-Order Logic}}},
  author = {Koch, Mark},
  pages = {9},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NJ9RIXNZ/Koch - Undecidability and Incompleteness of Second-Order .pdf}
}

@unpublished{kohlhaseExperiencesExportingMajor2020,
  title = {Experiences from {{Exporting Major Proof Assistant Libraries}}},
  author = {Kohlhase, Michael and Rabe, Florian},
  year = {2020}
}

@article{kokkeProgrammingLanguageFoundations2020,
  title = {Programming Language Foundations in {{Agda}}},
  author = {Kokke, Wen and Siek, Jeremy G. and Wadler, Philip},
  year = {2020},
  month = aug,
  journal = {Science of Computer Programming},
  volume = {194},
  pages = {102440},
  issn = {01676423},
  doi = {10.1016/j.scico.2020.102440},
  urldate = {2023-10-27},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PGQSD7GZ/Wadler - Programming Language Foundations in Agda.pdf;/home/flaviomoura/Zotero/storage/VY8FLEP6/Kokke et al. - 2020 - Programming language foundations in Agda.pdf}
}

@article{komarathPebblingMeetsColoring2018,
  title = {Pebbling Meets Coloring: {{Reversible}} Pebble Game on Trees},
  shorttitle = {Pebbling Meets Coloring},
  author = {Komarath, Balagopal and Sarma, Jayalal and Sawlani, Saurabh},
  year = {2018},
  month = feb,
  journal = {Journal of Computer and System Sciences},
  volume = {91},
  pages = {33--41},
  issn = {00220000},
  doi = {10.1016/j.jcss.2017.07.009},
  urldate = {2025-01-17},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/4QX4GKC4/Komarath et al. - 2018 - Pebbling meets coloring Reversible pebble game on trees.pdf}
}

@article{komendantskayaNewNormalWe2020,
  title = {The {{New Normal}}: {{We Cannot Eliminate Cuts}} in {{Coinductive Calculi}}, {{But We Can Explore Them}}},
  shorttitle = {The {{New Normal}}},
  author = {Komendantskaya, Ekaterina and Rozplokhas, Dmitry and Basold, Henning},
  year = {2020},
  month = aug,
  journal = {arXiv:2008.03714 [cs]},
  eprint = {2008.03714},
  primaryclass = {cs},
  urldate = {2020-08-15},
  abstract = {In sequent calculi, cut elimination is a property that guarantees that any provable formula can be proven analytically. For example, Gentzen's classical and intuitionistic calculi LK and LJ enjoy cut elimination. The property is less studied in coinductive extensions of sequent calculi. In this paper, we use coinductive Horn clause theories to show that cut is not eliminable in a coinductive extension of LJ, a system we call CLJ. We derive two further practical results from this study. We show that CoLP by Gupta et al. gives rise to cut-free proofs in CLJ with fixpoint terms, and we formulate and implement a novel method of coinductive theory exploration that provides several heuristics for discovery of cut formulae in CLJ.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/5GTNN3XL/Komendantskaya et al. - 2020 - The New Normal We Cannot Eliminate Cuts in Coindu.pdf;/home/flaviomoura/Zotero/storage/2I3L6635/2008.html}
}

@article{komoriSimplifiedProofChurchRosser2014,
  title = {A {{Simplified Proof}} of the {{Church-Rosser Theorem}}},
  author = {Komori, Yuichi and Matsuda, Naosuke and Yamakawa, Fumika},
  year = {2014},
  journal = {Studia Logica},
  volume = {102},
  number = {1},
  pages = {175--183},
  doi = {10.1007/s11225-013-9470-y},
  file = {/home/flaviomoura/Zotero/storage/875BSPMC/Komori et al. - 2014 - A Simplified Proof of the ChurchâRosser Theorem.pdf}
}

@book{kossakMathematicalLogic2018,
  title = {Mathematical {{Logic}}},
  author = {Kossak, Roman},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-97298-5}
}

@misc{kostyukovFunctionalApproachStandard2013,
  title = {A {{Functional Approach}} to {{Standard Binary Heaps}}},
  author = {Kostyukov, Vladimir},
  year = {2013},
  month = dec,
  number = {arXiv:1312.4666},
  eprint = {1312.4666},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-05-09},
  abstract = {This paper describes a new and purely functional implementation technique of binary heaps. A binary heap is a tree-based data structure that implements priority queue operations (insert, remove, minimum/maximum) and guarantees at worst logarithmic running time for them. Approaches and ideas described in this paper present a simple and asymptotically optimal implementation of immutable binary heap.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Data Structures and Algorithms},
  file = {/home/flaviomoura/Zotero/storage/GCIC3TUL/Kostyukov - 2013 - A Functional Approach to Standard Binary Heaps.pdf}
}

@article{koulouriTeachingIntroductoryProgramming2015,
  title = {Teaching {{Introductory Programming}}: {{A Quantitative Evaluation}} of {{Different Approaches}}},
  shorttitle = {Teaching {{Introductory Programming}}},
  author = {Koulouri, Theodora and Lauria, Stanislao and Macredie, Robert D.},
  year = {2015},
  month = feb,
  journal = {ACM Transactions on Computing Education},
  volume = {14},
  number = {4},
  pages = {1--28},
  issn = {1946-6226, 1946-6226},
  doi = {10.1145/2662412},
  urldate = {2020-07-11},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/LUB4G46A/Koulouri et al. - 2015 - Teaching Introductory Programming A Quantitative .pdf}
}

@inproceedings{koutavasFullyAbstractNormal2023,
  title = {Fully {{Abstract Normal Form Bisimulation}} for {{Call-by-Value PCF}}},
  booktitle = {2023 38th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}})},
  author = {Koutavas, Vasileios and Lin, Yu-Yang and Tzevelekos, Nikos},
  year = {2023},
  month = jun,
  pages = {1--13},
  doi = {10.1109/LICS56636.2023.10175778},
  abstract = {We present the first fully abstract normal form bisimulation for call-by-value PCF (PCFv). Our model is based on a labelled transition system (LTS) that combines elements from applicative bisimulation, environmental bisimulation and game semantics. In order to obtain completeness while avoiding the use of semantic quotiening, the LTS constructs traces corresponding to interactions with possible functional contexts. The model gives rise to a sound and complete technique for checking of PCFv program equivalence, which we implement in a bounded bisimulation checking tool. We test our tool on known equivalences from the literature and new examples.},
  keywords = {Computer science,Games,Optimization,Semantics,Testing},
  file = {/home/flaviomoura/Zotero/storage/GHBBPUE3/Koutavas et al. - 2023 - Fully Abstract Normal Form Bisimulation for Call-b.pdf;/home/flaviomoura/Zotero/storage/DSHJNMHZ/10175778.html}
}

@article{koutsoukou-argyrakiFormalisingMathematicsPraxis2021,
  title = {Formalising {{Mathematics}} -- in {{Praxis}}; {{A Mathematician}}'s {{First Experiences}} with {{Isabelle}}/{{HOL}} and the {{Why}} and {{How}} of {{Getting Started}}},
  author = {{Koutsoukou-Argyraki}, Angeliki},
  year = {2021},
  month = mar,
  journal = {Jahresbericht der Deutschen Mathematiker-Vereinigung},
  volume = {123},
  number = {1},
  pages = {3--26},
  issn = {1869-7135},
  doi = {10.1365/s13291-020-00221-1},
  urldate = {2024-01-11},
  abstract = {This is an account of a mathematician's first experiences with the proof assistant (interactive theorem prover) Isabelle/HOL, including a discussion on the rationale behind formalising mathematics and the choice of Isabelle/HOL in particular, some instructions for new users, some technical and conceptual observations focussing on some of the first difficulties encountered, and some thoughts on the use and potential of proof assistants for mathematics.},
  langid = {english},
  keywords = {03B35,68V15,68V20,68V35,Formalisation of mathematics,Interactive theorem proving,Isabelle/HOL,Proof assistant},
  file = {/home/flaviomoura/Zotero/storage/GMW96PFK/Koutsoukou-Argyraki - 2021 - Formalising Mathematics â in Praxis; A Mathematici.pdf}
}

@article{koutsoukou-argyrakiWhatCanFormal,
  title = {What Can Formal Systems Do for Mathematics? {{A}} Discussion through the Lens of Proof Assistants},
  author = {{Koutsoukou-Argyraki}, Angeliki},
  abstract = {This article containing interviews with Jeremy Avigad, Jasmin Blanchette, Fr{\textasciiacute}ed{\textasciiacute}eric Blanqui, Kevin Buzzard, Johan Commelin, Manuel Eberl, Timothy Gowers, Peter Koepke, Assia Mahboubi, Ursula Martin, and Lawrence C. Paulson attempts to approach the question of the significance of proof assistants---in tandem with the (possible) effects of their underlying logical formalisms---for contemporary and future mathematical practice. The answer to this broad question within such a fast-developing area involving cutting-edge research cannot be clear nor complete; here, through a discussion with eleven leading experts and considering some recent advances as well as several newly started research projects, we merely attempt to illuminate varying aspects of the topic, with the hope to demonstrate its dynamic, richness and potential.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/RIQRZSNA/Koutsoukou-Argyraki - What can formal systems do for mathematics A disc.pdf}
}

@article{kovacsGeneralizedUniverseHierarchies2021,
  title = {Generalized {{Universe Hierarchies}} and {{First-Class Universe Levels}}},
  author = {Kov{\'a}cs, Andr{\'a}s},
  year = {2021},
  month = feb,
  journal = {arXiv:2103.00223 [cs]},
  eprint = {2103.00223},
  primaryclass = {cs},
  urldate = {2021-03-06},
  abstract = {In type theories, universe hierarchies are commonly used to increase the expressive power of the theory while avoiding inconsistencies arising from size issues. There are numerous ways to specify universe hierarchies, and theories may differ in details of cumulativity, choice of universe levels, specification of type formers and eliminators, and available internal operations on levels. In the current work, we aim to provide a framework which covers a large part of the design space. First, we develop syntax and semantics for cumulative universe hierarchies, where levels may come from any set equipped with a transitive well-founded ordering. In the semantics, we show that induction-recursion can be used to model transfinite hierarchies, and also support lifting operations on type codes which strictly preserve type formers. Then, we consider a setup where universe levels are first-class types and subject to arbitrary internal reasoning. This generalizes the bounded polymorphism features of Coq and at the same time the internal level computations in Agda.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/UBJMKIQT/KovÃ¡cs - 2021 - Generalized Universe Hierarchies and First-Class U.pdf;/home/flaviomoura/Zotero/storage/6FX44JSC/2103.html}
}

@article{kovacsSignaturesInductionPrinciples2020,
  title = {Signatures and {{Induction Principles}} for {{Higher Inductive-Inductive Types}}},
  author = {Kov{\'a}cs, Andr{\'a}s and Kaposi, Ambrus},
  year = {2020},
  journal = {Logical Methods in Computer Science},
  volume = {16},
  publisher = {Episciences. org}
}

@article{kozakeviciusEstudandoFuncoesAlgoritmos2024,
  title = {{Estudando fun{\c c}{\~o}es e algoritmos por meio de origamis}},
  author = {Kozakevicius, Alice and Kulesza, Mait{\'e}},
  year = {2024},
  journal = {Revista Professor de Matem{\'a}tica On line},
  volume = {12},
  number = {7},
  issn = {2319023X},
  doi = {10.21711/2319023x2024/pmo127},
  urldate = {2024-04-03},
  abstract = {In this work, the paper folds obtained by the Japanese origami technique are considered as a starting point to define and present concrete examples of functions and their composites. Basic concepts like domain, range, direct and inverse image of a function are illustrated via concrete material. From the folds made via origami, concepts and definitions such as injective function, surjective function and invertible function are explored. In addition, origamis are natural examples for composition of functions and for obtaining the inverse of these composite functions. The contribution of the approach to the concept of function via origami is in the intuitive and playful presentation of the definition of algorithm, routines and subroutines.},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/7ICZXPRU/Kozakevicius e Kulesza - 2024 - Estudando funÃ§Ãµes e algoritmos por meio de origami.pdf}
}

@book{kozenAutomataComputability1997,
  title = {Automata and {{Computability}}},
  author = {Kozen, Dexter C.},
  year = {1997},
  series = {[]},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4612-1844-9}
}

@article{kozenNaturalTransformationsRewrite2016,
  title = {Natural {{Transformations}} as {{Rewrite Rules}} and {{Monad Composition}}},
  author = {Kozen, D.},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@article{kozenPracticalCoinduction2016,
  title = {Practical {{Coinduction}}},
  author = {Kozen, D. and Silva, A.},
  year = {2016},
  journal = {Mathematical Structures in Computer Science},
  volume = {nil},
  number = {nil},
  pages = {1--21},
  doi = {10.1017/s0960129515000493},
  file = {/home/flaviomoura/Zotero/storage/IHB8M629/Kozen e Silva - 2017 - Practical coinduction.pdf}
}

@misc{kozyrevCoqPilotPluginLLMbased2024,
  title = {{{CoqPilot}}, a Plugin for {{LLM-based}} Generation of Proofs},
  author = {Kozyrev, Andrei and Solovev, Gleb and Khramov, Nikita and Podkopaev, Anton},
  year = {2024},
  month = oct,
  number = {arXiv:2410.19605},
  eprint = {2410.19605},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2410.19605},
  urldate = {2024-10-28},
  abstract = {We present CoqPilot, a VS Code extension designed to help automate writing of Coq proofs. The plugin collects the parts of proofs marked with the admit tactic in a Coq file, i.e., proof holes, and combines LLMs along with non-machine-learning methods to generate proof candidates for the holes. Then, CoqPilot checks if each proof candidate solves the given subgoal and, if successful, replaces the hole with it. The focus of CoqPilot is twofold. Firstly, we want to allow users to seamlessly combine multiple Coq generation approaches and provide a zero-setup experience for our tool. Secondly, we want to deliver a platform for LLM-based experiments on Coq proof generation. We developed a benchmarking system for Coq generation methods, available in the plugin, and conducted an experiment using it, showcasing the framework's possibilities. Demo of CoqPilot is available at: https://youtu.be/oB1Lx-So9Lo. Code at: https://github.com/JetBrains-Research/coqpilot},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Software Engineering},
  file = {/home/flaviomoura/Zotero/storage/LDPSHQ8Q/Kozyrev et al. - 2024 - CoqPilot, a plugin for LLM-based generation of pro.pdf;/home/flaviomoura/Zotero/storage/XRGRXPV4/2410.html}
}

@article{krausNotionsAnonymousExistence2016,
  title = {Notions of {{Anonymous Existence}} in {{Martin-L}}\${\textbackslash}backslash\$``of {{Type Theory}}},
  author = {Kraus, N. and Escard{\'o}, M. and Coquand, T. and Altenkirch, T.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {03B15,Computer Science - Logic in Computer Science,F.4.1}
}

@book{kreiselElementsMathematicalLogic1967,
  title = {Elements of {{Mathematical Logic}} ({{Model Theory}})},
  author = {Kreisel, G. and Krivine, J. L.},
  year = {1967},
  publisher = {North Holland Publishing Company}
}

@article{kripkeOdelTheoremDirect2021,
  title = {G{\textbackslash}"odel's {{Theorem}} and {{Direct Self-Reference}}},
  author = {Kripke, Saul A.},
  year = {2021},
  month = jun,
  journal = {arXiv:2010.11979 [math]},
  eprint = {2010.11979},
  primaryclass = {math},
  urldate = {2021-06-08},
  abstract = {In his paper on the incompleteness theorems, G{\textbackslash}"odel seemed to say that a direct way of constructing a formula that says of itself that it is unprovable might involve a faulty circularity. In this note, it is proved that 'direct' self-reference can actually be used to prove his result.},
  archiveprefix = {arXiv},
  keywords = {03-03 03B10,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/WUVRFGIU/2010.html}
}

@incollection{kripkeSemanticalAnalysisIntuitionistic1965,
  title = {Semantical {{Analysis}} of {{Intuitionistic Logic I}}},
  booktitle = {Formal {{Systems}} and {{Recursive Functions}}},
  author = {Kripke, Saul A.},
  year = {1965},
  series = {Formal {{Systems}} and {{Recursive Functions}}},
  pages = {92--130},
  publisher = {Elsevier},
  doi = {10.1016/s0049-237x(08)71685-9}
}

@article{krivinePreuveFormelleIntuitionniste1996,
  title = {Une {{Preuve Formelle Et Intuitionniste Du Th{\'e}or{\`e}me De Compl{\'e}tude De La Logique Classique}}},
  author = {Krivine, J.-L.},
  year = {1996},
  journal = {Bull. symb. log.},
  volume = {2},
  number = {04},
  pages = {405--421},
  doi = {10.2307/421172}
}

@article{krivineProgramFullAxiom2020,
  ids = {krivineProgramFullAxiom2021},
  title = {A Program for the Full Axiom of Choice},
  author = {Krivine, Jean-Louis},
  year = {2020},
  month = aug,
  journal = {arXiv:2006.05433 [cs, math]},
  eprint = {2006.05433},
  primaryclass = {cs, math},
  urldate = {2020-08-04},
  abstract = {The theory of classical realizability is a framework for the Curry-Howard correspondence which enables to associate a program with each proof in Zermelo-Fraenkel set theory. But, almost all the applications of mathematics in physics, probability, statistics, etc. use Analysis i.e. the axiom of dependent choice (DC) or even the (full) axiom of choice (AC). It is therefore important to find explicit programs for these axioms. Various solutions are already known for DC, for instance the lambda-term known as "bar recursion". We present here the first one, as far as we know, for AC.},
  archiveprefix = {arXiv},
  keywords = {03E40,Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/BS4DRBG5/Krivine - 2020 - A program for the full axiom of choice.pdf;/home/flaviomoura/Zotero/storage/P6HTR654/Krivine - 2021 - A program for the full axiom of choice.pdf;/home/flaviomoura/Zotero/storage/ZNYWFWKS/Krivine - 2021 - A program for the full axiom of choice.pdf;/home/flaviomoura/Zotero/storage/5KUFEM7B/2006.html;/home/flaviomoura/Zotero/storage/JZ8W3P5F/2006.html;/home/flaviomoura/Zotero/storage/PH3GIV2J/2006.html}
}

@book{kuchenProgrammingLanguagesImplementations1996,
  title = {Programming {{Languages}}: {{Implementations}}, {{Logics}}, and {{Programs}}, 8th {{International Symposium}}, {{PLILP}}'96, {{Aachen}}, {{Germany}}, {{September}} 24-27, 1996, {{Proceedings}}},
  editor = {Kuchen, Herbert and Swierstra, S. Doaitse},
  year = {1996},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1140},
  publisher = {Springer},
  doi = {10.1007/3-540-61756-6},
  isbn = {3-540-61756-6}
}

@article{kuhailTeachingRecursiveThinking,
  title = {Teaching Recursive Thinking Using Unplugged Activities},
  author = {Kuhail, Mohammad A and Negreiros, Joao and Seffah, Ahmed},
  pages = {7},
  abstract = {Traditionally, recursion is primarily taught using coding activities, presenting a high cognitive load for novice programmers. A possible method to teach recursion to novice programmers is the use of unplugged activities, engaging tasks not involving coding. Despite having been shown to improve students' understanding of computational thinking, it has been argued that unplugged activities alone are not effective to teach recursion. In response, the authors engaged novice programmers who are non-computer science students by utilising unplugged visual activities to illustrate basic recursion concepts. Thereafter, the students were shown how to implement the activities with coding. The authors created three activities that illustrate recursion using breadth-first search (BFS) and depth-first search (DFS) algorithms. An evaluation study with 19 students was conducted in an on-line teaching environment. Empirical results show that most students learned the covered activities. Further, the students reported that the activities were engaging, and helped them learn how to think recursively.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/V4ECU8NL/Kuhail et al. - Teaching recursive thinking using unplugged activi.pdf}
}

@article{kumar2019design,
  title = {Design and Analysis of Algorithms},
  author = {Kumar, Sandeep Sen Amit},
  year = {2019},
  publisher = {Cambridge University Press},
  file = {/home/flaviomoura/Zotero/storage/JG4W54L7/Kumar - 2019 - Design and analysis of algorithms.pdf}
}

@article{kunzeFormalSmallStepVerification2018,
  title = {Formal {{Small-Step Verification}} of a {{Call-By-Value Lambda Calculus Machine}}},
  author = {Kunze, Fabian and Smolka, Gert and Forster, Yannick},
  year = {2018},
  journal = {CoRR},
  abstract = {We formally verify an abstract machine for a call-by-value lambda-calculus with de Bruijn terms, simple substitution, and small-step semantics. We follow a stepwise refinement approach starting with a naive stack machine with substitution. We then refine to a machine with closures, and finally to a machine with a heap providing structure sharing for closures. We prove the correctness of the three refinement steps with compositional small-step bottom-up simulations. There is an accompanying Coq development verifying all results.}
}

@article{kurbisNormalisationSubformulaProperty2022,
  title = {Normalisation and {{Subformula Property}} for a {{System}} of {{Classical Logic}} with {{Tarski}}'s {{Rule}}, and a {{Correction}}},
  author = {K{\"u}rbis, Nils},
  year = {2022},
  month = feb,
  journal = {Archive for Mathematical Logic},
  volume = {61},
  number = {1-2},
  eprint = {2108.03939},
  primaryclass = {cs, math},
  pages = {105--129},
  issn = {0933-5846, 1432-0665},
  doi = {10.1007/s00153-021-00775-6},
  urldate = {2023-04-25},
  abstract = {This paper considers a formalisation of classical logic using general introduction rules and general elimination rules. It proposes a definition of `maximal formula', `segment' and `maximal segment' suitable to the system, and gives reduction procedures for them. It is then shown that deductions in the system convert into normal form, i.e. deductions that contain neither maximal formulas nor maximal segments, and that deductions in normal form satisfy the subformula property. Tarski's Rule is treated as a general introduction rule for implication. The general introduction rule for negation has a similar form. Maximal formulas with implication or negation as main operator require reduction procedures of a more intricate kind not present in normalisation for intuitionist logic.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/MGTUZ3IY/KÃ¼rbis - 2022 - Normalisation and Subformula Property for a System.pdf}
}

@book{kurtmehlhornAlgorithmsDataStructures2008,
  title = {Algorithms and {{Data Structures}}: {{The Basic Toolbox}}},
  author = {Kurt Mehlhorn, Peter Sanders (auth.)},
  year = {2008},
  edition = {1},
  publisher = {Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-77977-3 978-3-540-77978-0}
}

@misc{kuruczUnificationMatchingLogic2024,
  title = {Unification in {{Matching Logic}} -- {{Revisited}}},
  author = {Kurucz, {\'A}d{\'a}m and Bereczky, P{\'e}ter and Horp{\'a}csi, D{\'a}niel},
  year = {2024},
  month = oct,
  number = {arXiv:2410.23760},
  eprint = {2410.23760},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2410.23760},
  urldate = {2024-11-01},
  abstract = {Matching logic is a logical framework for specifying and reasoning about programs using pattern matching semantics. A pattern is made up of a number of structural components and constraints. Structural components are syntactically matched, while constraints need to be satisfied. Having multiple structural patterns poses a practical problem as it requires multiple matching operations. This is easily remedied by unification, for which an algorithm has already been defined and proven correct in a sorted, polyadic variant of matching logic. This paper revisits the subject in the applicative variant of the language while generalising the unification problem and mechanizing a proven-sound solution in Coq.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/UIU2RT74/Kurucz et al. - 2024 - Unification in Matching Logic -- Revisited.pdf;/home/flaviomoura/Zotero/storage/5HGFW4DN/2410.html}
}

@book{laaksonenauth.GuideCompetitiveProgramming2017,
  title = {Guide to {{Competitive Programming}}: {{Learning}} and {{Improving Algorithms Through Contests}}},
  author = {Laaksonen (auth.), Antti},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  edition = {1},
  publisher = {Springer International Publishing},
  isbn = {978-3-319-72546-8 978-3-319-72547-5}
}

@book{laaksonenCompetitiveProgrammerHandbook2018,
  title = {Competitive {{Programmer}}'s {{Handbook}}},
  author = {Laaksonen, Antti},
  year = {2018}
}

@book{laaksonenGuideCompetitiveProgramming2017,
  title = {Guide to {{Competitive Programming}}},
  author = {Laaksonen, Antti},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-72547-5}
}

@article{ladymanIdentityHomotopyType2016,
  title = {Identity in {{Homotopy Type Theory}}: {{Part Ii}}, {{The Conceptual}} and {{Philosophical Status}} of {{Identity}} in {{Hott}}},
  author = {Ladyman, J. and Presnell, S.},
  year = {2016},
  journal = {Philosophia Mathematica},
  volume = {nil},
  number = {nil},
  pages = {nkw023},
  doi = {10.1093/philmat/nkw023}
}

@misc{lagoSessionTypingProbabilistic2022,
  title = {On {{Session Typing}}, {{Probabilistic Polynomial Time}}, and {{Cryptographic Experiments}} ({{Long Version}})},
  author = {Lago, Ugo Dal and Giusti, Giulia},
  year = {2022},
  month = jul,
  number = {arXiv:2207.03360},
  eprint = {2207.03360},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-07-08},
  abstract = {A system of session types is introduced as induced by a Curry Howard correspondence applied to Bounded Linear Logic, then extending the obtained type system with probabilistic choice operators and ground types. The resulting system satisfies the expected properties, like subject reduction and progress, but also unexpected ones, like a polynomial bound on the time needed to reduce processes. This makes the system suitable for modelling experiments and proofs from the so-called computational model of cryptography.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/DNCJDEKM/Lago and Giusti - 2022 - On Session Typing, Probabilistic Polynomial Time, .pdf}
}

@article{lairdCompositionalCostModel,
  title = {A {{Compositional Cost Model}} for the {$\lambda$}-Calculus},
  author = {Laird, James},
  pages = {14},
  abstract = {We describe a (time) cost model for the (call-by-value) {$\lambda$}-calculus based on a natural presentation of its game semantics: the cost of computing a finite approximant to the denotation of a term (its evaluation tree) is the size of its smallest derivation in the semantics. This measure has an optimality property enabling compositional reasoning about cost bounds: for any term A, context C[ ] and approximants a and c to the trees of A and C[A], the cost of computing c from C[A] is no more than the cost of computing a from A and c from C[a].},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/UTJMTJJY/Laird - A Compositional Cost Model for the Î»-calculus.pdf}
}

@book{lakeConciseGuideDatabases2013,
  title = {Concise {{Guide}} to {{Databases}}},
  author = {Lake, Peter and Crowther, Paul},
  year = {2013},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-5601-7}
}

@article{lammichProofPearlPurely2019,
  title = {Proof {{Pearl}}: {{Purely Functional}}, {{Simple}} and {{Efficient Priority Search Trees}} and {{Applications}} to {{Prim}} and {{Dijkstra}}},
  shorttitle = {Proof {{Pearl}}},
  author = {Lammich, Peter and Nipkow, Tobias},
  year = {2019},
  pages = {18 pages},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH, Wadern/Saarbruecken, Germany},
  doi = {10.4230/LIPICS.ITP.2019.23},
  urldate = {2022-01-13},
  abstract = {The starting point of this paper is a new, purely functional, simple and efficient data structure combining a search tree and a priority queue, which we call a priority search tree. The salient feature of priority search trees is that they offer a decrease-key operation, something that is missing from other simple, purely functional priority queue implementations. As two applications of this data structure we verify purely functional, simple and efficient implementations of Prim's and Dijkstra's algorithms. This constitutes the first verification of an executable and even efficient version of Prim's algorithm.},
  collaborator = {Wagner, Michael},
  copyright = {Creative Commons Attribution 3.0 Unported license (CC-BY 3.0)},
  langid = {english},
  keywords = {000 Computer science knowledge general works,Computer Science},
  file = {/home/flaviomoura/Zotero/storage/9QGCGAQR/Lammich e Nipkow - 2019 - Proof Pearl Purely Functional, Simple and Efficie.pdf}
}

@misc{lamontBAITBenchmarkingEmbedding2024,
  title = {{{BAIT}}: {{Benchmarking}} ({{Embedding}}) {{Architectures}} for {{Interactive Theorem-Proving}}},
  shorttitle = {{{BAIT}}},
  author = {Lamont, Sean and Norrish, Michael and Dezfouli, Amir and Walder, Christian and Montague, Paul},
  year = {2024},
  month = mar,
  number = {arXiv:2403.03401},
  eprint = {2403.03401},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-03-07},
  abstract = {Artificial Intelligence for Theorem Proving has given rise to a plethora of benchmarks and methodologies, particularly in Interactive Theorem Proving (ITP). Research in the area is fragmented, with a diverse set of approaches being spread across several ITP systems. This presents a significant challenge to the comparison of methods, which are often complex and difficult to replicate. Addressing this, we present BAIT, a framework for fair and streamlined comparison of learning approaches in ITP. We demonstrate BAIT's capabilities with an in-depth comparison, across several ITP benchmarks, of state-of-the-art architectures applied to the problem of formula embedding. We find that Structure Aware Transformers perform particularly well, improving on techniques associated with the original problem sets. BAIT also allows us to assess the end-to-end proving performance of systems built on interactive environments. This unified perspective reveals a novel end-to-end system that improves on prior work. We also provide a qualitative analysis, illustrating that improved performance is associated with more semantically-aware embeddings. By streamlining the implementation and comparison of Machine Learning algorithms in the ITP context, we anticipate BAIT will be a springboard for future research.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/Z8TQCPAL/Lamont et al. - 2024 - BAIT Benchmarking (Embedding) Architectures for I.pdf;/home/flaviomoura/Zotero/storage/IZ4SE37S/2403.html}
}

@book{landiLinearAlgebraAnalytic2018,
  title = {Linear {{Algebra}} and {{Analytic Geometry}} for {{Physical Sciences}}},
  author = {Landi, Giovanni and Zampini, Alessandro},
  year = {2018},
  series = {Undergraduate {{Lecture Notes}} in {{Physics}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-78361-1}
}

@article{landinMechanicalEvaluationExpressions1964,
  title = {The {{Mechanical Evaluation}} of {{Expressions}}},
  author = {Landin, P. J.},
  year = {1964},
  journal = {The Computer Journal},
  volume = {6},
  number = {4},
  pages = {308--320},
  doi = {10.1093/comjnl/6.4.308}
}

@book{laneCategoriesWorkingMathematician1978,
  title = {Categories for the {{Working Mathematician}}},
  author = {Lane, S. Mac},
  year = {1978},
  series = {Graduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4757-4721-8}
}

@book{langAlgebra2002,
  title = {Algebra},
  author = {Lang, Serge},
  year = {2002},
  series = {Graduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4613-0041-0}
}

@book{langtangenPrimerScientificProgramming2016,
  title = {A {{Primer}} on {{Scientific Programming}} with {{Python}}},
  author = {Langtangen, Hans Petter},
  year = {2016},
  series = {Texts in {{Computational Science}} and {{Engineering}}},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-49887-3}
}

@book{lantsoghtAZPhDTrajectory2018,
  title = {The {{A-Z}} of the {{PhD Trajectory}}},
  author = {Lantsoght, Eva O. L.},
  year = {2018},
  series = {Springer {{Texts}} in {{Education}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-77425-1}
}

@article{laoBuildingCheckingSuffix2021,
  title = {Building and {{Checking Suffix Array Simultaneously}} by {{Induced Sorting Method}}},
  author = {Lao, Bin and Wu, Yi and Nong, Ge and Chan, Wai Hong},
  year = {2021},
  journal = {IEEE Transactions on Computers},
  pages = {1--1},
  issn = {0018-9340, 1557-9956, 2326-3814},
  doi = {10.1109/TC.2021.3061709},
  urldate = {2021-03-06}
}

@article{laraAttributedGraphTransformation2007,
  title = {Attributed {{Graph Transformation With Node Type Inheritance}}},
  author = {de Lara, Juan and Bardohl, Roswitha and Ehrig, Hartmut and Ehrig, Karsten and Prange, Ulrike and Taentzer, Gabriele},
  year = {2007},
  journal = {Theoretical Computer Science},
  volume = {376},
  number = {3},
  pages = {139--163},
  doi = {10.1016/j.tcs.2007.02.001}
}

@unpublished{larchey-wendlingBreadthFirstExtractionLessons2018,
  title = {Breadth-{{First Extraction}}: {{Lessons}} from a {{Small Exercice}} in {{Algorithm Certification}}},
  author = {{Larchey-Wendling}, Dominique},
  year = {2018}
}

@inproceedings{larchey-wendlingProofPearlConstructive2018,
  title = {Proof {{Pearl}}: {{Constructive Extraction}} of {{Cycle Finding Algorithms}}},
  booktitle = {Interactive {{Theorem Proving}} - 9th {{International Conference}}, {{ITP}} 2018, {{Held}} as {{Part}} of the {{Federated Logic Conference}}, {{FloC}} 2018, {{Oxford}}, {{UK}}, {{July}} 9-12, 2018, {{Proceedings}}},
  author = {{Larchey-Wendling}, Dominique},
  year = {2018},
  pages = {370--387},
  doi = {10.1007/978-3-319-94821-8_22}
}

@article{larchey-wendlingProofPearlFaithful2023,
  title = {Proof {{Pearl}}: {{Faithful Computation}} and {{Extraction}} of {$\mu$}-{{Recursive Algorithms}} in {{Coq}}},
  author = {{Larchey-Wendling}, Dominique and Monin, Jean-Fran{\c c}ois},
  year = {2023},
  abstract = {Basing on an original Coq implementation of unbounded linear search for partially decidable predicates, we study the computational contents of {\textmu}-recursive functions via their syntactic representation, and a correct by construction Coq interpreter for this abstract syntax. When this interpreter is extracted, we claim the resulting OCaml code to be the natural combination of the implementation of the {\textmu}-recursive schemes of composition, primitive recursion and unbounded minimization of partial (i.e., possibly non-terminating) functions. At the level of the fully specified Coq terms, this implies the representation of higher-order functions of which some of the arguments are themselves partial functions. We handle this issue using some techniques coming from the Braga method. Hence we get a faithful embedding of {\textmu}-recursive algorithms into Coq preserving not only their extensional meaning but also their intended computational behavior. We put a strong focus on the quality of the Coq artifact which is both self contained and with a line of code count of less than 1k in total.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/QVEQIYSQ/Larchey-Wendling e Monin - 2023 - Proof Pearl Faithful Computation and Extraction o.pdf}
}

@book{lassaigneLogicComplexity2004,
  title = {Logic and {{Complexity}}},
  author = {Lassaigne, Richard and de Rougemont, Michel},
  year = {2004},
  series = {Nil},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-0-85729-392-3}
}

@inproceedings{laurent:hal-03096253,
  title = {An Anti-Locally-Nameless Approach to Formalizing Quantifiers},
  booktitle = {Certified Programs and Proofs},
  author = {Laurent, Olivier},
  year = {2021},
  month = jan,
  address = {virtual, Denmark},
  doi = {10.1145/3437992.3439926},
  hal_id = {hal-03096253},
  hal_version = {v1},
  pdf = {https://hal.archives-ouvertes.fr/hal-03096253/file/quantif.pdf},
  keywords = {first-order logic,formalization,normalization,proof assistant,proof theory,quantifiers},
  file = {/home/flaviomoura/Zotero/storage/VGWFS5YP/quantif.pdf}
}

@article{lavickaSemisimplicityGlivenkoTheorems2021,
  title = {Semisimplicity, {{Glivenko}} Theorems, and the Excluded Middle},
  author = {L{\'a}vi{\v c}ka, Tom{\'a}{\v s} and P{\v r}enosil, Adam},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.03528 [math]},
  eprint = {2101.03528},
  primaryclass = {math},
  urldate = {2021-01-12},
  abstract = {We formulate a general, signature-independent form of the law of the excluded middle and prove that a logic is semisimple if and only if it enjoys this law, provided that it satisfies a weak form of the so-called inconsistency lemma of Raftery. We then show that this equivalence can be used to provide simple syntactic proofs of the theorems of Kowalski and Kracht characterizing the semisimple varieties of FLew-algebras and Boolean algebras with operators, and to extend them to FLe-algebras and Heyting algebras with operators. Moreover, under stronger assumptions this correspondence works at the level of individual models: the semisimple models of such a logic are precisely those which satisfy an axiomatic form of the law of the excluded middle, and a Glivenko-like connection obtains between the logic and its extension by the axiom of the excluded middle. This in particular subsumes the well-known Glivenko theorems relating intuitionistic and classical logic and the modal logics S4 and S5. As a consequence, we also obtain a description of the subclassical substructural logics which are Glivenko related to classical logic.},
  archiveprefix = {arXiv},
  keywords = {03G27 03C05 06F05,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/NKGGDYRP/LÃ¡viÄka e PÅenosil - 2021 - Semisimplicity, Glivenko theorems, and the exclude.pdf;/home/flaviomoura/Zotero/storage/CST3XCB6/2101.html}
}

@book{lawrences.mossLogicLanguageInformation2018,
  title = {Logic, {{Language}}, {{Information}}, and {{Computation}}},
  author = {Lawrence S. Moss, Ruy de Queiroz, Maricarmen Martinez},
  year = {2018},
  series = {Lecture {{Notes}} in {{Computer Science}} 10944},
  edition = {1st ed.},
  publisher = {Springer Berlin Heidelberg},
  isbn = {978-3-662-57668-7 978-3-662-57669-4}
}

@book{laxCalculusApplications2014,
  title = {Calculus {{With Applications}}},
  author = {Lax, Peter D. and Terrell, Maria Shea},
  year = {2014},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-7946-8}
}

@book{leeAbstractAlgebra2018,
  title = {Abstract {{Algebra}}},
  author = {Lee, Gregory T.},
  year = {2018},
  series = {Springer {{Undergraduate Mathematics Series}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-77649-1}
}

@book{leeDataStructuresAlgorithms2015,
  title = {Data Structures and Algorithms with {{Python}}},
  author = {Lee, Kent D and Hubbard, Steve},
  year = {2015},
  publisher = {Springer}
}

@book{leeDataStructuresAlgorithms2024,
  title = {Data {{Structures}} and {{Algorithms}} with {{Python}}: {{With}} an {{Introduction}} to {{Multiprocessing}}},
  shorttitle = {Data {{Structures}} and {{Algorithms}} with {{Python}}},
  author = {Lee, Kent D. and Hubbard, Steve},
  year = {2024},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-031-42209-6},
  urldate = {2024-11-29},
  copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
  isbn = {978-3-031-42208-9 978-3-031-42209-6},
  langid = {english}
}

@book{leeFoundationsProgrammingLanguages2017,
  title = {Foundations of {{Programming Languages}}},
  author = {Lee, Kent D.},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-70790-7}
}

@book{leePythonProgrammingFundamentals2014,
  title = {Python {{Programming Fundamentals}}},
  author = {Lee, Kent D.},
  year = {2014},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-6642-9},
  file = {/home/flaviomoura/Zotero/storage/V4DJHUBN/Lee - 2014 - Python Programming Fundamentals.pdf}
}

@article{leeQualifyingSystemTerms2024,
  title = {Qualifying {{System F}} {\textsubscript{{$<$}:}} : {{Some Terms}} and {{Conditions May Apply}}},
  shorttitle = {Qualifying {{System F}} {\textsubscript{{$<$}}}},
  author = {Lee, Edward and Zhao, Yaoyu and Lhot{\'a}k, Ond{\v r}ej and You, James and Satheeskumar, Kavin and Brachth{\"a}user, Jonathan Immanuel},
  year = {2024},
  month = apr,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {8},
  number = {OOPSLA1},
  pages = {583--612},
  issn = {2475-1421},
  doi = {10.1145/3649832},
  urldate = {2024-05-09},
  abstract = {Type qualifiers offer a lightweight mechanism for enriching existing type systems to enforce additional, desirable, program invariants.    They do so by offering a restricted but effective form of subtyping.    While the theory of type qualifiers is well understood and present in many programming languages today, polymorphism over type qualifiers remains an area less well examined.    We explore how such a polymorphic system could arise by constructing a calculus, System F-sub-Q, which combines the higher-rank bounded polymorphism of System F-sub with the theory of type qualifiers. We explore how the ideas used to construct System F-sub-Q can be reused in situations where type qualifiers naturally arise---in reference immutability, function colouring, and capture checking. Finally, we re-examine other qualifier systems in the literature in light of the observations presented while developing System F-sub-Q.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VAPVSLIW/Lee et al. - 2024 - Qualifying System F   Some Terms and.pdf}
}

@book{lehmanMathematicsComputerScience2004,
  title = {Mathematics for {{Computer Science}}},
  author = {Lehman, E. and Leighton, T.},
  year = {2004}
}

@article{leinsterBasicCategoryTheory2016,
  title = {Basic {{Category Theory}}},
  author = {Leinster, T.},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Algebraic Topology,Mathematics - Category Theory,Mathematics - Logic}
}

@article{leitschCERESFirstorderSchemata2017,
  title = {{{CERES}} for First-Order Schemata},
  author = {Leitsch, Alexander and Peltier, Nicolas and Weller, Daniel},
  year = {2017},
  month = oct,
  journal = {Journal of Logic and Computation},
  volume = {27},
  number = {7},
  pages = {1897--1954},
  issn = {0955-792X},
  doi = {10.1093/logcom/exx003},
  urldate = {2024-07-30},
  abstract = {The cut-elimination method CERES (cut-elimination by resolution) (for first- and higher order classical logic) is based on the notion of a characteristic clause set, which is extracted from an LK-proof and is always unsatisfiable. A resolution refutation of this clause set can be used as a skeleton for a proof with atomic cuts only (atomic cut normal form). This is achieved by replacing clauses from the resolution refutation by the corresponding projections of the original proof. We present a generalization of CERES (called \$\{{\textbackslash}rm CERES\}\_s\$) to first-order proof schemata. Proof schemata are parameterized sequences of first-order proofs constructed using primitive recursive definitions. We define a schematic version of the sequent calculus, called LKS, and devise algorithms to extract schematic characteristic formulas and schematic projections from these proof schemata. We also define a schematic resolution calculus for constructing ground refutations of schemata of formulas, which can be applied to refute the schematic characteristic formulas. Finally the projection schemata and resolution schemata are plugged together and one obtains a schematic representation of proofs with only quantifier-free cuts, from which schematic Herbrand sequences can be extracted. A major benefit of \$\{{\textbackslash}rm CERES\}\_s\$ is the extension of cut-elimination to inductively defined proofs: we compare \$\{{\textbackslash}rm CERES\}\_s\$ with standard calculi using induction rules and demonstrate that \$\{{\textbackslash}rm CERES\}\_s\$ is capable of performing cut-elimination where traditional methods fail.},
  file = {/home/flaviomoura/Zotero/storage/Y6WR9A94/Leitsch et al. - 2017 - CERES for first-order schemata.pdf;/home/flaviomoura/Zotero/storage/NJS5DCM3/3062277.html}
}

@inproceedings{leitschCEResIntuitionisticLogic2012,
  title = {Towards {{CERes}} in Intuitionistic Logic},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{CSL}}.2012.485},
  author = {Leitsch, Alexander and Reis, Giselle and Woltzenlogel Paleo, Bruno},
  year = {2012},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.CSL.2012.485},
  urldate = {2024-07-06},
  abstract = {Cut-elimination, introduced by Gentzen, plays an important role in automating the analysis of mathematical proofs. The removal of cuts corresponds to the elimination of intermediate statements (lemmas), resulting in an analytic proof. CERes is a method of cut-elimination by resolution that relies on global proof transformations, in contrast to reductive methods, which use local proof-rewriting transformations. By avoiding redundant operations, it obtains a speed-up over Gentzen's traditional method (and its variations). CERes has been successfully implemented and applied to mathematical proofs, and it is fully developed for classical logic (first and higher order), multi-valued logics and G{\"o}del logic. But when it comes to mathematical proofs, intuitionistic logic also plays an important role due to its constructive characteristics and computational interpretation.  This paper presents current developments on adapting the CERes method to intuitionistic sequent calculus LJ. First of all, we briefly describe the CERes method for classical logic and the problems that arise when extending the method to intuitionistic logic. Then, we present the solutions found for the mentioned problems for the subclass LJ- (the class of intuitionistic proofs of an end-sequent containing no strong quantifiers and no formula on the right). In addition, we explain, with an example, some ideas for improving the method and covering a bigger fragment of LJ proofs. Finally, we summarize the results and point the direction for future research.},
  copyright = {https://creativecommons.org/licenses/by-nc-nd/3.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7EBUZ8YJ/Leitsch et al. - 2012 - Towards CERes in intuitionistic logic.pdf}
}

@misc{leitschHerbrandTheoremRefutation2024,
  title = {Herbrand's {{Theorem}} in {{Refutation Schemata}}},
  author = {Leitsch, Alexander and Lolic, Anela},
  year = {2024},
  month = apr,
  number = {arXiv:2402.13905},
  eprint = {2402.13905},
  primaryclass = {math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2402.13905},
  urldate = {2024-08-01},
  abstract = {An inductive proof can be represented as a proof schema, i.e. as a parameterized sequence of proofs defined in a primitive recursive way. A corresponding cut-elimination method, called schematic CERES, can be used to analyze these proofs, and to extract their (schematic) Herbrand sequents, even though Herbrand's theorem in general does not hold for proofs with induction inferences. This work focuses on the most crucial part of the schematic cut-elimination method, which is to construct a refutation of a schematic formula that represents the cut-structure of the original proof schema. We develop a new framework for schematic substitutions and define a unification algorithm for resolution schemata. Moreover, we show that this new formalism allows the extraction of a structure from the refutation schema, called a Herbrand schema, which represents its Herbrand sequent.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/KAFXJR9A/Leitsch e Lolic - 2024 - Herbrand's Theorem in Refutation Schemata.pdf;/home/flaviomoura/Zotero/storage/79U3L4QP/2402.html}
}

@inproceedings{leitschProofSchemataPrimitive2024,
  title = {On {{Proof Schemata}} and {{Primitive Recursive Arithmetic}}},
  booktitle = {Kalpa {{Publications}} in {{Computing}}},
  author = {Leitsch, Alexander and Lolic, Anela and Mahler, Stella},
  year = {2024},
  month = may,
  volume = {18},
  pages = {117--130},
  publisher = {EasyChair},
  issn = {2515-1762},
  doi = {10.29007/4g2q},
  urldate = {2024-07-16},
  langid = {american},
  file = {/home/flaviomoura/Zotero/storage/44JSAGQ4/Leitsch et al. - 2024 - On Proof Schemata and Primitive Recursive Arithmet.pdf}
}

@misc{lemeIntuitionismTruthTables2024,
  title = {Intuitionism with {{Truth Tables}}: {{A Decision Procedure}} for {{IPL Based}} on {{RNmatrices}}},
  shorttitle = {Intuitionism with {{Truth Tables}}},
  author = {Leme, Renato and Coniglio, Marcelo and Lopes, Bruno},
  year = {2024},
  month = apr,
  number = {arXiv:2308.13664},
  eprint = {2308.13664},
  primaryclass = {math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2308.13664},
  urldate = {2024-04-09},
  abstract = {This paper provides a new decision procedure for intuitionistic propositional logic (IPL) based on a 3-valued restricted non-deterministic matrix and proves its soundness and completeness.},
  archiveprefix = {arXiv},
  keywords = {03B20 03B45 03B25 03B35 68V15,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/68LRY8AZ/Leme et al. - 2024 - Intuitionism with Truth Tables A Decision Procedu.pdf;/home/flaviomoura/Zotero/storage/LS3LUHST/2308.html}
}

@article{lengrandCallByValueCallByNameStrong2003,
  title = {Call-{{By-Value}}, {{Call-By-Name}}, and {{Strong Normalization}} for the {{Classical Sequent Calculus}}},
  author = {Lengrand, St{\'e}phane},
  year = {2003},
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {86},
  number = {4},
  pages = {714--730},
  doi = {10.1016/s1571-0661(05)82619-2}
}

@techreport{lengrandInductionPrinciplesFoundation2005,
  type = {Technical {{Report}}},
  title = {Induction Principles as the Foundation of the Theory of Normalisation: {{Concepts}} and {{Techniques}}},
  author = {Lengrand, St{\'e}phane},
  year = {2005},
  month = mar,
  institution = {PPS laboratory, Universit{\'e} Paris 7}
}

@phdthesis{lengrandNormalisationEquivalenceProof2006,
  title = {Normalisation \& {{Equivalence}} in {{Proof Theory}} \& {{Type Theory}}},
  author = {Lengrand, St{\'e}phane},
  year = {2006},
  school = {Universit{\'e} Paris 7 \& University of St Andrews}
}

@inproceedings{lenkoTypeTheoreticalFoundations2018,
  title = {Type- {{Theoretical Foundations}} of the {{Derivation System}} in {{Coq}}},
  booktitle = {2018 {{IEEE First International Conference}} on {{System Analysis}} \& {{Intelligent Computing}} ({{SAIC}})},
  author = {Lenko, Vasyl and Pasichnyk, Volodymyr and Kunanets, Nataliia and Shcherbyna, Yuriy},
  year = {2018},
  month = oct,
  pages = {1--6},
  publisher = {IEEE},
  address = {Kyiv},
  doi = {10.1109/SAIC.2018.8516885},
  urldate = {2020-10-03},
  isbn = {978-1-5386-7196-2}
}

@article{lennon-bertrandCompleteBidirectionalTyping2021,
  title = {Complete {{Bidirectional Typing}} for the {{Calculus}} of {{Inductive Constructions}}},
  author = {{Lennon-Bertrand}, Meven},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.06513 [cs]},
  eprint = {2102.06513},
  primaryclass = {cs},
  urldate = {2021-02-15},
  abstract = {This article presents a bidirectional type system for the Calculus of Inductive Constructions (CIC). It introduces a novel judgement intermediate between the usual inference and checking, dubbed constrained inference, to handle the presence of computation in types. The key property is the completeness of the system with respect to the usual undirected one, which has been formally proven in Coq as a part of the MetaCoq project. Although it plays a central role in an ongoing completeness proof for a realistic typing algorithm, the interest of bidirectionality is much wider, as it clarifies previous works in the area and gives strong insights and structure when trying to prove properties on CIC or design variations and extensions.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/S8TXYRDG/Lennon-Bertrand - 2021 - Complete Bidirectional Typing for the Calculus of .pdf;/home/flaviomoura/Zotero/storage/MZ9E69VR/2102.html}
}

@unpublished{lennon-bertrandCompleteBidirectionalTyping2021a,
  title = {Complete {{Bidirectional Typing}} for the {{Calculus}} of {{Inductive Constructions}}},
  author = {{Lennon-Bertrand}, Meven},
  year = {2021},
  month = apr,
  urldate = {2021-05-01},
  abstract = {This article presents a bidirectional type system for the Calculus of Inductive Constructions (CIC). It introduces a new judgement intermediate between the usual inference and checking, dubbed constrained inference, to handle the presence of computation in types. The key property of the system is its completeness with respect to the usual undirected one, which has been formally proven in Coq as a part of the MetaCoq project. Although it plays an important role in an ongoing completeness proof for a realistic typing algorithm, the interest of bidirectionality is wider, as it gives insights and structure when trying to prove properties on CIC or design variations and extensions. In particular, we put forward constrained inference, an intermediate between the usual inference and checking judgements, to handle the presence of computation in types.},
  keywords = {Bidirectional Typing,Calculus of Inductive Constructions,Coq,Proof Assistants},
  file = {/home/flaviomoura/Zotero/storage/U5TW4JQ6/Lennon-Bertrand - 2021 - Complete Bidirectional Typing for the Calculus of .pdf}
}

@article{lennon-bertrandGradualizingCalculusInductive2020,
  title = {Gradualizing the {{Calculus}} of {{Inductive Constructions}}},
  author = {{Lennon-Bertrand}, Meven and Maillard, Kenji and Tabareau, Nicolas and Tanter, {\'E}ric},
  year = {2020},
  month = nov,
  journal = {arXiv:2011.10618 [cs]},
  eprint = {2011.10618},
  primaryclass = {cs},
  urldate = {2020-11-28},
  abstract = {Acknowledging the ordeal of a fully formal development in a proof assistant such as Coq, we investigate gradual variations on the Calculus of Inductive Construction (CIC) for swifter prototyping with imprecise types and terms. We observe, with a no-go theorem, a crucial tradeoff between graduality and the key properties of normalization and closure of universes under dependent product that CIC enjoys. Beyond this Fire Triangle of Graduality, we explore the gradualization of CIC with three different compromises, each relaxing one edge of the Fire Triangle. We develop a parametrized presentation of Gradual CIC that encompasses all three variations, and develop their metatheory. We first present a bidirectional elaboration of Gradual CIC to a dependently-typed cast calculus, which elucidates the interrelation between typing, conversion, and the gradual guarantees. We use a syntactic model into CIC to inform the design of a safe, confluent reduction, and establish, when applicable, normalization. We also study the stronger notion of graduality as embedding-projection pairs formulated by New and Ahmed, using appropriate semantic model constructions. This work informs and paves the way towards the development of malleable proof assistants and dependently-typed programming languages.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/CXFIIA8U/Lennon-Bertrand et al. - 2020 - Gradualizing the Calculus of Inductive Constructio.pdf;/home/flaviomoura/Zotero/storage/2TYHJ76X/2011.html}
}

@article{lepigrePracticalSubtypingSystem2016,
  title = {Practical {{Subtyping}} for {{System F With Sized}} ({{Co-}}){{Induction}}},
  author = {Lepigre, R. and Raffalli, C.},
  year = {2016},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,Mathematics - Logic}
}

@article{leroyFormalCertificationCompiler2006,
  title = {Formal {{Certification}} of a {{Compiler Back-End Or}}: Programming a Compiler with a Proof Assistant},
  author = {Leroy, X.},
  year = {2006},
  journal = {ACM SIGPLAN Notices},
  volume = {41},
  number = {1},
  pages = {42--54},
  doi = {10.1145/1111320.1111042}
}

@article{leroyFormalVerificationRealistic2009,
  title = {Formal {{Verification}} of a {{Realistic Compiler}}},
  author = {Leroy, Xavier},
  year = {2009},
  journal = {Communications of the ACM},
  volume = {52},
  number = {7},
  pages = {107},
  doi = {10.1145/1538788.1538814}
}

@article{leroyLocallyNamelessSolution1992,
  title = {A Locally Nameless Solution to the {{POPLMark}} Challenge},
  author = {Leroy, Xavier},
  year = {1992},
  month = dec,
  journal = {Bulletin of Sociological Methodology/Bulletin de M{\'e}thodologie Sociologique},
  volume = {37},
  number = {1},
  pages = {55--57},
  issn = {0759-1063, 2070-2779},
  doi = {10.1177/075910639203700105},
  urldate = {2023-03-19},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ZUTV435T/1992 - Institut national de recherche en informatique et .pdf}
}

@phdthesis{leroyLocallyNamelessSolution2007,
  type = {Report},
  title = {A Locally Nameless Solution to the {{POPLmark}} Challenge},
  author = {Leroy, Xavier},
  year = {2007},
  pages = {54},
  urldate = {2024-07-08},
  abstract = {The POPLmark challenge is a collective experiment intended to assess the usability of theorem provers and proof assistants in the context of fundamental research on programming languages. In this report, we present a solution to the challenge, developed with the Coq proof assistant, and using the "locally nameless" presentation of terms with binders introduced by McKinna, Pollack, Gordon, and McBride.},
  langid = {english},
  school = {INRIA},
  file = {/home/flaviomoura/Zotero/storage/ZUPZDK28/Leroy - 2007 - A locally nameless solution to the POPLmark challe.pdf}
}

@book{leroyProceedings2015Conference2015,
  title = {Proceedings of the 2015 {{Conference}} on {{Certified Programs}} and {{Proofs}}, {{CPP}} 2015, {{Mumbai}}, {{India}}, {{January}} 15-17, 2015},
  editor = {Leroy, X. and Tiu, A.},
  year = {2015},
  publisher = {ACM},
  isbn = {978-1-4503-3296-5}
}

@article{lescanneDependentTypesExtensive2016,
  title = {Dependent {{Types}} for {{Extensive Games}}},
  author = {Lescanne, P.},
  year = {2016},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Computer Science and Game Theory,Mathematics - Logic}
}

@article{lescanneZaioncParadoxRevisited2021,
  title = {Zaionc Paradox Revisited},
  author = {Lescanne, Pierre},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.06723 [cs, math]},
  eprint = {2104.06723},
  primaryclass = {cs, math},
  urldate = {2021-04-15},
  abstract = {Canonical expressions are representative of implicative propositions upto renaming of variables. In this paper we explore, using a Monte-Carlo approach, the model of canonical expressions in order to confirm the paradox that says that asymptotically almost all classical theorems are intuitionistic.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/NWNTPQ4F/Lescanne - 2021 - Zaionc paradox revisited.pdf;/home/flaviomoura/Zotero/storage/SUNLEA9D/2104.html}
}

@inproceedings{letouzeyCoqExtractionOverview2008,
  title = {Coq {{Extraction}}, an {{Overview}}},
  booktitle = {Logic and {{Theory}} of {{Algorithms}}, {{Fourth Conference}} on {{Computability}} in {{Europe}}, {{CiE}} 2008},
  author = {Letouzey, P.},
  editor = {A. Beckmann, C. Dimitracopoulos and L{\"o}we, B.},
  year = {2008},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {5028},
  publisher = {Springer-Verlag}
}

@misc{letouzeyHofstadterProblemCurious2018,
  title = {Hofstadter's Problem for Curious Readers},
  author = {Letouzey, Pierre},
  year = {2018},
  month = apr,
  number = {arXiv:1509.02479},
  eprint = {1509.02479},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1509.02479},
  urldate = {2024-04-23},
  abstract = {This document summarizes the proofs made during a Coq development inSummer 2015. This development investigates the function G introducedby Hofstadter in his famous "G\{{\textbackslash}"o\}del, Escher, Bach" bookas well as a related infinite tree. The left/right flipped variantof this G tree has also been studied here, followingHofstadter's "problem for the curious reader".The initial G function is refered as sequence A005206 inOEIS, while the flipped version is the sequence A123070.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - History and Overview},
  file = {/home/flaviomoura/Zotero/storage/DCZNK4DE/Letouzey - 2018 - Hofstadter's problem for curious readers.pdf;/home/flaviomoura/Zotero/storage/TTVAIP8S/1509.html}
}

@article{levesonInvestigationTherac25Accidents1993,
  title = {An {{Investigation}} of the {{Therac-25 Accidents}}},
  author = {Leveson, N. G. and Turner, C. S.},
  year = {1993},
  journal = {Computer},
  volume = {26},
  number = {7},
  pages = {18--41},
  doi = {10.1109/mc.1993.274940}
}

@book{levitinIntroductionDesignAnalysis2012,
  title = {Introduction to the {{Design}} and {{Analysis}} of {{Algorithms}}, {{Third Edition}}},
  author = {Levitin, A. V.},
  year = {2012},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {Boston, MA, USA},
  file = {/home/flaviomoura/Zotero/storage/N4RGADYX/levitinIntroductionDesignAnalysis2012.pdf;/home/flaviomoura/Zotero/storage/YEMVGIE5/Levitin-IntroductiontotheDesignandAnalysisofAlgorithms3ed.pdf}
}

@article{levyNominalUnificationHigherOrder2012,
  title = {Nominal {{Unification From}} a {{Higher-Order Perspective}}},
  author = {Levy, J. and Villaret, M.},
  year = {2012},
  journal = {ACM Transactions on Computational Logic},
  volume = {13},
  number = {2},
  pages = {1--31},
  doi = {10.1145/2159531.2159532}
}

@inproceedings{levyPVSBasedApproachTeaching1999,
  title = {A {{PVS-Based Approach}} for {{Teaching Constructing Correct Iterations}}},
  booktitle = {{{FM99}}: {{The World Congress}} in {{Formal Methods}}},
  author = {L{\'e}vy, Michel and Trilling, Laurent},
  editor = {Wing, Jeannette and Woodcock, Jim},
  year = {1999},
  month = sep,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1708 and 1709},
  pages = {1859--1860},
  publisher = {Springer-Verlag},
  address = {Toulouse, France}
}

@article{lewisIvImplicationAlgebra1912,
  title = {Iv.-Implication {{AND THE Algebra OF Logic}}},
  author = {LEWIS, C. I.},
  year = {1912},
  journal = {Mind},
  volume = {XXI},
  number = {84},
  pages = {522--531},
  doi = {10.1093/mind/xxi.84.522}
}

@article{liangChoicesRepresentationReduction2004,
  title = {Choices in {{Representation}} and {{Reduction Strategies}} for {{Lambda Terms}} in {{Intesional Contexts}}},
  author = {Liang, C. and Nadathur, G. and Qi, X.},
  year = {2004},
  journal = {Journal of Automated Reasoning},
  volume = {33},
  number = {2},
  pages = {89--132}
}

@inproceedings{liangTradeoffsIntensionalRepresentation2002,
  title = {Tradeoffs in the {{Intensional Representation}} of {{Lambda Terms}}},
  booktitle = {Rewriting {{Techniques}} and {{Applications}} ({{RTA}} 2002)},
  author = {Liang, C. and Nadathur, G.},
  editor = {Tison, S.},
  year = {2002},
  series = {{{LNCS}}},
  volume = {2378},
  pages = {192--206},
  publisher = {Springer-Verlag}
}

@unpublished{libalFunctionasconstructorsHigherOrderUnification2016,
  title = {Function-as-Constructors {{Higher-Order Unification}}},
  author = {Libal, T. and Miller, D.},
  year = {2016}
}

@inproceedings{libalFunctionsasconstructorsHigherorderUnification2016,
  title = {Functions-as-Constructors Higher-Order Unification},
  booktitle = {1st {{International Conference}} on {{Formal Structures}} for {{Computation}} and {{Deduction}} ({{FSCD}} 2016)},
  author = {Libal, Tomer and Miller, Dale},
  year = {2016},
  publisher = {Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik}
}

@inproceedings{libalRegularPatternsSecondOrder2015,
  title = {Regular {{Patterns}} in {{Second-Order Unification}}},
  booktitle = {Automated {{Deduction}} - {{CADE-25}} - 25th {{International Conference}} on {{Automated Deduction}}, {{Berlin}}, {{Germany}}, {{August}} 1-7, 2015, {{Proceedings}}},
  author = {Libal, T.},
  year = {2015},
  pages = {557--571},
  doi = {10.1007/978-3-319-21401-6_38}
}

@book{liesenLinearAlgebra2015,
  title = {Linear {{Algebra}}},
  author = {Liesen, J{\"o}rg and Mehrmann, Volker},
  year = {2015},
  series = {Springer {{Undergraduate Mathematics Series}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-24346-7}
}

@article{liesnikovGeneratingInductionPrinciples2020,
  ids = {liesnikovGeneratingInductionPrinciples2020a},
  title = {Generating Induction Principles and Subterm Relations for Inductive Types Using {{MetaCoq}}},
  author = {Liesnikov, Bohdan and Ullrich, Marcel and Forster, Yannick},
  year = {2020},
  month = jun,
  journal = {arXiv:2006.15135 [cs]},
  eprint = {2006.15135},
  primaryclass = {cs},
  urldate = {2020-07-22},
  abstract = {We implement three Coq plugins regarding inductive types in MetaCoq. The first plugin is a simple syntax transformation generating alternative constructors for inductive types by abstracting over concrete indices in the types of the constructors. The second plugin re-implements Coq's \${\textbackslash}texttt\{Scheme Induction\}\$ command in MetaCoq, and extends it to nested inductive types, e.g. types like rose trees which use \${\textbackslash}texttt\{list\}\$ in their definition, similar to the Elpi-plugin by Tassi. The third plugin implements the \${\textbackslash}texttt\{Derive Subterm\}\$ command provided by the Equations package in MetaCoq.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/N8NYVTY3/Liesnikov et al. - 2020 - Generating induction principles and subterm relati.pdf;/home/flaviomoura/Zotero/storage/MFS6D4XJ/2006.html}
}

@article{limaFormalizedExtensionSubstitution2023,
  title = {A {{Formalized Extension}} of the {{Substitution Lemma}} in {{Coq}}},
  author = {Lima, Maria J. D. and {de Moura}, Fl{\'a}vio L. C.},
  year = {2023},
  journal = {EPTCS},
  volume = {389},
  pages = {80--95},
  doi = {10.4204/EPTCS.389.7},
  urldate = {2024-10-05},
  file = {/home/flaviomoura/Zotero/storage/R8ZNTNWH/Lima e de Moura - A Formalized Extension of the Substitution Lemma i.pdf}
}

@book{liMathematicalLogicFoundations2014,
  title = {Mathematical {{Logic}}: {{Foundations}} for {{Information Science}}},
  author = {Li, W.},
  year = {2014},
  series = {Progress in {{Computer Science}} and {{Applied Logic}} 25},
  edition = {2},
  publisher = {Birkh{\"a}user Basel},
  isbn = {978-3-0348-0861-3 978-3-0348-0862-0}
}

@article{liModellingHighLevelMathematical2020,
  title = {Modelling {{High-Level Mathematical Reasoning}} in {{Mechanised Declarative Proofs}}},
  author = {Li, Wenda and Yu, Lei and Wu, Yuhuai and Paulson, Lawrence C.},
  year = {2020},
  journal = {CoRR},
  abstract = {Mathematical proofs can be mechanised using proof assistants to eliminate gaps and errors. However, mechanisation still requires intensive labour. To promote automation, it is essential to capture high-level human mathematical reasoning, which we address as the problem of generating suitable propositions. We build a non-synthetic dataset from the largest repository of mechanised proofs and propose a task on causal reasoning, where a model is required to fill in a missing intermediate proposition given a causal context. Our experiments (using various neural sequence-to-sequence models) reveal that while the task is challenging, neural models can indeed capture non-trivial mathematical reasoning. We further propose a hierarchical transformer model that outperforms the transformer baseline.}
}

@article{lindenhoviusLNLFPCLinearNonlinear,
  title = {{{LNL-FPC}}: {{The Linear}}/{{Non-linear Fixpoint Calculus}}},
  author = {Lindenhovius, Bert and Mislove, Michael and Zamdzhiev, Vladimir},
  volume = {17},
  pages = {61},
  abstract = {We describe a type system with mixed linear and non-linear recursive types called LNL-FPC (the linear/non-linear fixpoint calculus). The type system supports linear typing, which enhances the safety properties of programs, but also supports non-linear typing as well, which makes the type system more convenient for programming. Just as in FPC, we show that LNL-FPC supports type-level recursion, which in turn induces term-level recursion. We also provide sound and computationally adequate categorical models for LNL-FPC that describe the categorical structure of the substructural operations of Intuitionistic Linear Logic at all non-linear types, including the recursive ones. In order to do so, we describe a new technique for solving recursive domain equations within cartesian categories by constructing the solutions over pre-embeddings. The type system also enjoys implicit weakening and contraction rules that we are able to model by identifying the canonical comonoid structure of all non-linear types. We also show that the requirements of our abstract model are reasonable by constructing a large class of concrete models that have found applications not only in classical functional programming, but also in emerging programming paradigms that incorporate linear types, such as quantum programming and circuit description programming languages.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/H429BLVR/Lindenhovius et al. - LNL-FPC The LinearNon-linear Fixpoint Calculus.pdf}
}

@article{lindgrenIntroducingCertifiedCompilation2019,
  title = {Introducing {{Certified Compilation}} in {{Education By}} a {{Functional Language Approach}}},
  author = {Lindgren, Per and Lindner, Marcus and Fitinghoff, Nils},
  year = {2019},
  journal = {CoRR},
  abstract = {Classes on compiler technology are commonly found in Computer Science curricula, covering aspects of parsing, semantic analysis, intermediate transformations and target code generation. This paper reports on introducing certified compilation techniques through a functional language approach in an introductory course on Compiler Construction. Targeting students with little or no experience in formal methods, the proof process is highly automated using the Why3 framework. Underlying logic, semantic modelling and proofs are introduced along with exercises and assignments leading up to a formally verified compiler for a simplistic imperative language. This paper covers the motivation, course design, tool selection, and teaching methods, together with evaluations and suggested improvements from the perspectives of both students and teachers.}
}

@misc{liNominalApproachProbabilistic2024,
  title = {A {{Nominal Approach}} to {{Probabilistic Separation Logic}}},
  author = {Li, John M. and Aytac, Jon and {Johnson-Freyd}, Philip and Ahmed, Amal and Holtzen, Steven},
  year = {2024},
  month = may,
  number = {arXiv:2405.06826},
  eprint = {2405.06826},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.06826},
  urldate = {2024-05-29},
  abstract = {Currently, there is a gap between the tools used by probability theorists and those used in formal reasoning about probabilistic programs. On the one hand, a probability theorist decomposes probabilistic state along the simple and natural product of probability spaces. On the other hand, recently developed probabilistic separation logics decompose state via relatively unfamiliar measure-theoretic constructions for computing unions of sigma-algebras and probability measures. We bridge the gap between these two perspectives by showing that these two methods of decomposition are equivalent up to a suitable equivalence of categories. Our main result is a probabilistic analog of the classic equivalence between the category of nominal sets and the Schanuel topos. Through this equivalence, we validate design decisions in prior work on probabilistic separation logic and create new connections to nominal-set-like models of probability.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/TB76MRZP/Li et al. - 2024 - A Nominal Approach to Probabilistic Separation Log.pdf;/home/flaviomoura/Zotero/storage/66HYLET9/2405.html}
}

@article{linsNewFormulaExecution1986,
  title = {A New Formula for the Execution of Categorical Combinators},
  author = {Lins, R.},
  year = {1986},
  journal = {8th Conference on Automated Deduction (CADE)},
  volume = {volume 230 of LNCS},
  pages = {89--98}
}

@techreport{linsPartialCategoricalMulticombinators1992,
  title = {Partial Categorical Multi-Combinators and {{Church Rosser}} Theorems},
  author = {Lins, R.},
  year = {1992},
  month = may,
  number = {7/92},
  institution = {Computing Laboratory, University Kent at Canterbury}
}

@article{lintzmayerAnaliseAlgoritmosEstruturas,
  title = {{An{\'a}lise de Algoritmos e de Estruturas de Dados}},
  author = {Lintzmayer, Carla Negri and Mota, Guilherme Oliveira},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/3GC656V6/Lintzmayer e Mota - AnÃ¡lise de Algoritmos e de Estruturas de Dados.pdf}
}

@article{liReasoningIterationRecursion2021,
  title = {Reasoning about {{Iteration}} and {{Recursion Uniformly}} Based on {{Big-step Semantics}}},
  author = {Li, Ximeng and Zhang, Qianying and Wang, Guohui and Shi, Zhiping and Guan, Yong},
  year = {2021},
  month = aug,
  journal = {arXiv:2108.01883 [cs]},
  eprint = {2108.01883},
  primaryclass = {cs},
  urldate = {2021-08-10},
  abstract = {A reliable technique for deductive program verification should be proven sound with respect to the semantics of the programming language. For each different language, the construction of a separate soundness proof is often a laborious undertaking. In language-independent program verification, common aspects of computer programs are addressed to enable sound reasoning for all languages. In this work, we propose a solution for the sound reasoning about iteration and recursion based on the big-step operational semantics of any programming language. We give inductive proofs on the soundness and relative completeness of our reasoning technique. We illustrate the technique at simplified programming languages of the imperative and functional paradigms, with diverse features. We also mechanism all formal results in the Coq proof assistant.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/GFEYRKZA/Li et al. - 2021 - Reasoning about Iteration and Recursion Uniformly .pdf;/home/flaviomoura/Zotero/storage/SJ2D4ZDI/2108.html}
}

@misc{liSurveyDeepLearning2024,
  title = {A {{Survey}} on {{Deep Learning}} for {{Theorem Proving}}},
  author = {Li, Zhaoyu and Sun, Jialiang and Murphy, Logan and Su, Qidong and Li, Zenan and Zhang, Xian and Yang, Kaiyu and Si, Xujie},
  year = {2024},
  month = apr,
  number = {arXiv:2404.09939},
  eprint = {2404.09939},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-04-18},
  abstract = {Theorem proving is a fundamental aspect of mathematics, spanning from informal reasoning in mathematical language to rigorous derivations in formal systems. In recent years, the advancement of deep learning, especially the emergence of large language models, has sparked a notable surge of research exploring these techniques to enhance the process of theorem proving. This paper presents a pioneering comprehensive survey of deep learning for theorem proving by offering i) a thorough review of existing approaches across various tasks such as autoformalization, premise selection, proofstep generation, and proof search; ii) a meticulous summary of available datasets and strategies for data generation; iii) a detailed analysis of evaluation metrics and the performance of state-of-the-art; and iv) a critical discussion on the persistent challenges and the promising avenues for future exploration. Our survey aims to serve as a foundational reference for deep learning approaches in theorem proving, seeking to catalyze further research endeavors in this rapidly growing field.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence},
  file = {/home/flaviomoura/Zotero/storage/J5NRTM24/Li et al. - 2024 - A Survey on Deep Learning for Theorem Proving.pdf;/home/flaviomoura/Zotero/storage/9EWPMZR3/2404.html;/home/flaviomoura/Zotero/storage/GQKUPUKF/2404.html}
}

@article{litakLewisMeetsBrouwer2017,
  title = {Lewis Meets {{Brouwer}}: Constructive Strict Implication},
  author = {Litak, T. and Visser, A.},
  year = {2017},
  month = aug,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@article{liuConfluencePropertiesRewrite,
  title = {Confluence Properties of Rewrite Rules by Decreasing Diagrams},
  author = {Liu, Jiaxiang},
  abstract = {Formal methods are increasingly used for developing critical software. Proof assistants based on type theories allow to formally prove properties of software, in particular partial or total correctness. In expressive type theories allowing for dependent types, computations based on rewriting play a fundamental role in identifying types up to computation, such as even(2 + 2) and even(4 + 0) which both compute to even(4). This is possible thanks to two crucial properties of rewrite rules, termination and confluence. A third essential, more semantical property, is type preservation. Confluence is the property of rewriting-based computations expressing that the associated extensional relation is functional, implying uniqueness of normal forms, which exist thanks to termination. In this thesis, we are interested in confluence. Note that this problem is already present in algebraic specification languages, such as OBJ or the functional kernel of Maude. In those simply typed languages without functional types, type preservation is an easy property of the rules, and proving termination can be done independently of confluence. The confluence proof can therefore use the termination property. This is not possible in typed theories, for which termination, confluence of typed terms, and type preservation, depend on each other. Proving confluence on untyped terms is the usual way out, and can then be done first. The difficulty is that computations do not terminate on untyped terms, hence confluence must be proved for non-terminating computations. Our interest in this thesis is therefore to develop confluence proof methods in the presence of non-terminating computations.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/3JUVDGER/Liu - Confluence properties of rewrite rules by decreasi.pdf}
}

@article{liuDiscreteMathProgramming2020,
  title = {Discrete {{Math}} with {{Programming}}: {{A Principled Approach}}},
  shorttitle = {Discrete {{Math}} with {{Programming}}},
  author = {Liu, Yanhong A. and Castelllana, Matthew},
  year = {2020},
  month = nov,
  journal = {arXiv:2011.14059 [cs]},
  eprint = {2011.14059},
  primaryclass = {cs},
  urldate = {2020-12-04},
  abstract = {Discrete mathematics is the foundation of computer science. It focuses on concepts and reasoning methods that are studied using math notations. It has long been argued that discrete math is better taught with programming, which takes concepts and computing methods and turns them into executable programs. What has been lacking is a principled approach that supports all central concepts of discrete math -- especially predicate logic -- and that directly and precisely connects math notations with executable programs. This paper introduces such an approach. It is based on the use of a powerful language that extends the Python programming language with proper logic quantification ("for all" and "exists some"), as well as declarative set comprehension (also known as set builder) and aggregation (e.g., sum and product). Math and logical statements can be expressed precisely at a high level and be executed directly on a computer, encouraging declarative programming together with algorithmic programming. We describe the approach, detailed examples, experience in using it, and the lessons learned.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computers and Society},
  file = {/home/flaviomoura/Zotero/storage/YI97MSB7/Liu e Castelllana - 2020 - Discrete Math with Programming A Principled Appro.pdf;/home/flaviomoura/Zotero/storage/HSVKR72X/2011.html}
}

@book{lloydFoundationsLogicProgramming1987,
  title = {Foundations of {{Logic Programming}}},
  author = {Lloyd, J. W.},
  year = {1987},
  series = {Symbolic {{Computation}} -- {{Artificial Intelligence}}},
  edition = {Second},
  publisher = {Springer}
}

@article{loaderHigherOrderMatching2003,
  ids = {loaderHigherOrderMatching2003a},
  title = {Higher {{Order}} {$\beta$} {{Matching}} Is {{Undecidable}}},
  author = {Loader, Ralph},
  year = {2003},
  journal = {Logic journal of the Interest Group in Pure and Applied Logics},
  volume = {11},
  number = {1},
  pages = {51--68}
}

@article{loaderNotesSimplyTyped,
  title = {Notes on {{Simply Typed Lambda Calculus}}},
  author = {Loader, Ralph},
  pages = {39},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/M5UK7ZAV/Loader - Notes on Simply Typed Lambda Calculus.pdf}
}

@techreport{loaderNotesSimplyTyped1998,
  type = {Technical {{Report ECS-LFCS-98-381}}},
  title = {Notes on {{Simply Typed Lambda Calculus}}},
  author = {Loader, Ralph},
  year = {1998},
  institution = {University of Edinburgh}
}

@book{lockshinJoyScienceExamination2007,
  title = {The {{Joy}} of {{Science}}: {{An Examination}} of How {{Scientists Ask}} and {{Answer Questions Using}} the {{Story}} of {{Evolution}} as a {{Paradigm}}},
  author = {Lockshin, Richard A},
  year = {2007},
  publisher = {Springer Science \& Business Media}
}

@phdthesis{loebNaturalDeduction2007,
  title = {Natural {{Deduction}}},
  author = {Loeb, Iris},
  year = {2007},
  school = {Radboud University}
}

@article{lombardiProjectionsInfinitaryRewriting2016,
  title = {Projections for Infinitary Rewriting},
  author = {Lombardi, C. and R{\'i}os, A. and de Vrijer, R.},
  year = {2016},
  month = may,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@misc{lombardiThEoriesEom2024,
  title = {Th{\textbackslash}'eories G{\textbackslash}'eom{\textbackslash}'etriques Pour l'alg{\textbackslash}`ebre Des Nombres R{\textbackslash}'eels sans Test de Signe Ni Axiome de Choix D{\textbackslash}'ependant},
  author = {Lombardi, Henri and Mahboubi, Assia},
  year = {2024},
  month = aug,
  number = {arXiv:2406.15218},
  eprint = {2406.15218},
  primaryclass = {math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2406.15218},
  urldate = {2024-08-27},
  abstract = {In this memoir, we seek to construct a dynamical theory as complete as possible to describe the algebraic properties of the field of real numbers in constructive mathematics without axiom of dependent choice. We propose a theory which turns out to be very close to the theory of real closed local rings in classical mathematics. The theory of real closed rings is presented here in constructive form as a natural purely equational theory, which uses virtual root functions introduced in previous work. This work is also a first step through an essential goal for the future, which is to obtain a constructive version of o-minimal structures.},
  archiveprefix = {arXiv},
  keywords = {12D15 12J15 14Q20 14P10 03F65 03B35,Mathematics - Commutative Algebra,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/Y4LI3RHH/Lombardi and Mahboubi - 2024 - Th'eories g'eom'etriques pour l'alg`ebre des n.pdf;/home/flaviomoura/Zotero/storage/XTJDPRQU/2406.html}
}

@book{longleyHigherOrderComputability2015,
  title = {Higher-{{Order Computability}}},
  author = {Longley, John and Normann, Dag},
  year = {2015},
  series = {Theory and {{Applications}} of {{Computability}}},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-662-47992-6},
  urldate = {2024-08-12},
  copyright = {http://www.springer.com/tdm},
  isbn = {978-3-662-47991-9 978-3-662-47992-6}
}

@article{loowCompositionalSymbolicExecution2024,
  title = {Compositional {{Symbolic Execution}} for {{Correctness}} and {{Incorrectness Reasoning}} ({{Extended Version}})},
  author = {L{\"o}{\"o}w, Andreas and {Nantes-Sobrinho}, Daniele and Ayoun, Sacha-{\'E}lie and Cronj{\"a}ger, Caroline and Maksimovi{\'c}, Petar and Gardner, Philippa},
  year = {2024},
  journal = {LIPIcs, Volume 313, ECOOP 2024},
  volume = {313},
  eprint = {2407.10838},
  primaryclass = {cs},
  pages = {25:1-25:28},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.ECOOP.2024.25},
  urldate = {2024-09-23},
  abstract = {The introduction of separation logic has led to the development of symbolic execution techniques and tools that are (functionally) compositional with function specifications that can be used in broader calling contexts. Many of the compositional symbolic execution tools developed in academia and industry have been grounded on a formal foundation, but either the function specifications are not validated with respect to the underlying separation logic of the theory, or there is a large gulf between the theory and the implementation of the tool. We introduce a formal compositional symbolic execution engine which creates and uses function specifications from an underlying separation logic and provides a sound theoretical foundation for, and indeed was partially inspired by, the Gillian symbolic execution platform. This is achieved by providing an axiomatic interface which describes the properties of the consume and produce operations used in the engine to update compositionally the symbolic state, for example when calling function specifications. This consume-produce technique is used by VeriFast, Viper, and Gillian, but has not been previously characterised independently of the tool. As part of our result, we give consume and produce operations inspired by the Gillian implementation that satisfy the properties described by our axiomatic interface. A surprising property is that our engine semantics provides a common foundation for both correctness and incorrectness reasoning, with the difference in the underlying engine only amounting to the choice to use satisfiability or validity. We use this property to extend the Gillian platform, which previously only supported correctness reasoning, with incorrectness reasoning and automatic true bug-finding using incorrectness bi-abduction.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/MRY92VYA/LÃ¶Ã¶w et al. - 2024 - Compositional Symbolic Execution for Correctness a.pdf;/home/flaviomoura/Zotero/storage/VDF9GANA/2407.html}
}

@book{lovelandThreeViewsLogic2014,
  title = {Three {{Views}} of {{Logic}}: {{Mathematics}}, {{Philosophy}}, and {{Computer Science}}},
  author = {Loveland, D. W. and Hodel, R. E. and Sterrett, S. G.},
  year = {2014},
  publisher = {Princeton University Press},
  address = {Princeton, NJ, USA},
  isbn = {0-691-16044-9 978-0-691-16044-3}
}

@book{LSFA201611th2016,
  title = {{{LSFA}} 2016 - 11th {{Workshop}} on {{Logical}} and {{Semantic Frameworks}}, with {{Applications}}},
  year = {2016}
}

@book{lucaacetoLogicalFoundationsComputer2013,
  title = {Logical {{Foundations}} of {{Computer Science}}: {{International Symposium}}, {{LFCS}} 2013, {{San Diego}}, {{CA}}, {{USA}}, {{January}} 6-8, 2013. {{Proceedings}}},
  author = {Luca Aceto, Anna Ing{\'o}lfsd{\'o}ttir (auth.), Sergei Artemov, Anil Nerode (eds.)},
  year = {2013},
  series = {Lecture {{Notes}} in {{Computer Science}} 7734},
  edition = {1},
  publisher = {Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-642-35721-3 978-3-642-35722-0}
}

@techreport{lucchesiUndecidabilityUnificationProblem1972,
  title = {The Undecidability of the Unification Problem for Third Order Languages},
  author = {Lucchesi, C. L.},
  year = {1972},
  number = {CSRR 2060},
  institution = {University of Waterloo}
}

@book{luenbergerLinearNonlinearProgramming1984,
  title = {Linear and Nonlinear Programming},
  author = {Luenberger, David G and Ye, Yinyu and others},
  year = {1984},
  volume = {2},
  publisher = {Springer}
}

@article{lundTeachingHigherOrderLogic,
  title = {Teaching {{Higher-Order Logic Using Isabelle}}},
  author = {Lund, Simon Tobias and Villadsen, J{\o}rgen},
  journal = {EPTCS},
  volume = {400},
  pages = {59--78},
  urldate = {2024-04-08},
  file = {/home/flaviomoura/Zotero/storage/N59VM3YQ/Lund e Villadsen - Teaching Higher-Order Logic Using Isabelle.pdf}
}

@book{luoComputationReasoningType1994,
  title = {Computation and {{Reasoning}}: {{A Type Theory}} for {{Computer Science}}},
  author = {Luo, Z.},
  year = {1994},
  publisher = {Oxford University Press, Inc.},
  address = {New York, NY, USA},
  isbn = {0-19-853835-9}
}

@phdthesis{luoExtendedCalculusConstructions1990,
  title = {An {{Extended Calculus}} of {{Constructions}}},
  author = {Luo, Z.},
  year = {1990},
  school = {University of Edinburgh}
}

@inproceedings{madlenerGSOSFormalizedCoq2013,
  title = {{{GSOS Formalized}} in {{Coq}}},
  booktitle = {2013 {{International Symposium}} on {{Theoretical Aspects}} of {{Software Engineering}}},
  author = {Madlener, Ken and Smetsers, Sjaak},
  year = {2013},
  month = jul,
  pages = {199--206},
  publisher = {IEEE},
  address = {Birmingham, United Kingdom},
  doi = {10.1109/TASE.2013.34},
  urldate = {2024-02-07},
  abstract = {Structural operational semantics provides a wellknown framework to describe the semantics of programming languages, lending itself to formalization in theorem provers. The formalization of syntactic SOS rule formats, which enforce some form of well-behavedness, has so far received less attention. GSOS is a rule format that enjoys the property that the operational semantics and denotational semantics, both derived from the same set of GSOS rules, are consistent. The present paper formalizes the underlying theory in the theorem prover COQ, and proves the consistency property, also known as the adequacy theorem. The inspiration for our work has been drawn from the field of bialgebraic semantics.},
  isbn = {978-0-7695-5053-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DR826GXW/Madlener e Smetsers - 2013 - GSOS Formalized in Coq.pdf}
}

@book{magalhaesNaveguePorBelas2019,
  title = {Navegue Por Belas Paisagens Do {{C{\'a}lculo}} : Volume {{III}}},
  shorttitle = {Navegue Por Belas Paisagens Do {{C{\'a}lculo}}},
  author = {Magalh{\~a}es, Celius A.},
  year = {2019},
  publisher = {Editora Universidade de Bras{\'i}lia},
  doi = {10.26512/9788523010126},
  urldate = {2023-04-07},
  abstract = {O livro aborda os conceitos b{\'a}sicos de um primeiro curso de C{\'a}lculo em v{\'a}rias vari{\'a}veis, desde a continuidade e diferenciabilidade, passando pelas integrais m{\'u}ltiplas, at{\'e} alcan{\c c}ar os teoremas de Green, Gauss e Stokes, que s{\~a}o os principais teoremas do C{\'a}lculo Vetorial. A linguagem {\'e} coloquial e convida o leitor {\`a} reflex{\~a}o, apoiada por um grande n{\'u}mero de figuras distribu{\'i}das ao longo do texto. Decididamente {\'e} uma introdu{\c c}{\~a}o ao vasto mundo do C{\'a}lculo, em que s{\~a}o evitados os aspectos espinhosos e {\'e} dada mais aten{\c c}{\~a}o {\`a}s justificativas do que {\`a}s provas rigorosas. O foco est{\'a} em apresentar uma vis{\~a}o integrada dos principais conceitos, enfatizando as id{\'e}ias fundamentais e procurando destac{\'a}-las na variedade de situa{\c c}{\~o}es apresentadas. A comprees{\~a}o dessas id{\'e}ias fundamentais {\'e} refor{\c c}ada com o conjunto de exerc{\'i}cios apresentados que, longe de serem mec{\^a}nicos, procuram desenvolver a intui{\c c}{\~a}o, a capacidade de fazer dedu{\c c}{\~o}es e infer{\^e}ncias e o interesse pela disciplina. {\'E} um conte{\'u}do rico, com aplica{\c c}{\~o}es na F{\'i}sica, Qu{\'i}mica, Engenharias, Economia, etc., e inclui exemplos que ilustram essa riqueza. Espera-se que os leitores, alicer{\c c}ados nesta variedade de exemplos e situa{\c c}{\~o}es, venham a descobrir o fasc{\'i}nio que o C{\'a}lculo tem exercido sobre a comunidade cient{\'i}fica ao longo de v{\'a}rias gera{\c c}{\~o}es.},
  isbn = {978-85-230-1012-6},
  file = {/home/flaviomoura/Zotero/storage/F3T8AFKE/MagalhÃ£es - 2019 - Navegue por belas paisagens do CÃ¡lculo  volume II.pdf}
}

@article{mahboubiFormalProofIrrationality2020,
  title = {A {{Formal Proof}} of the {{Irrationality}} of \${\textbackslash}zeta(3)\$},
  author = {Mahboubi, Assia and {Sibut-Pinote}, Thomas},
  year = {2020},
  month = sep,
  journal = {arXiv:1912.06611 [cs]},
  eprint = {1912.06611},
  primaryclass = {cs},
  urldate = {2020-09-24},
  abstract = {This paper presents a complete formal verification of a proof that the evaluation of the Riemann zeta function at 3 is irrational, using the Coq proof assistant. This result was first presented by Ap{\textbackslash}'ery in 1978, and the proof we have formalized essentially follows the path of his original presentation. The crux of this proof is to establish that some sequences satisfy a common recurrence. We formally prove this result by an a posteriori verification of calculations performed by computer algebra algorithms in a Maple session. The rest of the proof combines arithmetical ingredients and asymptotic analysis, which we conduct by extending the Mathematical Components libraries.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.3},
  file = {/home/flaviomoura/Zotero/storage/BZZXW9J3/Mahboubi e Sibut-Pinote - 2020 - A Formal Proof of the Irrationality of $zeta(3)$.pdf;/home/flaviomoura/Zotero/storage/K5FCIALU/1912.html}
}

@article{mahboubiMachinecheckedMathematics2016,
  title = {Machine-Checked Mathematics},
  author = {Mahboubi, Assia},
  year = {2016},
  month = sep,
  journal = {Nieuw Archief voor Wiskunde},
  volume = {5/17},
  number = {3},
  pages = {5},
  publisher = {Richard Boucherie}
}

@book{mahboubiMathematicalComponents2021,
  title = {Mathematical {{Components}}},
  author = {Mahboubi, Assia and Tassi, Enrico},
  year = {2021},
  month = jan,
  publisher = {Zenodo},
  doi = {10.5281/ZENODO.4457887},
  urldate = {2021-08-09},
  abstract = {Mathematical Components is the name of a library of formalized mathematics for the Coq{$<$}br{$>$} system. It covers a variety of topics, from the theory of basic data structures (e.g., numbers,{$<$}br{$>$} lists, finite sets) to advanced results in various flavors of algebra. This library constitutes{$<$}br{$>$} the infrastructure for the machine-checked proofs of the Four Color Theorem and{$<$}br{$>$} of the Odd Order Theorem.{$<$}br{$>$} The reason of existence of this book is to break down the barriers to entry. While there{$<$}br{$>$} are several books around covering the usage of the Coq system{$<$}br{$>$} and the theory it is based on, the Mathematical Components library{$<$}br{$>$} is built in an unconventional way. As a consequence, this book provides a non-standard{$<$}br{$>$} presentation of Coq, putting upfront the formalization choices and the proof style that{$<$}br{$>$} are the pillars of the library.{$<$}br{$>$} This books targets two classes of public. On the one hand, newcomers, even the more{$<$}br{$>$} mathematically inclined ones, find a soft introduction to the programming language of{$<$}br{$>$} Coq, Gallina, and the SSReflect proof language. On the other hand accustomed Coq{$<$}br{$>$} users find a substantial account of the formalization style that made the Mathematical{$<$}br{$>$} Components library possible.},
  copyright = {Creative Commons Attribution Non Commercial 4.0 International, Open Access},
  langid = {english},
  keywords = {Coq,Formal Proofs,Formalized Mathematics,Mathematical Components,SSReflect,Type Theory},
  file = {/home/flaviomoura/Zotero/storage/83BSPX4L/book.pdf}
}

@book{maierAlgebra2005,
  title = {{\'A}lgebra {{I}}},
  author = {Maier, R.},
  year = {2005}
}

@book{maierTeoriaDosNumeros2005,
  title = {Teoria Dos {{N{\'u}meros}}},
  author = {Maier, R.},
  year = {2005}
}

@book{makinsonauth.SetsLogicMaths2012,
  title = {Sets, {{Logic}} and {{Maths}} for {{Computing}}},
  author = {Makinson (auth.), David},
  year = {2012},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  edition = {2},
  publisher = {Springer-Verlag London},
  isbn = {1-4471-2499-5 978-1-4471-2499-3}
}

@article{mamecheSTRONGNORMALIZATIONLCALCULUS,
  title = {{{STRONG NORMALIZATION OF THE}} {$\lambda$}-{{CALCULUS IN LEAN}}},
  author = {Mameche, Sarah and Stark, Kathrin},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/MWI5K8PR/Mameche e Stark - STRONG NORMALIZATION OF THE Î»-CALCULUS IN LEAN.pdf}
}

@article{manacherNewLinearTimeOnLine1975,
  title = {A {{New Linear-Time}} ``on-{{Line}}'' {{Algorithm}} for {{Finding}} the {{Smallest Initial Palindrome}} of a {{String}}},
  author = {Manacher, Glenn},
  year = {1975},
  journal = {Journal of the ACM},
  volume = {22},
  number = {3},
  pages = {346--351},
  doi = {10.1145/321892.321896}
}

@book{manberIntroductionAlgorithmsCreative1989,
  title = {Introduction to {{Algorithms}}: {{A Creative Approach}}},
  author = {Manber, Udi},
  year = {1989},
  publisher = {Addison-Wesley Longman Publishing Co., Inc. Boston, MA, USA},
  keywords = {imported},
  file = {/home/flaviomoura/Zotero/storage/LMTGLTXK/Manber - 1989 - Introduction to Algorithms A Creative Approach.pdf}
}

@article{manberUsingInductionDesign1988,
  title = {Using {{Induction To Design Algorithms}}},
  author = {Manber, Udi},
  year = {1988},
  journal = {Communications of the ACM},
  volume = {31},
  number = {11},
  pages = {1300--1313},
  doi = {10.1145/50087.50091},
  file = {/home/flaviomoura/Zotero/storage/QPTGGIZ8/Manber - 1988 - Using Induction To Design Algorithms.pdf}
}

@unpublished{mancosuDevelopmentMathematicalLogic2004,
  title = {The {{Development}} of {{Mathematical Logic}} from {{Russel}} to {{Tarski}}: 1900 - 1935},
  author = {Mancosu, Paolo and Zach, Richard and Badesa, Calixto},
  year = {2004}
}

@book{mancosuIntroductionProofTheory2021,
  title = {An {{Introduction}} to {{Proof Theory}}: {{Normalization}}, {{Cut-Elimination}}, and {{Consistency Proofs}}},
  shorttitle = {An {{Introduction}} to {{Proof Theory}}},
  author = {Mancosu, Paolo and Galvan, Sergio and Zach, Richard},
  year = {2021},
  month = aug,
  edition = {1},
  publisher = {Oxford University PressOxford},
  doi = {10.1093/oso/9780192895936.001.0001},
  urldate = {2023-01-11},
  abstract = {Abstract             Proof theory is a central area of mathematical logic of special interest to philosophy. It has its roots in the foundational debate of the 1920s, in particular, in Hilbert's program in the philosophy of mathematics, which called for a formalization of mathematics, as well as for a proof, using philosophically unproblematic, ``finitary'' means, that these systems are free from contradiction. Structural proof theory investigates the structure and properties of proofs in different formal deductive systems, including axiomatic derivations, natural deduction, and the sequent calculus. Central results in structural proof theory are the normalization theorem for natural deduction, proved here for both intuitionistic and classical logic, and the cut-elimination theorem for the sequent calculus. In formal systems of number theory formulated in the sequent calculus, the induction rule plays a central role. It can be eliminated from proofs of sequents of a certain elementary form: every proof of an atomic sequent can be transformed into a ``simple'' proof. This is Hilbert's central idea for giving finitary consistency proofs. The proof requires a measure of proof complexity called an ordinal notation. The branch of proof theory dealing with mathematical systems such as arithmetic thus has come to be called ordinal proof theory. The theory of ordinal notations is developed here in purely combinatorial terms, and the consistency proof for arithmetic presented in detail.},
  isbn = {978-0-19-289593-6 978-0-19-193879-5},
  langid = {english}
}

@article{mandelkernConstructiveRealProjective2015,
  title = {A {{Constructive Real Projective Plane}}},
  author = {Mandelkern, M.},
  year = {2015},
  journal = {Journal of Geometry},
  volume = {107},
  number = {1},
  pages = {19--60},
  doi = {10.1007/s00022-015-0272-4}
}

@techreport{manginEliminatingDependentPatternMatching2015,
  title = {Eliminating {{Dependent Pattern-Matching}} in {{Coq}}},
  author = {Mangin, C.},
  year = {2015},
  institution = {Universit{\'e} Paris-Diderot}
}

@article{manighettiComputationalInterpretationsMarkov2016,
  title = {Computational {{Interpretations}} of {{Markov}}'s Principle},
  author = {Manighetti, M.},
  year = {2016},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {03F03,03F30,03F50,03F55,Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic}
}

@article{manighettilinear,
  title = {A Linear Logic Approach to Arithmetic},
  author = {Manighetti, Matteo and Miller, Dale}
}

@article{manighettitwo,
  title = {Two Applications of Logic Programming to {{Coq}}},
  author = {Manighetti, Matteo and Miller, Dale and Momigliano, Alberto},
  file = {/home/flaviomoura/Zotero/storage/RC8RP56Z/Manighetti et al. - 2020 - Two Applications of Logic Programming to Coq.pdf}
}

@book{maninCourseMathematicalLogic1977,
  title = {A {{Course}} in {{Mathematical Logic}}},
  author = {Manin, Y. I.},
  year = {1977},
  series = {Graduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4757-4385-2}
}

@inproceedings{manoliosTerminationAnalysisCalling2006,
  title = {Termination {{Analysis}} with {{Calling Context Graphs}}},
  booktitle = {Proc. 18th {{Int}}. {{Conference}} on {{Computer Aided Verification CAV}}},
  author = {Manolios, P. and Vroon, D.},
  year = {2006},
  series = {Lncs},
  volume = {4144},
  pages = {401--414}
}

@phdthesis{mansutti2020reasoning,
  title = {Reasoning with Separation Logics: Complexity, Expressive Power, Proof Systems},
  author = {Mansutti, Alessio},
  year = {2020},
  school = {universit{\'e} Paris-Saclay}
}

@article{maraistCallbynameCallbyvalueCallbyneed1999,
  title = {Call-by-Name, {{Call-by-value}}, {{Call-by-need}} and the {{Linear}} Lambda {{Calculus}}},
  author = {Maraist, John and Odersky, Martin and Turner, David N. and Wadler, Philip},
  year = {1999},
  journal = {Theor. Comput. Sci.},
  volume = {228},
  number = {1-2},
  pages = {175--210},
  doi = {10.1016/S0304-3975(98)00358-2}
}

@article{marinEcumenicalModalLogic2020,
  title = {Ecumenical {{Modal Logic}}},
  author = {Marin, Sonia and Pereira, Luiz Carlos and Pimentel, Elaine and Sales, Emerson},
  year = {2020},
  journal = {CoRR},
  abstract = {The discussion about how to put together Gentzen's systems for classical and intuitionistic logic in a single unified system is back in fashion. Indeed, recently Prawitz and others have been discussing the so called Ecumenical Systems, where connectives from these logics can co-exist in peace. In Prawitz' system, the classical logician and the intuitionistic logician would share the universal quantifier, conjunction, negation, and the constant for the absurd, but they would each have their own existential quantifier, disjunction, and implication, with different meanings. Prawitz' main idea is that these different meanings are given by a semantical framework that can be accepted by both parties. In a recent work, Ecumenical sequent calculi and a nested system were presented, and some very interesting proof theoretical properties of the systems were established. In this work we extend Prawitz' Ecumenical idea to alethic K-modalities.}
}

@book{marquesLeadershipToday2017,
  title = {Leadership {{Today}}},
  author = {Marques, Joan and Dhiman, Satinder},
  year = {2017},
  series = {Springer {{Texts}} in {{Business}} and {{Economics}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-31036-7}
}

@article{martelliEfficientUnificationAlgorithm1982,
  title = {An {{Efficient Unification Algorithm}}},
  author = {Martelli, A. and Montanari, U.},
  year = {1982},
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {4},
  number = {2},
  pages = {258--282},
  doi = {10.1145/357162.357169}
}

@inproceedings{martin-lofConstructiveMathematicsComputer1985,
  title = {Constructive {{Mathematics}} and {{Computer Programming}}},
  booktitle = {Proc. {{Of}} a {{Discussion Meeting}} of the {{Royal Society}} of {{London}} on {{Mathematical Logic}} and {{Programming Languages}}},
  author = {{Martin-L{\"o}f}, P.},
  year = {1985},
  pages = {167--184},
  publisher = {Prentice-Hall, Inc.},
  address = {Upper Saddle River, NJ, USA},
  isbn = {0-13-561465-1}
}

@article{martinez-rivillasHomotopyDomainTheory2020,
  title = {Towards a {{Homotopy Domain Theory}}},
  author = {{Mart{\'i}nez-Rivillas}, Daniel O. and {de Queiroz}, Ruy J. G. B.},
  year = {2020},
  month = dec,
  journal = {arXiv:2007.15082 [cs]},
  eprint = {2007.15082},
  primaryclass = {cs},
  urldate = {2020-12-07},
  abstract = {An appropriate framework is put forward for the construction of \${\textbackslash}lambda\$-models with \${\textbackslash}infty\$-groupoid structure, which we call {\textbackslash}textit\{homotopic \${\textbackslash}lambda\$-models\} through the use of an \${\textbackslash}infty\$-category of Kan complexes with cartesian closure and enough points. With this we establish the start of a project of generalization of Domain Theory and \${\textbackslash}lambda\$-calculus, in the sense that the concept of proof (path) of equality of \${\textbackslash}lambda\$-terms is raised to {\textbackslash}textit\{higher proof\} (homotopy).},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/IZVC9IFZ/MartÃ­nez-Rivillas e de Queiroz - 2020 - Towards a Homotopy Domain Theory.pdf;/home/flaviomoura/Zotero/storage/XGA3PCER/2007.html}
}

@article{martinez-rivillasInftyGroupoidGenerated2021,
  title = {The \${\textbackslash}infty\$-Groupoid Generated by an Arbitrary Topological \${\textbackslash}lambda\$-Model},
  author = {{Mart{\'i}nez-Rivillas}, Daniel O. and {de Queiroz}, Ruy J. G. B.},
  year = {2021},
  month = jan,
  journal = {arXiv:1906.05729 [cs, math]},
  eprint = {1906.05729},
  primaryclass = {cs, math},
  urldate = {2021-01-19},
  abstract = {The lambda calculus is a universal programming language. It can represent the computable functions, and such offers a formal counterpart to the point of view of functions as rules. Terms represent functions and this allows for the application of a term/function to any other term/function, including itself. The calculus can be seen as a formal theory with certain pre-established axioms and inference rules, which can be interpreted by models. Dana Scott proposed the first non-trivial model of the extensional lambda calculus, known as \$ D\_{\textbackslash}infty\$, to represent the \${\textbackslash}lambda\$-terms as the typical functions of set theory, where it is not allowed to apply a function to itself. Here we propose a construction of an \${\textbackslash}infty\$-groupoid from any lambda model endowed with a topology. We apply this construction for the particular case \$D\_{\textbackslash}infty\$, and we see that the Scott topology does not provide enough information about the relationship between higher homotopies. This motivates a new line of research focused on the exploration of \${\textbackslash}lambda\$-models with the structure of a non-trivial \${\textbackslash}infty\$-groupoid to generalize the proofs of term conversion (e.g., \${\textbackslash}beta\$-equality, \${\textbackslash}eta\$-equality) to higher-proofs in \${\textbackslash}lambda\$-calculus.},
  archiveprefix = {arXiv},
  keywords = {68Q05,Computer Science - Logic in Computer Science,F.4.1,Mathematics - Algebraic Topology,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/ZDGQK6CP/MartÃ­nez-Rivillas e de Queiroz - 2021 - The $infty$-groupoid generated by an arbitrary to.pdf;/home/flaviomoura/Zotero/storage/C3XC3I7G/1906.html}
}

@article{martinez-rivillasModelInftyGroupoid2019,
  title = {A \${$\lambda\$$}-Model {{With}} \${\i}nfty\$-Groupoid {{Structure Based}} on {{Scotts}} \${$\lambda\$$}-Model \${{D}}\_{\i}nfty\$},
  author = {{Mart{\'i}nez-Rivillas}, Daniel O. and de Queiroz, Ruy J. G. B.},
  year = {2019},
  journal = {CoRR},
  abstract = {The lambda calculus is a universal programming language that represents the functions computable from the point of view of the functions as a rule, that allow the evaluation of a function on any other function. This language can be seen as a theory, with certain pre-established axioms and inference rules, which can be represented by models. Dana Scott proposed the first non-trivial model of the extensional lambda calculus, known as \$D\_{\i}nfty\$ , in order to represent the {$\lambda$}-terms as the typical functions of set theory, where it is not allowed to evaluate a function about itself. Here we propose a construction of a \${\i}nfty\$-groupoid from any lambda model endowed with a topology, with the purpose of projecting \$D\_{\i}nfty\$, with the Scott topology, to an extensional lambda model with an \${\i}nfty\$-groupoid structure under a composition operation between cells.}
}

@article{martinPurePatternCalculus2020,
  title = {Pure {{Pattern Calculus}} {\`a} {{La De Bruijn}}},
  author = {Mart{\'i}n, Alexis and R{\'i}os, Alejandro and Viso, Andr{\'e}s},
  year = {2020},
  journal = {CoRR},
  abstract = {It is well-known in the field of programming languages that dealing with variable names and binders may lead to conflicts such as undesired captures when implementing interpreters or compilers. This situation has been overcome by resorting to de Bruijn indices for calculi where binders capture only one variable name, like the {$\lambda$}-calculus. The advantage of this approach relies on the fact that so-called {$\alpha$}-equivalence becomes syntactical equality when working with indices. In recent years pattern calculi have gained considerable attention given their expressiveness. They turn out to be notoriously convenient to study the foundations of modern functional programming languages modeling features like pattern matching, path polymorphism, pattern polymorphism, etc. However, the literature falls short when it comes to dealing with {$\alpha$}-conversion and binders capturing simultaneously several variable names. Such is the case of the Pure Pattern Calculus (PPC): a natural extension of {$\lambda$}-calculus that allows to abstract virtually any term. This paper extends de Bruijn's ideas to properly overcome the multi-binding problem by introducing a novel presentation of PPC with bidimensional indices, in an effort to implement a prototype for a typed functional programming language based on PPC that captures path polymorphism.}
}

@misc{massaioliSemanticsProofsClassical2023,
  title = {On the Semantics of Proofs in Classical Sequent Calculus},
  author = {Massaioli, Fabio},
  year = {2023},
  month = jul,
  number = {arXiv:2307.16594},
  eprint = {2307.16594},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-08-01},
  abstract = {We discuss the problem of finding non-trivial invariants of non-deterministic, symmetric cut-reduction procedures in the classical sequent calculus. We come to the conclusion that (an enriched version of) the propositional fragment of GS4 -- i.e. the one-sided variant of Kleene's context-sharing style sequent system G4, where independent rule applications permute freely -- is an ideal framework in which to attack the problem. We show that the graph induced by axiom rules linking dual atom occurrences is preserved under arbitrary rule permutations in the cut-free fragment of GS4. We then refine the notion of axiom-induced graph so as to extend the result to derivations with cuts, and we exploit the invertibility of logical rules to define a global normalisation procedure that preserves the refined axiom-induced graphs, thus yielding a nontrivial invariant of cut-elimination in GS4. Finally, we build upon the result to devise a new proof system for classical propositional logic, where the rule permutations of GS4 reduce to identities.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science,F.3.1,F.3.2,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/FYBMI7SD/2307.16594.pdf}
}

@article{masuokaCounterexampleCuteliminationCyclic2021,
  title = {Counterexample to Cut-Elimination in Cyclic Proof System for First-Order Logic with Inductive Definitions},
  author = {Masuoka, Yukihiro and Tatsuta, Makoto},
  year = {2021},
  month = jun,
  journal = {arXiv:2106.11798 [cs, math]},
  eprint = {2106.11798},
  primaryclass = {cs, math},
  urldate = {2021-06-29},
  abstract = {A cyclic proof system is a proof system whose proof figure is a tree with cycles. The cut-elimination in a proof system is fundamental. It is conjectured that the cut-elimination in the cyclic proof system for first-order logic with inductive definitions does not hold. This paper shows that the conjecture is correct by giving a sequent not provable without the cut rule but provable in the cyclic proof system.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/24ELL6BX/Masuoka e Tatsuta - 2021 - Counterexample to cut-elimination in cyclic proof .pdf;/home/flaviomoura/Zotero/storage/CBEWEFA8/2106.html}
}

@incollection{matthesStabilizationAlternativeDoublenegation2006,
  title = {Stabilization --- an Alternative to Double-Negation Translation for Classical Natural Deduction},
  booktitle = {Logic {{Colloquium}} '03},
  author = {Matthes, Ralph},
  editor = {V{\"a}{\"a}n{\"a}nen, Jouko and {Stoltenberg-Hansen}, Viggo},
  year = {2006},
  series = {Lecture {{Notes}} in {{Logic}}},
  pages = {167--199},
  publisher = {Cambridge University Press},
  address = {Cambridge},
  doi = {10.1017/9781316755785.010},
  urldate = {2024-08-16},
  isbn = {978-1-316-75578-5},
  file = {/home/flaviomoura/Zotero/storage/S65QRMEN/Matthes - 2006 - Stabilization â an alternative to double-negation .pdf;/home/flaviomoura/Zotero/storage/6W3VGBSI/4A8B900380D867E0D3347FD0466CB5DA.html}
}

@misc{matthesSubstitutionNonWellfoundedSyntax2023,
  title = {Substitution for {{Non-Wellfounded Syntax}} with {{Binders}}},
  author = {Matthes, Ralph and Wullaert, Kobe and Ahrens, Benedikt},
  year = {2023},
  month = aug,
  number = {arXiv:2308.05485},
  eprint = {2308.05485},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-08-14},
  abstract = {We describe a generic construction of non-wellfounded syntax involving variable binding and its monadic substitution operation. Our construction of the syntax and its substitution takes place in category theory, notably by using monoidal categories and strong functors between them. A language is specified by a multisorted binding signature, say {$\Sigma$}. First, we provide sufficient criteria for {$\Sigma$} to generate a language of possibly infinite terms, through {$\omega$}-continuity. Second, we construct a monadic substitution operation for the language generated by {$\Sigma$}. A cornerstone in this construction is a mild generalization of the notion of heterogeneous substitution systems developed by Matthes and Uustalu; such a system encapsulates the necessary corecursion scheme for implementing substitution.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/YYI7SXKC/Matthes et al. - 2023 - Substitution for Non-Wellfounded Syntax with Binde.pdf}
}

@inproceedings{matthesSubstitutionNonWellfoundedSyntax2024,
  title = {Substitution for {{Non-Wellfounded Syntax}} with {{Binders Through Monoidal Categories}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{FSCD}}.2024.25},
  author = {Matthes, Ralph and Wullaert, Kobe and Ahrens, Benedikt},
  year = {2024},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.FSCD.2024.25},
  urldate = {2024-08-16},
  abstract = {We describe a generic construction of non-wellfounded syntax involving variable binding and its monadic substitution operation. Our construction of the syntax and its substitution takes place in category theory, notably by using monoidal categories and strong functors between them. A language is specified by a multi-sorted binding signature, say {$\Sigma$}. First, we provide sufficient criteria for {$\Sigma$} to generate a language of possibly infinite terms, through {$\omega$}-continuity. Second, we construct a monadic substitution operation for the language generated by {$\Sigma$}. A cornerstone in this construction is a mild generalization of the notion of heterogeneous substitution systems developed by Matthes and Uustalu; such a system encapsulates the necessary corecursion scheme for implementing substitution. The results are formalized in the Coq proof assistant, through the UniMath library of univalent mathematics.},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BKEKGY66/Matthes et al. - 2024 - Substitution for Non-Wellfounded Syntax with Binde.pdf}
}

@phdthesis{maunyCompilationLangagesFonctionnels1985,
  title = {Compilation Des Langages Fonctionnels Dans Les Combinateurs Cat{\'e}goriques - {{Application}} Au Langage {{ML}}},
  author = {Mauny, M.},
  year = {1985},
  address = {Paris, France},
  school = {Universit{\'e} Paris VII}
}

@article{mayerImportanceTeachingLogic,
  title = {The {{Importance}} of {{Teaching Logic}} to {{Computer Scientists}} and {{Electrical Engineers}}},
  author = {Mayer, Paul},
  abstract = {It is argued that logic, and in particular mathematical logic, should play a key role in the undergraduate curriculum for students in the computing fields, which include electrical engineering (EE), computer engineering (CE), and computer science (CS). This is based on 1) the history of the field of computing and its close ties with logic, 2) empirical results showing that students with better logical thinking skills perform better in tasks such as programming and mathematics, and 3) the skills students are expected to have in the job market. Further, we believe teaching logic to students explicitly will improve student retention, especially involving underrepresented minorities. Though this work focuses specifically on the computing fields, these results demonstrate the importance of logic education to STEM (science, technology, engineering, and mathematics) as a whole.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/LTYSRFIN/Mayer - The Importance of Teaching Logic to Computer Scien.pdf}
}

@article{mazzaMasterLogiqueMathematique,
  title = {Master 2 ``{{Logique Math{\'e}matique}} et {{Fondements}} de l'{{Informatique}}'', {{Univ}}. {{Paris}} 7},
  author = {Mazza, Damiano},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/U99F72RQ/Mazza - Master 2 âLogique MathÃ©matique et Fondements de lâ.pdf}
}

@book{mccainNatureScientificKnowledge2016,
  title = {The {{Nature}} of {{Scientific Knowledge}}},
  author = {McCain, Kevin},
  year = {2016},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-33405-9}
}

@inproceedings{mccartin-limConnectDotsProve2018,
  title = {Connect the {{Dots}} to {{Prove It}}: {{A Novel Way}} to {{Learn Proof Construction}}},
  shorttitle = {Connect the {{Dots}} to {{Prove It}}},
  booktitle = {Proceedings of the 49th {{ACM Technical Symposium}} on {{Computer Science Education}}},
  author = {{McCartin-Lim}, Mark and Woolf, Beverly and McGregor, Andrew},
  year = {2018},
  month = feb,
  pages = {533--538},
  publisher = {ACM},
  address = {Baltimore Maryland USA},
  doi = {10.1145/3159450.3159609},
  urldate = {2020-07-09},
  isbn = {978-1-4503-5103-4},
  langid = {english}
}

@book{mcconnellAnalysisAlgorithmsActive2001,
  title = {Analysis of {{Algorithms}}: {{An Active Learning Approach}}},
  author = {McConnell, Jeffrey J.},
  year = {2001},
  edition = {1st},
  publisher = {{Jones and Bartlett Publishers, Inc.}},
  address = {USA},
  isbn = {0-7637-1634-0 978-0-7637-1634-9}
}

@book{mccuneAutomatedDeductionCADE141997,
  title = {Automated {{Deduction}} - {{CADE-14}}, 14th {{International Conference}} on {{Automated Deduction}}, {{Townsville}}, {{North Queensland}}, {{Australia}}, {{July}} 13-17, 1997, {{Proceedings}}},
  editor = {McCune, William},
  year = {1997},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1249},
  publisher = {Springer},
  doi = {10.1007/3-540-63104-6},
  isbn = {3-540-63104-6}
}

@misc{mccuneProver9Mace42005,
  title = {Prover9 and Mace4},
  author = {McCune, W.},
  year = {2005/2010},
  howpublished = {http://www.cs.unm.edu/{\textasciitilde}mccune/prover9/}
}

@article{MechanicalMathematiciansCommunications2023,
  title = {Mechanical {{Mathematicians}} -- {{Communications}} of the {{ACM}}},
  year = {2023},
  month = apr,
  doi = {10.1145/3557998},
  urldate = {2024-03-22},
  langid = {american},
  file = {/home/flaviomoura/Zotero/storage/AMPPNRZJ/2023 - Mechanical Mathematicians â Communications of the .pdf;/home/flaviomoura/Zotero/storage/CBCTB5N9/mechanical-mathematicians.html}
}

@misc{MechanisationAKSAlgorithm,
  title = {Mechanisation of the {{AKS Algorithm}} {\textbar} {{Journal}} of {{Automated Reasoning}}},
  urldate = {2024-09-16},
  howpublished = {https://link.springer.com/article/10.1007/s10817-020-09563-y},
  file = {/home/flaviomoura/Zotero/storage/T3N2P98A/s10817-020-09563-y.html}
}

@article{mekFINITELYPRESENTABLEALGEBRAS,
  title = {{{FINITELY PRESENTABLE ALGEBRAS FOR FINITARY MONADS}}},
  author = {Mek, J Ada and Milius, S and Sousa, L and Wissmann, T},
  pages = {18},
  abstract = {For finitary regular monads T on locally finitely presentable categories we characterize the finitely presentable objects in the category of T-algebras in the style known from general algebra: they are precisely the algebras presentable by finitely many generators and finitely many relations.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/TJVW3MI3/Mek et al. - FINITELY PRESENTABLE ALGEBRAS FOR FINITARY MONADS.pdf}
}

@article{melkonianVerifiedCompilationBitML,
  title = {Verified Compilation from {{BitML}} to {{Bitcoin}}: {{An Agda Odyssey}}},
  author = {Melkonian, Orestis},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7JXGC7N6/Melkonian - Verified compilation from BitML to Bitcoin An Agd.pdf}
}

@misc{melliesCategoricalContoursChomskySchutzenberger2025,
  title = {The Categorical Contours of the {{Chomsky-Sch{\"u}tzenberger}} Representation Theorem},
  author = {Melli{\`e}s, Paul-Andr{\'e} and Zeilberger, Noam},
  year = {2025},
  month = mar,
  number = {arXiv:2405.14703},
  eprint = {2405.14703},
  primaryclass = {math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.14703},
  urldate = {2025-03-20},
  abstract = {We develop fibrational perspectives on context-free grammars and on nondeterministic finite-state automata over categories and operads. A generalized CFG is a functor from a free colored operad (aka multicategory) generated by a pointed finite species into an arbitrary base operad: this encompasses classical CFGs by taking the base to be a certain operad constructed from a free monoid, as an instance of a more general construction of an {\textbackslash}emph\{operad of spliced arrows\} \${\textbackslash}mathcal\{W\}{\textbackslash},{\textbackslash}mathcal\{C\}\$ for any category \${\textbackslash}mathcal\{C\}\$. A generalized NFA is a functor from an arbitrary bipointed category or pointed operad satisfying the unique lifting of factorizations and finite fiber properties: this encompasses classical word automata and tree automata without \${\textbackslash}epsilon\$-transitions, but also automata over non-free categories and operads. We show that generalized context-free and regular languages satisfy suitable generalizations of many of the usual closure properties, and in particular we give a simple conceptual proof that context-free languages are closed under intersection with regular languages. Finally, we observe that the splicing functor \${\textbackslash}mathcal\{W\} : Cat {\textbackslash}to Oper\$ admits a left adjoint \${\textbackslash}mathcal\{C\}: Oper {\textbackslash}to Cat\$, which we call the {\textbackslash}emph\{contour category\} construction since the arrows of \${\textbackslash}mathcal\{C\}{\textbackslash},{\textbackslash}mathcal\{O\}\$ have a geometric interpretation as oriented contours of operations of \${\textbackslash}mathcal\{O\}\$. A direct consequence of the contour / splicing adjunction is that every pointed finite species induces a universal CFG generating a language of {\textbackslash}emph\{tree contour words.\} This leads us to a generalization of the Chomsky-Sch{\textbackslash}"utzenberger Representation Theorem, establishing that a subset of a homset \$L {\textbackslash}subseteq {\textbackslash}mathcal\{C\}(A,B)\$ is a CFL of arrows if and only if it is a functorial image of the intersection of a \${\textbackslash}mathcal\{C\}\$-chromatic tree contour language with a regular language.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/FEZRXAAV/MelliÃ¨s e Zeilberger - 2025 - The categorical contours of the Chomsky-SchÃ¼tzenbe.pdf;/home/flaviomoura/Zotero/storage/73X2UAT8/2405.html}
}

@article{melliesFiveBasicConcepts2016,
  title = {Five {{Basic Concepts}} of {{Axiomatic Rewriting Theory}}},
  author = {Melli{\`e}s, P.-A.},
  year = {2016},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,Mathematics - Category Theory,Mathematics - Logic}
}

@misc{melliesFiveBasicConcepts2016a,
  title = {Five {{Basic Concepts}} of {{Axiomatic Rewriting Theory}}},
  author = {Melli{\`e}s, Paul-Andr{\'e}},
  year = {2016},
  month = sep,
  number = {arXiv:1609.09783},
  eprint = {1609.09783},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1609.09783},
  urldate = {2025-03-20},
  abstract = {In this invited talk, I will review five basic concepts of Axiomatic Rewriting Theory, an axiomatic and diagrammatic theory of rewriting started 25 years ago in a LICS paper with Georges Gonthier and Jean-Jacques L{\textbackslash}'evy, and developed along the subsequent years into a full-fledged 2-dimensional theory of causality and residuation in rewriting. I will give a contemporary view on the theory, informed by my later work on categorical semantics and higher-dimensional algebra, and also indicate a number of current research directions in the field.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/BCVK525B/MelliÃ¨s - 2016 - Five Basic Concepts of Axiomatic Rewriting Theory.pdf;/home/flaviomoura/Zotero/storage/C5U47Z9B/1609.html}
}

@inproceedings{melliesStabilityTheoremRewriting1998,
  title = {A {{Stability Theorem}} in {{Rewriting Theory}}},
  booktitle = {Thirteenth {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{Indianapolis}}, {{Indiana}}, {{USA}}, {{June}} 21-24, 1998},
  author = {Melli{\`e}s, Paul-Andr{\'e}},
  year = {1998},
  pages = {287--298},
  doi = {10.1109/LICS.1998.705665}
}

@incollection{melliesTypedLcalculiExplicit1995,
  title = {Typed {$\lambda$}-Calculi with Explicit Substitutions May Not Terminate},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}},
  author = {Mellies, Paul-Andr{\'e}},
  editor = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan and {Dezani-Ciancaglini}, Mariangiola and Plotkin, Gordon},
  year = {1995},
  volume = {902},
  pages = {328--334},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/BFb0014062},
  urldate = {2023-09-08},
  isbn = {978-3-540-59048-4 978-3-540-49178-1},
  file = {/home/flaviomoura/Zotero/storage/749P6V7C/Mellies - 1995 - Typed Î»-calculi with explicit substitutions may no.pdf}
}

@book{mendelsonIntroductionMathematicalLogic2015,
  title = {Introduction to {{Mathematical Logic}}, {{Sixth Edition}}},
  author = {Mendelson, Elliott},
  year = {2015},
  series = {Discrete {{Mathematics}} and {{Its Applications}}},
  edition = {6th ed},
  publisher = {CRC Press},
  isbn = {978-1-4822-3772-6 1-4822-3772-5 978-1-4822-3778-8 1-4822-3778-4},
  file = {/home/flaviomoura/Zotero/storage/AIGCKIUW/Mendelson - 2015 - Introduction to Mathematical Logic, Sixth Edition.pdf}
}

@article{mendelzonSwappingNaturalBridge2011,
  title = {Swapping: A Natural Bridge between Named and Indexed Explicit Substitution Calculi},
  shorttitle = {Swapping},
  author = {Mendelzon, Ariel and R{\'i}os, Alejandro and Ziliani, Beta},
  year = {2011},
  month = feb,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {49},
  eprint = {1102.3730},
  primaryclass = {cs},
  pages = {1--15},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.49.1},
  urldate = {2023-09-17},
  abstract = {This article is devoted to the presentation of lambda\_rex, an explicit substitution calculus with de Bruijn indexes and a simple notation. By being isomorphic to lambda\_ex - a recent formalism with variable names -, lambda\_rex accomplishes simulation of beta-reduction (Sim), preservation of beta-strong normalization (PSN) and meta-confluence (MC), among other desirable properties. Our calculus is based on a novel presentation of lambda\_dB, using a swap notion that was originally devised by de Bruijn. Besides lambda\_rex, two other indexed calculi isomorphic to lambda\_x and lambda\_xgc are presented, demonstrating the potential of our technique when applied to the design of indexed versions of known named calculi.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/SGYP87NB/Mendelzon et al. - 2011 - Swapping a natural bridge between named and index.pdf;/home/flaviomoura/Zotero/storage/7V75VW49/1102.html}
}

@article{menonDeterministicPrimalityTesting2013,
  title = {Deterministic {{Primality Testing}} - {{Understanding}} the {{Aks Algorithm}}},
  author = {Menon, Vijay},
  year = {2013},
  journal = {CoRR},
  abstract = {Prime numbers play a very vital role in modern cryptography and especially the difficulties involved in factoring numbers composed of product of two large prime numbers have been put to use in many modern cryptographic designs. Thus, the problem of distinguishing prime numbers from the rest is vital and therefore there is a need to have efficient primality testing algorithms. Although there had been many probabilistic algorithms for primality testing, there wasn't a deterministic polynomial time algorithm until 2002 when Agrawal, Kayal and Saxena came with an algorithm, popularly known as the AKS algorithm, which could test whether a given number is prime or composite in polynomial time. This project is an attempt at understanding the ingenious idea behind this algorithm and the underlying principles of mathematics that is required to study it. In fact, through out this project, one of the major objectives has been to make it as much self contained as possible. Finally, the project provides an implementation of the algorithm using Software for Algebra and Geometry Experimentation (SAGE) and arrives at conclusions on how practical or otherwise it is.}
}

@book{menzler-trottLogicLostGenius2017,
  title = {Logic's {{Lost Genius}}: {{The Life}} of {{Gerhard Gentzen}}},
  author = {{Menzler-Trott}, Eckart},
  year = {2017},
  publisher = {{AMS and the London Mathematical Society}}
}

@article{meshvelianiDependentTypesIntuitionism2017,
  title = {On Dependent Types and Intuitionism in Programming Mathematics},
  author = {Meshveliani, S. D.},
  year = {2017},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@article{metivierAnalysisRandomizedRendezvous2003,
  title = {Analysis of a {{Randomized Rendezvous Algorithm}}},
  author = {M{\'e}tivier, Y. and Saheb, N. and Zemmari, A.},
  year = {2003},
  journal = {Information and Computation},
  volume = {184},
  number = {1},
  pages = {109--128},
  doi = {10.1016/s0890-5401(03)00054-3}
}

@book{meyerToolsPracticalSoftware2012,
  title = {Tools for {{Practical Software Verification}}: {{LASER}}, {{International Summer School}} 2011, {{Elba Island}}, {{Italy}}, {{Revised Tutorial Lectures}}},
  shorttitle = {Tools for {{Practical Software Verification}}},
  editor = {Meyer, Bertrand and Nordio, Martin},
  year = {2012},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {7682},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-35746-6},
  urldate = {2020-07-07},
  isbn = {978-3-642-35745-9 978-3-642-35746-6},
  langid = {english}
}

@book{michalewiczHowSolveIt2004,
  title = {How to {{Solve It}}: {{Modern Heuristics}}},
  author = {Michalewicz, Zbigniew and Fogel, David B.},
  year = {2004},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-07807-5}
}

@book{miculanTypesProofsPrograms2008,
  title = {Types for {{Proofs}} and {{Programs}}, {{International Conference}}, {{TYPES}} 2007, {{Cividale}} Del {{Friuli}}, {{Italy}}, {{May}} 2-5, 2007, {{Revised Selected Papers}}},
  editor = {Miculan, Marino and Scagnetto, Ivan and Honsell, Furio},
  year = {2008},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {4941},
  publisher = {Springer},
  isbn = {978-3-540-68084-0}
}

@phdthesis{middeldorpModularPropertiesTerm1990,
  title = {Modular {{Properties}} of {{Term Rewriting Systems}}},
  author = {Middeldorp, Aart},
  year = {1990},
  school = {Vrije Universiteit, Amsterdam}
}

@article{miller1991unification,
  title = {Unification of Simply Typed Lambda-Terms as Logic Programming},
  author = {Miller, Dale},
  year = {1991}
}

@incollection{millerLogicProgrammingLanguage1991,
  title = {A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification},
  booktitle = {Extensions of {{Logic Programming}}},
  author = {Miller, Dale},
  editor = {{Schroeder-Heister}, Peter},
  year = {1991},
  volume = {475},
  pages = {253--281},
  publisher = {Springer-Verlag},
  address = {Berlin/Heidelberg},
  doi = {10.1007/BFb0038698},
  urldate = {2021-02-20},
  isbn = {978-3-540-53590-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/F825IN77/Miller - 1991 - A logic programming language with lambda-abstracti.pdf}
}

@article{millerLogicProgrammingLanguage1991a,
  title = {A {{Logic Programming Language}} with {{Lambda-Abstraction}}, {{Function Variables}}, and {{Simple Unification}}},
  author = {Miller, D.},
  year = {1991},
  journal = {J. Log. Comput.},
  volume = {1},
  number = {4},
  pages = {497--536}
}

@article{millerProofTheoryProof,
  title = {Proof Theory, Proof Search, and Logic Programming},
  author = {Miller, Dale},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/MNW7S7RG/Miller - Proof theory, proof search, and logic programming.pdf}
}

@article{millerRiemannHypothesisTests1976,
  title = {Riemann's Hypothesis and Tests for Primality},
  author = {Miller, G. L.},
  year = {1976},
  journal = {J. Comput. Sys. Sci.},
  number = {13},
  pages = {300--317}
}

@article{millerundecidability,
  title = {The Undecidability of Proof Search When Equality Is a Logical Connective},
  author = {Miller, Dale and Viel, Alexandre}
}

@book{milnerDefinitionStandardML1991,
  title = {The {{Definition}} of {{Standard ML}}},
  author = {Milner, R. and Tofte, M. and Harper, R.},
  year = {1991},
  publisher = {MIT Press}
}

@article{milnerLocalBigraphsConfluence2007,
  title = {Local {{Bigraphs}} and {{Confluence}}: {{Two Conjectures}}: ({{Extended Abstract}})},
  author = {Milner, R.},
  year = {2007},
  journal = {ENTCS},
  volume = {175},
  number = {3},
  pages = {65--73}
}

@book{minesCourseConstructiveAlgebra1988,
  title = {A {{Course}} in {{Constructive Algebra}}},
  author = {Mines, R. and Richman, F. and Ruitenburg, W.},
  year = {1988},
  series = {Universitext},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4419-8640-5}
}

@book{mintsShortIntroductionIntuitionistic2002,
  title = {A {{Short Introduction}} to {{Intuitionistic Logic}}},
  author = {Mints, G.},
  year = {2002},
  series = {The {{University Series}} in {{Mathematics}}},
  publisher = {Kluwer Academic Publishers},
  doi = {10.1007/b115304},
  file = {/home/flaviomoura/Zotero/storage/RP7AN67S/Mints - 2002 - A Short Introduction to Intuitionistic Logic.pdf}
}

@inproceedings{miquelForcingProgramTransformation2011,
  title = {Forcing as a {{Program Transformation}}},
  booktitle = {Proceedings of the 26th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{LICS}} 2011, {{June}} 21-24, 2011, {{Toronto}}, {{Ontario}}, {{Canada}}},
  author = {Miquel, A.},
  year = {2011},
  pages = {197--206},
  doi = {10.1109/LICS.2011.47}
}

@article{miquelImplicativeAlgebrasNew2020,
  title = {Implicative Algebras: A New Foundation for Realizability and Forcing},
  shorttitle = {Implicative Algebras},
  author = {Miquel, Alexandre},
  year = {2020},
  month = feb,
  journal = {arXiv:1802.00528 [math]},
  eprint = {1802.00528},
  primaryclass = {math},
  doi = {10.1017/S0960129520000079},
  urldate = {2021-04-27},
  abstract = {We introduce the notion of implicative algebra, a simple algebraic structure intended to factorize the model constructions underlying forcing and realizability (both in intuitionistic and classical logic). The salient feature of this structure is that its elements can be seen both as truth values and as (generalized) realizers, thus blurring the frontier between proofs and types. We show that each implicative algebra induces a (Set-based) tripos, using a construction that is reminiscent from the construction of a realizability tripos from a partial combinatory algebra. Relating this construction with the corresponding constructions in forcing and realizability, we conclude that the class of implicative triposes encompass all forcing triposes (both intuitionistic and classical), all classical realizability triposes (in the sense of Krivine) and all intuitionistic realizability triposes built from partial combinatory algebras.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/825KZTM7/Miquel - 2020 - Implicative algebras a new foundation for realiza.pdf;/home/flaviomoura/Zotero/storage/SHLE5MTN/1802.html}
}

@inproceedings{miquelLamdaZZermeloSet2004,
  title = {Lamda-{{Z}}: {{Zermelo}}'s {{Set Theory}} as a {{PTS}} with 4 {{Sorts}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}, {{International Workshop}}, {{TYPES}} 2004, {{Jouy-en-Josas}}, {{France}}, {{December}} 15-18, 2004, {{Revised Selected Papers}}},
  author = {Miquel, A.},
  year = {2004},
  pages = {232--251},
  doi = {10.1007/11617990_15}
}

@inproceedings{miquelModelImpredicativeType2000,
  title = {A {{Model}} for {{Impredicative Type Systems}}, {{Universes}}, {{Intersection Types}} and {{Subtyping}}},
  booktitle = {15th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{Santa Barbara}}, {{California}}, {{USA}}, {{June}} 26-29, 2000},
  author = {Miquel, Alexandre},
  year = {2000},
  pages = {18--29},
  doi = {10.1109/LICS.2000.855752}
}

@inproceedings{miquelSurveyClassicalRealizability2011,
  title = {A {{Survey}} of {{Classical Realizability}}},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}} - 10th {{International Conference}}, {{TLCA}} 2011, {{Novi Sad}}, {{Serbia}}, {{June}} 1-3, 2011. {{Proceedings}}},
  author = {Miquel, A.},
  year = {2011},
  pages = {1--2},
  doi = {10.1007/978-3-642-21691-6_1}
}

@techreport{miquelSurveyClassicalRealizability2011a,
  title = {A {{Survey}} of {{Classical Realizability}}},
  author = {Miquel, A.},
  year = {2011},
  institution = {{\'E}cole Normale Sup{\'e}rieure de Lyon}
}

@article{miquelTheoremesIncompletudeGodel,
  title = {{Les th{\'e}or{\`e}mes d'incompl{\'e}tude de G{\"o}del}},
  author = {Miquel, Alexandre},
  pages = {41},
  langid = {french},
  file = {/home/flaviomoura/Zotero/storage/FJW5GYII/Miquel - Les thÃ©orÃ¨mes dâincomplÃ©tude de GÃ¶del.pdf}
}

@article{miranda-pereaHowProveIt2015,
  title = {How to Prove It in {{Natural Deduction}}: {{A Tactical Approach}}},
  shorttitle = {How to Prove It in {{Natural Deduction}}},
  author = {{Miranda-Perea}, Favio E. and {Linares-Ar{\'e}valo}, P. Selene and Aliseda, Atocha},
  year = {2015},
  month = jul,
  journal = {arXiv:1507.03678 [cs]},
  eprint = {1507.03678},
  primaryclass = {cs},
  urldate = {2021-12-08},
  abstract = {The motivation for this paper comes out of our experience with teaching natural deduction (ND) and with the way this formal system is implemented by the Coq proof assistant, namely by means of so-called tactics, which are heuristics that transform a goal formula into a sequence of subgoals whose provability implies that of the original formula. We aim at capturing some of these tactics into a system of ND for minimal logic. Our goal is twofold: formal and didactic. The former delivers a formal system with its underlying heuristics to build proofs, which in turn serves our latter purpose, that of making an ideal system for the teaching of ND at an undergraduate level in a computer science program.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Computers and Society,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/BY4CYM5K/Miranda-Perea et al. - 2015 - How to prove it in Natural Deduction A Tactical A.pdf}
}

@article{mizeMachinesProgramsNeq2021,
  title = {Machines as {{Programs}}: {{P}} \${\textbackslash}neq\$ {{NP}}},
  shorttitle = {Machines as {{Programs}}},
  author = {Mize, Jonathan J.},
  year = {2021},
  month = sep,
  journal = {arXiv:2109.10670 [cs, math]},
  eprint = {2109.10670},
  primaryclass = {cs, math},
  urldate = {2021-09-23},
  abstract = {The Curry-Howard correspondence is often called the proofs-as-programs result. I offer a generalization of this result, something which may be called machines as programs. Utilizing this insight, I introduce two new Turing Machines called "Ceiling Machines." The formal ingredients of these two machines are nearly identical. But there are crucial differences, splitting the two into a "Higher Ceiling Machine" and a "Lower Ceiling Machine." A potential graph of state transitions of the Higher Ceiling Machine is then offered. This graph is termed the "canonically nondeterministic solution" or CNDS, whose accompanying problem is its own replication, i.e., the problem, "Replicate CNDS" (whose accompanying algorithm is cast in Martin-L{\textbackslash}"of type theory). I then show that while this graph can be replicated (solved) in polynomial time by a nondeterministic machine -- of which the Higher Ceiling Machine is a canonical example -- it cannot be solved in polynomial time by a deterministic machine, of which the Lower Ceiling Machine is also canonical. It is consequently proven that P \${\textbackslash}neq\$ NP.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computational Complexity,Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/EGAFXTFU/Mize - 2021 - Machines as Programs P $neq$ NP.pdf;/home/flaviomoura/Zotero/storage/BXPFIP8D/2109.html}
}

@incollection{mizunoFormalVerificationsCallbyNeed2019,
  title = {Formal {{Verifications}} of {{Call-by-Need}} and {{Call-by-Name Evaluations}} with {{Mutual Recursion}}},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Mizuno, Masayuki and Sumii, Eijiro},
  year = {2019},
  series = {Programming {{Languages}} and {{Systems}}},
  pages = {181--201},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-34175-6_10}
}

@mastersthesis{mncubeProgrammingLanguageTheory2020,
  title = {Programming {{Language Theory Applications}} for {{Verified Cryptography}} in {{EasyCrypt}}},
  author = {Mncube, Nashe},
  year = {2020},
  school = {University of Bristol}
}

@article{moineWillItFit,
  title = {Will It {{Fit}}? {{Verifying Heap Space Bounds}} of {{Concurrent Programs}} under {{Garbage Collection}} with {{Separation Logic}}},
  author = {Moine, Alexandre and Chargu{\'e}raud, Arthur and Pottier, Fran{\c c}ois},
  volume = {1},
  number = {1},
  abstract = {We present IrisFit, a Separation Logic with space credits for reasoning about heap space in a concurrent call-by-value {$\lambda$}-calculus equipped with tracing garbage collection and shared mutable state. Space credits, a purely logical device, are consumed when a heap block is allocated and recovered when a block becomes provably unreachable. For each allocated address, ``pointed-by-heap'' and ``pointed-by-thread'' assertions record which heap blocks point to this address and which threads hold this address as a root. We point out a fundamental difficulty in the analysis of the worst-case heap space complexity of concurrent programs in the presence of tracing garbage collection: if garbage collection phases and steps of the program's threads can be arbitrarily interleaved, then there exist undesirable scenarios where a root held by a sleeping thread prevents a possibly large amount of memory from being freed. This phenomenon leads to degraded worstcase heap space complexity bounds and to more complex logical specifications: for example, in a naive implementation of Treiber's lock-free stack, one cannot prove that ``pop frees up one list cell worth of heap space''. To remedy this problem, we propose two language features, namely protected sections, where garbage collection is disabled, and polling points, instructions that block the current thread if garbage collection has been requested. Protected sections can be exploited by the programmer to eliminate undesirable scenarios and thereby obtain better worst-case heap space complexity. Polling points can be inserted by the compiler to guarantee liveness. The heart of our contribution is IrisFit, a novel program logic that can establish worst-case heap space complexity bounds and whose reasoning rules can take advantage of the presence of protected sections. We construct IrisFit inside the Coq proof assistant on top of the Iris Separation Logic framework. We prove that IrisFit offers both a safety guarantee---programs cannot crash and cannot exceed a heap space limit---and a liveness guarantee---every memory allocation request is satisfied after a bounded number of execution steps by other threads. We illustrate the use of IrisFit via a number of case studies, including a version of Treiber's stack that is correctly decorated with protected sections. CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Separation logic; Program verification.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Z5BISY4N/Moine et al. - Will it Fit Verifying Heap Space Bounds of Concur.pdf}
}

@book{molenJohassonHeytingLetters2016,
  title = {The {{Johasson}}/{{Heyting}} Letters and the Birth of Minimal Logic},
  author = {van der Molen, T.},
  year = {2016}
}

@book{mollerModellingComputingSystems2013,
  title = {Modelling {{Computing Systems}}},
  author = {Moller, Faron and Struth, Georg},
  year = {2013},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer London},
  address = {London},
  doi = {10.1007/978-1-84800-322-4},
  urldate = {2020-07-07},
  isbn = {978-1-84800-321-7 978-1-84800-322-4}
}

@book{moninUnderstandingFormalMethods2002,
  title = {Understanding {{Formal Methods}}},
  author = {Monin, J.-F.},
  year = {2002},
  publisher = {Springer Verlag}
}

@book{monkMathematicalLogic1976,
  title = {Mathematical {{Logic}}},
  author = {Monk, J. Donald},
  year = {1976},
  publisher = {Springer New York},
  address = {New York, NY},
  doi = {10.1007/978-1-4684-9452-5},
  urldate = {2023-08-30},
  isbn = {978-1-4684-9454-9 978-1-4684-9452-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ERAAHXMV/Monk - 1976 - Mathematical Logic.pdf}
}

@article{moorHigherOrderMatchingProgram2001,
  title = {Higher-{{Order Matching}} for {{Program Transformation}}},
  author = {de Moor, O. and Sittampalam, G.},
  year = {2001},
  journal = {Theoretical Computer Science},
  volume = {269},
  number = {1-2},
  pages = {135--162},
  doi = {10.1016/s0304-3975(00)00402-3}
}

@article{mootClassicalLogicIntuitionistic2016,
  title = {Classical Logic and Intuitionistic Logic: Equivalent Formulations in Natural Deduction, {{G}}\${\textbackslash}backslash\$``odel-{{Kolmogorov-Glivenko}} Translation},
  author = {Moot, R. and Retor{\'e}, C.},
  year = {2016},
  month = feb,
  journal = {ArXiv e-prints},
  keywords = {03B20,03F03,Mathematics - Logic}
}

@article{moraschiniOrdersLatticesBoolean,
  title = {Orders, Lattices and {{Boolean}} Algebras},
  author = {Moraschini, Tommaso},
  pages = {137},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DXATQZYY/Moraschini - Orders, lattices and Boolean algebras.pdf}
}

@unpublished{moreiraLogicaComputacional2016,
  title = {L{\'o}gica {{Computacional}}},
  author = {Moreira, Nelma},
  year = {2016}
}

@book{morgadoAnaliseCombinatoriaProbabilidade1991,
  title = {An{\'a}lise {{Combinat{\'o}ria}} e {{Probabilidade}}},
  author = {Morgado, A. C. O. and de Carvalho, J. B. P. and Carvalho, P. C. P. and Fernandez, P.},
  year = {1991},
  publisher = {SBM}
}

@book{morinOpenDataStructures2013,
  title = {Open Data Structures: An Introduction},
  shorttitle = {Open Data Structures},
  author = {Morin, Pat},
  year = {2013},
  series = {{{OPEL}} ({{Open}} Paths to Enriched Learning)},
  publisher = {AU Press, Athabasca University},
  address = {Edmonton, AB},
  issn = {22912606},
  abstract = {Introduction -- Array-based lists -- Linked lists -- Skiplists -- Hash tables -- Binary trees -- Random binary search trees -- Scapegoat trees -- Red-black trees -- Heaps -- Sorting algorithms -- Graphs -- Data structures for integers -- External memory searching},
  isbn = {978-1-927356-38-8},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/YLZEQXRF/Morin - 2013 - Open data structures an introduction.pdf}
}

@inproceedings{morraFELIXUsingRewritingLogic2005,
  title = {{{FELIX}}: {{Using Rewriting-Logic}} for {{Generating Functionally Equivalent Implementations}}},
  booktitle = {Proc. 15th {{International Conference}} on {{Field-Programmable Logic}} and {{Applications}} ({{FPL}} 2005)},
  author = {Morra, C. and Becker, J. and {Ayala-Rinc{\'o}n}, M. and Hartenstein, R.},
  year = {2005}
}

@book{mortariIntroducaoLogica2001,
  title = {Introdu{\c c}{\~a}o {\`a} L{\'o}gica},
  author = {Mortari, C.A.},
  year = {2001},
  publisher = {Ed. UNESP},
  isbn = {978-85-7139-337-0}
}

@article{moschovakisElementaryRecursiveAlgorithms2021,
  title = {Elementary Recursive Algorithms},
  author = {Moschovakis, Yiannis N.},
  year = {2021},
  month = aug,
  journal = {arXiv:2108.03574 [math]},
  eprint = {2108.03574},
  primaryclass = {math},
  urldate = {2021-08-10},
  abstract = {They run our lives, if you believe the hype in the news, but there is no precise definition of "algorithms" which is generally accepted by the mathematicians, logicians and computer scientists who create and study them. My main aims here are (first) to discuss briefly and point to the few publications that try to deal with this foundational question and (primarily) to outline in Sections 4 and 5 simple proofs of two basic mathematical results about the "elementary recursive algorithms" from specified primitives expressed by recursive (McCarthy) programs.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/MYEAK3ZZ/Moschovakis - 2021 - Elementary recursive algorithms.pdf;/home/flaviomoura/Zotero/storage/9NLDQJ4C/2108.html}
}

@article{moschovakisIntuitionisticMathematicsLogic2020,
  title = {Intuitionistic {{Mathematics}} and {{Logic}}},
  author = {Moschovakis, Joan R. and Vafeiadou, Garyfallia},
  year = {2020},
  journal = {CoRR},
  abstract = {The first seeds of mathematical intuitionism germinated in Europe over a century ago in the constructive tendencies of Borel, Baire, Lebesque, Poincar{\'e}, Kronecker and others. The flowering was the work of one man, Luitzen Egbertus Jan Brouwer, who taught mathematics at the University of Amsterdam from 1909 until 1951. By proving powerful theorems on topological invariants and fixed points of continuous mappings, Brouwer quickly build a mathematical reputation strong enough to support his revolutionary ideas about the nature of mathematical activity. These ideas influenced Hilbert and G{\"o}del and established intuitionistic logic and mathematics as subjects worthy of independent study. Our aim is to describe the development of Brouwer's intuitionism, from his rejection of the classical law of excluded middle to his controversial theory of the continuum, with fundamental consequences for logic and mathematics. We borrow Kleene's formal axiomatic systems (incorporating earlier attempts by Kolmogorov, Glivenko, Heyting and Peano) for intuitionistic logic and arithmetic as subtheories of the corresponding classical theories, and sketch his use of g{\"o}del numbers of recursive functions to realize sentences of intuitionistic arithmetic including a form of Church's Thesis. Finally, we present Kleene and Vesley's axiomatic treatment of Brouwer's continuum, with the function-realizability interpretation which establishes its consistency.}
}

@misc{mouraCompanionDatasetArticle,
  title = {Companion Dataset of the Article "{{A}} Formalized Extension of the Substitution Lemma in {{Coq}}"},
  author = {de Moura, F. L. C. and Lima, M. J. D.},
  howpublished = {https://flaviomoura.info/files/msubst.v}
}

@mastersthesis{mouraComparandoCalculosSubstituicoes2002,
  title = {Comparando {{C{\'a}lculos}} de {{Substitui{\c c}{\~o}es Expl{\'i}citas}} Com {$\eta$}-Convers{\~a}o},
  author = {de Moura, F. L. C.},
  year = {2002},
  school = {Universidade de Bras{\'i}lia}
}

@unpublished{mouraConstructiveFormalisationModular2018,
  title = {A Constructive Formalisation of the {{Modular Strong Normalisation Theorem}}},
  author = {de Moura, F. L. C. and {D.L.Ventura} and {R.S.Ramos} and {F.S.Paranhos}},
  year = {2018}
}

@inproceedings{mouraFlexibleFrameworkVisualisation2011,
  title = {A {{Flexible Framework}} for {{Visualisation}} of {{Computational Properties}} of {{General Explicit Substitutions Calculi}}},
  booktitle = {Proc. 5th {{Workshop}} on {{Logical}} and {{Semantic Frameworks}}, with {{Applications}} ({{LSFA}} 2010)},
  author = {de Moura, F. L. C. and {A.V.Barbosa} and {Ayala-Rinc{\'o}n}, M. and Kamareddine, F.},
  year = {2011},
  series = {{{ENTCS}}},
  volume = {269},
  pages = {41--54}
}

@article{mouraFlexibleFrameworkVisualisation2011a,
  title = {A {{Flexible Framework}} for {{Visualisation}} of {{Computational Properties}} of {{General Explicit Substitutions Calculi}}},
  author = {de Moura, F. L. C. and Barbosa, A. V. and {Ayala-Rinc{\'o}n}, M. and Kamareddine, F.},
  year = {2011},
  journal = {Electr. Notes Theor. Comput. Sci.},
  volume = {269},
  pages = {41--54}
}

@inproceedings{mouraFrameworkSimulatingComparing2005,
  title = {A {{Framework}} for {{Simulating}} and {{Comparing Explicit Substitutions Calculi}}},
  booktitle = {5th {{International Workshop}} on the {{Implementation}} of {{Logics}} - {{IWIL}} 2004},
  author = {de Moura, F. L. C. and {Ayala-Rinc{\'o}n}, M. and Kamareddine, F.},
  editor = {Konev, Boris and Schulz, Stephan},
  year = {2005},
  pages = {16--30}
}

@inproceedings{mouraHigherOrderUnificationExplicit2014,
  title = {Higher-{{Order Unification}} via {{Explicit Substitutions}} at a {{Distance}}},
  booktitle = {{{LSFA}} 2014},
  author = {de Moura, F. L. C.},
  year = {2014}
}

@article{mouraHigherOrderUnificationStructural2008,
  title = {Higher-{{Order Unification}}: {{A}} Structural Relation between {{Huet}}'s Method and the One Based on Explicit Substitutions},
  author = {de Moura, F. L. C. and {M. Ayala-Rinc{\'o}n} and {F. Kamareddine}},
  year = {2008},
  journal = {Journal of Applied Logic},
  volume = {6},
  number = {1},
  pages = {72--108}
}

@inproceedings{mouraLeanTheoremProver2021,
  title = {The {{Lean}} 4 {{Theorem Prover}} and {{Programming Language}}},
  booktitle = {Automated {{Deduction}} -- {{CADE}} 28},
  author = {de Moura, Leonardo and Ullrich, Sebastian},
  editor = {Platzer, Andr{\'e} and Sutcliffe, Geoff},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {625--635},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-79876-5_37},
  abstract = {Lean 4 is a reimplementation of the Lean interactive theorem prover (ITP) in Lean itself. It addresses many shortcomings of the previous versions and contains many new features. Lean 4 is fully extensible: users can modify and extend the parser, elaborator, tactics, decision procedures, pretty printer, and code generator. The new system has a hygienic macro system custom-built for ITPs. It contains a new typeclass resolution procedure based on tabled resolution, addressing significant performance problems reported by the growing user base. Lean 4 is also an efficient functional programming language based on a novel programming paradigm called functional but in-place. Efficient code generation is crucial for Lean users because many write custom proof automation procedures in Lean itself.},
  isbn = {978-3-030-79876-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/4Q55SJAN/Moura e Ullrich - 2021 - The Lean 4 Theorem Prover and Programming Language.pdf}
}

@inproceedings{mouraMetaconfluenceCalculiExplicit2014,
  title = {Metaconfluence of {{Calculi}} with {{Explicit Substitutions}} at a {{Distance}}},
  booktitle = {34th {{International Conference}} on {{Foundation}} of {{Software Technology}} and {{Theoretical Computer Science}} ({{FSTTCS}} 2014)},
  author = {de Moura, F. L. C. and Kesner, D. and {Ayala-Rinc{\'o}n}, M.},
  editor = {Raman, Venkatesh and Suresh, S. P.},
  year = {2014},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  volume = {29},
  pages = {391--402},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address = {Dagstuhl, Germany},
  issn = {1868-8969},
  doi = {http://dx.doi.org/10.4230/LIPIcs.FSTTCS.2014.391},
  isbn = {978-3-939897-77-4}
}

@inproceedings{mouraSecondOrderMatching2005,
  ids = {mouraSecondOrderMatching2005a},
  title = {Second {{Order Matching}} via {{Explicit Substitutions}}},
  booktitle = {11th {{International Conference}} on {{Logic}} for {{Programming Artificial Intelligence}} and {{Reasoning}} ({{LPAR}}'04)},
  author = {de Moura, F. L. C. and Kamareddine, F. and {Ayala-Rinc{\'o}n}, M.},
  editor = {Baader, F. and Voronkov, A.},
  year = {2005},
  series = {{{LNAI}}},
  volume = {3452},
  pages = {433--448},
  publisher = {Springer-Verlag}
}

@article{mouraSUBSEXPLFrameworkSimulating2006,
  ids = {mouraSUBSEXPLFrameworkSimulating2006a},
  title = {{{SUBSEXPL}}: {{A Framework}} for {{Simulating}} and {{Comparing Explicit Substitutions Calculi}}},
  author = {de Moura, F. L. C. and {M. Ayala-Rinc{\'o}n} and Kamareddine, F.},
  year = {2006},
  journal = {Journal of Applied and Non-classical Logics},
  volume = {16},
  number = {1-2},
  pages = {119--150}
}

@unpublished{mouraThirdOrderMatchingExplicit2005,
  title = {Third-{{Order Matching}} via {{Explicit Substitutions}}},
  author = {de Moura, F. L. C. and {F. Kamareddine} and {M. Ayala-Rinc{\'o}n}},
  year = {2005}
}

@phdthesis{mouraUmEstudoComparativo2006,
  title = {Um {{Estudo Comparativo}} Sobre {{Unifica{\c c}{\~a}o}} de {{Ordem Superior}} Em {{C{\'a}lculos}} de {{Substitui{\c c}{\~o}es Expl{\'i}citas}}},
  author = {de Moura, F. L. C.},
  year = {2006},
  school = {Universidade de Bras{\'i}lia}
}

@inproceedings{mouraUnderstandingHigherOrder2004,
  title = {Understanding {{Higher Order Unification}} via {{Explicit Substitutions}} and {{Patterns}}},
  booktitle = {Contributions to the {{Doctoral Programme}} of the 2nd {{International Joint Conference}} on {{Automated Reasoning}}, {{Cork}}, {{Ireland}}, {{July}} 4-8, 2004.},
  author = {de Moura, F. L. C.},
  year = {2004}
}

@inproceedings{mouraUnificationLcalculiPropagation2016,
  title = {Unification for {$\lambda$}-Calculi without Propagation Rules},
  author = {de Moura, F. L. C.},
  year = {2016},
  pages = {179--195},
  doi = {10.1007/978-3-319-46750-4 11}
}

@phdthesis{mullerMathematicalKnowledgeManagement2019,
  title = {Mathematical {{Knowledge Management Across Formal Libraries}}},
  author = {M{\"u}ller, Dennis},
  year = {2019},
  school = {Friedrich-Alexander-Universit{\"a}t}
}

@book{mullerProgrammingLanguagesSystems2020,
  title = {Programming {{Languages}} and {{Systems}} - 29th {{European Symposium}} on {{Programming}}, {{ESOP}} 2020, {{Held}} as {{Part}} of the {{European Joint Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2020, {{Dublin}}, {{Ireland}}, {{April}} 25-30, 2020, {{Proceedings}}},
  editor = {M{\"u}ller, Peter},
  year = {2020},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {12075},
  publisher = {Springer},
  doi = {10.1007/978-3-030-44914-8}
}

@article{munoz-arboledaDistributedApproachGroup2008,
  title = {Distributed Approach to Group Control of Elevator Systems Using Fuzzy Logic and {{FPGA}} Implementation of Dispatching Algorithms},
  author = {{Mu{\~n}oz-Arboleda}, D. M. and Llanos, C. H. and {Ayala-Rinc{\'o}n}, M. and van Els, R. H.},
  year = {2008},
  journal = {Engineering Applications of Artificial Intelligence},
  volume = {21},
  number = {8},
  pages = {1309--1320}
}

@inproceedings{munozConfluencePreservationStrong1996,
  title = {Confluence and {{Preservation}} of {{Strong Normalisation}} in an {{Explicit Substitutions Calculus}}},
  booktitle = {Proceedings, 11th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{New Brunswick}}, {{New Jersey}}, {{USA}}, {{July}} 27-30, 1996},
  author = {Mu{\~n}oz, C. A.},
  year = {1996},
  pages = {440--447},
  doi = {10.1109/LICS.1996.561460}
}

@article{munozFormalVerificationTermination2021,
  title = {Formal {{Verification}} of {{Termination Criteria}} for {{First-Order Recursive Functions}}},
  author = {Mu{\~n}oz, Cesar A and {Ayala-Rinc{\'o}n}, Mauricio and Moscato, Mariano M and Dutle, Aaron M and Narkawicz, Anthony J and Almeida, Ariane Alves},
  year = {2021},
  pages = {17},
  abstract = {This paper presents a formalization of several termination criteria for first-order recursive functions. The formalization, which is developed in the Prototype Verification System (PVS), includes the specification and proof of equivalence of semantic termination, Turing termination, size change principle, calling context graphs, and matrix-weighted graphs. These termination criteria are defined on a computational model that consists of a basic functional language called PVS0, which is an embedding of recursive first-order functions. Through this embedding, the native mechanism for checking termination of recursive functions in PVS could be soundly extended with semi-automatic termination criteria such as calling contexts graphs.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/FPGWNR88/MuÃ±oz et al. - 2021 - Formal Verification of Termination Criteria for Fi.pdf}
}

@misc{murfetEliminationCuteliminationMultiplicative2022,
  title = {Elimination and Cut-Elimination in Multiplicative Linear Logic},
  author = {Murfet, Daniel and Troiani, William},
  year = {2022},
  month = jul,
  number = {arXiv:2207.10871},
  eprint = {2207.10871},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2022-08-01},
  abstract = {We associate to every proof structure in multiplicative linear logic an ideal which represents the logical content of the proof as polynomial equations. We show how cut-elimination in multiplicative proof nets corresponds to instances of the Buchberger algorithm for computing Gr{\textbackslash}"obner bases in elimination theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/ZZJI9J9N/Murfet and Troiani - 2022 - Elimination and cut-elimination in multiplicative .pdf;/home/flaviomoura/Zotero/storage/DVSNDUD5/2207.html}
}

@book{murrayAutomatedReasoningAnalytic1999,
  title = {Automated {{Reasoning}} with {{Analytic Tableaux}} and {{Related Methods}}, {{International Conference}}, {{TABLEAUX}} '99, {{Saratoga Springs}}, {{NY}}, {{USA}}, {{June}} 7-11, 1999, {{Proceedings}}},
  editor = {Murray, Neil V.},
  year = {1999},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {1617},
  publisher = {Springer},
  doi = {10.1007/3-540-48754-9},
  isbn = {3-540-66086-0}
}

@article{murrayIncrementalVulnerabilityDetection2021,
  title = {Incremental {{Vulnerability Detection}} with {{Insecurity Separation Logic}}},
  author = {Murray, Toby and Yan, Pengbo and Ernst, Gidon},
  year = {2021},
  month = sep,
  journal = {arXiv:2107.05225 [cs]},
  eprint = {2107.05225},
  primaryclass = {cs},
  urldate = {2021-09-20},
  abstract = {We present the first compositional, incremental static analysis for detecting memory-safety and information leakage vulnerabilities in C-like programs. To do so, we develop the first under-approximate relational program logics for reasoning about information flow, including Insecurity Separation Logic (InsecSL). Like prior under-approximate separation logics, we show that InsecSL can be automated via symbolic execution. We then adapt and extend a prior intra-procedural symbolic execution algorithm to build a bottom-up, inter-procedural and incremental analysis for detecting vulnerabilities. We prove our approach sound in Isabelle/HOL and implement it in a proof-of-concept tool, Underflow, for analysing C programs, which we apply to various case studies.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Cryptography and Security,Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/9Z99KPL8/Murray et al. - 2021 - Incremental Vulnerability Detection with Insecurit.pdf;/home/flaviomoura/Zotero/storage/JLGXU6ET/2107.html}
}

@book{murrayWriterTeachesWriting2003,
  title = {A {{Writer Teaches Writing Revised}}},
  author = {Murray, Donald M.},
  year = {2003},
  month = mar,
  edition = {2nd edition},
  publisher = {Cengage Learning},
  address = {Boston},
  isbn = {978-0-7593-9829-0},
  langid = {english}
}

@article{mutzeHamiltonCyclesGraphs2024,
  title = {On {{Hamilton Cycles}} in {{Graphs Defined}} by {{Intersecting Set Systems}}},
  author = {M{\"u}tze, Torsten},
  year = {2024},
  month = may,
  journal = {Notices of the American Mathematical Society},
  volume = {71},
  number = {05},
  pages = {1},
  issn = {0002-9920, 1088-9477},
  doi = {10.1090/noti2907},
  urldate = {2024-05-27},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/UWNM88UA/MÃ¼tze - 2024 - On Hamilton Cycles in Graphs Defined by Intersecti.pdf}
}

@book{nachumdershowitzRewritingComputationProof2007,
  title = {Rewriting, {{Computation}} and {{Proof}}: {{Essays Dedicated}} to {{Jean-Pierre Jouannaud}} on the {{Occasion}} of {{His}} 60th {{Birthday}}},
  author = {Nachum Dershowitz, Georg Moser (auth.), Hubert Comon-Lundh, Claude Kirchner, H{\'e}l{\`e}ne Kirchner (eds.)},
  year = {2007},
  series = {Lecture {{Notes}} in {{Computer Science}} 4600 : {{Theoretical Computer Science}} and {{General Issues}}},
  edition = {1},
  publisher = {Springer-Verlag Berlin Heidelberg},
  isbn = {3-540-73146-6 978-3-540-73147-4 978-3-540-73146-7}
}

@article{nadathurLogicReasoningLF2021,
  title = {A {{Logic}} for {{Reasoning About LF Specifications}}},
  author = {Nadathur, Gopalan and Southern, Mary},
  year = {2021},
  month = jun,
  journal = {arXiv:2107.00111 [cs]},
  eprint = {2107.00111},
  primaryclass = {cs},
  urldate = {2021-07-02},
  abstract = {We present a logic named L\_\{LF\} whose intended use is to formalize properties of specifications developed in the dependently typed lambda calculus LF. The logic is parameterized by the LF signature that constitutes the specification. Atomic formulas correspond to typing derivations relative to this signature. The logic includes a collection of propositional connectives and quantifiers. Quantification ranges over expressions that denote LF terms and LF contexts. Quantifiers of the first variety are qualified by simple types that describe the functional structure associated with the variables they bind; deeper, dependency related properties are expressed by the body of the formula. Context-level quantifiers are qualified by context schemas that identify patterns of declarations out of which actual contexts may be constructed. The semantics of variable-free atomic formulas is articulated via the derivability in LF of the judgements they encode. Propositional constants and connectives are understood in the usual manner and the meaning of quantifiers is explicated through substitutions of expressions that adhere to the type qualifications. The logic is complemented by a proof system that enables reasoning that is sound with respect to the described semantics. The main novelties of the proof system are the provision for case-analysis style reasoning about LF judgements, support for inductive reasoning over the heights of LF derivations and the encoding of LF meta-theorems. The logic is motivated by the paradigmatic example of type assignment in the simply-typed lambda calculus and the proof system is illustrated through the formalization of a proof of type uniqueness for this calculus.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/I9VKS5QW/Nadathur e Southern - 2021 - A Logic for Reasoning About LF Specifications.pdf;/home/flaviomoura/Zotero/storage/6KL8298Y/2107.html}
}

@article{nadathurNotationLambdaTerms1998,
  title = {A {{Notation}} for {{Lambda Terms}}: {{A Generalization}} of {{Environments}}},
  author = {Nadathur, G. and Wilson, D. S.},
  year = {1998},
  journal = {TCS},
  volume = {198},
  pages = {49--98}
}

@inproceedings{nadathurOverviewLProlog1988,
  title = {An {{Overview}} of {{$\lambda$Prolog}}},
  booktitle = {Proc. 5th {{Int}}. {{Logic Programming Conference}}},
  author = {Nadathur, G. and Miller, D.},
  editor = {Bowen, K.A. and Kowalski, R.A.},
  year = {1988},
  series = {Cambridge, {{MA}}},
  pages = {810--827},
  publisher = {MIT Press}
}

@misc{nadathurProofPearlPurported2021,
  title = {About a {{Proof Pearl}}: {{A Purported Solution}} to a {{POPLMARK Challenge Problem}} That Is {{Not One}}},
  shorttitle = {About a {{Proof Pearl}}},
  author = {Nadathur, Gopalan},
  year = {2021},
  month = dec,
  number = {arXiv:2112.09274},
  eprint = {2112.09274},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-09-22},
  abstract = {The POPLMARK Challenge comprises a set of problems intended to measure the strength of reasoning systems in the realm of mechanizing programming language meta-theory at the time the challenge was enunciated. Included in the collection is the exercise of demonstrating transitivity of subtyping for a specific algorithmic formulation of subtyping for an extension of System F. The challenge represented by this problem derives from the fact that, for the given formulation, subtyping must be proved simultaneously with another property called narrowing. In a paper published as a proof pearl, Brigitte Pientka claimed to have presented a solution to the problem in which "the full power of parametric and higher-order judgments" is exploited to "get the narrowing lemma for free." We show this claim to be inaccurate. In particular, we show that the simplification is in substantial part the result of changing the formulation of the subtyping relation in a way that modifies the challenge rather than the outcome of the manner in which the argument is mechanized.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/62MDIMER/Nadathur - 2021 - About a Proof Pearl A Purported Solution to a POP.pdf;/home/flaviomoura/Zotero/storage/HFXPZSWC/2112.html}
}

@inproceedings{nadathurSuspensionNotationLambda2002,
  title = {The {{Suspension Notation}} for {{Lambda Terms}} and Its {{Use}} in {{Metalanguage Implementations}}},
  booktitle = {Proceedings {{Ninth Workshop}} on {{Logic}}, {{Language}}, {{Information}} and {{Computation}} ({{WoLLIC}} 2002)},
  author = {Nadathur, G.},
  editor = {{de Queiroz}, R.J.G.B.},
  year = {2002},
  series = {{{ENTCS}}},
  volume = {67},
  publisher = {Elsevier Science Publishers}
}

@article{nagashimaSmartInductionIsabelle2020,
  title = {Smart {{Induction}} for {{Isabelle}}/Hol ({{System Description}})},
  author = {Nagashima, Yutaka},
  year = {2020},
  journal = {CoRR},
  abstract = {Proof assistants offer tactics to facilitate inductive proofs. However, it still requires human ingenuity to decide what arguments to pass to those induction tactics. To automate this process, we present smart\_induct for Isabelle/HOL. Given an inductive problem in any problem domain, smart\_induct lists promising arguments for the induct tactic without relying on a search. Our evaluation demonstrated smart\_induct produces valuable recommendations across problem domains.}
}

@article{nageleShortMechanizedProof2016,
  title = {A {{Short Mechanized Proof}} of the {{Church-Rosser Theorem}} by the {{Z-property}} for the \${\textbackslash}lambda{\textbackslash}beta\$-Calculus in {{Nominal Isabelle}}},
  author = {Nagele, J. and {van Oostrom}, V. and Sternagel, C.},
  year = {2016},
  month = sep,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@inproceedings{nakazawaCallbyvalue2017,
  title = {Z for Call-by-Value},
  booktitle = {6th {{International Workshop}} on {{Cofluence}} ({{IWC}} 2017)},
  author = {Nakazawa, Koji and Fujita, Ken-etsu},
  year = {2017},
  pages = {57--61},
  file = {/home/flaviomoura/Zotero/storage/NQ9VCSIM/Nakazawa e Fujita - 2017 - Z for call-by-value.pdf}
}

@article{nakazawaCompositionalConfluenceProofs2016,
  title = {Compositional {{Z}}: {{Confluence Proofs}} for {{Permutative Conversion}}},
  author = {Nakazawa, Koji and Fujita, Ken-etsu},
  year = {2016},
  journal = {Studia Logica},
  volume = {104},
  number = {6},
  pages = {1205--1224},
  doi = {10.1007/s11225-016-9673-0},
  file = {/home/flaviomoura/Zotero/storage/6VEIQWY2/Nakazawa e Fujita - 2016 - Compositional Z Confluence Proofs for Permutative.pdf}
}

@article{nakazawaPropertyCallbyvalueLambda,
  title = {Z Property for Call-by-Value Lambda Calculus},
  author = {Nakazawa, Koji and Fujita, Ken-etsu and Imagawa, Yuta},
  journal = {Mathematical Structures in Computer Science},
  pages = {12},
  abstract = {This paper gives a new proof of the confluence for Carraro and Guerrieri's call-by-value lambda calculus {$\lambda$}v{$\sigma$} with permutation rules. We adapt the compositional Z theorem to {$\lambda$}v{$\sigma$} .},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Z9EUYBT7/Nakazawa et al. - Z property for call-by-value lambda calculus.pdf}
}

@article{nakazawaPropertyShufflingCalculus2023,
  title = {Z Property for the Shuffling Calculus},
  author = {Nakazawa, Koji and Fujita, Ken-etsu and Imagawa, Yuta},
  year = {2023},
  month = jan,
  journal = {Mathematical Structures in Computer Science},
  pages = {1--13},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129522000408},
  urldate = {2023-01-12},
  abstract = {ABSTRACT                            This paper gives a new proof of confluence for Carraro and Guerrieri's call-by-value lambda calculus               {$\lambda$}                                v                                               {$\sigma$}                              with permutation rules. We adapt the compositional Z theorem to               {$\lambda$}                                v                                               {$\sigma$}                              .},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PILAQI6G/Nakazawa et al. - 2023 - Z property for the shuffling calculus.pdf}
}

@inproceedings{nakazawaReductionSystemExtensional2014,
  title = {Reduction {{System}} for {{Extensional Lambda-mu Calculus}}},
  booktitle = {Rewriting and {{Typed Lambda Calculi}}},
  author = {Nakazawa, Koji and Nagai, Tomoharu},
  editor = {Dowek, Gilles},
  year = {2014},
  pages = {349--363},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-08918-8_24},
  abstract = {The {$\Lambda\mu$}-calculus is an extension of Parigot's {$\lambda\mu$}-calculus. For the untyped {$\Lambda\mu$}-calculus, Saurin proved some fundamental properties such as the standardization and the separation theorem. Nakazawa and Katsumata gave extensional models, called stream models, in which terms are represented as functions on streams. This paper introduces a conservative extension of the {$\Lambda\mu$}-calculus, called {$\Lambda\mu$}cons, from which the open term model is straightforwardly constructed as a stream model, and for which we can define a reduction system satisfying several fundamental properties such as confluence, subject reduction, and strong normalization.},
  isbn = {978-3-319-08918-8},
  langid = {english}
}

@article{nakazawaStrongNormalizationClassical2008,
  title = {Strong Normalization of Classical Natural Deduction with Disjunctions},
  author = {Nakazawa, Koji and Tatsuta, Makoto},
  year = {2008},
  month = apr,
  journal = {Annals of Pure and Applied Logic},
  volume = {153},
  number = {1},
  pages = {21--37},
  issn = {0168-0072},
  doi = {10.1016/j.apal.2008.01.003},
  urldate = {2024-08-16},
  abstract = {This paper proves the strong normalization of classical natural deduction with disjunction and permutative conversions, by using CPS-translation and augmentations. Using them, this paper also proves the strong normalization of classical natural deduction with general elimination rules for implication and conjunction, and their permutative conversions. This paper also proves that natural deduction can be embedded into natural deduction with general elimination rules, strictly preserving proof normalization.},
  keywords = {Classical natural deduction,CPS-translation,General elimination,Permutative conversion,Strong normalization},
  file = {/home/flaviomoura/Zotero/storage/MYU9H8X6/Nakazawa e Tatsuta - 2008 - Strong normalization of classical natural deductio.pdf;/home/flaviomoura/Zotero/storage/34FXUS79/S0168007208000067.html}
}

@article{narbouxCombiningPencilPaper,
  title = {Combining Pencil/Paper Proofs and Formal Proofs, a Challenge for {{Artificial Intelligence}} and Mathematics Education},
  author = {Narboux, Julien and {Durand-Guerrier}, Viviane},
  pages = {29},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/642TL3UR/Narboux e Durand-Guerrier - Combining pencilpaper proofs and formal proofs, a.pdf}
}

@article{naumowicz14thInternationalConference,
  title = {14th {{International Conference}} on {{Interactive Theorem Proving}} ({{ITP}} 2023)},
  author = {Naumowicz, Adam},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/J8GME4IF/Naumowicz - 14th International Conference on Interactive Theor.pdf}
}

@inproceedings{naumowiczLIPIcsVolume2682023,
  title = {{{LIPIcs}}, {{Volume}} 268, {{ITP}} 2023, {{Complete Volume}}},
  booktitle = {{{DROPS-IDN}}/v2/Document/10.4230/{{LIPIcs}}.{{ITP}}.2023},
  author = {Naumowicz, Adam and Thiemann, Ren{\'e}},
  year = {2023},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  doi = {10.4230/LIPIcs.ITP.2023},
  urldate = {2024-04-17},
  abstract = {LIPIcs, Volume 268, ITP 2023, Complete Volume},
  copyright = {https://creativecommons.org/licenses/by/4.0/legalcode},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XCJJP9NL/Naumowicz e Thiemann - 2023 - LIPIcs, Volume 268, ITP 2023, Complete Volume.pdf}
}

@phdthesis{nebelNominalLambdaCalculus2015,
  title = {Nominal Lambda Calculus},
  author = {Nebel, Frank},
  year = {2015},
  school = {University of Leicester, UK}
}

@book{nederpeltLogicalReasoningFirst2004,
  title = {Logical {{Reasoning}}: {{A First Course}}},
  author = {Nederpelt, R. P. and Kamareddine, F. D.},
  year = {2004},
  series = {Texts in Computing},
  publisher = {King's College Publications},
  isbn = {978-0-9543006-7-8}
}

@article{nederpeltPresentationNaturalDeduction1977,
  title = {Presentation of {{Natural Deduction}}},
  author = {Nederpelt, R. P.},
  year = {1977},
  journal = {Zbornik Radova},
  number = {10},
  pages = {115--126},
  publisher = {Matemati{\v c}ki institut SANU},
  langid = {english},
  keywords = {fragments of classical logic,mathematical reasonings,metamathematics of constructive systems,natural deduction}
}

@book{nederpeltTypeTheoryFormal2014,
  title = {Type {{Theory}} and {{Formal Proof}}. {{An Introduction}}},
  author = {Nederpelt, R. and Geuvers, H.},
  year = {2014},
  publisher = {Cambridge University Press}
}

@article{negriCutEliminationPresence1998,
  title = {Cut Elimination in the Presence of Axioms},
  author = {Negri, Sara and Von Plato, Jan},
  year = {1998},
  journal = {Bulletin of Symbolic Logic},
  volume = {4},
  number = {4},
  pages = {418--435},
  publisher = {Cambridge University Press}
}

@article{negriGlivenkoSequentClasses2016,
  title = {Glivenko Sequent Classes in the Light of Structural Proof Theory},
  author = {Negri, Sara},
  year = {2016},
  month = may,
  journal = {Archive for Mathematical Logic},
  volume = {55},
  number = {3},
  pages = {461--473},
  issn = {1432-0665},
  doi = {10.1007/s00153-016-0474-y},
  urldate = {2024-08-12},
  abstract = {In 1968, Orevkov presented proofs of conservativity of classical over intuitionistic and minimal predicate logic with equality for seven classes of sequents, what are known as Glivenko classes. The proofs of these results, important in the literature on the constructive content of classical theories, have remained somehow cryptic. In this paper, direct proofs for more general extensions are given for each class by exploiting the structural properties of G3 sequent calculi; for five of the seven classes the results are strengthened to height-preserving statements, and it is further shown that the constructive and minimal proofs are identical in structure to the classical proof from which they are obtained.},
  langid = {english},
  keywords = {03F05,18B15,18C10,Conservativity of classical over intuitionistic theories,Glivenko classes,Predicate logic with equality and functions,Proof analysis,Sequent calculus},
  file = {/home/flaviomoura/Zotero/storage/925WCHSU/Negri - 2016 - Glivenko sequent classes in the light of structura.pdf}
}

@article{negriSequentCalculusNatural2001,
  title = {Sequent Calculus in Natural Deduction Style},
  author = {Negri, Sara and Von Plato, Jan},
  year = {2001},
  month = dec,
  journal = {Journal of Symbolic Logic},
  volume = {66},
  number = {4},
  pages = {1803--1816},
  issn = {0022-4812, 1943-5886},
  doi = {10.2307/2694976},
  urldate = {2024-03-20},
  abstract = {Abstract.             A sequent calculus is given in which the management of weakening and contraction is organized as in natural deduction. The latter has no explicit weakening or contraction, but vacuous and multiple discharges in rules that discharge assumptions. A comparison to natural deduction is given through translation of derivations between the two systems. It is proved that if a cut formula is never principal in a derivation leading to the right premiss of cut, it is a subformula of the conclusion. Therefore it is sufficient to eliminate those cuts that correspond to detour and permutation conversions in natural deduction.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DEH3X688/Negri e Von Plato - 2001 - Sequent calculus in natural deduction style.pdf}
}

@book{negriStructuralProofTheory2001,
  title = {Structural {{Proof Theory}}},
  author = {Negri, Sara and von Plato, Jan and Ranta, Aarne},
  editor = {Plato, Jan Von},
  year = {2001},
  publisher = {New York: Cambridge University Press},
  file = {/home/flaviomoura/Zotero/storage/7NC6RMH2/Negri et al. - 2001 - Structural Proof Theory.pdf}
}

@article{netoComoUmMatematico2021,
  title = {{Como um matem{\'a}tico captura pok{\'e}mons: Relato de experi{\^e}ncia em sala de aula no {\^a}mbito do Pibid / How a mathematist captures pok{\'e}mons: Report of a classroom experience under Pibid}},
  shorttitle = {{Como um matem{\'a}tico captura pok{\'e}mons}},
  author = {Neto, Lineu da Costa Ara{\'u}jo},
  year = {2021},
  month = sep,
  journal = {Brazilian Journal of Development},
  volume = {7},
  number = {9},
  pages = {93325--93334},
  issn = {2525-8761},
  doi = {10.34117/bjdv7n9-478},
  urldate = {2025-02-05},
  abstract = {O objetivo deste trabalho {\'e} descrever o material did{\'a}tico ``Como um matem{\'a}tico captura Pok{\'e}mons'', uma sequ{\^e}ncia de atividades de ensino em Geometria Plana e Espacial elaboradas por licenciandos em Matem{\'a}tica da Universidade de Bras{\'i}lia no {\^a}mbito do Programa Institucional de Bolsa de Inicia{\c c}{\~a}o {\`a} Doc{\^e}ncia em 2016. Trata-se de um estudo de caso a partir do relato de experi{\^e}ncia da divulga{\c c}{\~a}o desse caderno em eventos locais, regionais, nacionais e internacionais da {\'a}rea de Educa{\c c}{\~a}o Matem{\'a}tica. Os dados coletados, oriundos dos relat{\'o}rios das atividades desenvolvidas e do feedback dos alunos que participaram do programa, evidenciam as potencialidades da ado{\c c}{\~a}o da metodologia de resolu{\c c}{\~a}o de problemas na pr{\'a}tica pedag{\'o}gica de futuros professores de Matem{\'a}tica da educa{\c c}{\~a}o b{\'a}sica.},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/FGQLC2IW/Neto - 2021 - Como um matemÃ¡tico captura pokÃ©mons Relato de exp.pdf}
}

@article{neuperInteractiveFormalSpecification,
  title = {Interactive {{Formal Specification}} for {{Mathematical Problems}} of {{Engineers}}},
  author = {Neuper, Walther},
  journal = {EPTCS},
  volume = {400},
  pages = {120--138},
  urldate = {2024-04-08},
  file = {/home/flaviomoura/Zotero/storage/W5YGQR3H/Neuper - Interactive Formal Specification for Mathematical .pdf}
}

@article{newmanTheoriesCombinatorialDefinition1942,
  title = {On Theories with a Combinatorial Definition of Equivalence},
  author = {Newman, M. H. A.},
  year = {1942},
  journal = {Ann. of Math.},
  volume = {43(2)},
  pages = {223--243}
}

@article{niederhauserTableauxAutomatedReasoning,
  title = {Tableaux for {{Automated Reasoning}} in {{Dependently-Typed Higher-Order Logic}}},
  author = {Niederhauser, Johannes and Brown, Chad E},
  abstract = {Dependent type theory gives an expressive type system which facilitates succinct formalizations of mathematical concepts. In practice, it is mainly used for interactive theorem proving in the propositionsas-types style, with PVS being a notable exception. In this paper, we present native rules for automated reasoning in a dependently-typed version (DHOL) of classical higher-order logic (HOL). DHOL has an extensional type theory with an undecidable type checking problem which contains theorem proving. We implemented the inference rules as well as an automatic type checking mode in Lash, a fork of Satallax, the leading tableaux-based prover for HOL. Our method is sound and complete with respect to provability in DHOL. Completeness is guaranteed by the incorporation of a sound and complete translation from DHOL to HOL recently proposed by Rothgang et al. While this translation can already be used as a preprocessing step to any HOL prover, to achieve better performance, our system directly works in DHOL. Moreover, experimental results show that the DHOL version of Lash can outperform all major HOL provers executed on the translation.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AAX95UAE/Niederhauser and Brown - Tableaux for Automated Reasoning in Dependently-Ty.pdf}
}

@book{nielsonFormalMethodsAppetizer2019,
  title = {Formal {{Methods}}: {{An Appetizer}}},
  shorttitle = {Formal {{Methods}}},
  author = {Nielson, Flemming and Riis Nielson, Hanne},
  year = {2019},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-05156-3},
  urldate = {2020-10-27},
  isbn = {978-3-030-05155-6 978-3-030-05156-3},
  langid = {english}
}

@book{nielsonSemanticsApplicationsFormal1992,
  title = {Semantics with {{Applications}}: {{A Formal Introduction}}},
  author = {Nielson, Hanne Riis and Nielson, Flemming},
  year = {1992},
  publisher = {John Wiley \& Sons, Inc.},
  address = {New York, NY, USA},
  isbn = {0-471-92980-8}
}

@article{niesLogicBlog20202021,
  title = {Logic {{Blog}} 2020},
  author = {Nies, Andre},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.09508 [math]},
  eprint = {2101.09508},
  primaryclass = {math},
  urldate = {2021-01-26},
  abstract = {This year's blog has focused on the connections of group theory with logic and algorithms. The first post is on automata presentable groups. Then there are several posts related to topological groups, for instance Ivanov and Majcher showing that extreme amenability of closed subgroups of \$S\_{\textbackslash}infty\$ is a Borel property. One post due to Harrison-Trainor and Nies reviews notes by Segal on pseudofinite groups, and attempts an effective version. About 25 percent is on computability and randomness, in particular equivalence of reducibilities weaker than Turing on the K-trivials by Greenberg, Nies and Turetsky, and the effective SMB theorem in the quantum setting by Nies and Tomamichel.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/9N9NRN4Q/Nies - 2021 - Logic Blog 2020.pdf;/home/flaviomoura/Zotero/storage/SMZP7472/2101.html}
}

@book{nieuwenhuisRewritingTechniquesApplications2003,
  title = {Rewriting {{Techniques}} and {{Applications}}, 14th {{International Conference}}, {{RTA}} 2003, {{Valencia}}, {{Spain}}, {{June}} 9-11, 2003, {{Proceedings}}},
  editor = {Nieuwenhuis, Robert},
  year = {2003},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {2706},
  publisher = {Springer},
  isbn = {3-540-40254-3}
}

@book{nievergeltFoundationsLogicMathematics2002,
  title = {Foundations of {{Logic}} and {{Mathematics}}},
  author = {Nievergelt, Y.},
  year = {2002},
  series = {Nil},
  publisher = {Birkh{\"a}user Boston},
  doi = {10.1007/978-1-4612-0125-0}
}

@inproceedings{nipkow1993orthogonal,
  title = {Orthogonal Higher-Order Rewrite Systems Are Confluent},
  booktitle = {International Conference on Typed Lambda Calculi and Applications},
  author = {Nipkow, Tobias},
  year = {1993},
  pages = {306--317},
  organization = {Springer}
}

@article{nipkowFunctionalAlgorithmsVerified,
  title = {Functional {{Algorithms}}, {{Verified}}!},
  author = {Nipkow, Tobias and Blanchette, Jasmin and Eberl, Manuel and {G{\'o}mez-Londo{\~n}o}, Alejandro and Lammich, Peter and Sternagel, Christian and Wimmer, Simon and Zhan, Bohua},
  pages = {276},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/M9E89F35/Nipkow et al. - Functional Algorithms, Veriï¬ed!.pdf}
}

@inproceedings{nipkowFunctionalUnificationHigherOrder1993,
  ids = {nipkowFunctionalUnificationHigherorder1993},
  title = {Functional {{Unification}} of {{Higher-Order Patterns}}},
  booktitle = {Proc.{\textbackslash} 8th {{IEEE Symp}}.{\textbackslash} {{Logic}} in {{Computer Science}} ({{LICS}} 93)},
  author = {Nipkow, T.},
  year = {1993},
  pages = {64--74}
}

@inproceedings{nipkowHigherOrderCriticalPairs1991,
  title = {Higher-{{Order Critical Pairs}}},
  booktitle = {Proc.{\textbackslash} 6th {{IEEE Symp}}.{\textbackslash} {{Logic}} in {{Computer Science}}},
  author = {Nipkow, T.},
  year = {1991},
  pages = {342--349},
  publisher = {IEEE Press}
}

@book{nipkowIsabelleHOLProof2002,
  title = {Isabelle/{{HOL}} --- {{A Proof Assistant}} for {{Higher-Order Logic}}},
  author = {Nipkow, T. and Paulson, L. C. and Wenzel, M.},
  year = {2002},
  series = {Lncs},
  volume = {2283},
  publisher = {Springer}
}

@article{nipkowIsabelleMetalogicFormalization2021,
  title = {Isabelle's {{Metalogic}}: {{Formalization}} and {{Proof Checker}}},
  shorttitle = {Isabelle's {{Metalogic}}},
  author = {Nipkow, Tobias and Ro{\ss}kopf, Simon},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.12224 [cs]},
  eprint = {2104.12224},
  primaryclass = {cs},
  urldate = {2021-06-10},
  abstract = {Isabelle is a generic theorem prover with a fragment of higher-order logic as a metalogic for defining object logics. Isabelle also provides proof terms. We formalize this metalogic and the language of proof terms in Isabelle/HOL, define an executable (but inefficient) proof term checker and prove its correctness w.r.t. the metalogic. We integrate the proof checker with Isabelle and run it on a range of logics and theories to check the correctness of all the proofs in those theories.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/AF3B4TIQ/2104.html}
}

@misc{niuCostsensitiveComputationalAdequacy2024,
  title = {Cost-Sensitive Computational Adequacy of Higher-Order Recursion in Synthetic Domain Theory},
  author = {Niu, Yue and Sterling, Jonathan and Harper, Robert},
  year = {2024},
  month = mar,
  number = {arXiv:2404.00212},
  eprint = {2404.00212},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-04-08},
  abstract = {We study a cost-aware programming language for higher-order recursion dubbed \${\textbackslash}textbf\{PCF\}\_{\textbackslash}mathsf\{cost\}\$ in the setting of synthetic domain theory (SDT). Our main contribution relates the denotational cost semantics of \${\textbackslash}textbf\{PCF\}\_{\textbackslash}mathsf\{cost\}\$ to its computational cost semantics, a new kind of dynamic semantics for program execution that serves as a mathematically natural alternative to operational semantics in SDT. In particular we prove an internal, cost-sensitive version of Plotkin's computational adequacy theorem, giving a precise correspondence between the denotational and computational semantics for complete programs at base type. The constructions and proofs of this paper take place in the internal dependent type theory of an SDT topos extended by a phase distinction in the sense of Sterling and Harper. By controlling the interpretation of cost structure via the phase distinction in the denotational semantics, we show that \${\textbackslash}textbf\{PCF\}\_{\textbackslash}mathsf\{cost\}\$ programs also evince a noninterference property of cost and behavior. We verify the axioms of the type theory by means of a model construction based on relative sheaf models of SDT.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/GIVBFFNN/Niu et al. - 2024 - Cost-sensitive computational adequacy of higher-or.pdf;/home/flaviomoura/Zotero/storage/Y3IHY8RY/2404.html}
}

@inproceedings{nogueiraFormalizationSecurityProofs2010,
  title = {Formalization of {{Security Proofs Using PVS}} in the {{Dolev-Yao Model}}},
  booktitle = {Booklet {{Proc}}. {{Computability}} in {{Europe}} - {{CiE}}},
  author = {Nogueira, R. B. and Nascimento, A. C. A. and de Moura, F. L. C. and {Ayala-Rinc{\'o}n}, M.},
  year = {2010}
}

@inbook{nordstromMartinLofTypeTheory2001,
  title = {Martin-{{L{\"o}f}} 's Type Theory},
  booktitle = {Handbook of {{Logic}} in {{Computer Science}}: {{Volume}} 5. {{Algebraic}} and {{Logical Structures}}},
  author = {N{\"o}rdstrom, B. and Petersson, K.},
  year = {2001},
  month = jan,
  publisher = {Oxford University Press},
  doi = {10.1093/oso/9780198537816.003.0004},
  urldate = {2022-05-03},
  abstract = {The type theory described in this chapter has been developed by Martin-L{\"o}f with the original aim of being a clarification of constructive mathematics. Unlike most other formalizations of mathematics, type theory is not based on predicate logic. Instead, the logical constants are interpreted within type theory through the Curry-Howard correspondence between propositions and sets [Curry and Feys, 1958; Howard, 1980]: a proposition is interpreted as a set whose elements represent the proofs of the proposition. It is also possible to view a set as a problem description in a way similar to Kolmogorov's explanation of the intuitionistic propositional calculus [Kolmogorov, 1932]. In particular, a set can be seen as a specification of a programming problem; the elements of the set are then the programs that satisfy the specification. An advantage of using type theory for program construction is that it is possible to express both specifications and programs within the same formalism. Furthermore, the proof rules can be used to derive a correct program from a specification as well as to verify that a given program has a certain property. As a programming language, type theory is similar to typed functional languages such as ML [Gordon et al., 1979; Milner et al., 1990] and Haskell [Hudak et al, 1992], but a major difference is that the evaluation of a well-typed program always terminates. The notion of constructive proof is closely related to the notion of computer program. To prove a proposition ("x {\^I} A)(\$y{\^I}B)P(x,y) constructively means to give a function f which when applied to an element a in A gives an element b in B such that P(a, b) holds. So if the proposition ("x{\^I} A)(\$y{\^I}B)P(x,y) expresses a specification, then the function f obtained from the proof is a program satisfying the specification. A constructive proof could therefore itself be seen as a computer program and the process of computing the value of a program corresponds to the process of normalizing a proof. It is by this computational content of a constructive proof that type theory can be used as a programming language; and since the program is obtained from a proof of its specification, type theory can be used as a programming logic.},
  collaborator = {N{\"o}rdstrom, B. and Petersson, K.},
  isbn = {978-0-19-853781-6 978-0-19-191666-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AAGUU8MZ/NÃ¶rdstrom and Petersson - 2001 - Martin-LÃ¶f âs type theory.pdf}
}

@article{normannUncountabilityMathbb2020,
  title = {On the Uncountability of \${\textbackslash}mathbb\{\vphantom\}{{R}}\vphantom\{\}\$},
  author = {Normann, Dag and Sanders, Sam},
  year = {2020},
  month = oct,
  journal = {arXiv:2007.07560 [math]},
  eprint = {2007.07560},
  primaryclass = {math},
  urldate = {2020-10-09},
  abstract = {The uncountability of \${\textbackslash}mathbb\{R\}\$ (Cantor, 1874) is famous like few other theorems are; we investigate the logical and computational properties of \${\textbackslash}textsf\{NIN\}\$ (resp. \${\textbackslash}textsf\{NBI\}\$) the statement there is no injection (resp. bijection) from \$[0,1]\$ to \${\textbackslash}mathbb\{N\}\$. While intuitively weak, \${\textbackslash}textsf\{NIN\}\$ (and similar for \${\textbackslash}textsf\{NBI\}\$) is classified as rather strong on the 'normal' scale, both in terms of which comprehension axioms prove \${\textbackslash}textsf\{NIN\}\$ and which discontinuous functionals compute (Kleene S1-S9) the real numbers from \${\textbackslash}textsf\{NIN\}\$ from the data. Indeed, full second-order arithmetic is essential in each case. To obtain a classification in which \${\textbackslash}textsf\{NIN\}\$ and \${\textbackslash}textsf\{NBI\}\$ are weak, we explore the 'non-normal' scale based on (classically valid) continuity axioms and non-normal functionals, going back to Brouwer. In doing so, we derive \${\textbackslash}textsf\{NIN\}\$ and \${\textbackslash}textsf\{NBI\}\$ from basic theorems, like Arzel{\textbackslash}`a's convergence theorem for the Riemann integral (1885) and central theorems from Reverse Mathematics formulated with the standard definition of `countable set' involving injections or bijections to \${\textbackslash}mathbb\{N\}\$. Thus, the uncountability of \${\textbackslash}mathbb\{R\}\$ is a corollary to basic mainstream mathematics; \${\textbackslash}textsf\{NIN\}\$ and \${\textbackslash}textsf\{NBI\}\$ are (among) the weakest principles on the non-normal scale, which serendipitously reproves many of our previous results. Moreover, the Bolzano-Weierstrass theorem for countable sets in Cantor space is weak, but gives rise to \${\textbackslash}Pi\_2{\textasciicircum}1\$-\${\textbackslash}textsf\{CA\}\_0\$ when combined with higher-order \${\textbackslash}Pi\_1{\textasciicircum}1\$-\${\textbackslash}textsf\{CA\}\_0\$, i.e. the Suslin functional. Finally, \${\textbackslash}textsf\{NIN\}\$ and \${\textbackslash}textsf\{NBI\}\$ allow us to showcase to a wide audience the techniques (like Gandy selection) used in our ongoing project on the logical and computational properties of the uncountable.},
  archiveprefix = {arXiv},
  keywords = {03B30 03F35 03D55 03D30,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/XV52YHIE/Normann e Sanders - 2020 - On the uncountability of $mathbb R $.pdf;/home/flaviomoura/Zotero/storage/FDHJA5T9/2007.html}
}

@incollection{norrishProofPearlBruijn2007,
  title = {Proof {{Pearl}}: {{De Bruijn Terms Really Do Work}}},
  booktitle = {International {{Conference}} on {{Theorem Proving}} in {{Higher Order Logics}}},
  author = {Norrish, M. and Vestergaard, R.},
  year = {2007},
  month = sep,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {207--222},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-3-540-74591-4_16},
  chapter = {Lecture Notes in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/KX675LRJ/Norrish e Vestergaard - 2007 - Proof Pearl De Bruijn Terms Really Do Work.pdf}
}

@article{NotionsProvability2023,
  title = {On {{Notions}} of {{Provability}}},
  year = {2023},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/5APR9NQR/2023 - On Notions of Provability.pdf}
}

@article{nourRevisedCompletenessResult2016,
  title = {A Revised Completeness Result for the Simply Typed \${\textbackslash}lambda{\textbackslash}mu\$-Calculus Using Realizability Semantics},
  author = {Nour, K. and Ziadeh, M.},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic}
}

@misc{nuidaSimpleElementaryProof2023,
  title = {A {{Simple}} and {{Elementary Proof}} of {{Zorn}}'s {{Lemma}}},
  author = {Nuida, Koji},
  year = {2023},
  month = jun,
  number = {arXiv:2305.10258},
  eprint = {2305.10258},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2023-06-30},
  abstract = {We give a new simple proof of Zorn's Lemma (from the Axiom of Choice), which is elementary and does not rely on advanced knowledge in set theory (such as transfinite recursion) nor in ordered sets (such as well-ordered sets) beyond the statement of Zorn's Lemma itself.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {03E25 06A06 97E60,06A06 03E25 97E60,Mathematics - Combinatorics,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/FR6CA9N6/Nuida - 2024 - A Simple and Elementary Proof of Zorn's Lemma.pdf;/home/flaviomoura/Zotero/storage/KQGZDGTA/Nuida - 2023 - A Simple and Elementary Proof of Zorn's Lemma.pdf;/home/flaviomoura/Zotero/storage/7JQBBBDA/2305.html}
}

@inproceedings{nuutilaLearningProgrammingPBLnil,
  title = {Learning {{Programming}} with the {{PBL Method}} - {{Experiences}} on {{PBL Cases}} and {{Tutoring}}},
  booktitle = {Reflections on the {{Teaching}} of {{Programming}}},
  author = {Nuutila, Esko and T{\"o}rm{\"a}, Seppo and Kinnunen, P{\"a}ivi and Malmi, Lauri},
  year = {nil},
  series = {Reflections on the {{Teaching}} of {{Programming}}},
  pages = {47--67},
  publisher = {Springer Berlin Heidelberg}
}

@book{oberguggenbergerAnalysisComputerScientists2018,
  title = {Analysis for {{Computer Scientists}}: {{Foundations}}, {{Methods}}, and {{Algorithms}}},
  shorttitle = {Analysis for {{Computer Scientists}}},
  author = {Oberguggenberger, Michael and Ostermann, Alexander},
  year = {2018},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-91155-7},
  urldate = {2020-07-10},
  isbn = {978-3-319-91154-0 978-3-319-91155-7}
}

@book{oberguggenbergerAnalysisComputerScientists2018a,
  title = {Analysis for {{Computer Scientists}}},
  author = {Oberguggenberger, Michael and Ostermann, Alexander},
  year = {2018},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-91155-7}
}

@misc{obuaLogicAlgebra2023,
  title = {Logic Is {{Algebra}}},
  author = {Obua, Steven},
  year = {2023},
  month = apr,
  number = {arXiv:2304.00358},
  eprint = {2304.00358},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-04-04},
  abstract = {Logic really is just algebra, given one uses the right kind of algebra, and the right kind of logic. The right kind of algebra is abstraction algebra, and the right kind of logic is abstraction logic.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/N7FX3VXU/Obua - 2023 - Logic is Algebra.pdf}
}

@book{odifreddiLogicLogicians2019,
  title = {About {{Logic}} and {{Logicians}}},
  author = {Odifreddi, Piergiorgio},
  year = {2019},
  series = {A},
  volume = {2},
  publisher = {L{\'o}gica no Avi{\~a}o},
  isbn = {978-65-900390-1-9}
}

@book{odifreddiLogicLogicians2019a,
  title = {About {{Logic}} and {{Logicians}}},
  author = {Odifreddi, Piergiorgio},
  year = {2019},
  series = {A},
  volume = {1},
  publisher = {L{\'o}gica no Avi{\~a}o},
  isbn = {978-65-900390-2-6}
}

@book{odonnellDiscreteMathematicsUsing2006,
  title = {Discrete Mathematics Using a Computer},
  author = {O'Donnell, J. and Hall, C. and Page, R.},
  year = {2006},
  publisher = {Springer},
  isbn = {978-1-84628-241-6},
  lccn = {[2005935334]}
}

@book{ogiharaFundamentalsJavaProgramming2018,
  title = {Fundamentals of {{Java Programming}}},
  author = {Ogihara, Mitsunori},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-89491-1}
}

@article{ohlebuschModularityTerminationTerm1994,
  title = {On the Modularity of Termination of Term Rewriting Systems},
  author = {Ohlebusch, Enno},
  year = {1994},
  journal = {Theoretical Computer Science},
  volume = {136},
  number = {2},
  pages = {333--360},
  issn = {0304-3975},
  doi = {10.1016/0304-3975(94)00039-L}
}

@article{ohlebuschSimpleProofSufficient1993,
  title = {A Simple Proof of Sufficient Conditions for the Termination of the Disjoint Union of Term Rewriting Systems},
  author = {Ohlebusch, Enno},
  year = {1993},
  journal = {Bulletin of the EATCS},
  volume = {50},
  pages = {223--228}
}

@article{ohtsukaProofSubstitutionLemma1993,
  title = {A {{Proof}} of the {{Substitution Lemma}} in {{De Bruijn}}'s {{Notation}}},
  author = {Ohtsuka, Hiroshi},
  year = {1993},
  journal = {Information Processing Letters},
  volume = {46},
  number = {2},
  pages = {63--66},
  doi = {10.1016/0020-0190(93)90198-i},
  file = {/home/flaviomoura/Zotero/storage/UEAANCBQ/Ohtsuka - 1993 - A Proof of the Substitution Lemma in De Bruijn's N.pdf}
}

@book{okasaki1999purely,
  title = {Purely Functional Data Structures},
  author = {Okasaki, Chris},
  year = {1999},
  publisher = {Cambridge University Press},
  file = {/home/flaviomoura/Zotero/storage/QFXQXV7P/Okasaki - 1999 - Purely functional data structures.pdf}
}

@article{okasakiRedblackTreesFunctional1999,
  title = {Red-Black Trees in a Functional Setting},
  author = {Okasaki, Chris},
  year = {1999},
  month = jul,
  journal = {Journal of Functional Programming},
  volume = {9},
  number = {4},
  pages = {471--477},
  issn = {0956-7968, 1469-7653},
  doi = {10.1017/S0956796899003494},
  urldate = {2023-10-28},
  abstract = {Everybody learns about balanced binary search trees in their introductory computer  science classes, but even the stouthearted tremble at the thought of actually               implementing               such a beast. The details surrounding rebalancing are usually just too  messy. To show that this need not be the case, we present an algorithm for insertion  into red-black trees (Guibas and Sedgewick, 1978) that any competent programmer  should be able to implement in fifteen minutes or less.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/CFJB2MIE/Okasaki - 1999 - Red-black trees in a functional setting.pdf}
}

@misc{olarteMultimodalitiesNoncommutativityAssociativity2024,
  title = {Multi-Modalities and Non-Commutativity/Associativity in Functorial Linear Logic: A Case Study},
  shorttitle = {Multi-Modalities and Non-Commutativity/Associativity in Functorial Linear Logic},
  author = {Olarte, Carlos and Pimentel, Elaine},
  year = {2024},
  month = apr,
  number = {arXiv:2404.11445},
  eprint = {2404.11445},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.11445},
  urldate = {2024-04-18},
  abstract = {Similar to modal connectives, the exponential ! in intuitionistic linear logic (ILL) is not canonical, in the sense that if \$i{\textbackslash}not= j\$ then \$!{\textasciicircum}i F{\textbackslash}not{\textbackslash}equiv !{\textasciicircum}j F\$. Intuitively, this means that we can mark the exponential with labels taken from a set I organized in a pre-order \${\textbackslash}preceq\$, obtaining (possibly infinitely-many) exponentials (\$!{\textasciicircum}i\$ for \$i{\textbackslash}in I\$). There are, however, two main differences between multi-modalities in normal modal logics and subexponentials in linear logic. i. substructural behaviour. Subexponentials carry the possibility of having different structural behaviors; ii. nature of modalities. Normal modal logics start from the weakest version, assuming only axiom K, then extensions are considered, by adding other axioms. Exponentials in linear logic "take for granted" the behaviors expressed by axioms T and 4. Regarding (i), originally subexponentials could assume only weakening and contraction axioms, but later non-commutative/non-associative systems allowing commutative/ associative subexponentials were presented. Concerning (ii), Guerrini et al unified the modal and LL approaches, with the exponentials assuming only the linear version of K, with the possibility of adding modal extensions to it. This discussion was brought to multi-modal case, where subexponentials consider not only the structural axioms for contraction and weakening, but also the subexponential version of axioms \{K,4,D,T\}. In this work, we intend to join these two studies. This means that \$!{\textasciicircum}\{i\}\$ can behave classically or not, model associative and commutative systems or not, but also with exponential behaviors different from those in LL. Hence, by assigning different modal axioms one obtains, in a modular way, a class of different substructural modal logics.},
  archiveprefix = {arXiv},
  keywords = {03F52,Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/TAHWW4LW/Olarte e Pimentel - 2024 - Multi-modalities and non-commutativityassociativi.pdf;/home/flaviomoura/Zotero/storage/N8DIMNJ7/2404.html}
}

@article{olarteRewritingLogicApproach2021,
  title = {A {{Rewriting Logic Approach}} to {{Specification}}, {{Proof-search}}, and {{Meta-proofs}} in {{Sequent Systems}}},
  author = {Olarte, Carlos and Pimentel, Elaine and Rocha, Camilo},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.03113 [cs, math]},
  eprint = {2101.03113},
  primaryclass = {cs, math},
  urldate = {2021-01-11},
  abstract = {This paper develops an algorithmic-based approach for proving inductive properties of propositional sequent systems such as admissibility, invertibility, cut-elimination, and identity expansion. Although undecidable in general, these structural properties are crucial in proof theory because they can reduce the proof-search effort and further be used as scaffolding for obtaining other meta-results such as consistency. The algorithms -- which take advantage of the rewriting logic meta-logical framework, and use rewrite- and narrowing-based reasoning -- are explained in detail and illustrated with examples throughout the paper. They have been fully mechanized in the L-Framework, thus offering both a formal specification language and off-the-shelf mechanization of the proof-search algorithms coming together with semi-decision procedures for proving theorems and meta-theorems of the object system. As illustrated with case studies in the paper, the L-Framework, achieves a great degree of automation when used on several propositional sequent systems, including single conclusion and multi-conclusion intuitionistic logic, classical logic, classical linear logic and its dyadic system, intuitionistic linear logic, and normal modal logics.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/C2LS9G2W/Olarte et al. - 2021 - A Rewriting Logic Approach to Specification, Proof.pdf;/home/flaviomoura/Zotero/storage/ZGHGI87G/2101.html}
}

@inproceedings{oliveiraFormalizingConfluenceOrthogonal2012,
  title = {Formalizing the {{Confluence}} of {{Orthogonal Rewriting Systems}}},
  booktitle = {{{LSFA}}},
  author = {Oliveira, A. C. Rocha and {Ayala-Rinc{\'o}n}, M.},
  year = {2012},
  pages = {145--152}
}

@phdthesis{oliveiraUnificacaoConfluenciaTipos2016,
  title = {Unifica{\c c}{\~a}o, {{Conflu{\^e}ncia}} e {{Tipos}} Com {{Interse{\c c}{\~a}o}} Para {{Sistemas}} de {{Reescrita Nominal}}},
  author = {Oliveira, A. C. R.},
  year = {2016},
  school = {Universidade de Bras{\'i}lia}
}

@book{olverAppliedLinearAlgebra2018,
  title = {Applied {{Linear Algebra}}},
  author = {Olver, Peter J. and Shakiban, Chehrzad},
  year = {2018},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-91041-3}
}

@book{omodeoMartinDavisComputability2017,
  title = {Martin {{Davis}} on {{Computability}}, {{Computational Logic}}, and {{Mathematical Foundations}}},
  author = {Omodeo, Eugenio G and Policriti, Alberto},
  year = {2017},
  volume = {10},
  publisher = {Springer}
}

@misc{On_Monadic_Rewriting_Systems__Part_IPdf,
  title = {On\_{{Monadic}}\_{{Rewriting}}\_{{Systems}}\_\_{{Part}}\_{{I}}.Pdf},
  journal = {Google Docs},
  urldate = {2021-06-10},
  howpublished = {https://drive.google.com/file/d/10wDQa0nIF9Ibhq7F0-2uOQAM7k8TAaPr/view?usp=sharing\&usp=embed\_facebook},
  file = {/home/flaviomoura/Zotero/storage/K4RU5ZEQ/view.html}
}

@book{ongTypedLambdaCalculi2011,
  title = {Typed {{Lambda Calculi}} and {{Applications}} - 10th {{International Conference}}, {{TLCA}} 2011, {{Novi Sad}}, {{Serbia}}, {{June}} 1-3, 2011. {{Proceedings}}},
  editor = {Ong, C.-H. Luke},
  year = {2011},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {6690},
  publisher = {Springer},
  doi = {10.1007/978-3-642-21691-6},
  isbn = {978-3-642-21690-9}
}

@article{onoprienkoKripkeSemanticsLogic2020,
  title = {Kripke Semantics for the Logic of Problems and Propositions},
  author = {Onoprienko, A. A.},
  year = {2020},
  month = may,
  journal = {Sbornik: Mathematics},
  volume = {211},
  number = {5},
  pages = {709--732},
  issn = {1064-5616},
  doi = {10.1070/SM9275},
  urldate = {2023-04-22},
  abstract = {In this paper we study the propositional fragment HC of the joint logic of problems and propositions introduced by Melikhov. We provide Kripke semantics for this logic and show that HC is complete with respect to those models and has the finite model property. We consider examples of the use of HC-models usage. In particular, we prove that HC is a conservative extension of the logic H4. We also show that the logic HC is complete with respect to Kripke frames with sets of audit worlds introduced by Artemov and Protopopescu (who called them audit set models). Bibliography: 31 titles.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/B9X3M78B/Onoprienko - 2020 - Kripke semantics for the logic of problems and pro.pdf}
}

@article{oostromDevelopingDevelopments1997,
  title = {Developing {{Developments}}},
  author = {van Oostrom, Vincent},
  year = {1997},
  journal = {TCS},
  volume = {175},
  number = {1},
  pages = {159--181},
  doi = {10.1016/S0304-3975(96)00173-9},
  file = {/home/flaviomoura/Zotero/storage/KW5GGVZT/Oostrom - 1997 - Developing Developments.pdf}
}

@unpublished{oostromDraftYourMind2007,
  title = {Z - {{Draft}}: {{For Your Mind Only}}},
  author = {van Oostrom, Vincent},
  year = {2007}
}

@inproceedings{oostromSymmetriesCommutationDiamonds2020,
  title = {Some Symmetries of Commutation Diamonds},
  author = {van Oostrom, Vincent},
  year = {2020},
  pages = {1--6},
  langid = {english}
}

@book{oreganConciseGuideFormal2017,
  title = {Concise {{Guide}} to {{Formal Methods}}: {{Theory}}, {{Fundamentals}} and {{Industry Applications}}},
  shorttitle = {Concise {{Guide}} to {{Formal Methods}}},
  author = {O'Regan, Gerard},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-64021-1},
  urldate = {2020-10-27},
  isbn = {978-3-319-64020-4 978-3-319-64021-1},
  langid = {english}
}

@book{oreganGuideDiscreteMathematics2016,
  title = {Guide to {{Discrete Mathematics}}},
  author = {O'Regan, G.},
  year = {2016},
  series = {Texts in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-44561-8}
}

@article{oudheusdenMScThesisAfstudeerscriptie,
  title = {{{MSc Thesis}} ({{Afstudeerscriptie}})},
  author = {Oudheusden, Karel Van},
  pages = {78},
  abstract = {The history of computer science can be viewed from a number of disciplinary perspectives, ranging from electrical engineering to linguistics. As stressed by the historian Michael Mahoney, different `communities of computing' had their own views towards what could be accomplished with a programmable computing machine. The mathematical logicians, for instance, had established what programmable computing machines with unbounded resources could not do, while the switching theorists had showed how to analyze and synthesize circuits. ``But no science accounted for what finite machines with finite, random access memories could do or how they did it. That science had to be created.'' --Mahoney [78, p.6].},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VK2HADR4/Oudheusden - MSc Thesis (Afstudeerscriptie).pdf}
}

@article{overbeekLinearTermRewriting2021,
  title = {From {{Linear Term Rewriting}} to {{Graph Rewriting}} with {{Preservation}} of {{Termination}}},
  author = {Overbeek, Roy and Endrullis, J{\"o}rg},
  year = {2021},
  month = jun,
  journal = {arXiv:2106.13826 [cs]},
  eprint = {2106.13826},
  primaryclass = {cs},
  urldate = {2021-06-29},
  abstract = {Encodings of term rewriting systems (TRSs) into graph rewriting systems usually lose global termination, meaning the encodings do not terminate on all graphs. A typical encoding of the terminating TRS rule a(b(x)) -{$>$} b(a(x)), for example, may be indefinitely applicable along a cycle of a's and b's. Recently, we introduced PBPO+, a graph rewriting formalism in which rules employ a type graph to specify transformations and control rule applicability. In the present paper, we show that PBPO+ allows for a natural encoding of linear TRS rules that preserves termination globally. This result is a step towards modeling other rewriting formalisms, such as lambda calculus and higher order rewriting, using graph rewriting in a way that preserves properties like termination and confluence. We moreover expect that the encoding can serve as a guide for lifting TRS termination methods to PBPO+ rewriting.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/9PSQDMNY/Overbeek e Endrullis - 2021 - From Linear Term Rewriting to Graph Rewriting with.pdf;/home/flaviomoura/Zotero/storage/F9TRNGIQ/2106.html}
}

@techreport{owreFormalSemanticsPVS1999,
  type = {Technical {{Report}}},
  title = {The Formal Semantics of {{PVS}}},
  author = {Owre, S. and Shankar, N.},
  year = {1999},
  number = {CR-1999-209321},
  institution = {{NASA Scientific and Technical Informtaion (STI)}}
}

@inproceedings{owrePVSPrototypeVerification1992,
  title = {{{PVS}}: {{A Prototype Verification System}}},
  booktitle = {{{CADE}}},
  author = {Owre, S. and Rushby, J. M. and Shankar, N.},
  editor = {Kapur, D.},
  year = {1992},
  series = {Lnai},
  volume = {607},
  pages = {748--752},
  publisher = {sv}
}

@unpublished{owreWritingPVSProof2003,
  title = {Writing {{PVS Proof Strategies}}},
  author = {Owre, S. and Shankar, N.},
  year = {2003}
}

@misc{ozdemirSplitGrobnerBases2024,
  title = {Split {{Gr{\"o}bner Bases}} for {{Satisfiability Modulo Finite Fields}}},
  author = {Ozdemir, Alex and Pailoor, Shankara and Bassa, Alp and Ferles, Kostas and Barrett, Clark and Dillig, I{\c s}il},
  year = {2024},
  number = {2024/572},
  urldate = {2024-04-19},
  abstract = {Satisfiability modulo finite fields enables automated verification for cryptosystems. Unfortunately, previous solvers scale poorly for even some simple systems of field equations, in part because they build a full Gr{\"o}bner basis (GB) for the system. We propose a new solver that uses multiple, simpler GBs instead of one full GB. Our solver, implemented within the cvc5 SMT solver, admits specialized propagation algorithms, e.g., for understanding bitsums. Experiments show that it solves important bitsum-heavy determinism benchmarks far faster than prior solvers, without introducing much overhead for other benchmarks.},
  keywords = {finite fields,SMT,verification,zero knowledge},
  annotation = {Publication info: Published elsewhere. Minor revision. CAV'24},
  file = {/home/flaviomoura/Zotero/storage/R5RLJ3AM/Ozdemir et al. - 2024 - Split GrÃ¶bner Bases for Satisfiability Modulo Fini.pdf}
}

@book{p-mohringAssistantsPreuve2010,
  title = {Assistants de Preuve},
  author = {{P-Mohring}, C. and Werner, B. and Barras, B. and Herbelin, H. and Filli{\^a}tre, J.-C. and March{\'e}, C.},
  year = {2010}
}

@book{paarUnderstandingCryptography2010,
  title = {Understanding {{Cryptography}}},
  author = {Paar, Christof and Pelzl, Jan},
  year = {2010},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-04101-3}
}

@article{padovaniDecidabilityFourthorderMatching2000,
  title = {Decidability of Fourth-Order Matching},
  author = {Padovani, V.},
  year = {2000},
  journal = {Mathematical Structures in Computer Science},
  volume = {10},
  number = {3},
  pages = {361--372}
}

@book{pageWhatComputerScience2014,
  title = {What {{Is Computer Science}}?},
  author = {Page, Daniel and Smart, Nigel},
  year = {2014},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-04042-4},
  urldate = {2020-07-07},
  isbn = {978-3-319-04041-7 978-3-319-04042-4}
}

@article{palmgrenTypeTheorySetoids2019,
  title = {From {{Type Theory To Setoids}} and {{Back}}},
  author = {Palmgren, Erik},
  year = {2019},
  journal = {CoRR},
  abstract = {A model of Martin-L{\"o}f extensional type theory with universes is formalized in Agda, an interactive proof system based on Martin-L{\"o}f intensional type theory. This may be understood, we claim, as a solution to the old problem of modelling the full extensional theory in the intensional theory. Types are interpreted as setoids, and the model is therefore a setoid model. We solve the problem of intepreting type universes by utilizing Aczel's type of iterative sets, and show how it can be made into a setoid of small setoids containing the necessary setoid constructions. In addition we interpret the bracket types of Awodey and Bauer. Further quotient types should be interpretable.}
}

@article{palmgrenTypeTheorySetoids2022,
  title = {From Type Theory to Setoids and Back},
  author = {Palmgren, Erik},
  year = {2022},
  month = nov,
  journal = {Mathematical Structures in Computer Science},
  volume = {32},
  number = {10},
  pages = {1283--1312},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129521000189},
  urldate = {2023-10-06},
  abstract = {Abstract             A model of Martin-L{\"o}f extensional type theory with universes is formalized in Agda, an interactive proof system based on Martin-L{\"o}f intensional type theory. This may be understood, we claim, as a solution to the old problem of modeling the full extensional theory in the intensional theory. Types are interpreted as setoids, and the model is therefore a setoid model.We solve the problem of interpreting type universes by utilizing Aczel's type of iterative sets and show how it can be made into a setoid of small setoids containing the necessary setoid constructions. In addition, we interpret the bracket types of Awodey and Bauer. Further quotient types should be interpretable.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2P9BFBHX/Palmgren - 2022 - From type theory to setoids and back.pdf}
}

@article{parberry1995problems,
  title = {Problems on Algorithms},
  author = {Parberry, Ian},
  year = {1995},
  journal = {ACM SIGACT News},
  volume = {26},
  number = {2},
  pages = {50--56},
  publisher = {ACM New York, NY, USA}
}

@book{parberryProblemsAlgorithms1995,
  title = {Problems on {{Algorithms}}},
  author = {Parberry, I.},
  year = {1995},
  publisher = {Prentice Hall},
  isbn = {978-0-13-433558-2},
  lccn = {94048519}
}

@book{parberryProblemsAlgorithms2002,
  title = {Problems on {{Algorithms}}},
  author = {Parberry, Ian and Gasarch, William},
  year = {2002},
  publisher = {Prentice Hall},
  file = {/home/flaviomoura/Zotero/storage/QSWNJK4J/Parberry e Gasarch - 2002 - Problems on Algorithms.pdf}
}

@inproceedings{parigotConstructiveExistence2006,
  title = {On {{Constructive Existence}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {Parigot, Michel},
  editor = {Filli{\^a}tre, Jean-Christophe and {Paulin-Mohring}, Christine and Werner, Benjamin},
  year = {2006},
  pages = {268--273},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/11617990_17},
  abstract = {Baaz and Fermueller gave in 2003 an original characterization of constructive existence in classical logic [2]. In this note, we give a simple proof of this result based on cut-elimination in sequent calculus. The interest of this proof besides its simplicity is that it allows in particular to generalize the result to other logics enjoying cut-elimination. We also briefly discuss the significance of the characterization itself.},
  isbn = {978-3-540-31429-5},
  langid = {english}
}

@inproceedings{parigotLambdaMuCalculusAlgorithmicInterpretation1992,
  title = {Lambda-{{Mu-Calculus}}: {{An Algorithmic Interpretation}} of {{Classical Natural Deduction}}},
  booktitle = {Logic {{Programming}} and {{Automated Reasoning}},{{International Conference LPAR}}'92, {{St}}. {{Petersburg}}, {{Russia}}, {{July}} 15-20, 1992, {{Proceedings}}},
  author = {Parigot, Michel},
  year = {1992},
  pages = {190--201},
  doi = {10.1007/BFb0013061},
  file = {/home/flaviomoura/Zotero/storage/I8CSQ3HV/Parigot - 1992 - Î»Î¼-Calculus An algorithmic interpretation of clas.pdf}
}

@article{parigotProofsStrongNormalisation1997,
  title = {Proofs of {{Strong Normalisation}} for {{Second Order Classical Natural Deduction}}},
  author = {Parigot, Michel},
  year = {1997},
  journal = {J. Symb. Log.},
  volume = {62},
  number = {4},
  pages = {1461--1479},
  doi = {10.2307/2275652}
}

@inproceedings{parigotStrongNormalizationSecond1993,
  title = {Strong Normalization for Second Order Classical Natural Deduction},
  booktitle = {[1993] {{Proceedings Eighth Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Parigot, M.},
  year = {1993},
  month = jun,
  pages = {39--46},
  doi = {10.1109/LICS.1993.287602},
  keywords = {Calculus,Filters,H infinity control,inference mechanisms,lambda calculus,Logic programming,reducibility candidates,second order classical natural deduction,second-order intuitionistic natural deduction,strong normalization theorem}
}

@misc{parlamentoAdmissibilityStructuralRules2024,
  title = {Admissibility of the {{Structural Rules}} in the {{Sequent Calculus}} with {{Equality}}},
  author = {Parlamento, Franco and Previale, Flavio},
  year = {2024},
  month = mar,
  number = {arXiv:2403.06887},
  eprint = {2403.06887},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2403.06887},
  urldate = {2024-03-12},
  abstract = {On the ground of a general theorem concerning the admissibility of the structural rules in sequent calculi with additional atomic rules, we develop a proof theoretic analysis for several extensions of the \$\{{\textbackslash}bf G3[mic]\}\$ sequent calculi with rules for equality, including the one originally proposed by H.Wang. In the classical case we relate our results with the semantic tableau method for first order logic with equality. In particular we establish that, for languages without function symbols, in Fitting's alternative semantic tableau method, strictness (which does not allow the repetition of equalities which are modified) can be imposed together with the orientation of the replacement of equals. A significant progress is made toward extending that result to languages with function symbols although whether that is possible or not remains to be settled. We also briefly consider systems that, in the classical case, are related to the semantic tableau method in which one can expand branches by adding identities at will, obtaining that also in that case strictness can be imposed. Furthermore we discuss to what extent the strengthened form of the nonlengthening property of Orevkov known to hold for the sequent calculi with the structural rules applies also to the present context.},
  archiveprefix = {arXiv},
  keywords = {03705,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/3UI2JP5K/Parlamento e Previale - 2024 - Admissibility of the Structural Rules in the Seque.pdf;/home/flaviomoura/Zotero/storage/4HTBYC29/2403.html}
}

@article{parrowModalLogicsNominal2021,
  title = {Modal {{Logics}} for {{Nominal Transition Systems}}},
  author = {Parrow, Joachim and Borgstr{\"o}m, Johannes and Eriksson, Lars-Henrik and Gutkovas, Ram{\=u}nas Forsberg and Weber, Tjark},
  year = {2021},
  month = jan,
  journal = {arXiv:1904.02564 [cs]},
  eprint = {1904.02564},
  primaryclass = {cs},
  urldate = {2021-01-28},
  abstract = {We define a general notion of transition system where states and action labels can be from arbitrary nominal sets, actions may bind names, and state predicates from an arbitrary logic define properties of states. A Hennessy-Milner logic for these systems is introduced, and proved adequate and expressively complete for bisimulation equivalence. A main technical novelty is the use of finitely supported infinite conjunctions. We show how to treat different bisimulation variants such as early, late, open and weak in a systematic way, explore the folklore theorem that state predicates can be replaced by actions, and make substantial comparisons with related work. The main definitions and theorems have been formalised in Nominal Isabelle.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/VGVNYGLY/Parrow et al. - 2021 - Modal Logics for Nominal Transition Systems.pdf;/home/flaviomoura/Zotero/storage/WFWZQVAS/1904.html}
}

@misc{parsertLinearProgrammingIsabelle2024,
  title = {Linear {{Programming}} in {{Isabelle}}/{{HOL}}},
  author = {Parsert, Julian},
  year = {2024},
  month = mar,
  number = {arXiv:2403.19639},
  eprint = {2403.19639},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-04-07},
  abstract = {Linear programming describes the problem of optimising a linear objective function over a set of constraints on its variables. In this paper we present a solver for linear programs implemented in the proof assistant Isabelle/HOL. This allows formally proving its soundness, termination, and other properties. We base these results on a previous formalisation of the simplex algorithm which does not take optimisation problems into account. Using the weak duality theorem of linear programming we obtain an algorithm for solving linear programs. Using Isabelle's code generation mechanism we can generate an external solver for linear programs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/KMVPPUNV/Parsert - 2024 - Linear Programming in IsabelleHOL.pdf;/home/flaviomoura/Zotero/storage/JGNMVTJV/2403.html}
}

@article{parysHigherOrderNonemptinessStep2020,
  title = {Higher-{{Order Nonemptiness Step}} by {{Step}}},
  author = {Parys, Pawe{\l}},
  year = {2020},
  month = sep,
  journal = {arXiv:2009.08174 [cs]},
  eprint = {2009.08174},
  primaryclass = {cs},
  urldate = {2020-09-21},
  abstract = {We show a new simple algorithm that checks whether a given higher-order grammar generates a nonempty language of trees. The algorithm amounts to a procedure that transforms a grammar of order n to a grammar of order n-1, preserving nonemptiness, and increasing the size only exponentially. After repeating the procedure n times, we obtain a grammar of order 0, whose nonemptiness can be easily checked. Since the size grows exponentially at each step, the overall complexity is n-EXPTIME, which is known to be optimal. More precisely, the transformation (and hence the whole algorithm) is linear in the size of the grammar, assuming that the arity of employed nonterminals is bounded by a constant. The same algorithm allows to check whether an infinite tree generated by a higher-order recursion scheme is accepted by an alternating safety (or reachability) automaton, because this question can be reduced to the nonemptiness problem by taking a product of the recursion scheme with the automaton. A proof of correctness of the algorithm is formalised in the proof assistant Coq. Our transformation is motivated by a similar transformation of Asada and Kobayashi (2020) changing a word grammar of order n to a tree grammar of order n-1. The step-by-step approach can be opposed to previous algorithms solving the nonemptiness problem "in one step", being compulsorily more complicated.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Formal Languages and Automata Theory},
  file = {/home/flaviomoura/Zotero/storage/HBEQEUVH/Parys - 2020 - Higher-Order Nonemptiness Step by Step.pdf;/home/flaviomoura/Zotero/storage/3H7ETE3E/2009.html}
}

@article{paul-andreAsynchronousTemplateGames2021,
  title = {Asynchronous {{Template Games}} and the {{Gray Tensor Product}} of 2-{{Categories}}},
  author = {{Paul-Andr{\'e}}, Melli{\`e}s},
  year = {2021},
  month = may,
  journal = {arXiv:2105.04929 [cs, math]},
  eprint = {2105.04929},
  primaryclass = {cs, math},
  urldate = {2021-05-12},
  abstract = {In his recent and exploratory work on template games and linear logic, Melli{\textbackslash}`es defines sequential and concurrent games as categories with positions as objects and trajectories as morphisms, labelled by a specific synchronization template. In the present paper, we bring the idea one dimension higher and advocate that template games should not be just defined as 1-dimensional categories but as 2-dimensional categories of positions, trajectories and reshufflings (or reschedulings) as 2-cells. In order to achieve the purpose, we take seriously the parallel between asynchrony in concurrency and the Gray tensor product of 2-categories. One technical difficulty on the way is that the category S=2-Cat of small 2-categories equipped with the Gray tensor product is monoidal, and not cartesian. This prompts us to extend the framework of template games originally formulated by Melli{\textbackslash}`es in a category S with finite limits, and to upgrade it in the style of Aguiar's work on quantum groups to the more general situation of a monoidal category S with coreflexive equalizers, preserved by the tensor product componentwise. We construct in this way an asynchronous template game semantics of multiplicative additive linear logic (MALL) where every formula and every proof is interpreted as a labelled 2-category equipped, respectively, with the structure of Gray comonoid for asynchronous template games, and of Gray bicomodule for asynchronous strategies.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/9U57ZFDN/2105.html}
}

@book{paulin-mohringDefinitionsInductivesTheorie1996,
  title = {D{\'e}finitions {{Inductives}} En {{Th{\'e}orie}} Des {{Types}}. ({{Inductive Definitions}} in {{Type Theory}})},
  author = {{Paulin-Mohring}, Christine},
  year = {1996}
}

@inproceedings{paulin-mohringInductiveDefinitionsSystem1993,
  title = {Inductive {{Definitions}} in the System {{Coq}} - {{Rules}} and {{Properties}}},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}, {{International Conference}} on {{Typed Lambda Calculi}} and {{Applications}}, {{TLCA}} '93, {{Utrecht}}, {{The Netherlands}}, {{March}} 16-18, 1993, {{Proceedings}}},
  author = {{Paulin-Mohring}, C.},
  year = {1993},
  pages = {328--345},
  doi = {10.1007/BFb0037116}
}

@article{paulin-mohringIntroductionCalculusInductive,
  title = {Introduction to the {{Calculus}} of {{Inductive Constructions}}},
  author = {{Paulin-Mohring}, Christine},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/3D8HF8QF/Paulin-Mohring - Introduction to the Calculus of Inductive Construc.pdf}
}

@unpublished{paulin-mohringIntroductionCalculusInductive2014,
  title = {Introduction to the {{Calculus}} of {{Inductive Constructions}}},
  author = {{Paulin-Mohring}, C.},
  year = {2014}
}

@book{paulin-mohringLASER2011Summerschool2011,
  title = {{{LASER}} 2011 {{Summerschool Elba Island}}, {{Italy}} - {{Basics}} of {{COQ}}},
  author = {{Paulin-Mohring}, C.},
  year = {2011}
}

@unpublished{paulofeofiloffMinicursoAnaliseAlgoritmos,
  title = {{Minicurso de An{\'a}lise de Algoritmos}},
  author = {Paulo Feofiloff},
  abstract = {Este livrinho {\'e} uma vers{\~a}o corrigida do minicurso que ministrei nas JAI (Jornadas de Atualiza{\c c}{\~a}o em Inform{\'a}tica) de 2009 da SBC (Sociedade Brasileira de Computa{\c c}{\~a}o), ocorridas em Bento Gon{\c c}alves, RS, em julho de 2009. O minicurso foi publicado no livro organizado por Andr{\'e} P. L. F. de Carvalho e Tomasz Kowaltowski},
  langid = {portuguese}
}

@article{paulsonAckermannFunctionIterative2021,
  title = {Ackermann's {{Function}} in {{Iterative Form}}: {{A Proof Assistant Experiment}}},
  shorttitle = {Ackermann's {{Function}} in {{Iterative Form}}},
  author = {Paulson, Lawrence C.},
  year = {2021},
  month = aug,
  journal = {arXiv:2104.11157 [cs]},
  eprint = {2104.11157},
  primaryclass = {cs},
  urldate = {2021-08-16},
  abstract = {Ackermann's function can be expressed using an iterative algorithm, which essentially takes the form of a term rewriting system. Although the termination of this algorithm is far from obvious, its equivalence to the traditional recursive formulation---and therefore its totality---has a simple proof in Isabelle/HOL. This is a small example of formalising mathematics using a proof assistant, with a focus on the treatment of difficult recursions.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {03D99 03B35 68V20,Computer Science - Logic in Computer Science,D.2.4},
  file = {/home/flaviomoura/Zotero/storage/FDL644LK/Paulson - 2021 - Ackermann's Function in Iterative Form A Proof As.pdf}
}

@article{paulsonMachineAssistedProofOdel2014,
  title = {A {{Machine-Assisted Proof}} of {{G}}{\textbackslash}"odel's {{Incompleteness Theorems}} for the {{Theory}} of {{Hereditarily Finite Sets}}},
  author = {Paulson, Lawrence C.},
  year = {2014},
  month = sep,
  journal = {The Review of Symbolic Logic},
  volume = {7},
  number = {3},
  eprint = {2104.14260},
  pages = {484--498},
  issn = {1755-0203, 1755-0211},
  doi = {10.1017/S1755020314000112},
  urldate = {2021-04-30},
  abstract = {A formalisation of G{\textbackslash}"odel's incompleteness theorems using the Isabelle proof assistant is described. This is apparently the first mechanical verification of the second incompleteness theorem. The work closely follows \{{\textbackslash}'S\}wierczkowski (2003), who gave a detailed proof using hereditarily finite set theory. The adoption of this theory is generally beneficial, but it poses certain technical issues that do not arise for Peano arithmetic. The formalisation itself should be useful to logicians, particularly concerning the second incompleteness theorem, where existing proofs are lacking in detail.},
  archiveprefix = {arXiv},
  keywords = {68V20 03F40,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/BAD5TKVZ/Paulson - 2014 - A Machine-Assisted Proof of Godel's Incompletene.pdf;/home/flaviomoura/Zotero/storage/G7LFISGJ/2104.html}
}

@article{paulsonMechanisedProofGodel2015,
  title = {A {{Mechanised Proof}} of {{G{\"o}del}}'s {{Incompleteness Theorems Using Nominal Isabelle}}},
  author = {Paulson, Lawrence C.},
  year = {2015},
  journal = {J Autom Reasoning},
  volume = {55},
  number = {1},
  pages = {1--37},
  doi = {10.1007/s10817-015-9322-8}
}

@book{peixotoCorrectnessAKSPrimality2008,
  title = {The {{Correctness}} of the {{AKS Primality Test}} in {{Coq}}},
  author = {Peixoto, R. and de Moura, F. L. C.},
  year = {2008},
  annotation = {Published: Poster section of the XI Simp{\'o}sio Brasileiro de M{\'e}todos Formais (SBMF 2008)}
}

@article{pelayoHomotopyTypeTheory2012,
  title = {Homotopy Type Theory and {{Voevodsky}}'s Univalent Foundations},
  author = {Pelayo, A. and Warren, M. A.},
  year = {2012},
  journal = {CoRR},
  volume = {abs/1210.5658}
}

@article{pelayoPreliminaryUnivalentFormalization2013,
  title = {A Preliminary Univalent Formalization of the P-Adic Numbers},
  author = {Pelayo, A. and Voevodsky, V. and Warren, M. A.},
  year = {2013},
  journal = {CoRR},
  volume = {abs/1302.1207}
}

@book{peledSoftwareReliabilityMethods2001,
  title = {Software {{Reliability Methods}}},
  author = {Peled, Doron A.},
  year = {2001},
  series = {Texts in {{Computer Science}}},
  publisher = {Springer New York},
  address = {New York, NY},
  doi = {10.1007/978-1-4757-3540-6},
  urldate = {2020-08-26},
  isbn = {978-1-4419-2876-4 978-1-4757-3540-6}
}

@incollection{pelletierHistoryNaturalDeduction2012,
  ids = {pelletierHistoryNaturalDeduction2012a},
  title = {A {{History}} of {{Natural Deduction}}},
  booktitle = {Handbook of the {{History}} of {{Logic}}},
  author = {Pelletier, Francis Jeffry and Hazen, Allen P.},
  year = {2012},
  volume = {11},
  pages = {341--414},
  publisher = {Elsevier},
  doi = {10.1016/B978-0-444-52937-4.50007-1},
  urldate = {2020-07-04},
  isbn = {978-0-444-52937-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DVQFEUVY/PellHazenSubmittedv2.pdf;/home/flaviomoura/Zotero/storage/HRXX4NNU/Pelletier e Hazen - 2012 - A History of Natural Deduction.pdf}
}

@book{pereiraAdvancesNaturalDeduction2014,
  title = {Advances in {{Natural Deduction}}},
  author = {Pereira, L. C. and Haeusler, E. H. and de Paiva, V.},
  year = {2014},
  series = {Trends in {{Logic}}},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-007-7548-0}
}

@book{pereiraChapterNormalizationStrategies2024,
  title = {Chapter 7 {{Some Normalization Strategies}} for {{Classical Logic}} ({{Very First Draft}})},
  author = {Pereira, Luiz Carlos and De Paiva, Valeria and Pimentel, Elaine and Haeusler, Edward and Nascimento, Victor},
  year = {2024},
  month = jun,
  file = {/home/flaviomoura/Zotero/storage/WLQ7JFJ7/Pereira et al. - 2024 - Chapter 7 Some Normalization Strategies for Classi.pdf}
}

@incollection{pereiraConstructiveFragmentsClassical2015,
  title = {On {{Constructive Fragments}} of {{Classical Logic}}},
  booktitle = {Dag {{Prawitz}} on {{Proofs}} and {{Meaning}}},
  author = {Pereira, L. C. and Haeusler, E. H.},
  editor = {Wansing, Heinrich},
  year = {2015},
  pages = {281--292},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-11041-7_12},
  isbn = {978-3-319-11041-7},
  file = {/home/flaviomoura/Zotero/storage/9E33WYL8/Pereira and Haeusler - 2015 - On Constructive Fragments of Classical Logic.pdf}
}

@misc{pereiraTheoryPracticeDeductive2024,
  title = {The {{Theory}} and {{Practice}} of {{Deductive Verification}} of {{OCaml Programs}}},
  author = {Pereira, M{\'a}rio},
  year = {2024},
  month = apr,
  number = {arXiv:2404.17901},
  eprint = {2404.17901},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.17901},
  urldate = {2024-04-30},
  abstract = {Despite all the tremendous recent success of deductive verification, it is rarely the case that verification tools are applied to programs written in functional languages. When compared to the imperative world, there are only a handful of verification tools that can deal with functional programs. We believe the lack of pedagogical, problem-oriented documentation on how to use such tools might be one of the reasons behind this apparent mismatch between deductive verification and real-world functional software. In this paper, our goal is to drift away from this tendency. We chose the OCaml language as our working environment and provide a comprehensive, hands-on tutorial on how to apply different verification tools to OCaml-written programs. Our presentation takes an incremental approach: we first focus on purely functional programs; then on imperative programs, yet avoid pointers; finally, we use Separation Logic to reason about pointer-manipulating programs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/FQBSY3LH/Pereira - 2024 - The Theory and Practice of Deductive Verification .pdf;/home/flaviomoura/Zotero/storage/YRU9EQEY/2404.html}
}

@article{perroneNotesCategoryTheory2019,
  title = {Notes on {{Category Theory With Examples From Basic Mathematics}}},
  author = {Perrone, Paolo},
  year = {2019},
  journal = {CoRR},
  abstract = {These notes were originally developed as lecture notes for a category theory course. They should be well-suited to anyone that wants to learn category theory from scratch and has a scientific mind. There is no need to know advanced mathematics, nor any of the disciplines where category theory is traditionally applied, such as algebraic geometry or theoretical computer science. The only knowledge that is assumed from the reader is linear algebra. All concepts are explained by giving concrete examples from different, non-specialized areas of mathematics (such as basic group theory, graph theory, and probability). Not every example is helpful for every reader, but hopefully every reader can find at least one helpful example per concept. The reader is encouraged to read all the examples, this way they may even learn something new about a different field. Particular emphasis is given to the Yoneda lemma and its significance, with both intuitive explanations, detailed proofs, and specific examples. Another common theme in these notes is the relationship between categories and directed multigraphs, which is treated in detail. From the applied point of view, this shows why categorical thinking can help whenever some process is taking place on a graph. From the pure math point of view, this can be seen as the 1-dimensional first step into the theory of simplicial sets. Finally, monads and comonads are treated on an equal footing, differently to most literature in which comonads are often overlooked as "just the dual to monads". Theorems, interpretations and concrete examples are given for monads as well as for comonads.}
}

@book{perroneStartingCategoryTheory2024,
  title = {Starting {{Category Theory}}},
  author = {Perrone, Paolo},
  year = {2024},
  month = may,
  publisher = {WORLD SCIENTIFIC},
  doi = {10.1142/13670},
  urldate = {2024-04-19},
  isbn = {9789811286001 9789811286018},
  langid = {english}
}

@book{peterdybjerEpistemologyOntologyEssays2012,
  title = {Epistemology versus {{Ontology}}: {{Essays}} on the {{Philosophy}} and {{Foundations}} of {{Mathematics}} in {{Honour}} of {{Per Martin-L{\"o}f}}},
  author = {Peter Dybjer, Sten Lindstr{\"o}m, Erik Palmgren, G{\"o}ran Sundholm (eds.)},
  year = {2012},
  series = {Logic, {{Epistemology}}, and the {{Unity}} of {{Science}} 27},
  publisher = {Springer},
  isbn = {94-007-4434-X 978-94-007-4434-9 94-007-4435-8 978-94-007-4435-6}
}

@book{petersenMasteringEmacs2016,
  title = {Mastering {{Emacs}}},
  author = {Petersen, M.},
  year = {2016},
  publisher = {Mastering Emacs},
  file = {/home/flaviomoura/Zotero/storage/IKRB8T5W/mastering-emacs-v5.pdf;/home/flaviomoura/Zotero/storage/NFWZW33L/Petersen - 2016 - Mastering Emacs.pdf}
}

@book{petersGameTheory2015,
  title = {Game {{Theory}}},
  author = {Peters, Hans},
  year = {2015},
  series = {Springer {{Texts}} in {{Business}} and {{Economics}}},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-46950-7}
}

@inproceedings{petrovicUsingSmallStepRefinement2014,
  title = {Using {{Small-Step Refinement For Algorithm Verification In Computer Science Education}}},
  booktitle = {Joint {{Proceedings}} of the {{MathUI}}, {{OpenMath}} and {{ThEdu Workshops}} and {{Work}} in {{Progress}} Track at {{CICM}} Co-Located with {{Conferences}} on {{Intelligent Computer Mathematics}} ({{CICM}} 2014), {{Coimbra}}, {{Portugal}}, {{July}} 7-11, 2014.},
  author = {Petrovic, Danijela},
  year = {2014}
}

@inproceedings{pfenning1991unification,
  title = {Unification and Anti-Unification in the {{Calculus}} of {{Constructions}}},
  booktitle = {{{LICS}}},
  author = {Pfenning, Frank},
  year = {1991},
  volume = {91},
  pages = {74--85}
}

@book{pfenningAutomatedDeductionCADE212007,
  title = {Automated {{Deduction}} -- {{CADE-21}}: 21st {{International Conference}} on {{Automated Deduction Bremen}}, {{Germany}}, {{July}} 17-20, 2007 {{Proceedings}}},
  shorttitle = {Automated {{Deduction}} -- {{CADE-21}}},
  editor = {Pfenning, Frank},
  year = {2007},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {4603},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-73595-3},
  urldate = {2023-10-06},
  isbn = {978-3-540-73594-6 978-3-540-73595-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/58QE8WGF/Pfenning - 2007 - Automated Deduction â CADE-21 21st International .pdf}
}

@inproceedings{pfenningSystemDescriptionTwelf1999,
  title = {System Description: {{Twelf}} - {{A}} Metalogical Framework for Deductive Systems},
  booktitle = {16th {{International Conference}} on {{Automated Deduction}} ({{CADE-16}})},
  author = {Pfenning, F. and Sch{\"u}rmann, C.},
  year = {1999},
  series = {{{LNAI}}},
  volume = {1632},
  publisher = {Springer-Verlgar}
}

@misc{piedeleuIntroductionStringDiagrams2023,
  title = {An {{Introduction}} to {{String Diagrams}} for {{Computer Scientists}}},
  author = {Piedeleu, Robin and Zanasi, Fabio},
  year = {2023},
  month = nov,
  number = {arXiv:2305.08768},
  eprint = {2305.08768},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-11-23},
  abstract = {This document is an elementary introduction to string diagrams. It takes a computer science perspective: rather than using category theory as a starting point, we build on intuitions from formal language theory, treating string diagrams as a syntax with its semantics. After the basic theory, pointers are provided to contemporary applications of string diagrams in various fields of science.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/GU629ZJP/Piedeleu e Zanasi - 2023 - An Introduction to String Diagrams for Computer Sc.pdf;/home/flaviomoura/Zotero/storage/E78RQSX5/2305.html}
}

@article{pierceLambdaUltimateTA2009,
  title = {Lambda, the {{Ultimate TA}}: {{Using}} a {{Proof Assistant}} to {{Teach Programming Language Foundations}}},
  author = {Pierce, B. C.},
  year = {2009},
  journal = {SIGPLAN Not.},
  pages = {121--122},
  publisher = {ACM}
}

@book{pierceLogicalFoundations2018,
  title = {Logical {{Foundations}}},
  author = {Pierce, Benjamin C. and de Amorim, Arthur Azevedo and Casinghino, Chris and Gaboardi, Marco and Greenberg, Michael and Hri{\c t}cu, C{\v a}t{\v a}lin and Sj{\"o}berg, Vilhelm and Yorgey, Brent},
  year = {2018},
  month = may,
  series = {Software {{Foundations}} Series, Volume 1},
  publisher = {Electronic textbook}
}

@book{pierceProceedingsTLDI20122012,
  title = {Proceedings of {{TLDI}} 2012: {{The Seventh ACM SIGPLAN Workshop}} on {{Types}} in {{Languages Design}} and {{Implementation}}, {{Philadelphia}}, {{PA}}, {{USA}}, {{Saturday}}, {{January}} 28, 2012},
  editor = {Pierce, Benjamin C.},
  year = {2012},
  publisher = {ACM},
  isbn = {978-1-4503-1120-5}
}

@book{pierceSoftwareFoundations2014,
  title = {Software {{Foundations}}},
  author = {Pierce, Benjamin C. and Casinghino, Chris and Gaboardi, Marco and Greenberg, Michael and Hriatcu, Catvalin and Sjoberg, Vilhelm and Yorgey, Brent},
  year = {2014},
  publisher = {Electronic textbook}
}

@misc{PII0304397593,
  title = {{{PII}}: 0304-3975(93)90091-7 {\textbar} {{Elsevier Enhanced Reader}}},
  shorttitle = {{{PII}}},
  issn = {0304-3975},
  doi = {10.1016/0304-3975(93)90091-7},
  urldate = {2021-05-08},
  howpublished = {https://reader.elsevier.com/reader/sd/pii/0304397593900917?token=C455196D5A647B0F9CFADB36B59E34AA49325C37206473D2D3E05B2DCFE499B6B57E2CD5A20780F5C86FF0487E9F5740\&originRegion=us-east-1\&originCreation=20210508081017},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NF39GMQK/PII 0304-3975(93)90091-7  Elsevier Enhanced Read.pdf;/home/flaviomoura/Zotero/storage/MX5QH8ZU/0304397593900917.html}
}

@misc{PII0304397595,
  title = {{{PII}}: 0304-3975(95)00101-8 {\textbar} {{Elsevier Enhanced Reader}}},
  shorttitle = {{{PII}}},
  issn = {0304-3975},
  doi = {10.1016/0304-3975(95)00101-8},
  urldate = {2021-05-08},
  howpublished = {https://reader.elsevier.com/reader/sd/pii/0304397595001018?token=E284F52D74B4CB5C2C50743E219628699AFB4B665DDA8A345402EBD87FE41956E9FCCE93ABE45B60CD00DA54E258A451\&originRegion=us-east-1\&originCreation=20210508081652},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/5X7NDST4/0304397595001018.html;/home/flaviomoura/Zotero/storage/BWFA8GDE/0304397595001018.html}
}

@misc{pintoAbstractApproachGlivenko2016,
  title = {An Abstract Approach to {{Glivenko}}'s Theorem},
  author = {Pinto, Darllan Concei{\c c}{\~a}o and Mariano, Hugo Luiz},
  year = {2016},
  month = dec,
  number = {arXiv:1612.03410},
  eprint = {1612.03410},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2023-07-18},
  abstract = {The aim of this work is to provide a special kind of conservative translation between abstract logics, namely an abstract Glivenko's theorem. Firstly we define institutions on the categories of logic, algebraizable logics, and Lindenbaum algebraizable logic. In the sequel, we introduce the notion os Glivenko's context relating two algebraizable logics (respectively, Lindenbaum algebraizable logics) and we prove that for each Glivenko's context can be associated an institutions morphism between the corresponding logical institutions. As a consequence of the existence of such institutions morphisms, we have established abstract versions of Glivenko's theorem between those algebraizable logics (Lindenbaum algebraizable logics), generalizing the results presented in [Tor]. In particular, considering the institutions of classical logic and of intuitionistic logic, we build a Glivenko's context and thus an abstract Glivenko's theorem that is exactly the traditional Glivenko's theorem. Finally we present a category of algebraizable logic with Glivenko's context as morphisms. We can interpret the results of this work as an evidence of the (virtually unexplored) relevance of institution theory in the study of propositional logic.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {03B22 03G27 18C99,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/B646JU32/Pinto e Mariano - 2016 - An abstract approach to Glivenko's theorem.pdf}
}

@mastersthesis{pintoIntroducaoAnaliseCombinatoria2014,
  title = {Introdu{\c c}{\~a}o {\`a} {{An{\'a}lise Combinat{\'o}ria}}},
  author = {Pinto, R. C.},
  year = {2014},
  school = {PUC - Rio}
}

@article{pistoneNaturalityNaturalDeduction2019,
  title = {The {{Naturality}} of {{Natural Deduction}} ({{II}}). {{Some Remarks}} on {{Atomic Polymorphism}}},
  author = {Pistone, Paolo and Tranchini, Luca and Petrolo, Mattia},
  year = {2019},
  journal = {CoRR},
  abstract = {In this paper (which is a prosecution of "The naturality of natural deduction", Studia Logica 2019) we investigate the exact relationship between the Russell-Prawitz translation of intuitionistic propositional logic into intuitionistc second-order propositional logic (System F), and its variant proposed by Fernando Ferreira and Gilda Ferreira into the atomic fragment of System F (System Fat). In the previous paper we investigated the Russell-Prawitz translation via an extended equational theory for System F arising from its categorical semantics. The main result of this paper is that the Russell-Prawitz translation and Ferreira and Ferreira's translation are equivalent modulo this extended equational theory. This result highlights a close connection between our previous work and that of Ferreira and Ferreira. We argue however that the approach obtained by coupling the original Russell-Prawitz translation with our extended equational theory is more satisfactory for the study of proof identity than the one based on System Fat.}
}

@inproceedings{pit-claudelUntanglingMechanizedProofs2020,
  ids = {pit-claudelUntanglingMechanizedProofs2020a},
  title = {Untangling Mechanized Proofs},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Software Language Engineering}}},
  author = {{Pit-Claudel}, Cl{\'e}ment},
  year = {2020},
  month = nov,
  pages = {155--174},
  publisher = {ACM},
  address = {Virtual USA},
  doi = {10.1145/3426425.3426940},
  urldate = {2021-01-11},
  isbn = {978-1-4503-8176-5},
  langid = {english},
  keywords = {formal verification,literate programming,proof browsing,proof presentation},
  file = {/home/flaviomoura/Zotero/storage/43PSA3KW/Pit-Claudel - 2020 - Untangling mechanized proofs.pdf}
}

@book{pitmanProbability1993,
  title = {Probability},
  author = {Pitman, Jim},
  year = {1993},
  series = {[]},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4612-4374-8}
}

@book{pitt-francisGuideScientificComputing2017,
  title = {Guide to {{Scientific Computing}} in {{C}}++},
  author = {{Pitt-Francis}, Joe and Whiteley, Jonathan},
  year = {2017},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-73132-2}
}

@article{pittsAlphastructuralRecursionInduction2006,
  title = {Alpha-Structural Recursion and Induction},
  author = {Pitts, Andrew M.},
  year = {2006},
  month = may,
  journal = {Journal of the ACM},
  volume = {53},
  number = {3},
  pages = {459--506},
  issn = {0004-5411, 1557-735X},
  doi = {10.1145/1147954.1147961},
  urldate = {2023-10-05},
  abstract = {The               nominal               approach to abstract syntax deals with the issues of bound names and {$\alpha$}-equivalence by considering constructions and properties that are invariant with respect to permuting names. The use of permutations gives rise to an attractively simple formalization of common, but often technically incorrect uses of structural recursion and induction for abstract syntax modulo {$\alpha$}-equivalence. At the heart of this approach is the notion of               finitely supported               mathematical objects. This article explains the idea in as concrete a way as possible and gives a new derivation within higher-order classical logic of principles of {$\alpha$}-               structural               recursion and induction for {$\alpha$}-equivalence classes from the ordinary versions of these principles for abstract syntax trees.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/RAR5CE5E/Pitts - 2006 - Alpha-structural recursion and induction.pdf}
}

@article{pittsLocallyNamelessSets2023,
  title = {Locally {{Nameless Sets}}},
  author = {Pitts, Andrew M.},
  year = {2023},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {POPL},
  pages = {488--514},
  issn = {2475-1421},
  doi = {10.1145/3571210},
  urldate = {2023-02-06},
  abstract = {ANDREW M. PITTS, University of Cambridge, UK This paper provides a new mathematical foundation for the locally nameless representation of syntax with binders, one informed by nominal techniques. It gives an equational axiomatization of two key locally nameless operations, {\l}variable opening{\v z} and {\l}variable closing{\v z} and shows that a lot of the locally nameless infrastructure can be defined from that in a syntax-independent way, including crucially a {\l}shift{\v z} functor for name binding. That functor operates on a category whose objects we call locally nameless sets. Functors combining shift with sums and products have initial algebras that recover the usual locally nameless representation of syntax with binders in the finitary case. We demonstrate this by uniformly constructing such an initial locally nameless set for each instance of Plotkin's notion of binding signature. We also show by example that the shift functor is useful for locally nameless sets of a semantic rather than a syntactic character. The category of locally nameless sets is proved to be isomorphic to a known topos of finitely supported {$M$}-sets, where {$M$} is the full transformation monoid on a countably infinite set. A corollary of the proof is that several categories that have been used in the literature to model variable renaming operations on syntax with binders are all equivalent to each other and to the category of locally nameless sets. CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Categorical semantics; Equational logic and rewriting; Logic and verification; {$\bullet$} Software and its engineering {$\rightarrow$} Syntax.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/J8T4GVMR/Pitts - 2023 - Locally Nameless Sets.pdf;/home/flaviomoura/Zotero/storage/KNF9455V/Pitts - 2023 - Locally Nameless Sets.pdf}
}

@article{pittsNominalLogicFirst2003,
  title = {Nominal Logic, a First Order Theory of Names and Binding},
  author = {Pitts, Andrew M.},
  year = {2003},
  month = nov,
  journal = {Information and Computation},
  volume = {186},
  number = {2},
  pages = {165--193},
  issn = {08905401},
  doi = {10.1016/S0890-5401(03)00138-X},
  urldate = {2023-01-15},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/LYEMMEET/Pitts - 2003 - Nominal logic, a first order theory of names and b.pdf}
}

@article{pittsNominalTechniques2016,
  title = {Nominal Techniques},
  author = {Pitts, Andrew},
  year = {2016},
  month = feb,
  journal = {ACM SIGLOG News},
  volume = {3},
  number = {1},
  pages = {57--72},
  doi = {10.1145/2893582.2893594},
  urldate = {2024-09-06},
  abstract = {Programming languages abound with features making use of names in various ways. There is a mathematical foundation for the semantics of such features which uses groups of permutations of names and the notion of the support of an object with respect to the action of such a group. The relevance of this kind of mathematics for the semantics of names is perhaps not immediately obvious. That it is relevant and useful has emerged over the last 15 years or so in a body of work that has acquired its own name: nominal techniques. At the same time, the application of these techniques has broadened from semantics to computation theory in general. This article introduces the subject and is based upon a tutorial at LICS-ICALP 2015 [Pitts 2015a].}
}

@book{platoElementsLogicalReasoning2013,
  title = {Elements of Logical Reasoning},
  author = {von Plato, Jan},
  year = {2013},
  edition = {1. publ},
  publisher = {Cambridge University press},
  address = {Cambridge},
  abstract = {"Some of our earliest experiences of the conclusive force of an argument come from school mathematics: faced with a mathematical proof, we cannot deny the conclusion once the premisses have been accepted. Behind such arguments lies a more general pattern of 'demonstrative arguments' that is studied in the science of logic. Logical reasoning is applied at all levels, from everyday life to advanced sciences, and a remarkable level of complexity is achieved in everyday logical reasoning, even if the principles behind it remain intuitive. Jan von Plato provides an accessible but rigorous introduction to an important aspect of contemporary logic: its deductive machinery. He shows that when the forms of logical reasoning are analysed, it turns out that a limited set of first principles can represent any logical argument. His book will be valuable for students of logic, mathematics, and computer science"--},
  isbn = {978-1-107-03659-8 978-1-107-61077-4},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VMNFUNSR/Plato - 2013 - Elements of logical reasoning.pdf}
}

@article{platoKurtGODELFirst2018,
  title = {Kurt {{G{\"O}DEL}}'{{S First Steps}} in {{Logic}}: {{Formal Proofs}} in {{Arithmetic}} and {{Set Theory Through}} a {{System}} of {{Natural Deduction}}},
  author = {PLATO, JAN VON},
  year = {2018},
  journal = {The Bulletin of Symbolic Logic},
  volume = {24},
  number = {03},
  pages = {319--335},
  doi = {10.1017/bsl.2017.42}
}

@book{platoSavedCellar2017,
  title = {Saved from the {{Cellar}}},
  author = {von Plato, J.},
  year = {2017},
  series = {Sources and {{Studies}} in the {{History}} of {{Mathematics}} and {{Physical Sciences}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-42120-9}
}

@book{platzerAutomatedDeductionCADE2021,
  title = {Automated {{Deduction}} -- {{CADE}} 28: 28th {{International Conference}} on {{Automated Deduction}}, {{Virtual Event}}, {{July}} 12--15, 2021, {{Proceedings}}},
  shorttitle = {Automated {{Deduction}} -- {{CADE}} 28},
  editor = {Platzer, Andr{\'e} and Sutcliffe, Geoff},
  year = {2021},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {12699},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-030-79876-5},
  urldate = {2021-07-14},
  isbn = {978-3-030-79875-8 978-3-030-79876-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WNZLJYLD/Platzer e Sutcliffe - 2021 - Automated Deduction â CADE 28 28th International .pdf}
}

@book{platzerAutomatedDeductionCADE2021a,
  title = {Automated {{Deduction}} - {{CADE}} 28: 28th {{International Conference}} on {{Automated Deduction}}, {{Virtual Event}}, {{July}} 12--15, 2021, Proceedings},
  shorttitle = {Automated {{Deduction}} - {{CADE}} 28},
  editor = {Platzer, Andr{\'e} and Sutcliffe, Geoff},
  year = {2021},
  series = {Lecture {{Notes}} in {{Artificial Intelligence}}},
  number = {12699},
  publisher = {Springer},
  address = {Cham},
  isbn = {978-3-030-79876-5 978-3-030-79875-8},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/FEWDPNSR/Platzer e Sutcliffe - 2021 - Automated Deduction - CADE 28 28th International .pdf}
}

@book{platzerFormalMethods26th2025,
  title = {Formal {{Methods}}: 26th {{International Symposium}}, {{FM}} 2024, {{Milan}}, {{Italy}}, {{September}} 9--13, 2024, {{Proceedings}}, {{Part I}}},
  shorttitle = {Formal {{Methods}}},
  editor = {Platzer, Andr{\'e} and Rozier, Kristin Yvonne and Pradella, Matteo and Rossi, Matteo},
  year = {2025},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {14933},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-71162-6},
  urldate = {2024-09-26},
  copyright = {https://creativecommons.org/licenses/by/4.0},
  isbn = {978-3-031-71161-9 978-3-031-71162-6},
  langid = {english},
  keywords = {architecture verification and validation,artificial intelligence,computational complexity and cryptography,design and analysis of algorithms,embedded systems,formal languages and automata theory,formal logic,formal methods,machine learning,model checking,models of computation,Open Access,semantics and reasoning,software engineering,theory and algorithms for application domains},
  file = {/home/flaviomoura/Zotero/storage/7B7PNXVV/Platzer et al. - 2025 - Formal Methods 26th International Symposium, FM 2.pdf}
}

@book{platzerFormalMethods26th2025a,
  title = {Formal {{Methods}}: 26th {{International Symposium}}, {{FM}} 2024, {{Milan}}, {{Italy}}, {{September}} 9--13, 2024, {{Proceedings}}, {{Part II}}},
  shorttitle = {Formal {{Methods}}},
  editor = {Platzer, Andre and Rozier, Kristin Yvonne and Pradella, Matteo and Rossi, Matteo},
  year = {2025},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {14934},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-71177-0},
  urldate = {2024-09-26},
  copyright = {https://creativecommons.org/licenses/by/4.0},
  isbn = {978-3-031-71176-3 978-3-031-71177-0},
  langid = {english},
  keywords = {architecture verification and validation,artificial intelligence,computational complexity and cryptography,design and analysis of algorithms,embedded systems,formal languages and automata theory,formal logic,formal methods,machine learning,model checking,models of computation,Open Access,semantics and reasoning,software engineering,theory and algorithms for application domains},
  file = {/home/flaviomoura/Zotero/storage/R23QE2CV/Platzer et al. - 2025 - Formal Methods 26th International Symposium, FM 2.pdf}
}

@article{plotkinCallbyNameCallbyValueLambdaCalculus1975,
  title = {Call-by-{{Name}}, {{Call-by-Value}} and the Lambda-{{Calculus}}},
  author = {Plotkin, Gordon D.},
  year = {1975},
  journal = {Theor. Comput. Sci.},
  volume = {1},
  number = {2},
  pages = {125--159},
  doi = {10.1016/0304-3975(75)90017-1}
}

@misc{plotkinRecursionDoesNot2022,
  title = {Recursion Does Not Always Help},
  author = {Plotkin, Gordon},
  year = {2022},
  month = jun,
  number = {arXiv:2206.08413},
  eprint = {2206.08413},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2022-06-20},
  abstract = {We show that adding recursion does not increase the total numerical functions definable in the typed {$\lambda\beta\eta$}-calculus or the, possibly partial, numerical functions definable in the {$\lambda\Omega$}-calculus.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/EUTUEWWJ/Plotkin - 2022 - Recursion does not always help.pdf;/home/flaviomoura/Zotero/storage/F6HYECDR/Plotkin - 2022 - Recursion does not always help.pdf;/home/flaviomoura/Zotero/storage/APQ8SCNE/2206.html}
}

@inproceedings{plumpGraphUnificationMatching1994,
  title = {Graph {{Unification}} and {{Matching}}},
  booktitle = {{{TAGT}}},
  author = {Plump, D. and Habel, A.},
  year = {1994},
  pages = {75--88}
}

@inproceedings{pluskaEmbeddingIntuitionisticClassical,
  title = {Embedding {{Intuitionistic}} into {{Classical Logic}}},
  booktitle = {Proceedings of 24th {{International Conference}} on {{Logic}} for {{Programming}}, {{Artificial Intelligence}} and {{Reasoning}}},
  author = {Pluska, Alexander and Zuleger, Florian},
  pages = {329--307},
  doi = {10.29007/b294},
  urldate = {2023-06-08},
  abstract = {The famous double negation translation [16, 17] establishes an embedding of classical into intuitionistic logic. Curiously, the reverse direction has not been covered in literature. Utilizing a normal form for intuitionistic logic [20], we establish a small model property for intuitionistic propositional logic. We use this property for a direct encoding of the Kripke semantics into classical propositional logic and quantified Boolean formulae. Next, we transfer the developed techniques to the first order case and provide an embedding of intuitionistic first-order logic into classical first-order-logic. Our goal here is an encoding that facilitates the use of state-of-the-art provers for classical first-order logic for deter- mining intuitionistic validity. In an experimental evaluation, we show that our approach can compete with state-of-the-art provers for certain classes of benchmarks, in particular when the intuitionistic content is low. We further note that our constructions support the transfer of counter-models to validity, which is a desired feature in model checking applications.},
  file = {/home/flaviomoura/Zotero/storage/A2ITGKRE/Pluska e Zuleger - Embedding Intuitionistic into Classical Logic.pdf}
}

@book{pohlersProofTheoryFirst2009,
  title = {Proof {{Theory}} - {{A}} First Step into Impredicativity},
  author = {Pohlers, W.},
  year = {2009},
  series = {Universitext},
  publisher = {Springer Verlag},
  doi = {10.1007/978-3-540-69319-2}
}

@article{pollackHowBelieveMachineChecked,
  title = {How to {{Believe}} a {{Machine-Checked Proof}}},
  author = {Pollack, Robert},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/5XVALJDG/Pollack - How to Believe a Machine-Checked Proof.pdf}
}

@book{polyaHowSolveIt1971,
  title = {How to {{Solve It}}},
  author = {Polya, G.},
  year = {1971},
  month = nov,
  publisher = {Princeton University Press},
  abstract = {A perennial bestseller by eminent mathematician G. Polya, \emph{How to Solve It} will show anyone in any field how to think straight.{$<$}P{$>$}In lucid and appealing prose, Polya reveals how the mathematical method of demonstrating a proof or finding an unknown can be of help in attacking any problem that can be "reasoned" out--from building a bridge to winning a game of anagrams. Generations of readers have relished Polya's deft--indeed, brilliant--instructions on stripping away irrelevancies and going straight to the heart of the problem.{$<$}P{$>$}},
  isbn = {0-691-02356-5},
  keywords = {algorithms,math},
  annotation = {Published: Paperback}
}

@article{popescuCoConConferenceManagement2021,
  title = {{{CoCon}}: {{A Conference Management System}} with {{Formally Verified Document Confidentiality}}},
  shorttitle = {{{CoCon}}},
  author = {Popescu, Andrei and Lammich, Peter and Hou, Ping},
  year = {2021},
  month = feb,
  journal = {Journal of Automated Reasoning},
  volume = {65},
  number = {2},
  pages = {321--356},
  issn = {1573-0670},
  doi = {10.1007/s10817-020-09566-9},
  urldate = {2023-10-21},
  abstract = {We present a case study in formally verified security for realistic systems: the information flow security verification of the functional kernel of a web application, the CoCon conference management system. We use the Isabelle theorem prover to specify and verify fine-grained confidentiality properties, as well as complementary safety and ``traceback'' properties. The challenges posed by this development in terms of expressiveness have led to bounded-deducibility security, a novel security model and verification method generally applicable to systems describable as input/output automata.},
  langid = {english},
  keywords = {Conference Management System,Confidentiality,Information-Flow Security,Isabelle/HOL,Theorem Proving,Unwinding Proof Method},
  file = {/home/flaviomoura/Zotero/storage/BM55CCSJ/Popescu et al. - 2021 - CoCon A Conference Management System with Formall.pdf}
}

@phdthesis{popescuContributionsTheorySyntax2011,
  title = {Contributions to the Theory of Syntax with Bindings and to Process Algebra},
  author = {Popescu, Andrei},
  year = {2011},
  month = jan,
  urldate = {2023-11-28},
  copyright = {Copyright 2010 Andrei Popescu},
  school = {University of Illinois at Urbana-Champaign},
  file = {/home/flaviomoura/Zotero/storage/W823BV7A/Popescu - 2011 - Contributions to the theory of syntax with binding.pdf}
}

@misc{popescuNominalRecursorsEpiRecursors2023,
  title = {Nominal {{Recursors}} as {{Epi-Recursors}}: {{Extended Technical Report}}},
  shorttitle = {Nominal {{Recursors}} as {{Epi-Recursors}}},
  author = {Popescu, Andrei},
  year = {2023},
  month = nov,
  number = {arXiv:2301.00894},
  eprint = {2301.00894},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-02-19},
  abstract = {We study nominal recursors from the literature on syntax with bindings and compare them with respect to expressiveness. The term "nominal" refers to the fact that these recursors operate on a syntax representation where the names of bound variables appear explicitly, as in nominal logic. We argue that nominal recursors can be viewed as epi-recursors, a concept that captures abstractly the distinction between the constructors on which one actually recurses, and other operators and properties that further underpin recursion.We develop an abstract framework for comparing epi-recursors and instantiate it to the existing nominal recursors, and also to several recursors obtained from them by cross-pollination. The resulted expressiveness hierarchies depend on how strictly we perform this comparison, and bring insight into the relative merits of different axiomatizations of syntax. We also apply our methodology to produce an expressiveness hierarchy of nominal corecursors, which are principles for defining functions targeting infinitary non-well-founded terms (which underlie lambda-calculus semantics concepts such as B{\textbackslash}"ohm trees). Our results are validated with the Isabelle/HOL theorem prover.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,D.3,F.3,F.4},
  file = {/home/flaviomoura/Zotero/storage/QDTKQHUJ/Popescu - 2023 - Nominal Recursors as Epi-Recursors Extended Techn.pdf;/home/flaviomoura/Zotero/storage/T2LIZJHG/2301.html}
}

@article{popescuNominalRecursorsEpiRecursors2024,
  title = {Nominal {{Recursors}} as {{Epi-Recursors}}},
  author = {Popescu, Andrei},
  year = {2024},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {8},
  number = {POPL},
  pages = {425--456},
  issn = {2475-1421},
  doi = {10.1145/3632857},
  urldate = {2024-02-19},
  abstract = {We study nominal recursors from the literature on syntax with bindings and compare them with respect to expressiveness. The term "nominal" refers to the fact that these recursors operate on a syntax representation where the names of bound variables appear explicitly, as in nominal logic. We argue that nominal recursors can be viewed as epi-recursors, a concept that captures abstractly the distinction between the constructors on which one actually recurses, and other operators and properties that further underpin recursion. We develop an abstract framework for comparing epi-recursors and instantiate it to the existing nominal recursors, and also to several recursors obtained from them by cross-pollination. The resulted expressiveness hierarchies depend on how strictly we perform this comparison, and bring insight into the relative merits of different axiomatizations of syntax. We also apply our methodology to produce an expressiveness hierarchy of nominal corecursors, which are principles for defining functions targeting infinitary non-well-founded terms (which underlie lambda-calculus semantics concepts such as B{\"o}hm trees). Our results are validated with the Isabelle/HOL theorem prover.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/X4DWCQWJ/Popescu - 2024 - Nominal Recursors as Epi-Recursors.pdf}
}

@article{popescuRecursionPrinciplesSyntax,
  title = {Recursion Principles for Syntax with Bindings and Substitution},
  author = {Popescu, Andrei and Gunter, Elsa L},
  abstract = {We characterize the data type of terms with bindings, freshness and substitution, as an initial model in a suitable Horn theory. This characterization yields a convenient recursive definition principle, which we have formalized in Isabelle/HOL and employed in a series of case studies taken from the {$\lambda$}-calculus literature.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/R2PF46PQ/Popescu e Gunter - Recursion principles for syntax with bindings and .pdf}
}

@article{popescuRensetsRenamingBasedRecursion2023,
  title = {Rensets and {{Renaming-Based Recursion}} for {{Syntax}} with {{Bindings Extended Version}}},
  author = {Popescu, Andrei},
  year = {2023},
  month = jul,
  journal = {Journal of Automated Reasoning},
  volume = {67},
  number = {3},
  pages = {23},
  issn = {1573-0670},
  doi = {10.1007/s10817-023-09672-4},
  urldate = {2024-04-23},
  abstract = {We introduce renaming-enriched sets (rensets for short), which are algebraic structures axiomatizing fundamental properties of renaming (also known as variable-for-variable substitution) on syntax with bindings. Rensets compare favorably in some respects with the well-known foundation based on nominal sets. In particular, renaming is a more fundamental operator than the nominal swapping operator and enjoys a simpler, equationally expressed relationship with the variable-freshness predicate. Together with some natural axioms matching properties of the syntactic constructors, rensets yield a truly minimalistic characterization of \$\${\textbackslash}lambda \$\$-calculus terms as an abstract datatype---one involving an infinite set of unconditional equations, referring only to the most fundamental term operators: the constructors and renaming. This characterization yields a recursion principle, which (similarly to the case of nominal sets) can be improved by incorporating Barendregt's variable convention. When interpreting syntax in semantic domains, our renaming-based recursor is easier to deploy than the nominal recursor. Our results have been validated with the proof assistant Isabelle/HOL.},
  langid = {english},
  keywords = {Recursion principle,Renaming,Substitution,Syntax with bindings},
  file = {/home/flaviomoura/Zotero/storage/24ZA9T4E/Popescu - 2023 - Rensets and Renaming-Based Recursion for Syntax wi.pdf}
}

@inproceedings{popescuStrongNormalizationSystem2010,
  title = {Strong {{Normalization}} for {{System F}} by {{HOAS}} on {{Top}} of {{FOAS}}},
  booktitle = {2010 25th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  author = {Popescu, Andrei and Gunter, Elsa L. and Osborn, Christopher J.},
  year = {2010},
  month = jul,
  pages = {31--40},
  publisher = {IEEE},
  address = {Edinburgh, United Kingdom},
  doi = {10.1109/LICS.2010.48},
  urldate = {2024-02-19},
  abstract = {We present a point of view concerning HOAS (Higher-Order Abstract Syntax) and an extensive exercise in HOAS along this point of view. The point of view is that HOAS can be soundly and fruitfully regarded as a definitional extension on top of FOAS (First-Order Abstract Syntax). As such, HOAS is not only an encoding technique, but also a higher-order view of a first-order reality. A rich collection of concepts and proof principles is developed inside the standard mathematical universe to give technical life to this point of view. The exercise consists of a new proof of Strong Normalization for System F. The concepts and results presented here have been formalized in the theorem prover Isabelle/HOL.},
  isbn = {978-1-4244-7588-9},
  langid = {english},
  keywords = {Cognition,Construction industry,Context,Encoding,Equations,Higher-Order Abstract Syntax,Isabelle/HOL,Syntactics,System F},
  file = {/home/flaviomoura/Zotero/storage/M58K7MQ2/Popescu et al. - 2010 - Strong Normalization for System F by HOAS on Top o.pdf;/home/flaviomoura/Zotero/storage/ZINN75P4/Popescu et al. - 2010 - Strong Normalization for System F by HOAS on Top o.pdf;/home/flaviomoura/Zotero/storage/WPMBXRFL/5571067.html}
}

@book{porterLearnAIAssistedPython2024,
  title = {Learn {{AI-Assisted Python Programming}}: {{With Github Copilot}} and {{ChatGPT}}},
  author = {Porter, Leo},
  year = {2024},
  publisher = {{Simon and Schuster}},
  file = {/home/flaviomoura/Zotero/storage/QWDGRLFW/Porter - 2024 - Learn AI-Assisted Python Programming With Github .pdf}
}

@article{postVariantRecursivelyUnsolvable1946,
  title = {A Variant of a Recursively Unsolvable Problem},
  author = {Post, E. L.},
  year = {1946},
  month = apr,
  journal = {Bulletin of the American Mathematical Society},
  volume = {52},
  number = {4},
  pages = {264--268},
  publisher = {American Mathematical Society},
  file = {/home/flaviomoura/Zotero/storage/4FFKUNLY/Post - 1946 - A variant of a recursively unsolvable problem.pdf}
}

@article{pottierDepthFirstSearchStrong,
  title = {Depth-{{First Search}} and {{Strong Connectivity}} in {{Coq}}},
  author = {Pottier, Fran{\c c}ois},
  pages = {15},
  abstract = {Using Coq, we mechanize Wegener's proof of Kosaraju's linear-time algorithm for computing the strongly connected components of a directed graph. Furthermore, also in Coq, we define an executable and terminating depth-first search algorithm.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SPA5JFRR/Pottier - Depth-First Search and Strong Connectivity in Coq.pdf;/home/flaviomoura/Zotero/storage/VB8BKK94/Pottier - Depth-First Search and Strong Connectivity in Coq.pdf}
}

@inproceedings{pottierDepthFirstSearchStrong2015,
  title = {Depth-{{First Search}} and {{Strong Connectivity}} in {{Coq}}},
  booktitle = {Vingt-Sixi{\`e}mes Journ{\'e}es Francophones Des Langages Applicatifs ({{JFLA}} 2015)},
  author = {Pottier, Fran{\c c}ois},
  year = {2015},
  month = jan,
  urldate = {2024-04-05},
  abstract = {Using Coq, we mechanize Wegener's proof of Kosaraju's linear-time algorithm for computing the strongly connected components of a directed graph. Furthermore, also in Coq, we define an executable and terminating depth-first search algorithm.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/KWY6RHLH/Pottier - 2015 - Depth-First Search and Strong Connectivity in Coq.pdf}
}

@article{pottierHindleymilnerElaborationApplicative2014,
  title = {Hindley-Milner Elaboration in Applicative Style: Functional Pearl},
  shorttitle = {Hindley-Milner Elaboration in Applicative Style},
  author = {Pottier, Fran{\c c}ois},
  year = {2014},
  month = aug,
  journal = {ACM SIGPLAN Notices},
  volume = {49},
  number = {9},
  pages = {203--212},
  issn = {0362-1340},
  doi = {10.1145/2692915.2628145},
  urldate = {2024-04-05},
  abstract = {Type inference - the problem of determining whether a program is well-typed - is well-understood. In contrast, elaboration - the task of constructing an explicitly-typed representation of the program - seems to have received relatively little attention, even though, in a non-local type inference system, it is non-trivial. We show that the constraint-based presentation of Hindley-Milner type inference can be extended to deal with elaboration, while preserving its elegance. This involves introducing a new notion of "constraint with a value", which forms an applicative functor.},
  keywords = {constraints,elaboration,polymorphism,type inference},
  file = {/home/flaviomoura/Zotero/storage/XMYP68C3/Pottier - 2014 - Hindley-milner elaboration in applicative style f.pdf}
}

@article{pottierThunksDebitsSeparation2024,
  title = {Thunks and {{Debits}} in {{Separation Logic}} with {{Time Credits}}},
  author = {Pottier, Fran{\c c}ois and Gu{\'e}neau, Arma{\"e}l and Jourdan, Jacques-Henri and M{\'e}vel, Glen},
  year = {2024},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {8},
  number = {POPL},
  pages = {50:1482--50:1508},
  doi = {10.1145/3632892},
  urldate = {2024-06-14},
  abstract = {A thunk is a mutable data structure that offers a simple memoization service: it stores either a suspended computation or the result of this computation. Okasaki [1999] presents many data structures that exploit thunks to achieve good amortized time complexity. He analyzes their complexity by associating a debit with every thunk. A debit can be paid off in several increments; a thunk whose debit has been fully paid off can be forced. Quite strikingly, a debit is associated also with future thunks, which do not yet exist in memory. Some of the debit of a faraway future thunk can be transferred to a nearer future thunk. We present a complete machine-checked reconstruction of Okasaki's reasoning rules in Iris\$, a rich separation logic with time credits. We demonstrate the applicability of the rules by verifying a few operations on streams as well as several of Okasaki's data structures, namely the physicist's queue, implicit queues, and the banker's queue.},
  keywords = {program verification,separation logic,time complexity},
  file = {/home/flaviomoura/Zotero/storage/38PDG6XD/Pottier et al. - 2024 - Thunks and Debits in Separation Logic with Time Cr.pdf;/home/flaviomoura/Zotero/storage/KE4XB8MN/Pottier et al. - 2024 - Thunks and Debits in Separation Logic with Time Cr.pdf}
}

@inproceedings{pouillardNamelessPainless2011,
  title = {Nameless, Painless},
  booktitle = {Proceedings of the 16th {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Pouillard, Nicolas},
  year = {2011},
  month = sep,
  series = {{{ICFP}} '11},
  pages = {320--332},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/2034773.2034817},
  urldate = {2024-04-05},
  abstract = {De Bruijn indices are a well known technique for programming with names and binders. They provide a representation that is both simple and canonical. However, programming errors tend to be really easy to make. We propose a safer programming interface implemented as a library. Whereas indexing the types of names and terms by a numerical bound is a famous technique, we index them by worlds, a different notion of index that is both finer and more abstract. While being more finely typed, our approach incurs no loss of expressiveness or efficiency. Via parametricity we obtain properties about functions polymorphic on worlds. For instance, well-typed world-polymorphic functions over open {$\lambda$}-terms commute with any renaming of the free variables. Our whole development is conducted within Agda, from the code of the library, to its soundness proof and the properties of external functions. The soundness of our library is demonstrated via the construction of a logical relations argument.},
  isbn = {978-1-4503-0865-6},
  keywords = {binders,de bruijn indices,meta-programming,name abstraction,names},
  file = {/home/flaviomoura/Zotero/storage/HEWLAWX9/Pouillard - 2011 - Nameless, painless.pdf}
}

@article{pouillardUnifiedTreatmentSyntax2012,
  title = {A Unified Treatment of Syntax with Binders},
  author = {Pouillard, Nicolas and Pottier, Fran{\c c}ois},
  year = {2012},
  month = sep,
  journal = {Journal of Functional Programming},
  volume = {22},
  number = {4-5},
  pages = {614--704},
  issn = {1469-7653, 0956-7968},
  doi = {10.1017/S0956796812000251},
  urldate = {2024-04-05},
  abstract = {Atoms and de Bruijn indices are two well-known representation techniques for data structures that involve names and binders. However, using either technique, it is all too easy to make a programming error that causes one name to be used where another was intended. We propose an abstract interface to names and binders that rules out many of these errors. This interface is implemented as a library in Agda. It allows defining and manipulating term representations in nominal style and in de Bruijn style. The programmer is not forced to choose between these styles: on the contrary, the library allows using both styles in the same program, if desired. Whereas indexing the types of names and terms with a natural number is a well-known technique to better control the use of de Bruijn indices, we index types with worlds. Worlds are at the same time more precise and more abstract than natural numbers. Via logical relations and parametricity, we are able to demonstrate in what sense our library is safe, and to obtain theorems for free about world-polymorphic functions. For instance, we prove that a world-polymorphic term transformation function must commute with any renaming of the free variables. The proof is entirely carried out in Agda.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/V98C98WQ/Pouillard e Pottier - 2012 - A unified treatment of syntax with binders.pdf}
}

@article{powellComputationalContentZorn2020,
  title = {On the Computational Content of {{Zorn}}'s Lemma},
  author = {Powell, Thomas},
  year = {2020},
  month = jul,
  journal = {Proceedings of the 35th Annual ACM/IEEE Symposium on Logic in Computer Science},
  eprint = {2001.03540},
  pages = {768--781},
  doi = {10.1145/3373718.3394745},
  urldate = {2021-04-28},
  abstract = {We give a computational interpretation to an abstract instance of Zorn's lemma formulated as a wellfoundedness principle in the language of arithmetic in all finite types. This is achieved through G{\textbackslash}"odel's functional interpretation, and requires the introduction of a novel form of recursion over non-wellfounded partial orders whose existence in the model of total continuous functionals is proven using domain theoretic techniques. We show that a realizer for the functional interpretation of open induction over the lexicographic ordering on sequences follows as a simple application of our main results.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/5LY2TJPT/Powell - 2020 - On the computational content of Zorn's lemma.pdf;/home/flaviomoura/Zotero/storage/R2QYYT9X/2001.html}
}

@article{powellDependentChoiceTermination2019,
  title = {Dependent {{Choice As}} a {{Termination Principle}}},
  author = {Powell, Thomas},
  year = {2019},
  journal = {CoRR},
  abstract = {We introduce a new formulation of the axiom of dependent choice that can be viewed as an abstract termination principle, which generalises the recursive path orderings used to establish termination of rewrite systems. We consider several variants of our termination principle, and relate them to general termination theorems in the literature.}
}

@article{powellLimitsComputation2021,
  title = {The {{Limits}} of {{Computation}}},
  author = {Powell, Andrew},
  year = {2021},
  month = may,
  journal = {Axiomathes},
  issn = {1122-1151, 1572-8390},
  doi = {10.1007/s10516-021-09561-8},
  urldate = {2021-06-01},
  abstract = {This article provides a survey of key papers that characterise computable functions, but also provides some novel insights as follows. It is argued that the power of algorithms is at least as strong as functions that can be proved to be totally computable in type-theoretic translations of subsystems of second-order Zermelo Fraenkel set theory. Moreover, it is claimed that typed systems of the lambda calculus give rise naturally to a functional interpretation of rich systems of types and to a hierarchy of ordinal recursive functionals of arbitrary type that can be reduced by substitution to natural number functions.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9SVN6GLI/Powell - 2021 - The Limits of Computation.pdf}
}

@article{prattEveryPrimeHas1975,
  title = {Every Prime Has a Succinct Certificate},
  author = {Pratt, V.},
  year = {1975},
  journal = {SIAM journal on Computing},
  number = {4},
  pages = {214--220}
}

@incollection{prawitzSurveyConnectionsClassical1968,
  title = {A {{Survey}} of {{Some Connections Between Classical}}, {{Intuitionistic}} and {{Minimal Logic}}},
  booktitle = {Studies in {{Logic}} and the {{Foundations}} of {{Mathematics}}},
  author = {Prawitz, D. and Malmn{\"a}s, P. -E.},
  editor = {Schmidt, H. Arnold and Sch{\"u}tte, K. and Thiele, H. -J.},
  year = {1968},
  month = jan,
  series = {Contributions to {{Mathematical Logic}}},
  volume = {50},
  pages = {215--229},
  publisher = {Elsevier},
  doi = {10.1016/S0049-237X(08)70527-5},
  urldate = {2024-07-06},
  abstract = {This chapter discusses the relationships among classical, intuitionistic and minimal logic. Classical logic is interpretable (also interpretable with respect to derivability) in intuitionistic and minimal logic by the translation absurdity, conjunctions, implications, and universal formulas. If the intuitionistic natural number theory is consistent, then the classical natural number theory is also consistent. Intuitionistic predicate logic is interpretable (also interpretable with respect to derivability) in classical predicate logic. A classical argument can be understood intuitionistically, if the formulas are interpreted throughout in the weak sense, that is, classical logic can be interpreted in intuitionistic logic by a translation that successively replaces classical formulas by their double negation. The chapter suggests that the axioms for classical and intuitionistic natural number theory are the same.},
  file = {/home/flaviomoura/Zotero/storage/FAAHTBC8/Prawitz e MalmnÃ¤s - 1968 - A Survey of Some Connections Between Classical, In.pdf;/home/flaviomoura/Zotero/storage/LQRI8QAM/S0049237X08705275.html}
}

@book{priceExtractingComputationalLogic2024,
  title = {Extracting {{Computational Logic}} from {{Legal Text}}: {{A Decision Support Approach}} for {{Public Sector Automation}}},
  shorttitle = {Extracting {{Computational Logic}} from {{Legal Text}}},
  author = {Price, Simon and Bertl, Markus},
  year = {2024},
  month = mar,
  doi = {10.13140/RG.2.2.31797.28649},
  abstract = {This research presents first steps towards a generic approach to automatically translating legal text into machine-executable computational logic. We demonstrate how this approach can be used to automate public sector processes. Since automation of legal processes is a high-risk application of AI, we use explainable AI based on natural language processing using scope-restricted pattern matching and grammatical parsing. Our approach consists of document structure inference from the raw legal text, semantically neutral pre-processing, recognition of internal and external references, target resolution for internal references, paragraph contextualization and, finally, rule extraction. Extracted rules are converted to Prolog predicates and visualized as textual lists and graphical decision trees. Our developed Law as Code prototype has been evaluated as a proof-of-concept at the Austrian Ministry of Finance and successfully demonstrated the automatic extraction of explainable rules from the Austrian Study Funding Act. This validates our approach and suggests promising future research directions, most notably the prospect of integrating Large Language Models (LLMs) into the rule extraction process, while retaining provenance and explainability.},
  file = {/home/flaviomoura/Zotero/storage/FA6WAVZ7/Price e Bertl - 2024 - Extracting Computational Logic from Legal Text A .pdf}
}

@article{pricePentiumFdivFlawLessons1995,
  title = {Pentium {{Fdiv Flaw-Lessons Learned}}},
  author = {Price, D.},
  year = {1995},
  journal = {IEEE Micro},
  volume = {15},
  number = {2},
  pages = {86--88},
  doi = {10.1109/40.372360}
}

@book{Proceedings11thAnnual1996,
  title = {Proceedings, 11th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{New Brunswick}}, {{New Jersey}}, {{USA}}, {{July}} 27-30, 1996},
  year = {1996},
  publisher = {IEEE Computer Society},
  isbn = {0-8186-7463-6}
}

@book{Proceedings26thAnnual2011,
  title = {Proceedings of the 26th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{LICS}} 2011, {{June}} 21-24, 2011, {{Toronto}}, {{Ontario}}, {{Canada}}},
  year = {2011},
  publisher = {IEEE Computer Society},
  isbn = {978-0-7695-4412-0}
}

@misc{Proceedings37thAnnual,
  title = {Proceedings of the 37th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}} {\textbar} {{ACM Conferences}}},
  urldate = {2024-03-23},
  howpublished = {https://dl.acm.org/doi/proceedings/10.1145/3531130},
  file = {/home/flaviomoura/Zotero/storage/35XWJI3Z/3531130.html}
}

@book{Proceedings9thInternational2020,
  title = {Proceedings of the 9th {{International Workshop}} on {{Confluence}}, {{IWC}} 2020},
  year = {2020}
}

@book{ProceedingsSeventhAnnual1992,
  title = {Proceedings of the {{Seventh Annual Symposium}} on {{Logic}} in {{Computer Science}} ({{LICS}} '92), {{Santa Cruz}}, {{California}}, {{USA}}, {{June}} 22-25, 1992},
  year = {1992},
  publisher = {IEEE Computer Society},
  isbn = {0-8186-2735-2}
}

@techreport{programHomotopyTypeTheory2013,
  title = {Homotopy Type Theory: {{Univalent}} Foundations of Mathematics},
  author = {Program, The Univalent Foundations},
  year = {2013},
  institution = {Institute for Advanced Study}
}

@misc{ProgrammingLanguagesSystems,
  title = {Programming {{Languages}} and {{Systems}}: 33rd {{European Symposium}} on {{Programming}}, {{ESOP}} 2024, {{Held}} as {{Part}} of the {{European Joint Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2024, {{Luxembourg City}}, {{Luxembourg}}, {{April}} 6--11, 2024, {{Proceedings}}, {{Part I}} {\textbar} {{SpringerLink}}},
  urldate = {2024-04-08},
  howpublished = {https://link.springer.com/book/10.1007/978-3-031-57262-3},
  file = {/home/flaviomoura/Zotero/storage/QHKN2R3L/Programming Languages and Systems 33rd European S.pdf;/home/flaviomoura/Zotero/storage/2M3M86MX/978-3-031-57262-3.html}
}

@book{ProgrammingLanguagesSystemsa,
  title = {Programming {{Languages}} and {{Systems}}},
  urldate = {2024-04-08},
  abstract = {The open access ESOP 2024 proceedings focus on fundamental issues in the specification, design, analysis, implementation of programming languages systems.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/M336TQDZ/Programming Languages and Systems.pdf;/home/flaviomoura/Zotero/storage/MMHQLS37/978-3-031-57267-8.html}
}

@misc{PrologNext50,
  title = {Prolog: {{The Next}} 50 {{Years}} {\textbar} {{SpringerLink}}},
  urldate = {2024-04-08},
  howpublished = {https://link.springer.com/book/10.1007/978-3-031-35254-6\#page=391},
  file = {/home/flaviomoura/Zotero/storage/X2H5YZF3/978-3-031-35254-6.html}
}

@misc{PropertyShufflingCalculus,
  title = {Z Property for the Shuffling Calculus {\textbar} {{Mathematical Structures}} in {{Computer Science}} {\textbar} {{Cambridge Core}}},
  urldate = {2024-10-09},
  howpublished = {https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/z-property-for-the-shuffling-calculus/FC6BFF5D10E789FC8010BD9B0BA911D7},
  file = {/home/flaviomoura/Zotero/storage/LBU3G66N/Z property for the shuffling calculus  Mathematic.pdf;/home/flaviomoura/Zotero/storage/WB5ES69J/FC6BFF5D10E789FC8010BD9B0BA911D7.html}
}

@article{przybylekSetsAtomsDefinability2021,
  title = {Beyond Sets with Atoms: Definability in First Order Logic},
  shorttitle = {Beyond Sets with Atoms},
  author = {Przyby{\l}ek, Micha{\l} R.},
  year = {2021},
  month = jan,
  journal = {arXiv:2003.04803 [cs]},
  eprint = {2003.04803},
  primaryclass = {cs},
  urldate = {2021-01-26},
  abstract = {Sets with atoms serve as an alternative to ZFC foundations for mathematics, where some infinite, though highly symmetric sets, behave in a finitistic way. Therefore, one can try to carry over analysis of the classical algorithms from finite structures to some infinite structures. Recent results show that this is indeed possible and leads to many practical applications. In this paper we shall take another route to finite analysis of infinite sets, which extends and sheds more light on sets with atoms. As an application of our theory we give a characterisation of languages recognized by automata definable in fragments of first-order logic.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/FXP59JZT/PrzybyÅek - 2021 - Beyond sets with atoms definability in first orde.pdf;/home/flaviomoura/Zotero/storage/69NJ8RWR/2003.html}
}

@phdthesis{raamsdonkConfluenceNormalizationHigherOrder1996,
  title = {Confluence and {{Normalization}} for {{Higher-Order Rewriting}}},
  author = {van Raamsdonk, F.},
  year = {1996},
  address = {Netherlands},
  school = {Amsterdam University}
}

@inproceedings{raamsdonkConfluenceSuperdevelopments1993,
  title = {Confluence and {{Superdevelopments}}},
  booktitle = {{{RTA}}},
  author = {van Raamsdonk, F.},
  year = {1993},
  pages = {168--182}
}

@book{raamsdonkLogicalVerification2011,
  title = {Logical {{Verification}}},
  author = {van Raamsdonk, F.},
  year = {2011},
  annotation = {Published: Vrije Universiteit Amsterdam}
}

@techreport{raamsdonkNormalisation1995,
  title = {On {{Normalisation}}},
  author = {van Raamsdonk, F. and Severi, P.},
  year = {1995},
  institution = {CWI}
}

@article{raamsdonkPerpetualReductionsInlcalculus1999,
  title = {Perpetual {{Reductions In$\lambda$-calculus}}},
  author = {van Raamsdonk, F. and Severi, P. and S{\o}rensen, M. H. B. and Xi, H.},
  year = {1999},
  journal = {Information and Computation},
  volume = {149},
  number = {2},
  pages = {173--225},
  doi = {10.1006/inco.1998.2750},
  file = {/home/flaviomoura/Zotero/storage/5AAUVFMA/van Raamsdonk et al. - 1999 - Perpetual Reductions inÎ»-Calculus.pdf;/home/flaviomoura/Zotero/storage/JJFYR3WV/S089054019892750X.html}
}

@article{rabeModelTheoryDependentlyTyped,
  title = {Model {{Theory}} for {{Dependently-Typed Higher-Order Logic}}},
  author = {Rabe, Florian},
  abstract = {Both higher-order logic and dependent types are popular features for expressive languages for automated reasoning. Recently DHOL was introduced as a language that provides the expressivity of dependent types while retaining the simplicity of higher-order logic. DHOL was introduced with a proof system and a translation to HOL, but it lacked a model-theoretical semantics.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/K2FY63SF/Rabe - Model Theory for Dependently-Typed Higher-Order Lo.pdf}
}

@article{rabeProceedingsWorkshopLogical,
  title = {Proceedings {{Workshop}} on {{Logical Frameworks}} and {{Meta-Languages}}: {{Theory}} and {{Practice}}},
  shorttitle = {Proceedings {{Workshop}} on {{Logical Frameworks}} and {{Meta-Languages}}},
  author = {Rabe, Florian and Coen, Claudio Sacerdoti},
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {404},
  eprint = {2407.05822},
  primaryclass = {cs},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.404},
  urldate = {2024-07-09},
  abstract = {Logical frameworks and meta-languages form a common substrate for representing, implementing and reasoning about a wide variety of deductive systems of interest in logic and computer science. Their design, implementation and their use in reasoning tasks, ranging from the correctness of software to the properties of formal systems, have been the focus of considerable research over the last three decades. The LFMTP workshop brought together designers, implementors and practitioners to discuss various aspects impinging on the structure and utility of logical frameworks, including the treatment of variable binding, inductive and co-inductive reasoning techniques and the expressiveness and lucidity of the reasoning process. The 2024 instance of LFMTP was organized by Florian Rabe and Claudio Sacerdoti Coen in Tallinn, Estonia, the 8th July, as a satellite event of the FSCD conference. The workshop received 8 submissions, of which 6 were presented at the workshop. Of these, 2 were work-in-progress presentations, and 4 were accepted for these formal proceedings. Additionally, Carsten Sch{\textbackslash}"urmann of IT University of Copenhagen gave an invited talk on Nominal State Separating Proofs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/3UGKJFN7/2407.html}
}

@book{rabhi1999algorithms,
  title = {Algorithms: {{A}} Functional Programming Approach},
  author = {Rabhi, Fethi and Lapalme, Guy},
  year = {1999},
  volume = {10},
  publisher = {Addison-Wesley},
  file = {/home/flaviomoura/Zotero/storage/TU27G2LS/Rabhi e Lapalme - 1999 - Algorithms A functional programming approach.pdf}
}

@article{rabinProbabilisticAlgorithmTesting1980,
  title = {Probabilistic Algorithm for Testing Primality},
  author = {Rabin, M. O.},
  year = {1980},
  journal = {J Number Theory},
  number = {12},
  pages = {128--138}
}

@unpublished{raffalliComputationalContentsClassical2020,
  title = {Computational Contents of Classical Logic and Extensional Choice},
  author = {Raffalli, Christophe},
  year = {2020}
}

@article{ragdeProustNanoProof2016,
  title = {Proust: {{A Nano Proof Assistant}}},
  author = {Ragde, P.},
  year = {2016},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages}
}

@inproceedings{rahliNominalExplorationIntuitionism2016,
  title = {A {{Nominal Exploration}} of {{Intuitionism}}},
  booktitle = {Proceedings of the 5th {{ACM SIGPLAN Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Rahli, V. and Bickford, M.},
  year = {2016},
  series = {{{CPP}} 2016},
  pages = {130--141},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/2854065.2854077},
  isbn = {978-1-4503-4127-1},
  keywords = {Continuity,Coq,Exceptions,Intuitionistic Type Theory,Nominal Type Theory,Nuprl,Squashing,Truncation}
}

@book{rahmanImmanentReasoningEquality2018,
  title = {Immanent {{Reasoning}} or {{Equality}} in {{Action}}: {{A Plaidoyer}} for the {{Play Level}}},
  shorttitle = {Immanent {{Reasoning}} or {{Equality}} in {{Action}}},
  author = {Rahman, Shahid and McConaughey, Zoe and Klev, Ansten and Clerbout, Nicolas},
  year = {2018},
  series = {Logic, {{Argumentation}} \& {{Reasoning}}},
  volume = {18},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-91149-6},
  urldate = {2022-07-11},
  isbn = {978-3-319-91148-9 978-3-319-91149-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/T2ZVMBCY/rahman2018.pdf;/home/flaviomoura/Zotero/storage/WBFN8WDW/Rahman et al. - 2018 - Immanent Reasoning or Equality in Action A Plaido.pdf}
}

@book{ramosFormalizacaoTerminacaoEspecificacoes2016,
  title = {Formaliza{\c c}{\~a}o Da {{Termina{\c c}{\~a}o}} de {{Especifica{\c c}{\~o}es Funcionais}}},
  author = {Ramos, Thiago Mendon{\c c}a Ferreira},
  year = {2016}
}

@phdthesis{ramosFormalizationContextFreeLanguage2016,
  title = {Formalization of {{Context-Free Language Theory}}},
  author = {Ramos, M. V. M.},
  year = {2016},
  school = {Centro de Inform{\'a}tica, UFPE}
}

@book{rantaPESCAProofEditor2000,
  title = {{{PESCA}}--{{A Proof Editor}} for {{Sequent Calculus}}},
  author = {Ranta, A.},
  year = {2000},
  publisher = {{Department of Computing Science, Chalmers University of Technology and University of Gothenburg}}
}

@article{rathjenProofTheoryConstructive2016,
  title = {Proof {{Theory}} of {{Constructive Systems}}: {{Inductive Types}} and {{Univalence}}},
  author = {Rathjen, M.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {03C62,03F30,03F50,Mathematics - Logic}
}

@article{rathjenWellOrderingPrinciplesProof2020,
  title = {Well-{{Ordering Principles}} in {{Proof Theory}} and {{Reverse Mathematics}}},
  author = {Rathjen, Michael},
  year = {2020},
  month = oct,
  journal = {arXiv:2010.12453 [math]},
  eprint = {2010.12453},
  primaryclass = {math},
  urldate = {2020-10-26},
  abstract = {Several theorems about the equivalence of familiar theories of reverse mathematics with certain well-ordering principles have been proved by recursion-theoretic and combinatorial methods (Friedman, Marcone, Montalban et al.) and with far-reaching results by proof-theoretic technology (Afshari, Freund, Girard, Rathjen, Thomson, Valencia Vizcano, Weiermann et al.), employing deduction search trees and cut elimination theorems in infinitary logics with ordinal bounds in the latter case. At type level one, the well-ordering principles are of the form (*) "if X is well-ordered then f(X) is well-ordered" where f is a standard proof theoretic function from ordinals to ordinals (such f's are always dilators). One aim of the paper is to present a general methodology underlying these results that enables one to construct omega-models of particular theories from (*) and even beta-models from the type 2 version of (*). As (*) is of complexity Pi-1-2 such a principle cannot characterize stronger comprehensions at the level of Pi-1-1-comprehension. This requires a higher order version of (*) that employs ideas from ordinal representation systems with collapsing functions used in impredicative proof theory. The simplest one is the Bachmann construction. Relativizing the latter construction to any dilator f and asserting that this always yields a well-ordering turns out to be equivalent to Pi-1-1-comprehension. This result has been conjectured and a proof strategy adumbrated roughly 10 years ago, but the proof has only been worked out in recent years.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/HMIZKXIV/Rathjen - 2020 - Well-Ordering Principles in Proof Theory and Rever.pdf;/home/flaviomoura/Zotero/storage/XTDSMHKI/2010.html}
}

@book{readThinkingLogicIntroduction1995,
  title = {Thinking {{About Logic}}: {{An Introduction}} to the {{Philosophy}} of {{Logic}}},
  author = {Read, Stephen},
  year = {1995},
  publisher = {Oxford University Press}
}

@unpublished{recuperacaoPropostaParaRetomada2020,
  title = {Proposta Para Retomada Das Atividades N{\~a}o Presenciais},
  author = {das a{\c c}{\~o}es de Recupera{\c c}{\~a}o, Comit{\^e} de Coordena{\c c}{\~a}o},
  year = {2020}
}

@incollection{reedExtendingHigherOrderUnification2003,
  title = {Extending {{Higher-Order Unification}} to {{Support Proof Irrelevance}}},
  booktitle = {Lecture {{Notes}} in {{Computer Science}}},
  author = {Reed, Jason},
  year = {2003},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {238--252},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/10930755_16}
}

@book{ReflectionsTeachingProgramming2008,
  title = {Reflections on the {{Teaching}} of {{Programming}}},
  year = {2008},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-77934-6}
}

@article{regnierEquivalenceLambdatermes1994,
  title = {Une {\'E}quivalence Sur Les Lambda-Termes},
  author = {Regnier, Laurent},
  year = {1994},
  journal = {Theoretical Computer Science},
  volume = {126},
  number = {2},
  pages = {281--292},
  publisher = {Elsevier},
  file = {/home/flaviomoura/Zotero/storage/SGS6UYMN/de Mathtmatiques - Une kquivalence sur les lambda- termes.pdf;/home/flaviomoura/Zotero/storage/MIQXKBQZ/0304397594900124.html}
}

@article{regnierRetractionsTypesMany2002,
  title = {Retractions of {{Types With Many Atoms}}},
  author = {Regnier, Laurent and Urzyczyn, Pawel},
  year = {2002},
  journal = {CoRR},
  abstract = {We define a sound and complete proof system for affine beta-eta-retractions in simple types built over many atoms, and we state simple necessary conditions for arbitrary beta-eta-retractions in simple and polymorphic types.}
}

@article{reisFacilitatingMetaTheoryReasoning2021,
  title = {Facilitating {{Meta-Theory Reasoning}} ({{Invited Paper}})},
  author = {Reis, Giselle},
  year = {2021},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {337},
  eprint = {2107.07661},
  pages = {1--12},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.337.1},
  urldate = {2021-07-19},
  abstract = {Structural proof theory is praised for being a symbolic approach to reasoning and proofs, in which one can define schemas for reasoning steps and manipulate proofs as a mathematical structure. For this to be possible, proof systems must be designed as a set of rules such that proofs using those rules are correct by construction. Therefore, one must consider all ways these rules can interact and prove that they satisfy certain properties which makes them "well-behaved". This is called the meta-theory of a proof system. Meta-theory proofs typically involve many cases on structures with lots of symbols. The majority of cases are usually quite similar, and when a proof fails, it might be because of a sub-case on a very specific configuration of rules. Developing these proofs by hand is tedious and error-prone, and their combinatorial nature suggests they could be automated. There are various approaches on how to automate, either partially or completely, meta-theory proofs. In this paper, I will present some techniques that I have been involved in for facilitating meta-theory reasoning.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/3J8EAWFT/Reis - 2021 - Facilitating Meta-Theory Reasoning (Invited Paper).pdf;/home/flaviomoura/Zotero/storage/UC9D9NHP/Reis - 2021 - Facilitating Meta-Theory Reasoning (Invited Paper).pdf;/home/flaviomoura/Zotero/storage/35VIQ376/2107.html;/home/flaviomoura/Zotero/storage/G4NFA6UT/2107.html}
}

@phdthesis{ReisPHD,
  title = {Cut-Elimination by Resolution in Intuitionistic Logic},
  author = {Reis, Giselle},
  year = {2014},
  school = {Vienna University of Technology},
  file = {/home/flaviomoura/Zotero/storage/LE7GRQ75/Reis - 2014 - Cut-elimination by resolution in intuitionistic lo.pdf}
}

@unpublished{renaudMetaconfluenceLambdaTt2011,
  title = {Metaconfluence of \${\textbackslash}lambda{\textbackslash}tt J\$: Dealing with Non-Deterministic Replacements},
  author = {Renaud, F.},
  year = {2011}
}

@article{renaudStudentCenteredTeachingLarge2007,
  title = {Student-{{Centered Teaching}} in {{Large Classes}} with {{Limited Resources}}},
  author = {Renaud, Susan and Tannenbaum, Elizabeth and Stantial, Phillip},
  year = {2007},
  journal = {English Teaching Forum},
  volume = {45},
  number = {34},
  pages = {12--17}
}

@techreport{reportZtoConfl,
  type = {Technical {{Report}}},
  title = {A Formalization of the (Compositional) z Property},
  author = {{de Moura}, Fl{\'a}vio L. C. and Rezende, Leandro O.},
  year = {2021},
  institution = {Universidade de Bras{\'i}lia}
}

@book{reusauth.LimitsComputationProgramming2016,
  title = {Limits of {{Computation}}: {{From}} a {{Programming Perspective}}},
  author = {Reus (auth.), Bernhard},
  year = {2016},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  edition = {1},
  publisher = {Springer International Publishing},
  isbn = {978-3-319-27887-2 978-3-319-27889-6}
}

@misc{ReviewFunctionalAlgorithms,
  title = {Review on {{Functional Algorithms}}, {{Verified}}!: {{By Tobias Nipkow}}, {{Jasmin Blanchette}}, {{Manuel Eberl}}, {{Alejandro G{\'o}mez-Londo{\~n}o}}, {{Peter Lammich}}, {{Christian Sternagel}}, {{Simon Wimmer}}, and {{Bohua Zhan Freely}} Downloadable: {{https://functional-algorithms-verified.org:}} {{Formal Aspects}} of {{Computing}}: {{Vol}} 35, {{No}} 2},
  urldate = {2024-06-14},
  howpublished = {https://dl.acm.org/doi/10.1145/3594639}
}

@article{reyes29thInternationalConference,
  title = {29th {{International Conference}} on {{Types}} for {{Proofs}} and {{Programs}}},
  author = {Reyes, Eduardo Hermo and Villanueva, Alicia},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/3DG8R5IH/Reyes e Villanueva - 29th International Conference on Types for Proofs .pdf}
}

@article{riazanovDesignImplementationVAMPIRE2002,
  title = {The Design and Implementation of {{VAMPIRE}}},
  author = {Riazanov, Alexandre and Voronkov, Andrei},
  year = {2002},
  journal = {AI Commun.},
  volume = {15},
  number = {2-3},
  pages = {91--110},
  urldate = {2021-12-26}
}

@book{ribenboimLittleBookBigger2004,
  title = {The {{Little}} Book of {{Bigger Primes}}},
  author = {Ribenboim, Paulo},
  year = {2004},
  edition = {3},
  publisher = {Springer},
  address = {New York, NY}
}

@book{ribenboimNewBookPrime1995,
  title = {The {{New}} Book of {{Prime Number Records}}},
  author = {Ribenboim, Paulo},
  year = {1995},
  publisher = {Springer}
}

@misc{rijkeIntroductionHomotopyType2022,
  title = {Introduction to {{Homotopy Type Theory}}},
  author = {Rijke, Egbert},
  year = {2022},
  month = dec,
  number = {arXiv:2212.11082},
  eprint = {2212.11082},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2022-12-24},
  abstract = {This is an introductory textbook to univalent mathematics and homotopy type theory, a mathematical foundation that takes advantage of the structural nature of mathematical definitions and constructions. It is common in mathematical practice to consider equivalent objects to be the same, for example, to identify isomorphic groups. In set theory it is not possible to make this common practice formal. For example, there are as many distinct trivial groups in set theory as there are distinct singleton sets. Type theory, on the other hand, takes a more structural approach to the foundations of mathematics that accommodates the univalence axiom. This, however, requires us to rethink what it means for two objects to be equal. This textbook introduces the reader to Martin-L{\textbackslash}"of's dependent type theory, to the central concepts of univalent mathematics, and shows the reader how to do mathematics from a univalent point of view. Over 200 exercises are included to train the reader in type theoretic reasoning. The book is entirely self-contained, and in particular no prior familiarity with type theory or homotopy theory is assumed.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {03B38,Mathematics - Category Theory,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/DMPCTYKR/Rijke - 2022 - Introduction to Homotopy Type Theory.pdf}
}

@article{ringerQedLargeSurvey2019,
  ids = {ringerQEDLargeSurvey2019},
  title = {Qed {{At Large}}: A {{Survey}} of {{Engineering}} of {{Formally Verified Software}}},
  author = {Ringer, Talia and Palmskog, Karl and Sergey, Ilya and Gligoric, Milos and Tatlock, Zachary},
  year = {2019},
  journal = {Foundations and Trends{\textregistered} in Programming Languages},
  volume = {5},
  number = {2-3},
  eprint = {2003.06458},
  pages = {102--281},
  doi = {10.1561/2500000045},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,D.2.4,F.3.1,I.2.3},
  file = {/home/flaviomoura/Zotero/storage/E8SJV73G/Ringer et al. - 2019 - QED at Large A Survey of Engineering of Formally .pdf;/home/flaviomoura/Zotero/storage/7HR5327F/2003.html}
}

@phdthesis{riosContributionsEtudeLcalculs1993,
  type = {Th{\`e}se de {{Doctorat}}},
  title = {Contributions {\`a} l'{\'e}tude de {$\lambda$}-Calculs Avec Des Substitutions Explicites},
  author = {R{\'i}os, A.},
  year = {1993},
  school = {Universit{\'e} Paris VII}
}

@article{robinsonMachineorientedLogicBased1965,
  title = {A {{Machine-oriented Logic Based}} on the {{Resolution Principle}}},
  author = {Robinson, J. A.},
  year = {1965},
  journal = {Journal of the ACM},
  volume = {12},
  number = {1},
  pages = {23--41}
}

@book{roccaProceedings6thWorkshop2011,
  title = {Proceedings 6th {{Workshop}} on {{Logical}} and {{Semantic Frameworks}} with {{Applications}}, {{LSFA}} 2011, {{Belo Horizonte}}, {{Brazil}}, 27 {{August}} 2011},
  editor = {Rocca, S. Ronchi Della and Pimentel, E.},
  year = {2011},
  series = {{{EPTCS}}},
  volume = {81},
  doi = {10.4204/EPTCS.81}
}

@unpublished{rogersSimplifyingNormalFunctors2024,
  title = {Simplifying Normal Functors: An Old and a New Model of {$\lambda$}-Calculus},
  shorttitle = {Simplifying Normal Functors},
  author = {Rogers, Morgan and Seiller, Thomas and Troiani, William},
  year = {2024},
  month = mar,
  urldate = {2024-03-15},
  abstract = {The introduction of Linear Logic by Jean-Yves Girard takes its origins in the so-called normal functors model of lambda-calculus in which untyped {$\lambda$}-terms are interpreted as `normal functors' between presheaf categories. As a result, we produce a new model in `normal functions' between sets of (possibly infinite) multisets, gaining new insights on Girard's original construction. We then extend this to an explicit model of intuitionistic Linear Logic, contrasting the result with the weighted relational model.},
  keywords = {Linear Logic,Normal functors,Semantics},
  file = {/home/flaviomoura/Zotero/storage/TV9JVF7K/Rogers et al. - 2024 - Simplifying normal functors an old and a new mode.pdf}
}

@misc{rojasTutorialIntroductionLambda2015,
  title = {A {{Tutorial Introduction}} to the {{Lambda Calculus}}},
  author = {Rojas, Raul},
  year = {2015},
  month = mar,
  number = {arXiv:1503.09060},
  eprint = {1503.09060},
  primaryclass = {cs},
  institution = {arXiv},
  doi = {10.48550/arXiv.1503.09060},
  urldate = {2022-06-06},
  abstract = {This paper is a concise and painless introduction to the \${\textbackslash}lambda\$-calculus. This formalism was developed by Alonzo Church as a tool for studying the mathematical properties of effectively computable functions. The formalism became popular and has provided a strong theoretical foundation for the family of functional programming languages. This tutorial shows how to perform arithmetical and logical computations using the \${\textbackslash}lambda\$-calculus and how to define recursive functions, even though \${\textbackslash}lambda\$-calculus functions are unnamed and thus cannot refer explicitly to themselves.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1},
  file = {/home/flaviomoura/Zotero/storage/332RJBLX/Rojas - 2015 - A Tutorial Introduction to the Lambda Calculus.pdf;/home/flaviomoura/Zotero/storage/FFLPS22R/1503.html}
}

@unpublished{rollaIntroducaoProbabilidadeNotas2019,
  title = {Introdu{\c c}{\~a}o {\`a} {{Probabilidade}} - {{Notas}} de {{Aula}}},
  author = {Rolla, Leonardo T.},
  year = {2019}
}

@inproceedings{roseExplicitCyclicSubstitutions1992,
  title = {Explicit Cyclic Substitutions},
  booktitle = {3rd {{International Workshop}} on {{Conditional Term Rewriting Systems}} ({{CTRS}})},
  author = {Rose, K.},
  editor = {Rusinowitch, Micha{\"e}l and R{\'e}my, Jean-Luc},
  year = {1992},
  volume = {656},
  pages = {36--50},
  publisher = {Springer-Verlag}
}

@article{roseExplicitSubstitutionNames2011,
  title = {On {{Explicit Substitution With Names}}},
  author = {Rose, K. H. and Bloo, R. and Lang, F.},
  year = {2011},
  journal = {J Autom Reasoning},
  volume = {49},
  number = {2},
  pages = {275--300},
  doi = {10.1007/s10817-011-9222-5},
  file = {/home/flaviomoura/Zotero/storage/5SYMBXPP/Rose et al. - 2011 - On Explicit Substitution With Names.pdf}
}

@book{rosenDiscreteMathematicsIts2012,
  title = {Discrete Mathematics and Its Applications},
  author = {Rosen, K. H.},
  year = {2012},
  publisher = {McGraw-Hill},
  isbn = {978-0-07-338309-5},
  lccn = {[2011011060]},
  file = {/home/flaviomoura/Zotero/storage/FKCKITA6/Rosen - 2012 - Discrete mathematics and its applications.pdf}
}

@book{roughgardenAlgorithmsIlluminatedPart2017,
  title = {Algorithms {{Illuminated}} ({{Part}} 1): {{The Basics}}},
  author = {Roughgarden, T.},
  year = {2017},
  series = {Algorithms {{Illuminated Series}}},
  publisher = {Soundlikeyourself Publishing, LLC},
  isbn = {978-0-9992829-0-8},
  lccn = {2017914282}
}

@book{roughgardenAlgorithmsIlluminatedPart2018,
  title = {Algorithms {{Illuminated}} ({{Part}} 2): {{Graph Algorithms}} and {{Data Structures}} ({{Volume}} 2)},
  author = {Roughgarden, Tim},
  year = {2018},
  publisher = {Soundlikeyourself Publishing, LLC},
  isbn = {978-0-9992829-2-2}
}

@book{roughgardenAlgorithmsIlluminatedPart2019,
  title = {Algorithms {{Illuminated}} ({{Part}} 3): {{Greedy Algorithms}} and {{Dynamic Programming}}},
  author = {Roughgarden, T.},
  year = {2019},
  series = {Algorithms {{Illuminated Series}}},
  publisher = {Soundlikeyourself Publishing, LLC},
  isbn = {978-0-9992829-4-6}
}

@book{roychoudhuryTheoreticalAspectsComputingICTAC2012,
  title = {Theoretical {{Aspects}} of {{Computing-ICTAC}} 2012: 9th {{International Colloquium}}, {{Bangalore}}, {{India}}, {{September}} 24-27, 2012, {{Proceedings}}},
  author = {Roychoudhury, Abhik and others},
  year = {2012},
  volume = {7521},
  publisher = {Springer},
  doi = {10.1007/978-3-642-32943-2}
}

@book{rudinPrinciplesMathematicalAnalysis1976,
  title = {Principles of Mathematical Analysis},
  author = {Rudin, Walter},
  year = {1976},
  publisher = {Mcgraw-Hill},
  address = {Paris}
}

@book{runcimanProceedingsEighthACM2003,
  title = {Proceedings of the {{Eighth ACM SIGPLAN International Conference}} on {{Functional Programming}}, {{ICFP}} 2003, {{Uppsala}}, {{Sweden}}, {{August}} 25-29, 2003},
  editor = {Runciman, Colin and Shivers, Olin},
  year = {2003},
  publisher = {ACM},
  isbn = {1-58113-756-7}
}

@book{russellPrinciplesMathematics1903,
  title = {The {{Principles}} of {{Mathematics}}},
  author = {Russell, B.},
  year = {1903},
  edition = {2},
  publisher = {W. W. Norton \& Company},
  address = {Berlin}
}

@book{russelPrincipiaMathematica1910,
  title = {Principia {{Mathematica}}},
  author = {Russel, B. A. W. and Whitehead, A. N.},
  year = {1910/1913},
  volume = {1 and 2},
  publisher = {Cambridge University Press}
}

@misc{rybakovAlgorithmicExpressivityFinitevariable2023,
  title = {On Algorithmic Expressivity of Finite-Variable Fragments of Intuitionistic Modal Logics},
  author = {Rybakov, M. and Shkatov, D.},
  year = {2023},
  month = jun,
  number = {arXiv:2306.15202},
  eprint = {2306.15202},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2023-07-08},
  abstract = {We obtain poly-time embeddings of the intuitionistic modal logics FS and MIPC into their positive one-variable fragments.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/YFYVHP37/Rybakov e Shkatov - 2023 - On algorithmic expressivity of finite-variable fra.pdf}
}

@incollection{saibiFormalizationLcalculusExplicit1995,
  title = {Formalization of a {$\lambda$}-Calculus with Explicit Substitutions in {{Coq}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {Sa{\"i}bi, Amokrane},
  editor = {Goos, Gerhard and Hartmanis, Juris and Leeuwen, Jan and Dybjer, Peter and Nordstr{\"o}m, Bengt and Smith, Jan},
  year = {1995},
  volume = {996},
  pages = {183--202},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-60579-7_10},
  urldate = {2023-04-03},
  isbn = {978-3-540-60579-9 978-3-540-47770-9},
  file = {/home/flaviomoura/Zotero/storage/6NPYSMCE/SaÃ¯bi - 1995 - Formalization of a Î»-calculus with explicit substi.pdf}
}

@misc{saidiMathPVSLargeLanguage2023,
  title = {Math-{{PVS}}: {{A Large Language Model Framework}} to {{Map Scientific Publications}} to {{PVS Theories}}},
  shorttitle = {Math-{{PVS}}},
  author = {Saidi, Hassen and Jha, Susmit and Sahai, Tuhin},
  year = {2023},
  month = oct,
  number = {arXiv:2310.17064},
  eprint = {2310.17064},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-10-27},
  abstract = {As artificial intelligence (AI) gains greater adoption in a wide variety of applications, it has immense potential to contribute to mathematical discovery, by guiding conjecture generation, constructing counterexamples, assisting in formalizing mathematics, and discovering connections between different mathematical areas, to name a few. While prior work has leveraged computers for exhaustive mathematical proof search, recent efforts based on large language models (LLMs) aspire to position computing platforms as co-contributors in the mathematical research process. Despite their current limitations in logic and mathematical tasks, there is growing interest in melding theorem proving systems with foundation models. This work investigates the applicability of LLMs in formalizing advanced mathematical concepts and proposes a framework that can critically review and check mathematical reasoning in research papers. Given the noted reasoning shortcomings of LLMs, our approach synergizes the capabilities of proof assistants, specifically PVS, with LLMs, enabling a bridge between textual descriptions in academic papers and formal specifications in PVS. By harnessing the PVS environment, coupled with data ingestion and conversion mechanisms, we envision an automated process, called {\textbackslash}emph\{math-PVS\}, to extract and formalize mathematical theorems from research papers, offering an innovative tool for academic review and discovery.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computation and Language,Computer Science - Logic in Computer Science,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/DMTTR4M6/Saidi et al. - 2023 - math-PVS A Large Language Model Framework to Map .pdf;/home/flaviomoura/Zotero/storage/VIF24SGD/2310.html}
}

@unpublished{sakaiInnermostTerminatingRightlinear2003,
  title = {Innermost Terminating Right-Linear Overlay Term Rewriting Systems Are Terminating},
  author = {Sakai, M.},
  year = {2003}
}

@unpublished{sambinIntuitionisticTypeTheory1980,
  title = {Intuitionistic {{Type Theory}}},
  author = {Sambin, G.},
  year = {1980}
}

@book{sampaioTheoreticalAspectsComputing2016,
  title = {Theoretical {{Aspects}} of {{Computing}} - {{ICTAC}} 2016},
  editor = {Sampaio, A. and Wang, F.},
  year = {2016},
  journal = {Theoretical Aspects of Computing - ICTAC 2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {9965},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-46750-4}
}

@inproceedings{sanchez-gilLocallyNamelessRepresentation2012,
  title = {A {{Locally Nameless Representation}} for a {{Natural Semantics}} for {{Lazy Evaluation}}},
  author = {{S{\'a}nchez-Gil}, Lidia and {Hidalgo-Herrero}, Mercedes and {Ortega-Mall{\'e}n}, Yolanda},
  year = {2012},
  series = {Theoretical {{Aspects}} of {{Computing}} - {{ICTAC}} 2012},
  pages = {105--119},
  publisher = {Springer Berlin Heidelberg}
}

@article{sanchezterrafAnotherProofGlivenko2015,
  title = {Yet {{Another Proof}} of {{Glivenko}}'s {{Theorem}}},
  author = {S{\'a}nchez Terraf, P.},
  year = {2015},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {03B20,F.4.1,I.2.3,Mathematics - Logic,Primary 03F03. Secondary 03F55},
  file = {/home/flaviomoura/Zotero/storage/CVCZ84GD/SÃ¡nchez Terraf - 2015 - Yet Another Proof of Glivenko's Theorem.pdf}
}

@article{sandersBeNotBe2017,
  title = {To Be or Not to Be Constructive, That Is Not the Question},
  author = {Sanders, S.},
  year = {2017},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Logic}
}

@article{sankaranFinitaryAnalogueDownward2017,
  title = {A {{Finitary Analogue}} of the {{Downward L}}\${\textbackslash}backslash\$``owenheim-{{Skolem Property}}},
  author = {Sankaran, A.},
  year = {2017},
  month = may,
  journal = {ArXiv e-prints},
  keywords = {03C13,03C52,05C38,05C62,05C76,Computer Science - Logic in Computer Science,F.4.1,G.2.2}
}

@inproceedings{santanaSAEPTUMVerificationELAN2006,
  title = {{{SAEPTUM}}: Verification of {{ELAN Hardware}} Specifications Using the Proof Assistant {{PVS}}},
  booktitle = {Proc. 19th {{Symposium}} on {{Integrated Circuits}} and {{System Design}} - {{SBCCI}} 2006},
  author = {Sant'ana, T. M. and {Ayala-Rinc{\'o}n}, M.},
  year = {2006},
  pages = {125--130}
}

@article{santannaFlowAxiomChoice2020,
  title = {Flow: The {{Axiom}} of {{Choice}} Is Independent from the {{Partition Principle}}},
  shorttitle = {Flow},
  author = {Sant'Anna, Adonai S. and Bueno, Otavio and {de Fran{\c c}a}, Marcio P. P. and Brodzinski, Renato},
  year = {2020},
  month = oct,
  journal = {arXiv:2010.03664 [math]},
  eprint = {2010.03664},
  primaryclass = {math},
  urldate = {2020-10-09},
  abstract = {We introduce a general theory of functions called Flow. We prove ZF, non-well founded ZF and ZFC can be immersed within Flow as a natural consequence from our framework. The existence of strongly inaccessible cardinals is entailed from our axioms. And our first important application is the introduction of a model of Zermelo-Fraenkel set theory where the Partition Principle (PP) holds but not the Axiom of Choice (AC). So, Flow allows us to answer to the oldest open problem in set theory: if PP entails AC.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/FIW8G3VR/Sant'Anna et al. - 2020 - Flow the Axiom of Choice is independent from the .pdf;/home/flaviomoura/Zotero/storage/AJTVIIGW/2010.html}
}

@article{santoCoinductiveApproachProof2021,
  title = {A {{Coinductive Approach}} to {{Proof Search}} through {{Typed Lambda-Calculi}}},
  author = {Santo, Jos{\'e} Esp{\'i}rito and Matthes, Ralph and Pinto, Lu{\'i}s},
  year = {2021},
  month = jul,
  journal = {Annals of Pure and Applied Logic},
  eprint = {1602.04382},
  pages = {103026},
  issn = {01680072},
  doi = {10.1016/j.apal.2021.103026},
  urldate = {2021-07-30},
  abstract = {In reductive proof search, proofs are naturally generalized by solutions, comprising all possibly infinite structures generated by locally correct, bottom-up application of inference rules. We propose an extension of the Curry-Howard paradigm of representation, from proofs to solutions: to represent solutions by possibly infinite terms of a dedicated lambda-calculus. This new, comprehensive approach to proof search is exemplified with the sequent calculus LJT for intuitionistic implication logic. A finitary representation is proposed, comprising lambda-terms extended with a formal greatest fixed point, and a type system that can be seen as a logic of coinductive proofs. In the finitary system, fixed-point variables enjoy a relaxed form of binding that allows the detection of cycles through the type system. Formal sums are used to express alternatives in the search process. Moreover, formal sums are used in the coinductive syntax to define "decontraction" (contraction bottom-up) - an operation whose theory we initiate in this paper. As a semantics, we assign a coinductive lambda-term to each finitary term. The main result is the existence of an equivalent finitary representation for any full solution space expressed coinductively. This result is the main ingredient in the proof that our logic of coinductive proofs is sound and complete with respect to the coinductive semantics. These results are the foundation for an original approach to proof search, where the search builds the finitary representation of the full solution space, and the a posteriori analysis typically consisting in applying a syntax-directed procedure or function. The paper illustrates this for proof search and inhabitation problems in the simply-typed lambda-calculus, reviewing results detailed elsewhere, and including new results that obtain extensive generalizations of the so-called monatomic theorem.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/IHVR5MWG/Santo et al. - 2021 - A Coinductive Approach to Proof Search through Typ.pdf;/home/flaviomoura/Zotero/storage/HWYP4HEN/1602.html}
}

@inproceedings{santoDelayedSubstitutions2007,
  title = {Delayed {{Substitutions}}},
  booktitle = {18th {{International Conference}} on {{Rewriting Techniques}} and {{Applications}} ({{RTA}}'07)},
  author = {Santo, J. E.},
  year = {2007},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {169--183},
  publisher = {Springer Science + Business Media},
  doi = {10.1007/978-3-540-73449-9_14}
}

@misc{santoFaithfulQuantitativeNotion2024,
  title = {A {{Faithful}} and {{Quantitative Notion}} of {{Distant Reduction}} for the {{Lambda-Calculus}} with {{Generalized Applications}}},
  author = {Santo, Jos{\'e} Esp{\'i}rito and Kesner, Delia and Peyrot, Lo{\"i}c},
  year = {2024},
  month = jul,
  number = {arXiv:2201.04156},
  eprint = {2201.04156},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2201.04156},
  urldate = {2024-07-29},
  abstract = {We introduce a call-by-name lambda-calculus \${\textbackslash}lambda Jn\$ with generalized applications which is equipped with distant reduction. This allows to unblock \${\textbackslash}beta\$-redexes without resorting to the standard permutative conversions of generalized applications used in the original \${\textbackslash}Lambda J\$-calculus with generalized applications of Joachimski and Matthes. We show strong normalization of simply-typed terms, and we then fully characterize strong normalization by means of a quantitative (i.e. non-idempotent intersection) typing system. This characterization uses a non-trivial inductive definition of strong normalization --related to others in the literature--, which is based on a weak-head normalizing strategy. We also show that our calculus \${\textbackslash}lambda Jn\$ relates to explicit substitution calculi by means of a faithful translation, in the sense that it preserves strong normalization. Moreover, our calculus \${\textbackslash}lambda Jn\$ and the original \${\textbackslash}Lambda J\$-calculus determine equivalent notions of strong normalization. As a consequence, \${\textbackslash}lambda J\$ inherits a faithful translation into explicit substitutions, and its strong normalization can also be characterized by the quantitative typing system designed for \${\textbackslash}lambda Jn\$, despite the fact that quantitative subject reduction fails for permutative conversions.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/D75NPVD8/Santo et al. - 2024 - A Faithful and Quantitative Notion of Distant Redu.pdf;/home/flaviomoura/Zotero/storage/YVGWP8NQ/2201.html}
}

@misc{santoHowAvoidCommuting2024,
  title = {How to Avoid the Commuting Conversions of {{IPC}}},
  author = {Santo, Jos{\'e} Esp{\'i}rito and Ferreira, Gilda},
  year = {2024},
  month = feb,
  number = {arXiv:2402.16171},
  eprint = {2402.16171},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2024-02-27},
  abstract = {Since the observation in 2006 that it is possible to embed IPC into the atomic polymorphic lambda-calculus (a predicative fragment of system F with universal instantiations restricted to atomic formulas) different such embeddings appeared in the literature. All of them comprise the Russell-Prawitz translation of formulas, but have different strategies for the translation of proofs. Although these embeddings preserve proof identity, all fail in delivering preservation of reduction steps. In fact, they translate the commuting conversions of IPC to beta-equality, or to other kinds of reduction or equality generated by new principles added to system F. The cause for this is the generation of redexes by the translation itself. In this paper, we present an embedding of IPC into atomic system F, still based on the same translation of formulas, but which maps commuting conversions to syntactic identity, while simulating the other kinds of reduction steps present in IPC beta{\textbackslash}eta-reduction. In this sense the translation achieves a truly commuting conversion-free image of IPC in atomic system F.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/LYL58RG7/Santo e Ferreira - 2024 - How to avoid the commuting conversions of IPC.pdf;/home/flaviomoura/Zotero/storage/ERF7U577/2402.html}
}

@article{santoNotePreservationStrong2011,
  title = {A {{Note}} on {{Preservation}} of {{Strong Normalisation}} in the {$\lambda$}-Calculus},
  author = {Santo, J. E.},
  year = {2011},
  journal = {Theoretical Computer Science},
  volume = {412},
  number = {11},
  pages = {1027--1032},
  doi = {10.1016/j.tcs.2010.10.049}
}

@article{santoProofSearchFull2020,
  title = {Proof Search for Full Intuitionistic Propositional Logic through a Coinductive Approach for Polarized Logic},
  author = {Santo, Jos{\'e} Esp{\'i}rito and Matthes, Ralph and Pinto, Lu{\'i}s},
  year = {2020},
  month = jul,
  journal = {arXiv:2007.16161 [cs, math]},
  eprint = {2007.16161},
  primaryclass = {cs, math},
  urldate = {2020-08-03},
  abstract = {The approach to proof search dubbed "coinductive proof search", and previously developed by the authors for implicational intuitionistic logic, is in this paper extended to polarized intuitionistic logic. As before, this includes developing a coinductive description of the search spaces generated by a sequent, an equivalent inductive syntax describing the same space, and decision procedures for inhabitation problems in the form of predicates defined by recursion on the inductive syntax. The polarized logic can be used as a platform from which proof search for other logics is understood. We illustrate the technique with LJT, a focused sequent calculus for full intuitionistic propositional logic (including disjunction). For that, we have to work out the "negative translation" of LJT into the polarized logic (that sees all intuitionistic types as negative types), and verify that the translation gives a faithful representation of proof search in LJT as proof search in the polarized logic.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/T7QYPBM5/Santo et al. - 2020 - Proof search for full intuitionistic propositional.pdf;/home/flaviomoura/Zotero/storage/GXU9VWY9/2007.html}
}

@article{santoTuringNormalizacao2012,
  title = {Turing e a Normaliza{\c c}{\~a}o},
  author = {Santo, Jos{\'e} Esp{\'i}rito},
  year = {2012},
  journal = {Boletim da Sociedade Portuguesa de Matem{\'a}tica},
  volume = {67},
  pages = {79--96}
}

@book{sassoneFoundationsSoftwareScience2005,
  title = {Foundations of {{Software Science}} and {{Computational Structures}}, 8th {{International Conference}}, {{FOSSACS}} 2005, {{Held}} as {{Part}} of the {{Joint European Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2005, {{Edinburgh}}, {{UK}}, {{April}} 4-8, 2005, {{Proceedings}}},
  editor = {Sassone, Vladimiro},
  year = {2005},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {3441},
  publisher = {Springer},
  doi = {10.1007/b106850},
  isbn = {3-540-25388-2}
}

@article{satoIntuitionisticSettheoreticalModel2023,
  title = {An Intuitionistic Set-Theoretical Model of Fully Dependent {{CC}}},
  author = {Sato, Masahiro and Garrigue, Jacques},
  year = {2023},
  month = apr,
  journal = {Mathematical Structures in Computer Science},
  pages = {1--32},
  issn = {0960-1295, 1469-8072},
  doi = {10.1017/S0960129523000087},
  urldate = {2023-04-20},
  abstract = {Abstract                            Werner's set-theoretical model is one of the simplest models of CIC. It combines a functional view of predicative universes with a collapsed view of the impredicative sort ``                                                                      \$\{{\textbackslash}tt Prop\}\$                                               ''. However, this model of                                                                      \$\{{\textbackslash}tt Prop\}\$                                               is so coarse that the principle of excluded middle                                                                      \$P {\textbackslash}lor {\textbackslash}neg P\$                                               holds. Following our previous work, we interpret                                                                      \$\{{\textbackslash}tt Prop\}\$                                               into a topological space (a special case of Heyting algebra) to make the model more intuitionistic without sacrificing simplicity. We improve on that work by providing a full interpretation of dependent product types, using Alexandroff spaces. We also extend our approach to inductive types by adding support for                                                                      \$\{{\textbackslash}mathsf\{list\}\}\$                                               s.},
  langid = {english}
}

@book{sattlerContributionsDoctoralProgramme2004,
  title = {Contributions to the {{Doctoral Programme}} of the 2nd {{International Joint Conference}} on {{Automated Reasoning}}, {{Cork}}, {{Ireland}}, {{July}} 4-8, 2004},
  editor = {Sattler, Ulrike},
  year = {2004},
  series = {{{CEUR Workshop Proceedings}}},
  volume = {106},
  publisher = {CEUR-WS.org}
}

@misc{sattlerNaturalNumbersIntegers2024,
  title = {Natural Numbers from Integers},
  author = {Sattler, Christian and W{\"a}rn, David},
  year = {2024},
  month = may,
  number = {arXiv:2405.18388},
  eprint = {2405.18388},
  primaryclass = {cs, math},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.18388},
  urldate = {2024-05-29},
  abstract = {In homotopy type theory, a natural number type is freely generated by an element and an endomorphism. Similarly, an integer type is freely generated by an element and an automorphism. Using only dependent sums, identity types, extensional dependent products, and a type of two elements with large elimination, we construct a natural number type from an integer type. As a corollary, homotopy type theory with only \${\textbackslash}Sigma\$, \${\textbackslash}mathsf\{Id\}\$, \${\textbackslash}Pi\$, and finite colimits with descent (and no universes) admits a natural number type. This improves and simplifies a result by Rose.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/9TXU8QUA/Sattler e WÃ¤rn - 2024 - Natural numbers from integers.pdf;/home/flaviomoura/Zotero/storage/V6XB49FP/2405.html}
}

@misc{saviFirstorderTheoriesQuaternions2024,
  title = {On the First-Order Theories of Quaternions and Octonions},
  author = {Savi, Enrico},
  year = {2024},
  month = apr,
  number = {arXiv:2404.04976},
  eprint = {2404.04976},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2024-04-09},
  abstract = {Let \$L\$ be the language of rings. We provide an axiomatization of the \$L\$-theories of quaternions and octonions and we characterize the models of mentioned theories: they coincide, up to isomorphism, to quaternion and octonion algebras over a real closed field, respectively. We prove these theories are complete, model complete and they do not have quantifier elimination. Then, we focus on the class of ordered polynomials. Over \${\textbackslash}mathbb\{H\}\$ and \${\textbackslash}mathbb\{O\}\$ these polynomials are of special interest in hypercomplex analysis slice they are slice regular. We deduce some fundamental properties of the zero locus of ordered polynomials from completeness and we prove the failure of qantifier elimination for the fragment of ordered formulas as well.},
  archiveprefix = {arXiv},
  keywords = {03C10 03C98 (Primary) 16K20 17A35 30G35 14P10 (Secondary),Mathematics - Algebraic Geometry,Mathematics - Logic,Mathematics - Rings and Algebras},
  file = {/home/flaviomoura/Zotero/storage/5P4CUM8Q/Savi - 2024 - On the first-order theories of quaternions and oct.pdf;/home/flaviomoura/Zotero/storage/C3LRT6KS/2404.html}
}

@incollection{savilleClonesClosedCategories2024,
  title = {Clones, Closed Categories, and Combinatory Logic},
  author = {Saville, Philip},
  year = {2024},
  volume = {14575},
  eprint = {2405.01675},
  primaryclass = {cs, math},
  pages = {160--181},
  doi = {10.1007/978-3-031-57231-9_8},
  urldate = {2024-05-06},
  abstract = {We give an exposition of the semantics of the simply-typed lambda-calculus, and its linear and ordered variants, using multi-ary structures. We define universal properties for multicategories, and use these to derive familiar rules for products, tensors, and exponentials. Finally we explain how to recover both the category-theoretic syntactic model and its semantic interpretation from the multi-ary framework. We then use these ideas to study the semantic interpretation of combinatory logic and the simply-typed lambda-calculus without products. We introduce extensional SK-clones and show these are sound and complete for both combinatory logic with extensional weak equality and the simply-typed lambda-calculus without products. We then show such SK-clones are equivalent to a variant of closed categories called SK-categories, so the simply-typed lambda-calculus without products is the internal language of SK-categories. As a corollary, we deduce that SK-categories have the same relationship to cartesian monoidal categories that closed categories have to monoidal categories.},
  archiveprefix = {arXiv},
  keywords = {18D15,Computer Science - Logic in Computer Science,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/L6SUF3MI/Saville - 2024 - Clones, closed categories, and combinatory logic.pdf;/home/flaviomoura/Zotero/storage/V5I2TGNM/2405.html}
}

@inproceedings{schaferCompletenessDecidabilityBruijn2015,
  title = {Completeness and {{Decidability}} of de {{Bruijn Substitution Algebra}} in {{Coq}}},
  booktitle = {Proceedings of the 2015 {{Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Sch{\"a}fer, Steven and Smolka, Gert and Tebbi, Tobias},
  year = {2015},
  month = jan,
  series = {{{CPP}} '15},
  pages = {67--73},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/2676724.2693163},
  urldate = {2024-07-29},
  abstract = {We consider a two-sorted algebra over de Bruijn terms and de Bruijn substitutions equipped with the constants and operations from Abadi et al.'s sigma-calculus. We consider expressions with term variables and substitution variables and show that the semantic equivalence obtained with the algebra coincides with the axiomatic equivalence obtained with finitely many axioms based on the sigma-calculus. We prove this result with an informative decision algorithm for axiomatic equivalence, which in the negative case returns a variable assignment separating the given expressions in the algebra. The entire development is formalized in Coq.},
  isbn = {978-1-4503-3296-5},
  file = {/home/flaviomoura/Zotero/storage/N24ADYX4/SchÃ¤fer et al. - 2015 - Completeness and Decidability of de Bruijn Substit.pdf}
}

@phdthesis{schaferEngineeringFormalSystems2019,
  title = {Engineering {{Formal Systems}} in {{Constructive Type Theory}}},
  author = {Sch{\"a}fer, Steven},
  year = {2019},
  school = {Universit{\"a}t des Saarlandes}
}

@article{schererDecidingEquivalenceSums2016,
  title = {Deciding Equivalence with Sums and the Empty Type},
  author = {Scherer, G.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {03F03,68N18,Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.3.3,F.4.1}
}

@article{scheweInsignificantChoicePolynomial2020,
  title = {Insignificant {{Choice Polynomial Time}}},
  author = {Schewe, Klaus-Dieter},
  year = {2020},
  abstract = {In the late 1980s Gurevich conjectured that there is no logic capturing PTIME, where "logic" has to be understood in a very general way comprising computation models over isomorphism classes of structures. In this article we first show that Gurevich's conjecture is false. For this we extend the seminal research of Blass, Gurevich and Shelah on {\textbackslash}em choiceless polynomial time (CPT), which exploits deterministic Abstract State Machines (ASMs) supporting unbounded parallelism to capture the choiceless fragment of PTIME. CPT is strictly included in PTIME. We observe that choice is unavoidable, but that a restricted version suffices, which guarantees that the final result is independent from the choice. Such a version of polynomially bounded ASMs, which we call {\textbackslash}em insignificant choice polynomial time (ICPT) will indeed capture PTIME. This can be expressed in the logic of non-deterministic ASMs plus inflationary fixed-point. We use this result for our second contribution showing that PTIME differs from NP. For the proof we build again on the research on CPT first establishing a limitation on permutation classes of the sets that can be activated by an ICPT computation. We then prove an equivalence theorem, which characterises structures that cannot be distinguished by the logic. In particular, this implies that SAT cannot be decided by an ICPT computation.}
}

@book{schleicherInvitationMathematics2011,
  title = {An {{Invitation}} to {{Mathematics}}},
  editor = {Schleicher, Dierk and Lackmann, Malte},
  year = {2011},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-19533-4}
}

@phdthesis{schlichtkrullFormalizationLogicIsabelle2018,
  title = {Formalization of {{Logic}} in the {{Isabelle Proof Assistant}}},
  author = {Schlichtkrull, Anders},
  year = {2018},
  school = {Technical University of Denmark}
}

@article{schmidt-schaussNominalUnificationHigher2016,
  title = {Nominal {{Unification}} of {{Higher Order Expressions}} with {{Recursive Let}}},
  author = {{Schmidt-Schau{\ss}}, M. and Kutsia, T. and Levy, J. and Villaret, M.},
  year = {2016},
  month = aug,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages}
}

@article{schmidt-schaussNominalUnificationMatching2021,
  title = {Nominal {{Unification}} and {{Matching}} of {{Higher Order Expressions}} with {{Recursive Let}}},
  author = {{Schmidt-Schau{\ss}}, Manfred and Kutsia, Temur and Levy, Jordi and Villaret, Mateu and Kutz, Yunus},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.08146 [cs]},
  eprint = {2102.08146},
  primaryclass = {cs},
  urldate = {2021-02-21},
  abstract = {A sound and complete algorithm for nominal unification of higher-order expressions with a recursive let is described, and shown to run in nondeterministic polynomial time. We also explore specializations like nominal letrec-matching for expressions, for DAGs, and for garbage-free expressions and determine their complexity. Finally, we also provide a nominal unification algorithm for higher-order expressions with recursive let and atom-variables, where we show that it also runs in nondeterministic polynomial time.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,I.2.3},
  file = {/home/flaviomoura/Zotero/storage/4S66HFF5/Schmidt-SchauÃ et al. - 2021 - Nominal Unification and Matching of Higher Order E.pdf;/home/flaviomoura/Zotero/storage/F6TFL5TV/Schmidt-SchauÃ et al. - 2022 - Nominal Unification and Matching of Higher Order E.pdf;/home/flaviomoura/Zotero/storage/Z4FPKGK2/2102.html}
}

@article{schoisswohlAutomatingInductionReflection2021,
  title = {Automating {{Induction}} by {{Reflection}}},
  author = {Schoisswohl, Johannes and Kov{\'a}cs, Laura},
  year = {2021},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {337},
  eprint = {2107.07669},
  pages = {39--54},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.337.4},
  urldate = {2021-07-19},
  abstract = {Despite recent advances in automating theorem proving in full first-order theories, inductive reasoning still poses a serious challenge to state-of-the-art theorem provers. The reason for that is that in first-order logic induction requires an infinite number of axioms, which is not a feasible input to a computer-aided theorem prover requiring a finite input. Mathematical practice is to specify these infinite sets of axioms as axiom schemes. Unfortunately these schematic definitions cannot be formalized in first-order logic, and therefore not supported as inputs for first-order theorem provers. In this work we introduce a new method, inspired by the field of axiomatic theories of truth, that allows to express schematic inductive definitions, in the standard syntax of multi-sorted first-order logic. Further we test the practical feasibility of the method with state-of-the-art theorem provers, comparing it to solvers' native techniques for handling induction.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/AX4F47V2/Schoisswohl e KovÃ¡cs - 2021 - Automating Induction by Reflection.pdf;/home/flaviomoura/Zotero/storage/HLNA8XJH/2107.html}
}

@article{scholliersWebPieTinySlice,
  title = {{{WebPie}}: {{A Tiny Slice}} of {{Dependent Typing}}},
  shorttitle = {{{WebPie}}},
  author = {Scholliers, Christophe},
  journal = {EPTCS},
  volume = {400},
  pages = {2--27},
  urldate = {2024-04-08},
  file = {/home/flaviomoura/Zotero/storage/PIYXPJPR/Scholliers - WebPie A Tiny Slice of Dependent Typing.pdf}
}

@book{schoningLogicComputerScientists2008,
  title = {Logic for {{Computer Scientists}}},
  author = {Sch{\"o}ning, Uwe},
  year = {2008},
  series = {[]},
  publisher = {Birkh{\"a}user Boston},
  doi = {10.1007/978-0-8176-4763-6}
}

@article{schreiberQuantumGaugeField2014,
  title = {Quantum {{Gauge Field Theory}} in {{Cohesive Homotopy Type Theory}}},
  author = {Schreiber, Urs and Shulman, Michael},
  year = {2014},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {158},
  pages = {109--126},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.158.8},
  urldate = {2022-07-05},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/YDINYV5Q/Schreiber and Shulman - 2014 - Quantum Gauge Field Theory in Cohesive Homotopy Ty.pdf}
}

@inproceedings{schreinerTheoremAlgorithmChecking2019,
  title = {Theorem and {{Algorithm Checking}} for {{Courses}} on {{Logic}} and {{Formal Methods}}},
  booktitle = {{\textbackslash}rm {{Proceedings}} 7th {{International Workshop}} on {{Theorem}} Proving Components for {{Educational}} Software, {\textbackslash}rm {{Oxford}}, {{United Kingdom}}, 18 July 2018},
  author = {Schreiner, Wolfgang},
  editor = {Quaresma, Pedro and Neuper, Walther},
  year = {2019},
  series = {Electronic {{Proceedings}} in {{Theoretical Computer Science}}},
  volume = {290},
  pages = {56--75},
  publisher = {Open Publishing Association},
  doi = {10.4204/EPTCS.290.5}
}

@article{schroeder-heisterCompletenessIntuitionisticLogic1983,
  title = {The Completeness of Intuitionistic Logic with Respect to a Validity Concept Based on an Inversion Principle},
  author = {{Schroeder-Heister}, P.},
  year = {1983},
  journal = {J. Philosophical Logic},
  volume = {12},
  number = {3},
  pages = {359--377},
  doi = {10.1007/BF00263483}
}

@article{schubertHowHardPositive2016,
  title = {How {{Hard Is Positive Quantification}}?},
  author = {Schubert, A. and Urzyczyn, P. and {Walukiewicz-Chrz{\k a}szcz}, D.},
  year = {2016},
  journal = {ACM Transactions on Computational Logic},
  volume = {17},
  number = {4},
  pages = {1--29},
  doi = {10.1145/2981544}
}

@article{schubertMintsHierarchyFirstOrder2016,
  title = {On the {{Mints Hierarchy}} in {{First-Order Intuitionistic Logic}}},
  author = {Schubert, A. and Urzyczyn, P. and Zdanowski, K.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@misc{schubertProofConstructionSATsolving2024,
  title = {Between Proof Construction and {{SAT-solving}}},
  author = {Schubert, Aleksy and Urzyczyn, Pawe{\l} and Zdanowski, Konrad},
  year = {2024},
  month = may,
  number = {arXiv:2405.05670},
  eprint = {2405.05670},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2405.05670},
  urldate = {2024-05-10},
  abstract = {The classical satisfiability problem (SAT) is used as a natural and general tool to express and solve combinatorial problems that are in NP. We postulate that provability for implicational intuitionistic propositional logic (IIPC) can serve as a similar natural tool to express problems in Pspace. This approach can be particularly convenient for two reasons. One is that provability in full IPC (with all connectives) can be reduced to provability of implicational formulas of order three. Another advantage is a convenient interpretation in terms of simple alternating automata. Additionally, we distinguish some natural subclasses of IIPC corresponding to the complexity classes NP and co-NP. Our experimental results show that a simple decision procedure requires a significant amount of time only in a small fraction of cases.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/EXIXXNKI/Schubert et al. - 2024 - Between proof construction and SAT-solving.pdf;/home/flaviomoura/Zotero/storage/IB4RW54A/2405.html}
}

@book{schutteProofTheory1977,
  title = {Proof {{Theory}}},
  author = {Sch{\"u}tte, K.},
  year = {1977},
  series = {Grundlehren Der Mathematischen {{Wissenschaften}}},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-66473-1}
}

@book{schwichtenbergProofsComputations2012,
  title = {Proofs and {{Computations}}},
  author = {Schwichtenberg, H. and Wainer, S. S.},
  year = {2012},
  edition = {1st},
  publisher = {Cambridge University Press},
  address = {New York, NY, USA},
  isbn = {0-521-51769-9 978-0-521-51769-0}
}

@incollection{schwichtenbergRECURSIONTHEORY2011,
  title = {{{RECURSION THEORY}}},
  booktitle = {Proofs and {{Computations}}},
  editor = {Schwichtenberg, Helmut and Wainer, Stanley S.},
  year = {2011},
  series = {Perspectives in {{Logic}}},
  pages = {61--112},
  publisher = {Cambridge University Press},
  address = {Cambridge},
  doi = {10.1017/CBO9781139031905.004},
  urldate = {2024-07-13},
  abstract = {In this chapter we develop the basics of recursive function theory, or as it is more generally known, computability theory. Its history goes back to the seminal works of Turing, Kleene and others in the 1930s.A computable function is one defined by a program whose operational semantics tell an idealized computer what to do to its storage locations as it proceeds deterministically from input to output, without any prior restrictions on storage space or computation time. We shall be concerned with various program styles and the relationships between them, but the emphasis throughout this chapter and in part 2 will be on one underlying data type, namely the natural numbers, since it is there that the most basic foundational connections between proof theory and computation are to be seen in their clearest light. This is not to say that computability over more general and abstract data types is less important. Quite the contrary. For example, from a logical point of view, Stoltenberg-Hansen and Tucker [1999], Tucker and Zucker [2000], [2006] and Moschovakis [1997] give excellent presentations of a more abstract approach, and our part 3 develops a theory in higher types from a completely general standpoint.The two best-known models of machine computation are the Turing Machine and the (Unlimited) Register Machine of Shepherdson and Sturgis [1963]. We base our development on the latter since it affords the quickest route to the results we want to establish (see also Cutland [1980]).},
  isbn = {978-0-521-51769-0}
}

@book{secoEquacoesDiferenciaisOrdinarias2018,
  title = {Equa{\c c}{\~o}es Diferenciais Ordin{\'a}rias e S{\'e}ries de Pot{\^e}ncias},
  author = {Seco, Lucas and Patr{\~a}o, Mauro},
  year = {2018},
  publisher = {Editora Universidade de Bras{\'i}lia},
  doi = {10.26512/9788523010164},
  urldate = {2023-04-07},
  abstract = {As equa{\c c}{\~o}es que descrevem o movimento e, de maneira mais geral, taxas de varia{\c c}{\~a}o, s{\~a}o denominadas equa{\c c}{\~o}es diferenciais ordin{\'a}rias (EDOs). Neste livro, apresentamos uma introdu{\c c}{\~a}o {\`a}s EDOs na qual as s{\'e}ries de pot{\^e}ncias aparecem pela necessidade de resolver EDOs de coeficientes vari{\'a}veis. Buscamos simplicidade e rigor, numa exposi{\c c}{\~a}o autocontida, ilustrada por mais de 60 figuras e que d{\'a} {\^e}nfase aos conceitos essenciais e, ao mesmo tempo, a demonstra{\c c}{\~o}es acess{\'i}veis. Nas EDOs de 1a ordem, focamos apenas nas separ{\'a}veis e nas lineares, que s{\~a}o os casos de maior aplica{\c c}{\~a}o e necess{\'a}rios para o desenvolvimento da teoria de ordem superior. O restante do livro {\'e} dedicado {\`a} teoria das EDOs lineares, come{\c c}ando pelas EDOs de 2a ordem. Obtemos a solu{\c c}{\~a}o geral da homog{\^e}nea via f{\'o}rmula de Abel e, para coeficientes constantes, obtemos a exist{\^e}ncia de solu{\c c}{\~o}es fundamentais por meio do operador de deriva{\c c}{\~a}o. No caso de coeficientes vari{\'a}veis, primeiro procuramos solu{\c c}{\~o}es polinomiais, o que nos leva a equa{\c c}{\~o}es de recorr{\^e}ncia. Em seguida consideramos solu{\c c}{\~o}es dadas por s{\'e}ries de pot{\^e}ncias e quest{\~o}es relacionadas {\`a} converg{\^e}ncia. Por {\'u}ltimo, consideramos equa{\c c}{\~o}es de ordem superior e sistemas, focando no caso de coeficientes constantes. Usamos o operador de deriva{\c c}{\~a}o para resolver as EDOs homog{\^e}neas de ordem superior e obter de forma rigorosa o m{\'e}todo dos coeficientes a determinar. Usamos a transformada de Laplace para resolver EDOs e sistemas de EDOs com coeficientes constantes.},
  isbn = {978-85-230-1016-4},
  file = {/home/flaviomoura/Zotero/storage/RESJRIIG/Seco e PatrÃ£o - 2018 - EquaÃ§Ãµes diferenciais ordinÃ¡rias e sÃ©ries de potÃªn.pdf}
}

@book{sedgewick2013introduction,
  title = {An Introduction to the Analysis of Algorithms},
  author = {Sedgewick, Robert and Flajolet, Philippe},
  year = {2013},
  publisher = {Pearson Education India}
}

@book{sedgewickAlgorithms2011,
  title = {Algorithms},
  author = {Sedgewick, Robert and Wayne, Kevin Daniel},
  year = {2011},
  edition = {4th ed},
  publisher = {Addison-Wesley},
  address = {Upper Saddle River, NJ},
  isbn = {978-0-321-57351-3},
  lccn = {QA76.9.A43 S429 2011},
  keywords = {Computer algorithms,Textbooks},
  file = {/home/flaviomoura/Zotero/storage/IUBTZK34/Sedgewick e Wayne - 2011 - Algorithms.pdf}
}

@inproceedings{segundoFormalizingNamedExplicit2014,
  title = {Formalizing {{Named Explicit Substitutions Calculi}} in {{Coq}}},
  booktitle = {{{CICM-WS-WiP}} 2014},
  author = {Segundo, W. L. R. de C. and de Moura, F. L. C. and Ventura, D. L.},
  editor = {{CEUR-WS}},
  year = {2014},
  volume = {1186},
  address = {{\textbackslash}tt http://ceur-ws.org/Vol-1186/}
}

@book{seidlUMLClassroom2015,
  title = {{{UML}} @ {{Classroom}}},
  author = {Seidl, Martina and Scholz, Marion and Huemer, Christian and Kappel, Gerti},
  year = {2015},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-12742-2}
}

@article{seldinNormalizationExcludedMiddle1989,
  title = {Normalization and Excluded Middle. {{I}}},
  author = {Seldin, Jonathan P.},
  year = {1989},
  journal = {Studia Logica},
  volume = {48},
  number = {2},
  pages = {193--217},
  doi = {10.1007/BF02770512}
}

@article{seldinRoleImplicationFormal2000,
  title = {On the {{Role}} of {{Implication}} in {{Formal Logic}}},
  author = {Seldin, Jonathan P.},
  year = {2000},
  journal = {The Journal of Symbolic Logic},
  volume = {65},
  number = {03},
  pages = {1076--1114},
  doi = {10.2307/2586689}
}

@unpublished{seldinSearchReductionCombinatory2015,
  ids = {seldinSearchReductionCombinatory2016},
  title = {The Search for a Reduction in Combinatory Logic Equivalent to \${\textbackslash}lambda{\textbackslash}beta\$-Reduction, {{Part II}}},
  author = {Seldin, J. P.},
  year = {2015}
}

@article{seligmanTeachingNaturalDeduction2015,
  title = {Teaching Natural Deduction in the Right Order with {{Natural Deduction Planner}}},
  author = {Seligman, J. and Thompson, D.},
  year = {2015},
  journal = {CoRR}
}

@article{selingerLectureNotesLambda,
  title = {Lecture {{Notes}} on the {{Lambda Calculus}}},
  author = {Selinger, Peter},
  abstract = {This is a set of lecture notes that developed out of courses on the lambda calculus that I taught at the University of Ottawa in 2001 and at Dalhousie University in 2007. Topics covered in these notes include the untyped lambda calculus, the Church-Rosser theorem, combinatory algebras, the simply-typed lambda calculus, the Curry-Howard isomorphism, weak and strong normalization, type inference, denotational semantics, complete partial orders, and the language PCF.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/D3VZDUND/Selinger - Lecture Notes on the Lambda Calculus.pdf}
}

@article{selsamCongruenceClosureIntensional2017,
  title = {Congruence {{Closure}} in {{Intensional Type Theory}}},
  author = {Selsam, D. and {de Moura}, L.},
  year = {2017},
  month = jan,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@book{selzerAppliedBioinformatics2018,
  title = {Applied {{Bioinformatics}}},
  author = {Selzer, Paul M. and Marh{\"o}fer, Richard J. and Koch, Oliver},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-68301-0}
}

@techreport{sergeyIntroducingFunctionalProgrammers2014,
  title = {Introducing {{Functional Programmers}} to {{Interactive Theorem Proving}} and {{Program Verification}}},
  author = {Sergey, I. and Nanevski, A.},
  year = {2014},
  institution = {IMDEA Software Institute}
}

@book{sergeyProgramsProofsMechanizing2016,
  title = {Programs and {{Proofs}} - {{Mechanizing Mathematics}} with {{Dependent Types}}},
  author = {Sergey, I.},
  year = {2016},
  annotation = {Published: {\textbackslash}tt http://ilyasergey.net/pnp/pnp.pdf},
  file = {/home/flaviomoura/Zotero/storage/6CYNXJUN/pnp.pdf}
}

@phdthesis{severiNormalisationLambdaCalculus1996,
  title = {Normalisation in {{Lambda Calculus}} and {{Its}} Relation to {{Type Inference}}},
  author = {Severi, P.},
  year = {1996},
  school = {Eindhoven University of Technology}
}

@article{sheneComparativeStudyLinked1996,
  title = {A Comparative Study of Linked List Sorting Algorithms},
  author = {Shene, Ching-Kuang},
  year = {1996},
  month = apr,
  journal = {3C ON-LINE},
  volume = {3},
  number = {2},
  pages = {4--9},
  issn = {1078-2192},
  doi = {10.1145/225890.225893},
  urldate = {2024-12-11},
  abstract = {Carraway recently published an article [2] describing a sorting algorithm (the sediment sort) for doubly linked lists. He claimed that the sediment sort is one of the fastest and most efficient sorts for linked list, and planned to determine its complexity. In this article, a comparative study will be presented to show that the sediment sort is only a minor variation of the bubble sort which has been known to the computer science community for more than three decades and that the sediment sort is perhaps the slowest algorithm for sorting linked lists.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XELSV6ED/Shene - 1996 - A comparative study of linked list sorting algorit.pdf}
}

@article{shiDesigningProofDeautomation,
  title = {Designing {{Proof Deautomation}} for {{Coq}}},
  author = {Shi, Jessica and Torczon, Cassia and Goldstein, Harrison},
  abstract = {Proof assistant users rely on automation to reduce the burden of writing and maintaining proofs. By design, automation hides the details of intermediate proof steps, making proofs both shorter and more robust. However, we observed in a need-finding study that users sometimes do want to examine the details of these intermediate steps, either to understand how the proof works or to pinpoint where it has broken. To support such activities, we describe a proof deautomation procedure that reconstructs the underlying steps of an automated proof. We discuss the design considerations that shaped our approach to deautomation --- in particular, the requirement that deautomation should remain informative even for failing proofs --- and we propose a deautomation algorithm and a proof-of-concept implementation.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/9FR6SLSS/Shi et al. - Designing Proof Deautomation for Coq.pdf}
}

@inproceedings{shillitoMechanisedConstructiveReverse2024,
  title = {A {{Mechanised}} and {{Constructive Reverse Analysis}} of {{Soundness}} and {{Completeness}} of {{Bi-intuitionistic Logic}}},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Shillito, Ian and Kirst, Dominik},
  year = {2024},
  month = jan,
  series = {{{CPP}} 2024},
  pages = {218--229},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3636501.3636957},
  urldate = {2024-05-29},
  abstract = {Using the Coq proof assistant, we investigate the minimal non-constructive principles needed to show soundness and completeness of propositional bi-intuitionistic logic. Before being revisited and corrected by Gor{\'e} and Shillito, the completeness of bi-intuitionistic logic, an extension of intuitionistic logic with a dual operation to implication, had a rather erratic history, making it an ideal case for computer mechanisation. Moreover, contributing a constructive perspective, we observe that the completeness of bi-intuitionistic logic explicates the same characteristics already observed in an ongoing effort to analyse completeness theorems in general.},
  isbn = {9798400704888},
  keywords = {bi-intuitionistic logic,completeness,constructive reverse mathematics,Coq},
  file = {/home/flaviomoura/Zotero/storage/K8ZIW4UE/Shillito e Kirst - 2024 - A Mechanised and Constructive Reverse Analysis of .pdf}
}

@misc{shillitoNewCalculusIntuitionistic2023,
  title = {A New Calculus for Intuitionistic {{Strong L}}{\textbackslash}"ob Logic: Strong Termination and Cut-Elimination, Formalised},
  shorttitle = {A New Calculus for Intuitionistic {{Strong L}}{\textbackslash}"ob Logic},
  author = {Shillito, Ian and {van der Giessen}, Iris and Gor{\'e}, Rajeev and Iemhoff, Rosalie},
  year = {2023},
  month = sep,
  number = {arXiv:2309.00486},
  eprint = {2309.00486},
  primaryclass = {cs, math},
  publisher = {arXiv},
  urldate = {2023-09-04},
  abstract = {We provide a new sequent calculus that enjoys syntactic cut-elimination and strongly terminating backward proof search for the intuitionistic Strong L{\textbackslash}"ob logic \${\textbackslash}sf\{iSL\}\$, an intuitionistic modal logic with a provability interpretation. A novel measure on sequents is used to prove both the termination of the naive backward proof search strategy, and the admissibility of cut in a syntactic and direct way, leading to a straightforward cut-elimination procedure. All proofs have been formalised in the interactive theorem prover Coq.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/26Q2IP5X/Shillito et al. - 2023 - A new calculus for intuitionistic Strong Lob log.pdf;/home/flaviomoura/Zotero/storage/V5E99QRM/2309.html}
}

@book{shortliffeBiomedicalInformatics2014,
  title = {Biomedical {{Informatics}}},
  editor = {Shortliffe, Edward H. and Cimino, James J.},
  year = {2014},
  series = {[]},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-4474-8}
}

@book{shoupComputationalIntroductionNumber2008,
  title = {A {{Computational Introduction}} to {{Number Theory}} and {{Algebra}}},
  author = {Shoup, Victor},
  year = {2008},
  publisher = {Cambridge University Press}
}

@article{shulmanStrangeNewUniverses2024a,
  title = {Strange New Universes: {{Proof}} Assistants and Synthetic Foundations},
  shorttitle = {Strange New Universes},
  author = {Shulman, Michael},
  year = {2024},
  month = feb,
  journal = {Bulletin of the American Mathematical Society},
  volume = {61},
  number = {2},
  pages = {257--270},
  issn = {0273-0979, 1088-9485},
  doi = {10.1090/bull/1830},
  urldate = {2024-08-05},
  abstract = {Existing computer programs called proof assistants can verify the correctness of mathematical proofs but their specialized proof languages present a barrier to entry for many mathematicians. Large language models have the potential to lower this barrier, enabling mathematicians to interact with proof assistants in a more familiar vernacular. Among other advantages, this may allow mathematicians to explore radically new kinds of mathematics using an LLM-powered proof assistant to train their intuitions as well as ensure their arguments are correct. Existing proof assistants have already played this role for fields such as homotopy type theory.},
  copyright = {https://www.ams.org/publications/copyright-and-permissions},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BFMASJM3/Shulman - 2024 - Strange new universes Proof assistants and synthe.pdf}
}

@misc{siebertzAdvancesAlgorithmicMeta2024,
  title = {Advances in {{Algorithmic Meta Theorems}}},
  author = {Siebertz, Sebastian and Vigny, Alexandre},
  year = {2024},
  month = nov,
  number = {arXiv:2411.15365},
  eprint = {2411.15365},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2411.15365},
  urldate = {2024-11-29},
  abstract = {Tractability results for the model checking problem of logics yield powerful algorithmic meta theorems of the form: Every computational problem expressible in a logic \$L\$ can be solved efficiently on every class \${\textbackslash}mathscr\{C\}\$ of structures satisfying certain conditions. The most prominent logics studied in the field are (counting) monadic second-order logic (C)MSO, and first-order logic FO and its extensions. The complexity of CMSO model checking in general and of FO model checking on monotone graph classes is very well understood. In recent years there has been a rapid and exciting development of new algorithmic meta theorems. On the one hand there has been major progress for FO model checking on hereditary graph classes. This progress was driven by the development of a combinatorial structure theory for the logically defined monadically stable and monadically dependent graph classes, as well as by the advent of the new width measure twinwidth. On the other hand, new algorithmic meta theorems for new logics with expressive power between FO and CMSO offer a new unifying view on methods like the irrelevant vertex technique and recursive understanding. In this paper we overview the recent advances in algorithmic meta theorems and provide rough sketches for the methods to prove them.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Discrete Mathematics,Computer Science - Logic in Computer Science,Mathematics - Combinatorics,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/NUAS98Z5/Siebertz e Vigny - 2024 - Advances in Algorithmic Meta Theorems.pdf;/home/flaviomoura/Zotero/storage/4VLZSST3/2411.html}
}

@book{siekmannComputationalLogic2014,
  title = {Computational {{Logic}}},
  editor = {Siekmann, J{\"o}rg H.},
  year = {2014},
  series = {Handbook of the {{History}} of {{Logic}}},
  volume = {9},
  publisher = {Elsevier},
  isbn = {978-0-444-51624-4}
}

@article{siekmannUnificationTheory1989,
  title = {Unification {{Theory}}},
  author = {Siekmann, J. H.},
  year = {1989},
  journal = {Journal of Symbolic Computation},
  volume = {7},
  number = {3-4},
  pages = {207--274},
  doi = {10.1016/s0747-7171(89)80012-4}
}

@book{silvaLogicaParaComputacao2006,
  title = {L{\'o}gica Para Computa{\c c}{\~a}o},
  author = {da Silva, F. S. C. and de Melo, A. C. V. and Finger, M.},
  year = {2006},
  publisher = {THOMSON PIONEIRA},
  isbn = {978-85-221-0517-5}
}

@article{simonsenModularityInfinitaryTerm2006,
  title = {On Modularity in Infinitary Term Rewriting},
  author = {Simonsen, Jakob Grue},
  year = {2006},
  journal = {Inf. Comput.},
  volume = {204},
  number = {6},
  pages = {957--988},
  doi = {10.1016/j.ic.2006.02.005}
}

@phdthesis{simpsonProofTheorySemantics1994,
  title = {The {{Proof Theory}} and {{Semantics}} of {{Intuitionistic Modal Logic}}},
  author = {Simpson, Alex K.},
  year = {1994},
  school = {University of Edinburgh}
}

@book{simsComputationFinitelyPresented1994,
  title = {Computation with {{Finitely Presented Groups}}},
  author = {Sims, Charles C.},
  year = {1994},
  series = {Encyclopedia of {{Mathematics}} and Its {{Applications}}},
  publisher = {Cambridge University Press},
  address = {Cambridge},
  doi = {10.1017/CBO9780511574702},
  urldate = {2024-03-12},
  abstract = {Research in computational group theory, an active subfield of computational algebra, has emphasised three areas: finite permutation groups, finite solvable groups, and finitely presented groups. This book deals with the third of these areas. The author emphasises the connections with fundamental algorithms from theoretical computer science, particularly the theory of automata and formal languages, computational number theory, and computational commutative algebra. The LLL lattice reduction algorithm and various algorithms for Hermite and Smith normal forms from computational number theory are used to study the abelian quotients of a finitely presented group. The work of Baumslag, Cannonito and Miller on computing nonabelian polycyclic quotients is described as a generalisation of Buchberger's Gr{\"o}bner basis methods to right ideals in the integral group ring of a polycyclic group. Researchers in computational group theory, mathematicians interested in finitely presented groups and theoretical computer scientists will find this book useful.},
  isbn = {978-0-521-43213-9},
  file = {/home/flaviomoura/Zotero/storage/NYF4F2EZ/B4EA39C60B0A6253AA46A9D80443B9C7.html}
}

@techreport{singhInteractiveTheoremProving2015,
  title = {Interactive Theorem Proving in {{Coq}} and the {{Curry-Howard Isomorphism}}},
  author = {Singh, A. K.},
  year = {2015},
  institution = {TIFR Mumbai}
}

@misc{sinhaWuMethodCan2024,
  title = {Wu's {{Method}} Can {{Boost Symbolic AI}} to {{Rival Silver Medalists}} and {{AlphaGeometry}} to {{Outperform Gold Medalists}} at {{IMO Geometry}}},
  author = {Sinha, Shiven and Prabhu, Ameya and Kumaraguru, Ponnurangam and Bhat, Siddharth and Bethge, Matthias},
  year = {2024},
  month = apr,
  number = {arXiv:2404.06405},
  eprint = {2404.06405},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-08-21},
  abstract = {Proving geometric theorems constitutes a hallmark of visual reasoning combining both intuitive and logical skills. Therefore, automated theorem proving of Olympiad-level geometry problems is considered a notable milestone in human-level automated reasoning. The introduction of AlphaGeometry, a neurosymbolic model trained with 100 million synthetic samples, marked a major breakthrough. It solved 25 of 30 International Mathematical Olympiad (IMO) problems whereas the reported baseline based on Wu's method solved only ten. In this note, we revisit the IMO-AG-30 Challenge introduced with AlphaGeometry, and find that Wu's method is surprisingly strong. Wu's method alone can solve 15 problems, and some of them are not solved by any of the other methods. This leads to two key findings: (i) Combining Wu's method with the classic synthetic methods of deductive databases and angle, ratio, and distance chasing solves 21 out of 30 methods by just using a CPU-only laptop with a time limit of 5 minutes per problem. Essentially, this classic method solves just 4 problems less than AlphaGeometry and establishes the first fully symbolic baseline, strong enough to rival the performance of an IMO silver medalist. (ii) Wu's method even solves 2 of the 5 problems that AlphaGeometry failed to solve. Thus, by combining AlphaGeometry with Wu's method we set a new state-of-the-art for automated theorem proving on IMO-AG-30, solving 27 out of 30 problems, the first AI method which outperforms an IMO gold medalist.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Computation and Language,Computer Science - Computational Geometry,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/7V24NFPX/Sinha et al. - 2024 - Wu's Method can Boost Symbolic AI to Rival Silver .pdf}
}

@article{sinkarovsChoosingLosingHow2021,
  title = {Choosing Is {{Losing}}: {{How}} to Combine the Benefits of Shallow and Deep Embeddings through Reflection},
  shorttitle = {Choosing Is {{Losing}}},
  author = {{\v S}inkarovs, Artjoms and Cockx, Jesper},
  year = {2021},
  month = may,
  journal = {arXiv:2105.10819 [cs]},
  eprint = {2105.10819},
  primaryclass = {cs},
  urldate = {2021-05-29},
  abstract = {Dependently-typed host languages empower users to verify a wide range of properties of embedded languages and programs written in them. Designers of such embedded languages are faced with a difficult choice between using a shallow or a deep embedding. The former is easier to use because the entire infrastructure of the host langauge is immediately available. Meanwhile, the latter gives full access to the structure of embedded programs, but is difficult to use in practice, especially when the embedded language is itself dependently typed. The main insight presented in this paper is that the choice between shallow and deep embedding can be eliminated by working in a host language with reflection capabilities: we start from a shallow embedding that can use all libraries and tools of the host language, and later use reflection to expose the deep structure of the embedded programs. Concretely, we apply this technique to embed three programming languages -- Kaleidoscope, SaC, and (a subset of) APL -- into the dependently typed theorem prover Agda, using dependent types to statically enforce several properties of interest. We then use Agda's reflection capabilities to extract the embedded programs back into the original language, so that the existing toolchain can be leveraged. In this process, statically verified properties of the host language are mapped onto runtime checks in the target language, allowing extracted programs to interact safely with existing code. Finally, we demonstrate the feasibility of our approach with the implementation and extraction of a convolutional neural network in our embedding of APL.{\textbackslash}@},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/KHFKEDPQ/2105.html}
}

@book{sipserIntroductionTheoryComputation1996,
  title = {Introduction to the {{Theory}} of {{Computation}}},
  author = {Sipser, Michael},
  year = {1996},
  edition = {1st},
  publisher = {International Thomson Publishing},
  isbn = {0-534-94728-X},
  file = {/home/flaviomoura/Zotero/storage/U6SWYN8Q/Sipser.pdf}
}

@article{sitnikovskiFormalizingTextEditors2020,
  title = {Formalizing {{Text Editors}} in {{Coq}}},
  author = {Sitnikovski, Boro},
  year = {2020},
  journal = {CoRR},
  abstract = {Text editors represent one of the fundamental tools that writers use -- software developers, book authors, mathematicians. A text editor must work as intended in that it allows the users to do their job. We will start by introducing a small subset of a full-blown text editor -- line editor. Next, we will give a concrete definition (specification) of what a complete text editor means. Afterward, we will provide an implementation of a line editor in Coq, and then we will prove that it is a complete text editor.}
}

@article{sitnikovskiTutorialImplementingHoare2021,
  title = {Tutorial on Implementing {{Hoare}} Logic for Imperative Programs in {{Haskell}}},
  author = {Sitnikovski, Boro},
  year = {2021},
  month = feb,
  journal = {arXiv:2101.11320 [cs]},
  eprint = {2101.11320},
  primaryclass = {cs},
  urldate = {2021-02-19},
  abstract = {Using the programming language Haskell, we introduce an implementation for a simple imperative language that can evaluate arithmetic and boolean expressions; step by step, we will expand the implementation starting from arithmetic expressions, to boolean expressions and then to imperative programs. As we expand the language, we will show several evaluation strategies, considering the normalization property and how it affects an implementation. Finally, we will provide a bottom-up implementation of Hoare's logic which will allow us to deduce facts about programs without the need for a full evaluation.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/JCJNM8WG/Sitnikovski - 2021 - Tutorial on implementing Hoare logic for imperativ.pdf;/home/flaviomoura/Zotero/storage/UCFTEI7E/2101.html}
}

@book{skansiIntroductionDeepLearning2018,
  title = {Introduction to {{Deep Learning}}},
  author = {Skansi, Sandro},
  year = {2018},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-73004-2}
}

@book{skienaAlgorithmDesignManual2008,
  title = {The Algorithm Design Manual},
  author = {Skiena, Steven S},
  year = {2008},
  edition = {2ed.},
  publisher = {Springer},
  isbn = {1-84800-069-3 978-1-84800-069-8 978-1-84800-070-4 1-84800-070-7},
  file = {/home/flaviomoura/Zotero/storage/T2EN6VA7/Skiena - 2008 - The algorithm design manual.pdf}
}

@article{slindTeachingHOLCourse,
  title = {Teaching a {{HOL Course}}: {{Experience Report}}},
  author = {Slind, Konrad and Barrus, Steven and Choe, Seungkeol and Condrat, Chris and Duan, Jianjun and Gopalakrishnan, Sivaram and Knoll, Aaron and Kuwahara, Hiro and Li, Guodong and Liu, Lei and Moore, Steffanie and Palmer, Robert and Tuttle, Claurissa and Walton, Sean and Yang, Yu and Zhang, Junxing},
  pages = {11},
  abstract = {Experience from teaching a course in Higher Order Logic theorem proving is recounted, from both the student and teacher perspective.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ZIVV3MJT/Slind et al. - Teaching a HOL Course Experience Report.pdf}
}

@book{slindTheoremProvingHigher2004,
  title = {Theorem {{Proving}} in {{Higher Order Logics}}, 17th {{International Conference}}, {{TPHOLs}} 2004, {{Park City}}, {{Utah}}, {{USA}}, {{September}} 14-17, 2004, {{Proceedings}}},
  editor = {Slind, Konrad and Bunker, Annette and Gopalakrishnan, Ganesh},
  year = {2004},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {3223},
  publisher = {Springer},
  doi = {10.1007/b100400},
  isbn = {3-540-23017-3}
}

@book{smartCryptographyMadeSimple2016,
  title = {Cryptography {{Made Simple}}},
  author = {Smart, Nigel P.},
  year = {2016},
  series = {Information {{Security}} and {{Cryptography}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-21936-3}
}

@book{smithIntroductionFormalLogic2003,
  title = {An {{Introduction}} to {{Formal Logic}}},
  author = {Smith, Peter},
  year = {2003},
  publisher = {Cambridge University Press}
}

@article{smolkaModelingProvingComputational,
  title = {Modeling and {{Proving}} in {{Computational Type Theory Using}} the {{Coq Proof Assistant}}},
  author = {Smolka, Gert},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/VS2IE94H/Smolka - Textbook under Construction.pdf}
}

@book{smullyanFirstOrderLogic1968,
  title = {First-{{Order Logic}}},
  author = {Smullyan, Raymond M.},
  year = {1968},
  series = {[]},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-86718-7},
  file = {/home/flaviomoura/Zotero/storage/N2DJEQWM/Smullyan - 1968 - First-Order Logic.pdf}
}

@book{smullyanLogicalLabyrinths2009,
  title = {Logical {{Labyrinths}}},
  author = {Smullyan, Raymond},
  year = {2009},
  publisher = {AK Peters},
  isbn = {1-56881-443-7 978-1-56881-443-8},
  file = {/home/flaviomoura/Zotero/storage/FLXIXWL3/Smullyan - 2009 - Logical Labyrinths.pdf}
}

@book{smullyanWhatNameThis1978,
  title = {What Is the Name of This Book?},
  author = {Smullyan, Raymond},
  year = {1978},
  publisher = {Touchstone},
  keywords = {book.math},
  file = {/home/flaviomoura/Zotero/storage/2HK59SX9/Smullyan - 1978 - What is the name of this book.pdf}
}

@article{sniedovichDijkstraAlgorithmRevisited,
  title = {Dijkstra's Algorithm Revisited: The Dynamic Programming Connexion},
  author = {Sniedovich, Moshe},
  abstract = {Dijkstra's Algorithm is one of the most popular algorithms in computer science. It is also popular in operations research. It is generally viewed and presented as a greedy algorithm. In this paper we attempt to change this perception by providing a dynamic programming perspective on the algorithm. In particular, we are reminded that this famous algorithm is strongly inspired by Bellman's Principle of Optimality and that both conceptually and technically it constitutes a dynamic programming successive approximation procedure par excellence. One of the immediate implications of this perspective is that this popular algorithm can be incorporated in the dynamic programming syllabus and in turn dynamic programming should be (at least) alluded to in a proper exposition/teaching of the algorithm.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2QEMX2NG/Sniedovich - Dijkstraâs algorithm revisited the dynamic progra.pdf}
}

@article{snyderHigherOrderUnificationRevisited1989,
  title = {Higher-{{Order Unification Revisited}}: {{Complete Sets}} of {{Transformations}}},
  author = {Snyder, W. and Gallier, J. H.},
  year = {1989},
  journal = {J. Symb. Comput.},
  volume = {8},
  number = {1/2},
  pages = {101--140}
}

@article{snyderUsingSudokuIntroduce2010,
  title = {Using {{Sudoku}} to {{Introduce Proof Techniques}}},
  author = {Snyder, Brian A.},
  year = {2010},
  month = may,
  journal = {PRIMUS},
  volume = {20},
  number = {5},
  pages = {383--391},
  issn = {1051-1970, 1935-4053},
  doi = {10.1080/10511970802326145},
  urldate = {2022-07-13},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HABTAY7J/Snyder - 2010 - Using Sudoku to Introduce Proof Techniques.pdf}
}

@book{soberonProblemSolvingMethodsCombinatorics2013,
  title = {Problem-{{Solving Methods}} in {{Combinatorics}}},
  author = {Sober{\'o}n, P.},
  year = {2013},
  series = {Nil},
  publisher = {Springer Nature},
  doi = {10.1007/978-3-0348-0597-1}
}

@mastersthesis{sobrinhoProblemaDeducaoIntruso2009,
  title = {O {{Problema}} Da {{Dedu{\c c}{\~a}o}} Do {{Intruso}} Para Um {{Protocolo Criptogr{\'a}fico Especificado}} via {{Reescrita M{\'o}dulo AC}}. 2009},
  author = {Sobrinho, D. Nantes},
  year = {2009},
  school = {Departamento de Matem{\'a}tica - Universidade de Bras{\'i}lia}
}

@inproceedings{sobrinhoReductionIntruderDeduction2010,
  title = {Reduction of the {{Intruder Deduction Problem}} into {{Equational Elementary Deduction}} for {{Electronic Purse Protocols}} with {{Blind Signatures}}},
  booktitle = {Proc. 17th {{Workshop}} on {{Logic}}, {{Language}}, {{Information}} and {{Computation}} - {{WoLLIC}} 2010},
  author = {Sobrinho, D. Nantes and {Ayala-Rinc{\'o}n}, M.},
  year = {2010},
  series = {{{LNAI}}},
  volume = {6188},
  pages = {218--231}
}

@book{socher-ambrosiusDeductionSystems1997,
  title = {Deduction {{Systems}}},
  author = {{Socher-Ambrosius}, R. and Johann, P.},
  year = {1997},
  series = {Nil},
  publisher = {Springer Nature},
  doi = {10.1007/978-1-4612-2266-8}
}

@book{soiferMathematicsProblemSolving2009,
  title = {Mathematics as {{Problem Solving}}},
  author = {Soifer, A.},
  year = {2009},
  series = {Nil},
  publisher = {Springer New York},
  doi = {10.1007/978-0-387-74647-0}
}

@article{sojakovaEquivalenceTorusProduct2016,
  title = {The {{Equivalence}} of the {{Torus}} and the {{Product}} of {{Two Circles}} in {{Homotopy Type Theory}}},
  author = {Sojakova, K.},
  year = {2016},
  journal = {ACM Transactions on Computational Logic},
  volume = {17},
  number = {4},
  pages = {1--19},
  doi = {10.1145/2992783}
}

@article{sojakovaSyllepsisHomotopyType2021,
  title = {Syllepsis in {{Homotopy Type Theory}}},
  author = {Sojakova, Kristina},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.14283 [cs]},
  eprint = {2107.14283},
  primaryclass = {cs},
  urldate = {2021-08-02},
  abstract = {It is well-known that in homotopy type theory (HoTT), one can prove the Eckmann-Hilton theorem: given two 2-loops p, q : 1 = 1 on the reflexivity path at an arbitrary point a : A, we have pq = qp. If we go one dimension higher, i.e., if p and q are 3-loops, we show that a property classically known as syllepsis also holds in HoTT: namely, the Eckmann-Hilton proof for q and p is the inverse of the Eckmann-Hilton proof for p and q.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/MTS32UXB/Sojakova - 2021 - Syllepsis in Homotopy Type Theory.pdf;/home/flaviomoura/Zotero/storage/XL8TMTVU/2107.html}
}

@article{solovayFastMonteCarloTest1977,
  title = {A Fast {{Monte-Carlo}} Test for Primality},
  author = {Solovay, R. and Strassen, V.},
  year = {1977},
  journal = {SIAM journal on Computing},
  number = {6},
  pages = {84--86}
}

@misc{songEquationalBitVectorSolving2024,
  title = {Equational {{Bit-Vector Solving}} via {{Strong Gr}}{\textbackslash}"obner {{Bases}}},
  author = {Song, Jiaxin and Fu, Hongfei and Zhang, Charles},
  year = {2024},
  month = feb,
  number = {arXiv:2402.16314},
  eprint = {2402.16314},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2402.16314},
  urldate = {2024-02-27},
  abstract = {Bit-vectors, which are integers in a finite number of bits, are ubiquitous in software and hardware systems. In this work, we consider the satisfiability modulo theories (SMT) of bit-vectors. Unlike normal integers, the arithmetics of bit-vectors are modular upon integer overflow. Therefore, the SMT solving of bit-vectors needs to resolve the underlying modular arithmetics. In the literature, two prominent approaches for SMT solving are bit-blasting (that transforms the SMT problem into boolean satisfiability) and integer solving (that transforms the SMT problem into integer properties). Both approaches ignore the algebraic properties of the modular arithmetics and hence could not utilize these properties to improve the efficiency of SMT solving. In this work, we consider the equational theory of bit-vectors and capture the algebraic properties behind them via strong Gr{\textbackslash}"obner bases. First, we apply strong Gr{\textbackslash}"obner bases to the quantifier-free equational theory of bit-vectors and propose a novel algorithmic improvement in the key computation of multiplicative inverse modulo a power of two. Second, we resolve the important case of invariant generation in quantified equational bit-vector properties via strong Gr{\textbackslash}"obner bases and linear congruence solving. Experimental results over an extensive range of benchmarks show that our approach outperforms existing methods in both time efficiency and memory consumption.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/YLB84MW8/Song et al. - 2024 - Equational Bit-Vector Solving via Strong Grobner.pdf;/home/flaviomoura/Zotero/storage/DFBR2JRB/2402.html}
}

@misc{songLargeLanguageModels2024,
  title = {Towards {{Large Language Models}} as {{Copilots}} for {{Theorem Proving}} in {{Lean}}},
  author = {Song, Peiyang and Yang, Kaiyu and Anandkumar, Anima},
  year = {2024},
  month = apr,
  number = {arXiv:2404.12534},
  eprint = {2404.12534},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2404.12534},
  urldate = {2025-01-27},
  abstract = {Theorem proving is an important challenge for large language models (LLMs), as formal proofs can be checked rigorously by proof assistants such as Lean, leaving no room for hallucination. Existing LLM-based provers try to prove theorems in a fully autonomous mode without human intervention. In this mode, they struggle with novel and challenging theorems, for which human insights may be critical. In this paper, we explore LLMs as copilots that assist humans in proving theorems. We introduce Lean Copilot, a framework for running LLM inference in Lean. It enables programmers to build various LLM-based proof automation tools that integrate seamlessly into the workflow of Lean users. Using Lean Copilot, we build tools for suggesting proof steps (tactic suggestion), completing intermediate proof goals (proof search), and selecting relevant premises (premise selection) using LLMs. Users can use our pretrained models or bring their own ones that run either locally (with or without GPUs) or on the cloud. Experimental results demonstrate the effectiveness of our method in assisting humans and automating theorem proving process compared to existing rule-based proof automation in Lean. We open source all codes under a permissive MIT license to facilitate further research.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Machine Learning,Statistics - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/BJSRM92W/Song et al. - 2024 - Towards Large Language Models as Copilots for Theo.pdf;/home/flaviomoura/Zotero/storage/J6ENMUN2/2404.html}
}

@book{sorensenLecturesCurryHowardIsomorphism2006,
  title = {Lectures on the {{Curry-Howard Isomorphism}}, {{Volume}} 149 ({{Studies}} in {{Logic}} and the {{Foundations}} of {{Mathematics}})},
  author = {S{\o}rensen, M. H. and Urzyczyn, P.},
  year = {2006},
  publisher = {Elsevier Science Inc.},
  address = {New York, NY, USA},
  isbn = {0-444-52077-5},
  file = {/home/flaviomoura/Zotero/storage/SAQVHNBK/SÃ¸rensen e Urzyczyn - 2006 - Lectures on the Curry-Howard Isomorphism, Volume 1.pdf}
}

@incollection{sorensenSequentCalculus2006,
  title = {Sequent Calculus},
  booktitle = {Studies in {{Logic}} and the {{Foundations}} of {{Mathematics}}},
  author = {S{\o}rensen, Morten Heine and Urzyczyin, Pawel},
  year = {2006},
  volume = {149},
  pages = {161--194},
  publisher = {Elsevier},
  doi = {10.1016/S0049-237X(06)80008-X},
  urldate = {2022-09-12},
  isbn = {978-0-444-52077-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/G4ULLPQD/SÃ¸rensen e Urzyczyin - 2006 - Sequent calculus.pdf}
}

@article{sottilePolymorphicSystem2021,
  title = {Polymorphic {{System I}}},
  author = {Sottile, Cristian F. and {D{\'i}az-Caro}, Alejandro and L{\'o}pez, Pablo E. Mart{\'i}nez},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.03215 [cs]},
  eprint = {2101.03215},
  primaryclass = {cs},
  urldate = {2021-01-12},
  abstract = {System I is a simply-typed lambda calculus with pairs, extended with an equational theory obtained from considering the type isomorphisms as equalities. In this work we propose an extension of System I to polymorphic types, adding the corresponding isomorphisms. We provide non-standard proofs of subject reduction and strong normalisation, extending those of System I.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/7RRGLE92/Sottile et al. - 2021 - Polymorphic System I.pdf;/home/flaviomoura/Zotero/storage/9HEFMWYR/2101.html}
}

@mastersthesis{sozeauCoercionParPredicats2005,
  title = {Coercion Par Pr{\'e}dicats En {{Coq}}},
  author = {Sozeau, Matthieu},
  year = {2005},
  school = {Universit{\'e} Paris VII}
}

@article{sozeauCorrectCompleteType,
  title = {Correct and {{Complete Type Checking}} and {{Certified Erasure}} for {{Coq}}, in {{Coq}}},
  author = {Sozeau, Matthieu and Forster, Yannick and {Lennon-Bertrand}, Meven and Nielsen, Jakob Botsch and Tabareau, Nicolas and Winterhalter, Th{\'e}o},
  abstract = {Coq is built around a well-delimited kernel that performs type checking for definitions in a variant of the Calculus of Inductive Constructions (CIC). Although the metatheory of CIC is very stable and reliable, the correctness of its implementation in Coq is less clear. Indeed, implementing an efficient type checker for CIC is a rather complex task, and many parts of the code rely on implicit invariants which can easily be broken by further evolution of the code. Therefore, on average, one critical bug has been found every year in Coq. This paper presents the first implementation of a type checker for the kernel of Coq (without the module system, template polymorphism and {$H$}-conversion), which is proven sound and complete in Coq with respect to its formal specification. Note that because of G{\"o}del's second incompleteness theorem, there is no hope to prove completely the soundness of the specification of Coq inside Coq (in particular strong normalization), but it is possible to prove the correctness and completeness of the implementation assuming soundness of the specification, thus moving from a trusted code base (TCB) to a trusted theory base (TTB) paradigm. Our work is based on the MetaCoq project which provides meta-programming facilities to work with terms and declarations at the level of the kernel. We verify a relatively efficient type checker based on the specification of the typing relation of the Polymorphic, Cumulative Calculus of Inductive Constructions (PCUIC) at the basis of Coq. It is worth mentioning that during the verification process, we have found a source of incompleteness in Coq's official type checker, which has then been fixed in Coq 8.14 thanks to our work. In addition to the kernel implementation, another essential feature of Coq is the so-called extraction mechanism: the production of executable code in functional languages from Coq definitions. We present a verified version of this subtle type and proof erasure step, therefore enabling the verified extraction of a safe type checker for Coq in the future. CCS Concepts: {$\bullet$} Theory of computation {$\rightarrow$} Type theory.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/8Q8HCG42/Sozeau et al. - Correct and Complete Type Checking and Certified E.pdf}
}

@phdthesis{sozeauEnvironnementPourProgrammation2008,
  title = {Un Environnement Pour La Programmation Avec Types D{\'e}pendants},
  author = {Sozeau, Matthieu},
  year = {2008},
  school = {Universit{\'e} Paris 11}
}

@article{sozeauEquationsReloadedHighlevel2019,
  title = {Equations {{Reloaded}}: {{High-level Dependently-typed Functional Programming}} and {{Proving}} in {{Coq}}},
  author = {Sozeau, Matthieu and Mangin, Cyprien},
  year = {2019},
  month = jul,
  journal = {Proc. ACM Program. Lang.},
  volume = {3},
  number = {ICFP},
  pages = {86:1--86:29},
  publisher = {ACM},
  address = {New York, NY, USA},
  issn = {2475-1421},
  doi = {10.1145/3341690},
  keywords = {dependent pattern-matching,proof assistants,recursion},
  file = {/home/flaviomoura/Zotero/storage/JMPIMADV/Sozeau and Mangin - 2019 - Equations reloaded high-level dependently-typed f.pdf}
}

@inproceedings{sozeauFirstClassTypeClasses2008,
  title = {First-{{Class Type Classes}}},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  author = {Sozeau, Matthieu and Oury, Nicolas},
  editor = {Mohamed, Otmane Ait and Mu{\~n}oz, C{\'e}sar and Tahar, Sofi{\`e}ne},
  year = {2008},
  pages = {278--293},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-71067-7_23},
  abstract = {Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.},
  isbn = {978-3-540-71067-7},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/QH9PRI8K/Sozeau and Oury - 2008 - First-Class Type Classes.pdf}
}

@article{sozeauMetaCoqProject2020,
  title = {The {{MetaCoq Project}}},
  author = {Sozeau, Matthieu and Anand, Abhishek and Boulier, Simon and Cohen, Cyril and Forster, Yannick and Kunze, Fabian and Malecha, Gregory and Tabareau, Nicolas and Winterhalter, Th{\'e}o},
  year = {2020},
  month = jun,
  journal = {Journal of Automated Reasoning},
  volume = {64},
  number = {5},
  pages = {947--999},
  issn = {0168-7433, 1573-0670},
  doi = {10.1007/s10817-019-09540-0},
  urldate = {2020-11-17},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/FMIZEHGH/Sozeau et al. - 2020 - The MetaCoq Project.pdf}
}

@article{sozeauNewLookGeneralized2009,
  title = {A {{New Look}} at {{Generalized Rewriting}} in {{Type Theory}}},
  author = {Sozeau, M.},
  year = {2009},
  journal = {J. Formalized Reasoning},
  volume = {2},
  number = {1},
  pages = {41--62},
  doi = {10.6092/issn.1972-5787/1574},
  file = {/home/flaviomoura/Zotero/storage/VERU2WQ5/Sozeau - 2009 - A New Look at Generalized Rewriting in Type Theory.pdf}
}

@inproceedings{sozeauProgramingFingerTrees2007,
  title = {Program-Ing {{Finger Trees}} in {{Coq}}},
  booktitle = {Proceedings of the 12th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  author = {Sozeau, Matthieu},
  year = {2007},
  series = {{{ICFP}} '07},
  pages = {13--24},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/1291151.1291156},
  isbn = {978-1-59593-815-2},
  keywords = {C\<scp\>oq\</scp\>,certification,dependent types,finger trees}
}

@incollection{sozeauSubsetCoercionsCoq2007,
  title = {Subset {{Coercions}} in {{Coq}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {Sozeau, Matthieu},
  editor = {Altenkirch, Thorsten and McBride, Conor},
  year = {2007},
  volume = {4502},
  pages = {237--252},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-74464-1_16},
  urldate = {2023-10-23},
  isbn = {978-3-540-74463-4 978-3-540-74464-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NSV79J2Y/Sozeau - 2007 - Subset Coercions in Coq.pdf}
}

@article{sozeauTouringMetaCoqProject2021,
  title = {Touring the {{MetaCoq Project}} ({{Invited Paper}})},
  author = {Sozeau, Matthieu},
  year = {2021},
  month = jul,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {337},
  eprint = {2107.07670},
  pages = {13--29},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.337.2},
  urldate = {2021-07-19},
  abstract = {Proof assistants are getting more widespread use in research and industry to provide certified and independently checkable guarantees about theories, designs, systems and implementations. However, proof assistant implementations themselves are seldom verified, although they take a major share of the trusted code base in any such certification effort. In this area, proof assistants based on Higher-Order Logic enjoy stronger guarantees, as self-certified implementations have been available for some years. One cause of this difference is the inherent complexity of dependent type theories together with their extensions with inductive types, universe polymorphism and complex sort systems, and the gap between theory on paper and practical implementations in efficient programming languages. MetaCoq is a collaborative project that aims to tackle these difficulties to provide the first fully-certified realistic implementation of a type checker for the full calculus underlying the Coq proof assistant. To achieve this, we refined the sometimes blurry, if not incorrect, specification and implementation of the system. We show how theoretical tools from this community such as bidirectional type-checking, Tait-Martin-L{\textbackslash}"of/Takahashi's confluence proof technique and monadic and dependently-typed programming can help construct the following artefacts: a specification of Coq's syntax and type theory, the Polymorphic Cumulative Calculus of (Co)-Inductive Constructions (PCUIC); a monad for the manipulation of raw syntax and interaction with the Coq system; a verification of PCUIC's metatheory, whose main results are the confluence of reduction, type preservation and principality of typing; a realistic, correct and complete type-checker for PCUIC; a sound type and proof erasure procedure from PCUIC to untyped lambda-calculus, i.e., the core of the extraction mechanism of Coq.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/CQE92WBF/Sozeau - 2021 - Touring the MetaCoq Project (Invited Paper).pdf;/home/flaviomoura/Zotero/storage/WILYCICQ/2107.html}
}

@article{spichkovaBoringFormalMethods2016,
  title = {''{{Boring}} Formal Methods'' or ''{{Sherlock Holmes}} Deduction Methods''?},
  author = {Spichkova, M.},
  year = {2016},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Computers and Society,Computer Science - Logic in Computer Science}
}

@inproceedings{spichkovaBoringFormalMethods2016a,
  title = {"{{Boring Formal Methods}}" or "{{Sherlock Holmes Deduction Methods}}"?},
  booktitle = {{{STAF}}},
  author = {Spichkova, M.},
  year = {2016},
  pages = {242--252},
  publisher = {Springer}
}

@article{spittersTypeClassesMathematics2011,
  title = {Type {{Classes}} for {{Mathematics}} in {{Type Theory}}},
  author = {SPITTERS, B. and WEEGEN, E. VAN DER},
  year = {2011},
  journal = {Mathematical Structures in Computer Science},
  volume = {21},
  number = {04},
  pages = {795--825},
  doi = {10.1017/s0960129511000119},
  file = {/home/flaviomoura/Zotero/storage/NJA238WF/Spitters e Van Der Weegen - 2011 - Type classes for mathematics in type theory.pdf}
}

@article{standeferTranslationsGentzenPrawitz2019,
  title = {Translations {{Between Gentzen}}--{{Prawitz}} and {{Ja{\'s}kowski}}--{{Fitch Natural Deduction Proofs}}},
  author = {Standefer, Shawn},
  year = {2019},
  month = dec,
  journal = {Studia Logica},
  volume = {107},
  number = {6},
  pages = {1103--1134},
  issn = {0039-3215, 1572-8730},
  doi = {10.1007/s11225-018-9828-2},
  urldate = {2021-06-21},
  langid = {english}
}

@article{stanislawRulesSuppositionsFormal1934,
  title = {On the {{Rules}} of {{Suppositions}} in {{Formal Logic}}},
  author = {Stanis{\l}aw, Ja{\'s}kowski},
  year = {1934},
  journal = {Studia Logica},
  edition = {1},
  pages = {5--32}
}

@phdthesis{starkMechanisingSyntaxBinders2019,
  type = {{{doctoralThesis}}},
  title = {Mechanising Syntax with Binders in {{Coq}}},
  author = {Stark, Kathrin},
  year = {2019},
  doi = {10.22028/D291-30298},
  urldate = {2024-06-14},
  abstract = {Mechanising binders in general-purpose proof assistants such as Coq is cumbersome and difficult. Yet binders, substitutions, and instantiation of terms with substitutions are a critical ingredient of many programming languages. Any practicable mechanisation of the meta-theory of the latter hence requires a lean formalisation of the former. We investigate the topic from three angles: First, we realise formal systems with binders based on both pure and scoped de Bruijn algebras together with basic syntactic rewriting lemmas and automation. We automate this process in a compiler called Autosubst; our final tool supports many-sorted, variadic, and modular syntax. Second, we justify our choice of realisation and mechanise a proof of convergence of the sigma calculus, a calculus of explicit substitutions that is complete for equality of the de Bruijn algebra corresponding to the lambda calculus. Third, to demonstrate the practical usefulness of our approach, we provide concise, transparent, and accessible mechanised proofs for a variety of case studies refined to de Bruijn substitutions.},
  langid = {english},
  school = {Saarl{\"a}ndische Universit{\"a}ts- und Landesbibliothek},
  annotation = {Accepted: 2020-03-03T11:01:57Z},
  file = {/home/flaviomoura/Zotero/storage/QIKSCBGA/Stark - 2019 - Mechanising syntax with binders in Coq.pdf}
}

@article{statmanIntuitionisticPropositionalLogic1979,
  title = {Intuitionistic Propositional Logic Is Polynomial-Space Complete},
  author = {Statman, Richard},
  year = {1979},
  month = jul,
  journal = {Theoretical Computer Science},
  volume = {9},
  number = {1},
  pages = {67--72},
  issn = {0304-3975},
  doi = {10.1016/0304-3975(79)90006-9},
  urldate = {2024-07-02},
  abstract = {It is the purpose of this note to show that the question of whether a given propositional formula is intuitionistically valid (in Brouwer's sense, in Kripke's sense, or just provable by Heyting's rules, see Kreisel [7]) is p-space complete (see Stockmeyer [14]). Our result has the following consequences:1.(a) There is a simple (i.e. polynomial time) translation of intuitionistic propositional logic into classical propositional logic if and only if NP = p-space.2.(b) The problem of determining if a type of the typed {$\lambda$}-calculus is the type of a closed {$\lambda$}-term is p-space complete (this will be discussed below).3.(c) There is a polynomial bounded intuitionistic proof system if and only if NP = p-space (see Cook and Reckhow [2]).},
  file = {/home/flaviomoura/Zotero/storage/I7K2CGIA/Statman - 1979 - Intuitionistic propositional logic is polynomial-s.pdf;/home/flaviomoura/Zotero/storage/LVBR2LRE/0304397579900069.html}
}

@book{steffenMathematicalFoundationsAdvanced2018,
  title = {Mathematical {{Foundations}} of {{Advanced Informatics}}},
  author = {Steffen, Bernhard and R{\"u}thing, Oliver and Huth, Michael},
  year = {2018},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-68397-3}
}

@article{steffenonBELOSPROBLEMASMATEMATICA,
  title = {{BELOS PROBLEMAS DE MATEM{\'A}TICA}},
  author = {Steffenon, Rog{\'e}rio and Guarnieri, Felipe},
  pages = {139},
  langid = {portuguese},
  file = {/home/flaviomoura/Zotero/storage/WT3JZ3TQ/Steffenon e Guarnieri - BELOS PROBLEMAS DE MATEMÃTICA.pdf}
}

@article{steinbergComputableAnalysisNotions2021,
  title = {Computable Analysis and Notions of Continuity in {{Coq}}},
  author = {Steinberg, Florian and Thery, Laurent and Thies, Holger},
  year = {2021},
  month = may,
  journal = {arXiv:1904.13203 [cs]},
  eprint = {1904.13203},
  primaryclass = {cs},
  urldate = {2021-05-12},
  abstract = {We give a number of formal proofs of theorems from the field of computable analysis. Many of our results specify executable algorithms that work on infinite inputs by means of operating on finite approximations and are proven correct in the sense of computable analysis. The development is done in the proof assistant Coq and heavily relies on the Incone library for information theoretic continuity. This library is developed by one of the authors and the paper can be used as an introduction to the library as it describes many of its most important features in detail. While the ability to have full executability in a formal development of mathematical statements about real numbers and the like is not a feature that is unique to the Incone library, its original contribution is to adhere to the conventions of computable analysis to provide a general purpose interface for algorithmic reasoning on continuous structures. The results that provide complete computational content include that the algebraic operations and the efficient limit operator on the reals are computable, that certain countably infinite products are isomorphic to spaces of functions, compatibility of the enumeration representation of subsets of natural numbers with the abstract definition of the space of open subsets of the natural numbers, and that continuous realizability implies sequential continuity. We also formalize proofs of non-computational results that support the correctness of our definitions. These include that the information theoretic notion of continuity used in the library is equivalent to the metric notion of continuity on Baire space, a complete comparison of the different concepts of continuity that arise from metric and represented-space structures and the discontinuity of the unrestricted limit operator on the real numbers and the task of selecting an element of a closed subset of the natural numbers.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/HVYZNTHK/1904.html}
}

@book{stephensonPythonWorkbook2014,
  title = {The {{Python Workbook}}},
  author = {Stephenson, Ben},
  year = {2014},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-14240-1}
}

@book{sterling1994art,
  title = {The Art of {{Prolog}}: Advanced Programming Techniques},
  author = {Sterling, Leon and Shapiro, Ehud Y},
  year = {1994},
  publisher = {MIT press}
}

@article{sternagelProofPearlaMechanized2012,
  title = {Proof {{Pearl-a Mechanized Proof}} of {{Ghc}}'s {{Mergesort}}},
  author = {Sternagel, Christian},
  year = {2012},
  journal = {J Autom Reasoning},
  volume = {51},
  number = {4},
  pages = {357--370},
  doi = {10.1007/s10817-012-9260-7}
}

@phdthesis{stewartFormulaeastypesCorrespondenceClassical1999,
  title = {On the Formulae-as-Types Correspondence for Classical Logic},
  author = {Stewart, C. A.},
  year = {1999},
  school = {Oxford University}
}

@article{stewartIntuitionisticModalLogic2018,
  title = {Intuitionistic {{Modal Logic}}: {{A}} 15-Year Retrospective},
  author = {Stewart, Charles and de Paiva, Valeria and Alechina, Natasha},
  year = {2018},
  journal = {J. Log. Comput.},
  volume = {28},
  number = {5},
  pages = {873--882},
  doi = {10.1093/logcom/exv042}
}

@book{stillwellRoadsInfinityMathematics2010,
  title = {Roads to {{Infinity}}: {{The Mathematics}} of {{Truth}} and {{Proof}}},
  author = {Stillwell, John C.},
  year = {2010},
  publisher = {AK Peters},
  isbn = {1-56881-466-6 978-1-56881-466-7}
}

@book{stillwellYearningImpossibleSurprising2018,
  title = {Yearning for the {{Impossible}}: {{The Surprising Truths}} of {{Mathematics}}},
  author = {Stillwell, John},
  year = {2018},
  edition = {2nd},
  publisher = {CRC Press},
  isbn = {1-138-58610-2 978-1-138-58610-9}
}

@inproceedings{stirlingGameTheoreticApproachDeciding2006,
  title = {A {{Game-Theoretic Approach}} to {{Deciding Higher-Order Matching}}.},
  booktitle = {{{ICALP}} (2)},
  author = {Stirling, C.},
  year = {2006},
  pages = {348--359}
}

@article{stoberAverageCaseMergeinsertion2019,
  title = {On the {{Average Case}} of {{Mergeinsertion}}},
  author = {Stober, Florian and Wei{\ss}, Armin},
  year = {2019},
  journal = {CoRR},
  abstract = {MergeInsertion, also known as the Ford-Johnson algorithm, is a sorting algorithm which, up to today, for many input sizes achieves the best known upper bound on the number of comparisons. Indeed, it gets extremely close to the information-theoretic lower bound. While the worst-case behavior is well understood, only little is known about the average case. This work takes a closer look at the average case behavior. In particular, we establish an upper bound of \$n {\textbackslash}log n - 1.4005n + o(n)\$ comparisons. We also give an exact description of the probability distribution of the length of the chain a given element is inserted into and use it to approximate the average number of comparisons numerically. Moreover, we compute the exact average number of comparisons for \$n\$ up to 148. Furthermore, we experimentally explore the impact of different decision trees for binary insertion. To conclude, we conduct experiments showing that a slightly different insertion order leads to a better average case and we compare the algorithm to the recent combination with (1,2)-Insertionsort by Iwama and Teruyama.}
}

@misc{stockApplicationAIFormal2024,
  title = {Application of {{AI}} to Formal Methods -- an Analysis of Current Trends},
  author = {Stock, Sebastian and Dunkelau, Jannik and Mashkoor, Atif},
  year = {2024},
  month = nov,
  number = {arXiv:2411.14870},
  eprint = {2411.14870},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2411.14870},
  urldate = {2024-11-25},
  abstract = {With artificial intelligence (AI) being well established within the daily lives of research communities, we turn our gaze toward an application area that appears intuitively unsuited for probabilistic decision-making: the area of formal methods (FM). FM aim to provide sound and understandable reasoning about problems in computer science, which seemingly collides with the black-box nature that inhibits many AI approaches. However, many researchers have crossed this gap and applied AI techniques to enhance FM approaches. As this dichotomy of FM and AI sparked our interest, we conducted a systematic mapping study to map the current landscape of research publications. In this study, we investigate the previous five years of applied AI to FM (2019-2023), as these correspond to periods of high activity. This investigation results in 189 entries, which we explore in more detail to find current trends, highlight research gaps, and give suggestions for future research.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/JW2ZV9PF/Stock et al. - 2024 - Application of AI to formal methods -- an analysis.pdf;/home/flaviomoura/Zotero/storage/VECKAXF5/2411.html}
}

@book{stoneAlgorithmsFunctionalProgramming2018,
  title = {Algorithms for {{Functional Programming}}},
  author = {Stone, John David},
  year = {2018},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-662-57970-1},
  urldate = {2021-07-01},
  isbn = {978-3-662-57968-8 978-3-662-57970-1},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/SW4YBRJE/Stone - 2018 - Algorithms for Functional Programming.pdf}
}

@inproceedings{stormOnward232023,
  title = {Onward!'23},
  booktitle = {Proceedings of the 2023 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}},
  author = {van der Storm, Tijs and Hirschfeld, Robert},
  year = {2023},
  month = oct,
  publisher = {ACM},
  address = {Cascais Portugal},
  isbn = {9798400703881},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PAAIKT4G/Storm e Hirschfeld - 2023 - Onward!'23.pdf}
}

@inproceedings{stratulat:hal-00763236,
  title = {A Unified View of Induction Reasoning for First-Order Logic},
  booktitle = {Turing-100, the Alan Turing Centenary Conference},
  author = {Stratulat, Sorin},
  year = {2012},
  month = jun,
  address = {Manchester, United Kingdom},
  hal_id = {hal-00763236},
  hal_version = {v1},
  pdf = {https://hal.inria.fr/hal-00763236/file/document-poster.pdf}
}

@unpublished{stratulatECyclistImplementationEfficient2020,
  title = {E-{{Cyclist}}: {{Implementation}} of an {{Efficient Validation}} of {{FOL ID Cyclic Induction Reasoning}} ({{System Description}})},
  shorttitle = {E-{{Cyclist}}},
  author = {Stratulat, Sorin},
  year = {2020},
  month = feb,
  urldate = {2021-04-17},
  abstract = {Checking the soundness of cyclic induction reasoning for first-order logic with inductive definitions (FOLID) is decidable but the standard checking method is based on an exponential complement operation for B{\"u}chi automata. Recently, we introduced a polynomial checking method whose most expensive steps recall the comparisons done with multiset path orderings. We describe the implementation of our method in the Cyclist prover. Referred to as E-Cyclist, it successfully checked all the proofs included in the original distribution of Cyclist. Heuristics have been devised to automatically define from the analysis of the proof derivations the ordering measures that satisfy the ordering constraints. FOLID cyclic proof derivations may also be hard to certify. E-Cyclist witnesses a strong relation between the two cyclic and well-founded induction reasonings. This opens the perspective of using the known certification methods that work for well-founded induction proofs.},
  file = {/home/flaviomoura/Zotero/storage/77GUK62M/Stratulat - 2020 - E-Cyclist Implementation of an Efficient Validati.pdf}
}

@phdthesis{stratulatNoetherianInductionComputerAssisted2021,
  type = {Habilitation {\`a} Diriger Des Recherches},
  title = {Noetherian {{Induction}} for {{Computer-Assisted First-Order Reasoning}}},
  author = {Stratulat, Sorin},
  year = {2021},
  month = jun,
  urldate = {2021-07-20},
  school = {Universit{\'e} de Lorraine},
  keywords = {certification de preuves,Coq,first-order formal reasoning,Noetherian induction reasoning,proof certification,raisonnement formel de premier ordre,raisonnement par recurrence noetherienne,SPIKE},
  file = {/home/flaviomoura/Zotero/storage/KR8TQLP4/Stratulat - 2021 - Noetherian Induction for Computer-Assisted First-O.pdf}
}

@inproceedings{stratulatStructuralVsCyclic2016,
  title = {Structural vs. {{Cyclic Induction}}},
  booktitle = {{{SYNASC}}'2016 {{International Symposium}} on {{Symbolic}} and {{Numeric Algorithms}} for {{Scientific Computing}}},
  author = {Stratulat, Sorin},
  year = {2016},
  month = sep,
  series = {Symbolic and {{Numeric Algorithms}} for {{Scientific Computing}} ({{SYNASC}}), 2016 18th {{International Symposium}} On},
  pages = {29--36},
  address = {Timisoara, Romania},
  doi = {10.1109/SYNASC.2016.018},
  urldate = {2021-04-17},
  abstract = {Structural and (Noetherian) cyclic induction are two instances of the Noetherian induction principle adapted to reason on first-order logic. From a theoretical point of view, every structural proof can be converted to a cyclic proof but the other way is only conjectured. From a practical point of view, i) structural induction principles are built-in or automatically issued from the analysis of recursive data structures by many theorem provers, and ii) the implementation of cyclic induction reasoning may require additional resources such as functional schemas, libraries and human interaction. In this paper, we firstly define a set of conjectures that can be proved by using cyclic induction and following a similar scenario. Next, we implement the cyclic induction reasoning in the Coq proof assistant. Finally, we show that the scenarios for proving these conjectures with structural induction differ in terms of the number of induction steps and lemmas, as well as proof scenario. We identified three conjectures from this set that are hard or impossible to be proved by structural induction.},
  keywords = {Coq,cyclic induction,mechanical reasoning,Noetherian induction,structural induction},
  file = {/home/flaviomoura/Zotero/storage/6VUWWZJ2/Stratulat - 2016 - Structural vs. Cyclic Induction.pdf}
}

@article{streicherClassicalRealizabilityModel2014,
  title = {A {{Classical Realizability Model}} Arising from a {{Stable Model}} of {{Untyped Lambda Calculus}}},
  author = {Streicher, T.},
  year = {2014},
  month = jul,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - Category Theory,Mathematics - Logic}
}

@book{streicherIntroductionConstructiveLogic2001,
  title = {Introduction to {{Constructive Logic}} and {{Mathematics}}},
  author = {Streicher, T.},
  year = {2001}
}

@book{streicherInvestigationsIntentionalType1993,
  title = {Investigations {{Into Intentional Type Theory}}},
  author = {Streicher, T.},
  year = {1993}
}

@misc{stroblWhatFormalLanguages2024,
  title = {What {{Formal Languages Can Transformers Express}}? {{A Survey}}},
  shorttitle = {What {{Formal Languages Can Transformers Express}}?},
  author = {Strobl, Lena and Merrill, William and Weiss, Gail and Chiang, David and Angluin, Dana},
  year = {2024},
  month = may,
  number = {arXiv:2311.00208},
  eprint = {2311.00208},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2311.00208},
  urldate = {2024-05-08},
  abstract = {As transformers have gained prominence in natural language processing, some researchers have investigated theoretically what problems they can and cannot solve, by treating problems as formal languages. Exploring such questions can help clarify the power of transformers relative to other models of computation, their fundamental capabilities and limits, and the impact of architectural choices. Work in this subarea has made considerable progress in recent years. Here, we undertake a comprehensive survey of this work, documenting the diverse assumptions that underlie different results and providing a unified framework for harmonizing seemingly contradictory findings.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Computation and Language,Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science,Computer Science - Machine Learning},
  file = {/home/flaviomoura/Zotero/storage/ENP6DMP4/Strobl et al. - 2024 - What Formal Languages Can Transformers Express A .pdf;/home/flaviomoura/Zotero/storage/F6LQ3YEL/2311.html}
}

@unpublished{stumpRealizabilityInductionDependent2016,
  title = {From {{Realizability}} to {{Induction}} via {{Dependent Intersection}}},
  author = {Stump, A.},
  year = {2016}
}

@article{stumpRelationalTypeTheory2021,
  title = {Relational {{Type Theory}} ({{All Proofs}})},
  author = {Stump, Aaron and Delaware, Benjamin and Jenkins, Christopher},
  year = {2021},
  month = jan,
  journal = {arXiv:2101.09655 [cs]},
  eprint = {2101.09655},
  primaryclass = {cs},
  urldate = {2021-01-26},
  abstract = {This paper introduces Relational Type Theory (RelTT), a new approach to type theory with extensionality principles, based on a relational semantics for types. The type constructs of the theory are those of System F plus relational composition, converse, and promotion of application of a term to a relation. A concise realizability semantics is presented for these types. The paper shows how a number of constructions of traditional interest in type theory are possible in RelTT, including eta-laws for basic types, inductive types with their induction principles, and positive-recursive types. A crucial role is played by a lemma called Identity Inclusion, which refines the Identity Extension property familiar from the semantics of parametric polymorphism. The paper concludes with a type system for RelTT, paving the way for implementation.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/9GVZUJ8G/Stump et al. - 2021 - Relational Type Theory (All Proofs).pdf;/home/flaviomoura/Zotero/storage/UC9NJIMH/2101.html}
}

@book{stumpVerifiedFunctionalProgramming2016,
  title = {Verified {{Functional Programming}} in {{Agda}}},
  author = {Stump, Aaron},
  year = {2016},
  month = feb,
  publisher = {{Association for Computing Machinery and Morgan \& Claypool}},
  address = {New York, NY, USA},
  doi = {10.1145/2841316},
  urldate = {2025-03-24},
  isbn = {978-1-970001-27-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BLWRF2D6/Stump - 2016 - Verified Functional Programming in Agda.pdf}
}

@article{suarezCombinatorialApplicationsCompactness,
  title = {Combinatorial {{Applications}} of the {{Compactness Theorem}}},
  author = {Su{\'a}rez, Fabi{\'a}n Fernando Serrano and {de Lima}, Thaynara Arielly},
  abstract = {This work discusses a formalization in Isabelle/HOL of the compactness theorem for propositional logic. The formalization is based on the model existence theorem approach. Further, the paper presents applications of this theorem to formalize combinatorial theorems over countable structures: the De Bruijn-Erd{\"o}s Graph coloring theorem for countable graphs, K{\"o}nig Lemma, and set- and graph-theoretical versions of Hall's Theorem for countable families of sets and graphs.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/QSDPFHHQ/SuÃ¡rez e de Lima - Combinatorial Applications of the Compactness Theo.pdf}
}

@article{swanNielsenSchreierTheoremHomotopy2020,
  title = {On the {{Nielsen-Schreier Theorem}} in {{Homotopy Type Theory}}},
  author = {Swan, Andrew W.},
  year = {2020},
  month = oct,
  journal = {arXiv:2010.01187 [cs, math]},
  eprint = {2010.01187},
  primaryclass = {cs, math},
  urldate = {2020-10-10},
  abstract = {We give a formulation of the Nielsen-Schreier theorem (subgroups of free groups are free) in homotopy type theory using the presentation of groups as pointed connected 1-truncated types. We show the special case of finite index subgroups holds constructively and the full theorem follows from the axiom of choice. We give an example of a boolean infinity topos where our formulation of the theorem does not hold and show a stronger "untruncated" version of the theorem is provably false in homotopy type theory.},
  archiveprefix = {arXiv},
  keywords = {03F65 03B38 20E05,Computer Science - Logic in Computer Science,Mathematics - Algebraic Topology,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/SQ45VGKI/Swan - 2020 - On the Nielsen-Schreier Theorem in Homotopy Type T.pdf;/home/flaviomoura/Zotero/storage/IYQNG58N/2010.html}
}

@book{swartPhilosophicalMathematicalLogic2018,
  title = {Philosophical and {{Mathematical Logic}}},
  author = {de Swart, Harrie},
  year = {2018},
  series = {Springer {{Undergraduate Texts}} in {{Philosophy}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-03255-5}
}

@misc{swensonSimpleEfficientAlgorithm2024,
  title = {A {{Simple}} and {{Efficient Algorithm}} for {{Sorting Signed Permutations}} by {{Reversals}}},
  author = {Swenson, Krister M.},
  year = {2024},
  month = mar,
  number = {arXiv:2403.20165},
  eprint = {2403.20165},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-04-04},
  abstract = {In 1937, biologists Sturtevant and Tan posed a computational question: transform a chromosome represented by a permutation of genes, into a second permutation, using a minimum-length sequence of reversals, each inverting the order of a contiguous subset of elements. Solutions to this problem, applied to Drosophila chromosomes, were computed by hand. The first algorithmic result was a heuristic that was published in 1982. In the 1990s a more biologically relevant version of the problem, where the elements have signs that are also inverted by a reversal, finally received serious attention by the computer science community. This effort eventually resulted in the first polynomial time algorithm for Signed Sorting by Reversals. Since then, a dozen more articles have been dedicated to simplifying the theory and developing algorithms with improved running times. The current best algorithm, which runs in \$O(n {\textbackslash}log{\textasciicircum}2 n / {\textbackslash}log{\textbackslash}log n)\$ time, fails to meet what some consider to be the likely lower bound of \$O(n {\textbackslash}log n)\$. In this article, we present the first algorithm that runs in \$O(n {\textbackslash}log n)\$ time in the worst case. The algorithm is fairly simple to implement, and the running time hides very low constants.},
  archiveprefix = {arXiv},
  keywords = {68Q25 68P10 62P10,Computer Science - Data Structures and Algorithms,F.2.2,G.2.1,J.3},
  file = {/home/flaviomoura/Zotero/storage/D3TPCUJI/Swenson - 2024 - A Simple and Efficient Algorithm for Sorting Signe.pdf;/home/flaviomoura/Zotero/storage/WFLV9SLF/2403.html}
}

@article{tabareauMarriageUnivalenceParametricity2020,
  title = {The {{Marriage}} of {{Univalence}} and {{Parametricity}}},
  author = {Tabareau, Nicolas and Tanter, {\'E}ric and Sozeau, Matthieu},
  year = {2020},
  month = oct,
  journal = {arXiv:1909.05027 [cs]},
  eprint = {1909.05027},
  primaryclass = {cs},
  urldate = {2021-01-23},
  abstract = {Reasoning modulo equivalences is natural for everyone, including mathematicians. Unfortunately, in proof assistants based on type theory, equality is appallingly syntactic and, as a result, exploiting equivalences is cumbersome at best. Parametricity and univalence are two major concepts that have been explored to transport programs and proofs across type equivalences, but they fall short of achieving seamless, automatic transport. This work first clarifies the limitations of these two concepts in isolation, and then devises a fruitful marriage between both. The resulting concept, univalent parametricity, is an heterogeneous extension of parametricity strengthened with univalence that fully realizes programming and proving modulo equivalences. In addition to the theory of univalent parametricity, we present a lightweight framework implemented in Coq that allows the user to transparently transfer definitions and theorems for a type to an equivalent one, as if they were equal. For instance, this makes it possible to conveniently switch between an easy-to-reason-about representation and a computationally-efficient representation, as soon as they are proven equivalent. The combination of parametricity and univalence supports transport {\textbackslash}`a la carte: basic univalent transport, which stems from a type equivalence, can be complemented with additional proofs of equivalences between functions over these types, in order to be able to lift more programs and proofs, as well as to yield more efficient terms. We illustrate the use of univalent parametricity on several examples, including a recent integration of native integers in Coq.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/362RHD97/Tabareau et al. - 2020 - The Marriage of Univalence and Parametricity.pdf;/home/flaviomoura/Zotero/storage/7J43VUVI/1909.html}
}

@phdthesis{tahatAPPLICATIONSINTERACTIVETHEOREM2016,
  title = {{{ON THE APPLICATIONS OF INTERACTIVE THEOREM PROVING IN COMPUTATIONAL SCIENCES AND ENGINEERING}}},
  author = {Tahat, A.},
  year = {2016},
  school = {Michigan Technological University}
}

@incollection{taitGentzenOriginalConsistency2015,
  title = {Gentzen's {{Original Consistency Proof}} and the {{Bar Theorem}}},
  booktitle = {Gentzen's {{Centenary}}},
  author = {Tait, W. W.},
  editor = {Kahle, Reinhard and Rathjen, Michael},
  year = {2015},
  pages = {213--228},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-319-10103-3_8},
  urldate = {2023-07-05},
  isbn = {978-3-319-10102-6 978-3-319-10103-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/KQ8VZVLP/Tait - 2015 - Gentzenâs Original Consistency Proof and the Bar T.pdf}
}

@incollection{taitPrimitiveRecursiveArithmetic2012,
  title = {Primitive {{Recursive Arithmetic}} and {{Its Role}} in the {{Foundations}} of {{Arithmetic}}: {{Historical}} and {{Philosophical Reflections}}},
  shorttitle = {Primitive {{Recursive Arithmetic}} and {{Its Role}} in the {{Foundations}} of {{Arithmetic}}},
  booktitle = {Epistemology versus {{Ontology}}: {{Essays}} on the {{Philosophy}} and {{Foundations}} of {{Mathematics}} in {{Honour}} of {{Per Martin-L{\"o}f}}},
  author = {Tait, William W.},
  editor = {Dybjer, P. and Lindstr{\"o}m, Sten and Palmgren, Erik and Sundholm, G.},
  year = {2012},
  pages = {161--180},
  publisher = {Springer Netherlands},
  address = {Dordrecht},
  doi = {10.1007/978-94-007-4435-6_8},
  urldate = {2024-08-01},
  abstract = {We discuss both the historical roots of Skolem's primitive recursive arithmetic, its essential role in the foundations of arithmetic, its relation to the finitism of Hilbert and Bernays, and its relation to Kant's philosophy of mathematics.},
  isbn = {978-94-007-4435-6},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IDJJ2D2I/Tait - 2012 - Primitive Recursive Arithmetic and Its Role in the.pdf}
}

@article{takahashiParallelReductionsLAMBDA1989,
  title = {Parallel {{Reductions}} in \${\textbackslash}{{LAMBDA}}\$-Calculus},
  author = {Takahashi, Masako},
  year = {1989},
  journal = {Journal of Symbolic Computation},
  volume = {7},
  number = {2},
  pages = {113--123},
  doi = {10.1016/s0747-7171(89)80045-8}
}

@article{takahashiParallelReductionsLambdaCalculus1995,
  title = {Parallel {{Reductions}} in Lambda-{{Calculus}}},
  author = {Takahashi, Masako},
  year = {1995},
  journal = {Inf. Comput.},
  volume = {118},
  number = {1},
  pages = {120--127},
  doi = {10.1006/inco.1995.1057}
}

@book{takloo-bighashPythagoreanIntroductionNumber2018,
  title = {A {{Pythagorean Introduction}} to {{Number Theory}}},
  author = {{Takloo-Bighash}, Ramin},
  year = {2018},
  series = {Undergraduate {{Texts}} in {{Mathematics}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-02604-2}
}

@phdthesis{tan2021curry,
  title = {Curry-Howard Correspondence: {{An}} Intuitive Language for Mathematics},
  author = {Tan, Xiao},
  year = {2021},
  school = {Tufts University},
  file = {/home/flaviomoura/Zotero/storage/96CVVCD5/Tan - 2021 - Curry-howard correspondence An intuitive language.pdf}
}

@article{tarauDerivingTheoremsImplicational2020,
  title = {Deriving {{Theorems}} in {{Implicational Linear Logic}}, {{Declaratively}}},
  author = {Tarau, Paul and {de Paiva}, Valeria},
  year = {2020},
  month = sep,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {325},
  eprint = {2009.10241},
  pages = {110--123},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.325.18},
  urldate = {2020-09-24},
  abstract = {The problem we want to solve is how to generate all theorems of a given size in the implicational fragment of propositional intuitionistic linear logic. We start by filtering for linearity the proof terms associated by our Prolog-based theorem prover for Implicational Intuitionistic Logic. This works, but using for each formula a PSPACE-complete algorithm limits it to very small formulas. We take a few walks back and forth over the bridge between proof terms and theorems, provided by the Curry-Howard isomorphism, and derive step-by-step an efficient algorithm requiring a low polynomial effort per generated theorem. The resulting Prolog program runs in O(N) space for terms of size N and generates in a few hours 7,566,084,686 theorems in the implicational fragment of Linear Intuitionistic Logic together with their proof terms in normal form. As applications, we generate datasets for correctness and scalability testing of linear logic theorem provers and training data for neural networks working on theorem proving challenges. The results in the paper, organized as a literate Prolog program, are fully replicable. Keywords: combinatorial generation of provable formulas of a given size, intuitionistic and linear logic theorem provers, theorems of the implicational fragment of propositional linear intuitionistic logic, Curry-Howard isomorphism, efficient generation of linear lambda terms in normal form, Prolog programs for lambda term generation and theorem proving.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Logic in Computer Science,Computer Science - Programming Languages,Computer Science - Symbolic Computation},
  file = {/home/flaviomoura/Zotero/storage/PPXV9KXS/Tarau e de Paiva - 2020 - Deriving Theorems in Implicational Linear Logic, D.pdf;/home/flaviomoura/Zotero/storage/TPV59LV9/2009.html}
}

@article{tarjanAlgorithmDesign1987,
  title = {Algorithm Design},
  author = {Tarjan, Robert E.},
  year = {1987},
  month = mar,
  journal = {Communications of the ACM},
  volume = {30},
  number = {3},
  pages = {204--212},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/214748.214752},
  urldate = {2024-11-11},
  abstract = {The quest for efficiency in computational methods yields not only fast algorithms, but also insights that lead to elegant, simple, and general problem-solving methods.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/2KC7IYWD/Tarjan - 1987 - Algorithm design.pdf}
}

@article{tarjanAmortizedComputationalComplexity1985,
  title = {Amortized {{Computational Complexity}}},
  author = {Tarjan, Robert Endre},
  year = {1985},
  month = apr,
  journal = {SIAM Journal on Algebraic Discrete Methods},
  volume = {6},
  number = {2},
  pages = {306--318},
  issn = {0196-5212, 2168-345X},
  doi = {10.1137/0606031},
  urldate = {2024-11-11},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/GDJJIUUU/Tarjan - 1985 - Amortized Computational Complexity.pdf}
}

@inproceedings{tarjanDepthfirstSearchLinear1971,
  title = {Depth-First Search and Linear Graph Algorithms},
  booktitle = {12th {{Annual Symposium}} on {{Switching}} and {{Automata Theory}} (Swat 1971)},
  author = {Tarjan, Robert},
  year = {1971},
  month = oct,
  pages = {114--121},
  publisher = {IEEE},
  address = {East Lansing, MI, USA},
  doi = {10.1109/SWAT.1971.10},
  urldate = {2020-10-10},
  file = {/home/flaviomoura/Zotero/storage/IZAPKS7E/Tarjan - 1971 - Depth-first search and linear graph algorithms.pdf}
}

@book{teamCoqProofAssistant2018,
  title = {The {{Coq Proof Assistant}}, Version 8.7.2},
  author = {Team, The Coq Development},
  year = {2018},
  month = feb,
  doi = {10.5281/zenodo.1174360}
}

@misc{teamCoqProofAssistant2021,
  title = {The {{Coq Proof Assistant}}},
  author = {Team, The Coq Development},
  year = {2021},
  month = oct,
  doi = {10.5281/ZENODO.5704840},
  urldate = {2021-12-27},
  abstract = {Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. Typical applications include the certification of properties of programming languages (e.g. the CompCert compiler certification project, the Verified Software Toolchain for verification of C programs, or the Iris framework for concurrent separation logic), the formalization of mathematics (e.g. the full formalization of the Feit-Thompson theorem, or homotopy type theory), and teaching. Coq version 8.14 integrates many usability improvements, as well as an important change in the core language. The main changes include: The internal representation of {$<$}code{$>$}match{$<$}/code{$>$} has changed to a more space-efficient and cleaner structure, allowing the fix of a completeness issue with cumulative inductive types in the type-checker. The internal representation is now closer to the user-level view of {$<$}code{$>$}match{$<$}/code{$>$}, where the argument context of branches and the inductive binders {$<$}code{$>$}in{$<$}/code{$>$} and {$<$}code{$>$}as{$<$}/code{$>$} do not carry type annotations. A new {$<$}code{$>$}coqnative{$<$}/code{$>$} binary performs separate native compilation of libraries, starting from a {$<$}code{$>$}.vo{$<$}/code{$>$} file. It is supported by {$<$}code{$>$}coq\_makefile{$<$}/code{$>$}. Improvements to typeclasses and canonical structure resolution, allowing more terms to be considered as classes or keys. More control over notations declarations and support for primitive types in string and number notations. Removal of deprecated tactics, notably {$<$}code{$>$}omega{$<$}/code{$>$}, which has been replaced by a greatly improved {$<$}code{$>$}lia{$<$}/code{$>$}, along with many bug fixes. New Ltac2 APIs for interaction with Ltac1, manipulation of inductive types and printing. Many changes and additions to the standard library in the numbers, vectors and lists libraries. A new signed primitive integers library {$<$}code{$>$}Sint63{$<$}/code{$>$} is available in addition to the unsigned {$<$}code{$>$}Uint63{$<$}/code{$>$} library. See the Changes in 8.14.0 section below for the detailed list of changes, including potentially breaking changes marked with {$<$}strong{$>$}Changed{$<$}/strong{$>$}. Coq's reference manual, documentation of the standard library and developer documentation of the ML API are also available. Emilio Jes{\'u}s Gallego Arias, Ga{\"e}tan Gilbert, Michael Soegtrop and Th{\'e}o Zimmermann worked on maintaining and improving the continuous integration system and package building infrastructure. Erik Martin-Dorel has maintained the Coq Docker images that are used in many Coq projects for continuous integration. The OPAM repository for Coq packages has been maintained by Guillaume Claret, Karl Palmskog, Matthieu Sozeau and Enrico Tassi with contributions from many users. A list of packages is available at https://coq.inria.fr/opam/www/. The Coq Platform has been maintained by Michael Soegtrop and Enrico Tassi. Our current maintainers are Yves Bertot, Fr{\'e}d{\'e}ric Besson, Ali Caglayan, Tej Chajed, Cyril Cohen, Pierre Corbineau, Pierre Courtieu, Maxime D{\'e}n{\`e}s, Jim Fehrle, Julien Forest, Emilio Jes{\'u}s Gallego Arias, Ga{\"e}tan Gilbert, Georges Gonthier, Benjamin Gr{\'e}goire, Jason Gross, Hugo Herbelin, Vincent Laporte, Olivier Laurent, Assia Mahboubi, Kenji Maillard, Guillaume Melquiond, Pierre-Marie P{\'e}drot, Cl{\'e}ment Pit-Claudel, Pierre Roux, Kazuhiko Sakaguchi, Vincent Semeria, Michael Soegtrop, Arnaud Spiwack, Matthieu Sozeau, Enrico Tassi, Laurent Th{\'e}ry, Anton Trunov, Li-yao Xia and Th{\'e}o Zimmermann. See the Coq Team face book page for more details. The 54 contributors to this version are Reynald Affeldt, Arthur Azevedo de Amorim, Yves Bertot, Fr{\'e}d{\'e}ric Besson, Lasse Blaauwbroek, Ana Borges, Ali Caglayan, Cyril Cohen, Columbus240, Pierre Courtieu, Maxime D{\'e}n{\`e}s, Andrej Dudenhefner, Jim Fehrle, Yannick Forster, Simon Friis Vindum, Ga{\"e}tan Gilbert, Jason Gross, Samuel Gruetter, Stefan Haan, Hugo Herbelin, Jasper Hugunin, Emilio Jes{\'u}s Gallego Arias, Jacques-Henri Jourdan, Ralf Jung, Jan-Oliver Kaiser, Fabian Kunze, Vincent Laporte, Olivier Laurent, Yishuai Li, Barry M. Trager, Kenji Maillard, Erik Martin-Dorel, Guillaume Melquiond, Isaac Oscar Gariano, Pierre-Marie P{\'e}drot, Rudy Peterson, Cl{\'e}ment Pit-Claudel, Pierre Roux, Takafumi Saikawa, Kazuhiko Sakaguchi, Gabriel Scherer, Vincent Semeria, shenlebantongying, Avi Shinnar, slrnsc, Michael Soegtrop, Matthieu Sozeau, Enrico Tassi, Hendrik Tews, Anton Trunov, Karolin Varner, Li-yao Xia, Beta Ziliani and Th{\'e}o Zimmermann. The Coq community at large helped improve the design of this new version via the GitHub issue and pull request system, the Coq development mailing list coqdev@inria.fr, the coq-club@inria.fr mailing list, the Discourse forum and the Coq Zulip chat. Version 8.14's development spanned 9 months from the release of Coq 8.13.0. Guillaume Melquiond is the release manager of Coq 8.14. This release is the result of 522 merged PRs, closing {\textasciitilde}150 issues.},
  copyright = {GNU Lesser General Public License v2.1 only, Open Access},
  howpublished = {Zenodo},
  langid = {english},
  keywords = {formal proofs,mathematical software,proof assistant}
}

@misc{teamCoqProofAssistant2024,
  title = {The {{Coq Proof Assistant}}},
  author = {Team, The Coq Development},
  year = {2024},
  month = jun,
  doi = {10.5281/zenodo.11551307},
  urldate = {2024-11-22},
  abstract = {Coq is a formal proof management system. It provides a formal language to write mathematical definitions, executable algorithms and theorems together with an environment for semi-interactive development of machine-checked proofs. Typical applications include the certification of properties of programming languages (e.g. the CompCert compiler certification project, the Verified Software Toolchain for verification of C programs, or the Iris framework for concurrent separation logic), the formalization of mathematics (e.g. the full formalization of the Feit-Thompson theorem, or homotopy type theory), and teaching. Coq version 8.19 extends the kernel universe polymorphism to polymorphism over sorts (e.g. Prop, SProp) along with a few new features, a host of improvements to the notation system, the Ltac2 standard library, and the removal of some standard library files after a long deprecation period. We highlight some of the most impactful changes here: Sort polymorphism makes it possible to share common constructs over Type Prop and SProp. The notation term\%\_scope to set a scope only temporarily (in addition to term\%scope for opening a scope applying to all subterms). lazy, simpl, cbn and cbv and the associated Eval and eval reductions learned to do head reduction when given flag head. New Ltac2 APIs, improved Ltac2 exact and dynamic building of Ltac2 term patterns. New performance evaluation facilities: Instructions to count CPU instructions used by a command (Linux only) and Profiling system to produce trace files. New command Attributes to assign attributes such as deprecated to a library file. Notable breaking changes: replace with by tac does not automatically attempt to solve the generated equality subgoal using the hypotheses. Use by first [assumption {\textbar} symmetry;assumption {\textbar} tac] if you need the previous behaviour. Removed old deprecated files from the standard library. See the Changes in 8.19.0 section below for the detailed list of changes, including potentially breaking changes marked with Changed. Coq's reference manual for 8.19, documentation of the 8.19 standard library and developer documentation of the 8.19 ML API are also available. Maxime D{\'e}n{\`e}s and Thierry Martinez with support from Erik Martin-Dorel and Th{\'e}o Zimmermann moved the CI away from gitlab.com to use Inria supported runner machines through gitlab.inria.fr. Th{\'e}o Zimmermann with help from Ali Caglayan and Jason Gross maintained coqbot used to run Coq's CI and other pull request management tasks. Jason Gross maintained the bug minimizer and its automatic use through coqbot. Jaime Arias and Erik Martin-Dorel maintained the Coq Docker images and Cyril Cohen, Vincent Laporte, Pierre Roux and Th{\'e}o Zimmermann maintained the Nix toolbox used by many Coq projects for continuous integration. Ali Caglayan, Emilio Jes{\'u}s Gallego Arias, Rudi Grinberg and Rodolphe Lepigre maintained the Dune build system for OCaml and Coq used to build Coq itself and many Coq projects. The opam repository for Coq packages has been maintained by Guillaume Claret, Guillaume Melquiond, Karl Palmskog and Enrico Tassi with contributions from many users. A list of packages is available on the Coq website. Our current maintainers are Yves Bertot, Fr{\'e}d{\'e}ric Besson, Ana Borges, Ali Caglayan, Tej Chajed, Cyril Cohen, Pierre Corbineau, Pierre Courtieu, Andres Erbsen, Jim Fehrle, Julien Forest, Emilio Jes{\'u}s Gallego Arias, Ga{\"e}tan Gilbert, Georges Gonthier, Benjamin Gr{\'e}goire, Jason Gross, Hugo Herbelin, Vincent Laporte, Olivier Laurent, Assia Mahboubi, Kenji Maillard, Guillaume Melquiond, Pierre-Marie P{\'e}drot, Cl{\'e}ment Pit-Claudel, Pierre Roux, Kazuhiko Sakaguchi, Vincent Semeria, Michael Soegtrop, Arnaud Spiwack, Matthieu Sozeau, Enrico Tassi, Laurent Th{\'e}ry, Anton Trunov, Li-yao Xia and Th{\'e}o Zimmermann. See the Coq Team face book page for more details. The 40 contributors to the 8.19 version are: quarkcool, Khalid Abdullah, Tanaka Akira, Isaac van Bakel, Fr{\'e}d{\'e}ric Besson, Lasse Blaauwbroek, Ana Borges, Ali Caglayan, Nikolaos Chatzikonstantinou, Maxime D{\'e}n{\`e}s, Andrej Dudenhefner, Andres Erbsen, Jim Fehrle, Ga{\"e}tan Gilbert, Jason Gross, Stefan Haan, Hugo Herbelin, Emilio Jes{\'u}s Gallego Arias, Pierre Jouvelot, Ralf Jung, Jan-Oliver Kaiser, Robbert Krebbers, Jean-Christophe L{\'e}chenet, Rodolphe Lepigre, Yann Leray, Yishuai Li, Guillaume Melquiond, Guillaume Munch-Maccagnoni, Sotaro Okada, Karl Palmskog, Pierre-Marie P{\'e}drot, Jim Portegies, Pierre Rousselin, Pierre Roux, Michael Soegtrop, David Swasey, Enrico Tassi, Shengyi Wang and Th{\'e}o Zimmermann. The Coq community at large helped improve this new version via the GitHub issue and pull request system, the coq-club@inria.fr mailing list, the Discourse forum and the Coq Zulip chat. Version 8.19's development spanned 4 months from the release of Coq 8.18.0 (6 months since the branch for 8.18.0). Ga{\"e}tan Gilbert and Matthieu Sozeau are the release managers of Coq 8.19. This release is the result of 285 merged PRs, closing 70 issues.},
  howpublished = {Zenodo},
  keywords = {formal proofs,mathematical software,proof assistant},
  file = {/home/flaviomoura/Zotero/storage/N7BKDV4F/Team - 2024 - The Coq Proof Assistant.pdf}
}

@article{tennantLogicMathematicsEx2024a,
  title = {The {{Logic}} for {{Mathematics}} without {{Ex Falso Quodlibet}}},
  author = {Tennant, Neil},
  year = {2024},
  month = mar,
  journal = {Philosophia Mathematica},
  pages = {nkae001},
  issn = {0031-8019, 1744-6406},
  doi = {10.1093/philmat/nkae001},
  urldate = {2024-03-14},
  abstract = {Informally rigorous mathematical reasoning is relevant. So too should be the premises to the conclusions of formal proofs that regiment it. The rule Ex Falso Quodlibet induces spectacular irrelevance. We therefore drop it. The resulting systems of Core Logic C and Classical Core Logic C+ can formalize all the informally rigorous reasoning in constructive and classical mathematics respectively. We effect a revised match-up between deducibility in Classical Core Logic and a new notion of relevant logical consequence. It matches better the deducibility relation of Classical Core Logic than does the Tarskian notion of consequence. It is implosive, not explosive.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/APF6V5BW/Tennant - 2024 - The Logic for Mathematics without Ex Falso Quodlib.pdf}
}

@book{tereseTermRewritingSystems2003,
  title = {Term {{Rewriting Systems}}},
  author = {{Terese}},
  year = {2003},
  series = {Cambridge {{Tracts}} in {{Theoretical Computer Science}}},
  volume = {55},
  publisher = {Cambridge University Press},
  keywords = {book term_rewriting},
  file = {/home/flaviomoura/Zotero/storage/P884SX6S/terese03.pdf}
}

@article{terrematteTryLogicTutorialApproach2015,
  title = {{{TryLogic}} Tutorial: An Approach to {{Learning Logic}} by Proving and Refuting},
  author = {Terrematte, P. and Marcos, J.},
  year = {2015},
  journal = {CoRR}
}

@article{theryForewordSpecialFocus2014,
  title = {Foreword {{To}} the {{Special Focus}} on {{Formal Proofs}} for {{Mathematics}} and {{Computer Science}}},
  author = {Th{\'e}ry, Laurent and Wiedijk, Freek},
  year = {2014},
  journal = {Mathematics in Computer Science},
  volume = {9},
  number = {1},
  pages = {1--3},
  doi = {10.1007/s11786-014-0214-9}
}

@misc{theryFormalisationFastFourier2022,
  title = {A {{Formalisation}} of a {{Fast Fourier Transform}}},
  author = {Th{\'e}ry, Laurent},
  year = {2022},
  month = oct,
  number = {arXiv:2210.05225},
  eprint = {2210.05225},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-10-03},
  abstract = {This notes explains how a standard algorithm that constructs the discrete Fourier transform has been formalised and proved correct in the Coq proof assistant using the SSReflect extension.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/NEKN5KI8/ThÃ©ry - 2022 - A Formalisation of a Fast Fourier Transform.pdf;/home/flaviomoura/Zotero/storage/ZPSQDVL3/2210.html}
}

@article{theryPlayingTowerHanoi,
  title = {Playing with the {{Tower}} of {{Hanoi Formally}}},
  author = {Th{\'e}ry, Laurent},
  pages = {20},
  abstract = {The Tower of Hanoi is a typical example that illustrates all the power of recursion in programming. In this paper, we show that it is also a very nice example for inductive proofs and formal verification. We present some non-trivial results about it that have been formalised in the Coq proof assistant.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/88T939EC/ThÃ©ry - Playing with the Tower of Hanoi Formally.pdf}
}

@article{theryProofPearlPlaying2021,
  title = {Proof {{Pearl}} : {{Playing}} with the {{Tower}} of {{Hanoi Formally}}},
  author = {Thery, Laurent},
  year = {2021},
  abstract = {The Tower of Hanoi is a typical example that is used in computer science courses to illustrate all the power of recursion. In this paper, we show that it is also a very nice example for inductive proofs and formal verification. We present some non-trivial results that have been formalised in the Coq proof assistant.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/LYEQ4YYU/Thery - 2021 - Proof Pearl  Playing with the Tower of Hanoi Form.pdf}
}

@book{thiemannProgrammingLanguagesSystems2016,
  title = {Programming {{Languages}} and {{Systems}}: 25th {{European Symposium}} on {{Programming}}, {{ESOP}} 2016, {{Held}} as {{Part}} of the {{European Joint Conferences}} on {{Theory}} and {{Practice}} of {{Software}}, {{ETAPS}} 2016, {{Eindhoven}}, {{The Netherlands}}, {{April}} 2--8, 2016, {{Proceedings}}},
  shorttitle = {Programming {{Languages}} and {{Systems}}},
  editor = {Thiemann, Peter},
  year = {2016},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {9632},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-662-49498-1},
  urldate = {2024-04-19},
  copyright = {http://www.springer.com/tdm},
  isbn = {978-3-662-49497-4 978-3-662-49498-1},
  langid = {english}
}

@book{ThirteenthAnnualIEEE1998,
  title = {Thirteenth {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}, {{Indianapolis}}, {{Indiana}}, {{USA}}, {{June}} 21-24, 1998},
  year = {1998},
  publisher = {IEEE Computer Society},
  isbn = {0-8186-8506-9}
}

@article{thomasonDagPrawitzNatural1967,
  title = {Dag {{Prawitz}}. {{Natural}} Deduction. {{A}} Proof-Theoretical Study. {{Acta Universitatis Stock-holmiensis}}, {{Stockholm}} Studies in Philosophy No. 3. {{Almqvist}} \& {{Wiksell}}, {{Stockholm}}, {{G{\"o}teborg}}, and {{Uppsala}}, 1965, 113 Pp.},
  author = {Thomason, Richmond},
  year = {1967},
  month = aug,
  journal = {Journal of Symbolic Logic},
  volume = {32},
  number = {2},
  pages = {255--256},
  issn = {0022-4812, 1943-5886},
  doi = {10.2307/2271676},
  urldate = {2024-04-10},
  copyright = {https://www.cambridge.org/core/terms},
  langid = {english}
}

@article{thurstonProofProgressMathematics1994,
  title = {On {{Proof}} and {{Progress}} in {{Mathematics}}},
  author = {Thurston, W. P.},
  year = {1994},
  journal = {Bulletin of the American Mathematical Society},
  volume = {30},
  number = {2},
  pages = {161--178},
  doi = {10.1090/s0273-0979-1994-00502-6}
}

@article{tiuCutEliminationLogic2012,
  title = {Cut {{Elimination}} for a {{Logic With Induction}} and {{Co-Induction}}},
  author = {Tiu, Alwen and Momigliano, Alberto},
  year = {2012},
  journal = {Journal of Applied Logic},
  volume = {10},
  number = {4},
  pages = {330--367},
  doi = {10.1016/j.jal.2012.07.007}
}

@article{tiuInductionCoinductionSequent2008,
  title = {Induction and {{Co-induction}} in {{Sequent Calculus}}},
  author = {Tiu, A. and Momigliano, A.},
  year = {2008},
  month = dec,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science}
}

@book{tiwari23rdInternationalConference2012,
  title = {23rd {{International Conference}} on {{Rewriting Techniques}} and {{Applications}} ({{RTA}}'12) , {{RTA}} 2012, {{May}} 28 - {{June}} 2, 2012, {{Nagoya}}, {{Japan}}},
  editor = {Tiwari, Ashish},
  year = {2012},
  journal = {RTA},
  series = {{{LIPIcs}}},
  volume = {15},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik},
  isbn = {978-3-939897-38-5}
}

@book{toelstraBasicProofTheory2000,
  title = {Basic Proof Theory},
  author = {Toelstra, A. S. and Schwichtenberg, H.},
  year = {2000},
  publisher = {Cambridge University Press},
  file = {/home/flaviomoura/Zotero/storage/TRQP4ZQN/Troelstra e Schwichtenberg - 2000 - Basic Proof Theory.pdf}
}

@book{tomjenkynsFundamentalsDiscreteMath2018,
  title = {Fundamentals of {{Discrete Math}} for {{Computer Science}}. {{A Problem-Solving Primer}}},
  author = {Tom Jenkyns, Ben Stephenson},
  year = {2018},
  edition = {2nd},
  publisher = {Springer},
  isbn = {978-3-319-70151-6}
}

@book{toscani2012algoritmos,
  title = {Complexidade de Algoritmos: {{Volume}} 13 Da S{\'e}rie Livros Did{\'a}ticos Inform{\'a}tica {{UFRGS}}},
  author = {Toscani, Laira V. and Veloso, Paulo A. S.},
  year = {2012},
  volume = {13},
  publisher = {Artmed Editora}
}

@inproceedings{tourProofAnalogyInteractive1987,
  title = {Proof {{Analogy}} in {{Interactive Theorem Proving}}: {{A Method}} to {{Express}} and {{Use}} It {{Via Second Order Pattern Matching}}},
  booktitle = {Proceedings of {{AAAI}} 87},
  author = {de la Tour, T. B. and Caferra, R.},
  year = {1987},
  pages = {95--99},
  publisher = {Morgan Kaufmann}
}

@article{toyamaCounterexamplesTerminationDirect1987,
  title = {Counterexamples to {{Termination}} for the {{Direct Sum}} of {{Term Rewriting Systems}}},
  author = {Toyama, Yoshihito},
  year = {1987},
  journal = {Inf. Process. Lett.},
  volume = {25},
  number = {3},
  pages = {141--143},
  doi = {10.1016/0020-0190(87)90122-0}
}

@book{trakhtenbrotAlgorithmsAutomaticComputing1963,
  title = {Algorithms and {{Automatic Computing Machines}}},
  author = {Trakhtenbrot, B. A.},
  year = {1963},
  publisher = {Gerard Arthus}
}

@incollection{tranchiniIdentityProofs2024,
  title = {Identity of {{Proofs}}},
  booktitle = {Harmony and {{Paradox}}: {{Intensional Aspects}} of {{Proof-Theoretic Semantics}}},
  author = {Tranchini, Luca},
  editor = {Tranchini, Luca},
  year = {2024},
  pages = {23--48},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-031-46921-3_2},
  urldate = {2024-04-20},
  abstract = {Proof-theoretic semantics is here presented as primarily concerned with the investigation of the relationship between proofs (understood as abstract entities) and derivations (the linguistic representations of proofs). This relationship is taken to be analogous to that between names and (abstract) objects in Frege. On this conception of proof-theoretic semantics, reductions and expansions should be viewed as identity-preserving operations on derivations and thus as inducing an equivalence relation on derivations such that equivalent derivations denote the same proof. Using this equivalence on derivations it is possible to define an equivalence relation on formulas that is stricter than interderivability, called isomorphism. We argue that identity of proofs and formula isomorphism show the intensional nature of this conception of proof-theoretic semantics. Finally, this conception is compared to the one advocated by Dummett and Prawitz, which is based on a notion of validity of derivations.},
  isbn = {978-3-031-46921-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/M2F5AU8V/Tranchini - 2024 - Identity of Proofs.pdf}
}

@article{tranchiniNaturalityNaturalDeduction2016,
  title = {The {{Naturality}} of {{Natural Deduction}}},
  author = {Tranchini, Luca and Pistone, Paolo and Petrolo, Mattia},
  year = {2016},
  journal = {CoRR},
  abstract = {Developing a suggestion by Russell, Prawitz showed how the usual natural deduction inference rules for disjunction, conjunction and absurdity can be derived using those for implication and the second order quantifier in propositional intuitionistic second order logic \$NI{\textasciicircum}2\$. It is however well known that the translation does not preserve the relations of identity among derivations induced by the permutative conversions and immediate expansions for the definable connectives, at least when the equational theory of \$NI{\textasciicircum}2\$ is assumed to consist only of {$\beta$} and {$\eta$} equations. On the basis of the categorial interpretation of \$NI{\textasciicircum}2\$, we introduce a new class of equations expressing what in categorial terms is a naturality condition satisfied by the transformations interpreting \$NI{\textasciicircum}2\$-derivations. We show that the Russell-Prawitz translation does preserve identity of proof with respect to the enriched system by highlighting the fact that naturality corresponds to a generalized permutation principle. We show that these result generalize some facts which have gone so far unnoticed, namely that the Russell-Prawitz translation maps particular classes of instances of the equations governing disjunction (and the other definable connectives) onto equations which are already included in the \${\textbackslash}beta{\textbackslash}eta\$ equational theory of \$NI{\textasciicircum}2\$. Finally, we compare our approach with the one proposed by Ferreira and Ferreira and show that the naturality condition suggests a generalization of their methods to a wider class of formulas.},
  file = {/home/flaviomoura/Zotero/storage/265B4EID/Tranchini et al. - 2016 - The Naturality of Natural Deduction.pdf}
}

@incollection{tranchiniParadoxesNaturalDeduction2024,
  title = {Paradoxes: {{A Natural Deduction Approach}}},
  shorttitle = {Paradoxes},
  booktitle = {Harmony and {{Paradox}}: {{Intensional Aspects}} of {{Proof-Theoretic Semantics}}},
  author = {Tranchini, Luca},
  editor = {Tranchini, Luca},
  year = {2024},
  pages = {89--99},
  publisher = {Springer International Publishing},
  address = {Cham},
  doi = {10.1007/978-3-031-46921-3_4},
  urldate = {2024-04-22},
  abstract = {The chapter introduces the Prawitz-Tennant analysis of paradoxes, according to which paradoxes are derivations of a contradiction which cannot be brought into normal form, due to ``loops'' arising in the process of reduction. After presenting Prawitz' original formulation of Russell's paradox, we introduce a simplified presentation of it, and then discuss the relevance of the difference between intuitionistic and classical logic and of structural properties of derivability for the Prawitz-Tennant analysis.},
  isbn = {978-3-031-46921-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/WCT64F9Y/Tranchini - 2024 - Paradoxes A Natural Deduction Approach.pdf}
}

@misc{traversieKurodaTranslationHigherOrder2024,
  title = {Kuroda's {{Translation}} for {{Higher-Order Logic}}},
  author = {Traversi{\'e}, Thomas},
  year = {2024},
  month = apr,
  number = {arXiv:2404.19503},
  eprint = {2404.19503},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2024-05-03},
  abstract = {In 1951, Kuroda defined an embedding of classical first-order logic into intuitionistic logic, such that a formula and its translation are equivalent in classical logic. Recently, Brown and Rizkallah extended this translation to higher-order logic, but did not prove the classical equivalence, and showed that the embedding fails in the presence of functional extensionality. We prove that functional extensionality and propositional extensionality are sufficient to derive the classical equivalence between a higher-order formula and its translation. We emphasize a condition under which Kuroda's translation works with functional extensionality.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/D23J5FBN/TraversiÃ© - 2024 - Kuroda's Translation for Higher-Order Logic.pdf}
}

@book{trobecIntroductionParallelComputing2018,
  title = {Introduction to {{Parallel Computing}}},
  author = {Trobec, Roman and Slivnik, Bo{\v s}tjan and Buli{\'c}, Patricio and Robi{\v c}, Borut},
  year = {2018},
  series = {Undergraduate {{Topics}} in {{Computer Science}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98833-7}
}

@book{troelstra1988constructivism,
  title = {Constructivism in Mathematics, Vol 1},
  author = {Troelstra, A.S. and {van Dalen}, D.},
  year = {1988},
  series = {Constructivism in Mathematics: {{An}} Introduction},
  publisher = {Elsevier Science},
  isbn = {978-0-444-70358-3},
  lccn = {lc88005240}
}

@incollection{troelstraChapterLogic1988,
  title = {Chapter 2 {{Logic}}},
  booktitle = {Constructivism in {{Mathematics}} - {{An Introduction}}},
  author = {Troelstra, A. S. and van Dalen, D.},
  year = {1988},
  series = {Studies in {{Logic}}},
  pages = {35--111},
  publisher = {Elsevier},
  doi = {10.1016/s0049-237x(09)70527-0}
}

@article{trufasAsynchronousMuddyChildren2023,
  title = {Asynchronous {{Muddy Children Puzzle}} (Work in Progress)},
  author = {Trufa{\c s}, Dafina and Teodorescu, Ioan and Diaconescu, Denisa and {\c S}erb{\u a}nu{\c t}{\u a}, Traian and Zamfir, Vlad},
  year = {2023},
  month = sep,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {389},
  eprint = {2309.13808},
  primaryclass = {cs},
  pages = {152--166},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.389.13},
  urldate = {2025-01-29},
  abstract = {In this work-in-progress paper we explore using the recently introduced VLSM formalism to define and reason about the dynamics of agent-based systems. To this aim we use VLSMs to formally present several possible approaches to modeling the interactions in the Muddy Children Puzzle as protocols that reach consensus asynchronously.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Multiagent Systems},
  file = {/home/flaviomoura/Zotero/storage/LPVKJPSN/TrufaÅ et al. - 2023 - Asynchronous Muddy Children Puzzle (work in progre.pdf;/home/flaviomoura/Zotero/storage/6PAXTEGJ/2309.html}
}

@misc{trufasIntuitionisticPropositionalLogic2024,
  title = {Intuitionistic {{Propositional Logic}} in {{Lean}}},
  author = {Trufa{\c s}, Dafina},
  year = {2024},
  month = oct,
  number = {arXiv:2410.23765},
  eprint = {2410.23765},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2410.23765},
  urldate = {2024-11-01},
  abstract = {In this paper we present a formalization of Intuitionistic Propositional Logic in the Lean proof assistant. Our approach focuses on verifying two completeness proofs for the studied logical system, as well as exploring the relation between the two analyzed semantical paradigms - Kripke and algebraic. In addition, we prove a large number of theorems and derived deduction rules.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/NXW4APBU/TrufaÅ - 2024 - Intuitionistic Propositional Logic in Lean.pdf;/home/flaviomoura/Zotero/storage/6HCCIL4L/2410.html}
}

@article{tseitenAssociativeCalculusUnsolvable1956,
  title = {Associative {{Calculus}} with {{Unsolvable Equivalence Problem}}},
  author = {Tseiten, G. S.},
  year = {1956},
  journal = {Dokl. Akad. Nauk SSSR},
  volume = {107},
  number = {3},
  pages = {370--371}
}

@article{turingComputableNumbersApplication1936,
  title = {On {{Computable Numbers}}, with an {{Application}} to the {{Entscheidungsproblem}}},
  author = {Turing, Alan M.},
  year = {1936},
  journal = {Proceedings of the London Mathematical Society},
  volume = {2},
  number = {42},
  pages = {230--265},
  keywords = {halting}
}

@unpublished{unbMinutaCEPE2020,
  type = {Minuta},
  title = {Minuta {{CEPE}}},
  author = {UnB},
  year = {2020},
  abstract = {Minuta CEPE sobre retorna das atividades n{\~a}o presenciais}
}

@book{UnderstandingLargeLanguage,
  title = {Understanding {{Large Language Models}}},
  urldate = {2024-04-20},
  abstract = {This book will teach you the underlying concepts of large language models (LLMs), as well as the technologies associated with them.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/HGTAFDA4/979-8-8688-0017-7.html}
}

@book{ungarNormalizationCutEliminationTheory1992,
  title = {Normalization, {{Cut-Elimination}}, and the {{Theory}} of {{Proofs}}},
  author = {Ungar, A. M.},
  year = {1992},
  series = {{{CSLI Lecture Notes}}},
  number = {28},
  publisher = {University of Chicago Press}
}

@inproceedings{urbanBarendregtsVariableConvention2007,
  title = {Barendregt's {{Variable Convention}} in {{Rule Inductions}}},
  booktitle = {Automated {{Deduction}} -- {{CADE-21}}},
  author = {Urban, Christian and Berghofer, Stefan and Norrish, Michael},
  editor = {Pfenning, Frank},
  year = {2007},
  pages = {35--50},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-73595-3_4},
  abstract = {Inductive definitions and rule inductions are two fundamental reasoning tools in logic and computer science. When inductive definitions involve binders, then Barendregt's variable convention is nearly always employed (explicitly or implicitly) in order to obtain simple proofs. Using this convention, one does not consider truly arbitrary bound names, as required by the rule induction principle, but rather bound names about which various freshness assumptions are made. Unfortunately, neither Barendregt nor others give a formal justification for the variable convention, which makes it hard to formalise such proofs. In this paper we identify conditions an inductive definition has to satisfy so that a form of the variable convention can be built into the rule induction principle. In practice this means we come quite close to the informal reasoning of ``pencil-and-paper'' proofs, while remaining completely formal. Our conditions also reveal circumstances in which Barendregt's variable convention is not applicable, and can even lead to faulty reasoning.},
  isbn = {978-3-540-73595-3},
  langid = {english}
}

@incollection{urbanBarendregtsVariableConvention2007a,
  title = {Barendregt's {{Variable Convention}} in {{Rule Inductions}}},
  booktitle = {Automated {{Deduction}} -- {{CADE-21}}},
  author = {Urban, Christian and Berghofer, Stefan and Norrish, Michael},
  editor = {Pfenning, Frank},
  year = {2007},
  volume = {4603},
  pages = {35--50},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  issn = {0302-9743, 1611-3349},
  doi = {10.1007/978-3-540-73595-3_4},
  urldate = {2023-10-06},
  isbn = {978-3-540-73594-6 978-3-540-73595-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/PB6SMG3X/Urban et al. - 2007 - Barendregtâs Variable Convention in Rule Induction.pdf}
}

@inproceedings{urbanFormalTreatmentBarendregt2005,
  title = {A Formal Treatment of the Barendregt Variable Convention in Rule Inductions},
  booktitle = {Proceedings of the 3rd {{ACM SIGPLAN}} Workshop on {{Mechanized}} Reasoning about Languages with Variable Binding},
  author = {Urban, Christian and Norrish, Michael},
  year = {2005},
  month = sep,
  pages = {25--32},
  publisher = {ACM},
  address = {Tallinn Estonia},
  doi = {10.1145/1088454.1088458},
  urldate = {2023-01-20},
  isbn = {978-1-59593-072-9},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/YDGAS5HU/Urban e Norrish - 2005 - A formal treatment of the barendregt variable conv.pdf}
}

@article{urbanGeneralBindingsAlphaEquivalence2012,
  title = {General {{Bindings}} and {{Alpha-Equivalence}} in {{Nominal Isabelle}}},
  author = {Urban, Christian and Kaliszyk, Cezary},
  year = {2012},
  month = jun,
  journal = {Logical Methods in Computer Science},
  volume = {Volume 8, Issue 2},
  publisher = {Episciences.org},
  issn = {1860-5974},
  doi = {10.2168/LMCS-8(2:14)2012},
  urldate = {2024-02-19},
  abstract = {Nominal Isabelle is a definitional extension of the Isabelle/HOL theorem prover. It provides a proving infrastructure for reasoning about programming language calculi involving named bound variables (as opposed to de-Bruijn indices). In this paper we present an extension of Nominal Isabelle for dealing with general bindings, that means term constructors where multiple variables are bound at once. Such general bindings are ubiquitous in programming language research and only very poorly supported with single binders, such as lambda-abstractions. Our extension includes new definitions of alpha-equivalence and establishes automatically the reasoning infrastructure for alpha-equated terms. We also prove strong induction principles that have the usual variable convention already built in.},
  file = {/home/flaviomoura/Zotero/storage/3L59KH5U/Urban and Kaliszyk - 2012 - General Bindings and Alpha-Equivalence in Nominal .pdf}
}

@book{urbanInteractiveTheoremProving2015,
  title = {Interactive {{Theorem Proving}} - 6th {{International Conference}}, {{ITP}} 2015, {{Nanjing}}, {{China}}, {{August}} 24-27, 2015, {{Proceedings}}},
  editor = {Urban, Christian and Zhang, Xingyuan},
  year = {2015},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {9236},
  publisher = {Springer},
  doi = {10.1007/978-3-319-22102-1},
  isbn = {978-3-319-22101-4}
}

@article{urbanNominalUnification2004,
  title = {Nominal {{Unification}}},
  author = {Urban, C. and Pitts, A. M. and Gabbay, M. J.},
  year = {2004},
  journal = {Theoretical Computer Science},
  volume = {323},
  number = {1-3},
  pages = {473--497},
  doi = {10.1016/j.tcs.2004.06.016}
}

@article{urciuoliStrongNormalizationSimplyTyped2020,
  title = {Strong {{Normalization}} for the {{Simply-Typed Lambda Calculus}} in {{Constructive Type Theory Using Agda}}},
  author = {Urciuoli, Sebasti{\'a}n and Tasistro, {\'A}lvaro and Szasz, Nora},
  year = {2020},
  month = sep,
  journal = {Electronic Notes in Theoretical Computer Science},
  volume = {351},
  pages = {187--203},
  issn = {15710661},
  doi = {10.1016/j.entcs.2020.08.010},
  urldate = {2020-10-16},
  langid = {english}
}

@article{vaananenSecondOrderLogicSet2015,
  title = {Second-{{Order Logic}} and {{Set Theory}}},
  author = {V{\"a}{\"a}n{\"a}nen, Jouko},
  year = {2015},
  journal = {Philosophy Compass},
  volume = {10},
  number = {7},
  pages = {463--478},
  doi = {10.1111/phc3.12229}
}

@article{vanattenBrouwerUnreliabilityLogical2015,
  title = {L.{{E}}.{{J}}. {{Brouwer}}'s `{{Unreliability}} of the Logical Principles'. {{A}} New Translation, with an Introduction},
  author = {{van Atten}, M. and Sundholm, G.},
  year = {2015},
  month = nov,
  journal = {ArXiv e-prints},
  keywords = {Mathematics - History and Overview}
}

@article{vanbruggeBarendregtConvenesKnaster2025,
  title = {Barendregt {{Convenes}} with {{Knaster}} and {{Tarski}}: {{Strong Rule Induction}} for {{Syntax}} with {{Bindings}}},
  shorttitle = {Barendregt {{Convenes}} with {{Knaster}} and {{Tarski}}},
  author = {{van Br{\"u}gge}, Jan and McKinna, James and Popescu, Andrei and Traytel, Dmitriy},
  year = {2025},
  month = jan,
  journal = {Barendregt Convenes with Knaster and Tarski: Implementation and Mechanization Artifact},
  volume = {9},
  number = {POPL},
  pages = {57:1687--57:1718},
  doi = {10.1145/3704893},
  urldate = {2025-02-10},
  abstract = {This paper is a contribution to the meta-theory of systems featuring syntax with bindings, such as {$\lambda$}-calculi and logics. It provides a general criterion that targets inductively defined rule-based systems, enabling for them inductive proofs that leverage Barendregt's variable convention of keeping the bound and free variables disjoint. It improves on the state of the art by (1) achieving high generality in the style of Knaster--Tarski fixed point definitions (as opposed to imposing syntactic formats), (2) capturing systems of interest without modifications, and (3) accommodating infinitary syntax and non-equivariant predicates.},
  file = {/home/flaviomoura/Zotero/storage/AYW9ACE3/van BrÃ¼gge et al. - 2025 - Barendregt Convenes with Knaster and Tarski Strong Rule Induction for Syntax with Bindings.pdf}
}

@misc{vancuykWhyMustEvery2023,
  title = {Why Must Every Data Scientist Be a {{Platonist}}},
  author = {Van Cuyk, Collin Joseph and Hong, Liang},
  year = {2023},
  month = mar,
  number = {arXiv:2303.11830},
  eprint = {2303.11830},
  primaryclass = {cs, math, stat},
  publisher = {arXiv},
  urldate = {2023-03-22},
  abstract = {Data scientists are not mathematicians, but they make heavy use of mathematics in their daily work. While mathematicians can study a mathematical object which is inaccessible to our five senses, data scientists must deal with real-world data which are observable to us. This fine line suggests that a data scientist's philosophical position on mathematics might have a nontrivial impact on their work. By examining how different philosophical views of mathematics affect the interpretation of the basic model assumption in data science, we arrive at the conclusion that a data scientist, who uses modern probabilistic and statistical tools, must be a Platonist.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {00A30,Computer Science - Logic in Computer Science,Mathematics - History and Overview,Mathematics - Logic,Statistics - Other Statistics},
  file = {/home/flaviomoura/Zotero/storage/DDVLC8PM/Van Cuyk e Hong - 2023 - Why must every data scientist be a Platonist.pdf}
}

@book{vanderbeiLinearProgramming2014,
  title = {Linear {{Programming}}},
  author = {Vanderbei, Robert J.},
  year = {2014},
  series = {International {{Series}} in {{Operations Research}} \& {{Management Science}}},
  publisher = {Springer US},
  doi = {10.1007/978-1-4614-7630-6}
}

@article{vanderleerUniversalAlgebraUnivalent2024,
  title = {Universal {{Algebra}}, {{Univalent Foundations}} and the {{Untyped}} {$\lambda$}-{{Calculus}}},
  author = {{van der Leer}, A. A.},
  year = {2024},
  urldate = {2024-12-22},
  abstract = {The {$\lambda$}-calculus is a versatile tool both in mathematical logic and computer science. This thesis studies and expands upon Martin Hyland's paper `Classical lambda calculus in modern dress'. It gives examples for the definitions and provides more detailed proofs, as well as one new proof for Hyland's fundamental theorem of the {$\lambda$}-calculus. It complements these definitions and proofs with material of previous authors by which Hyland has been inspired. The thesis translates Hyland's paper from set theory with classical logic to univalent foundations, and showcases where subtleties arise in such a translation. In particular, it discusses the different implementations of the Karoubi envelope in univalent foundations. Lastly, it discusses the accompanying formalization of parts of Hyland's paper, with in particular a tactic that was developed for applying {$\beta$}-reduction and substitution to {$\lambda$}-terms.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/Z9E232R5/van der Leer - 2024 - Universal Algebra, Univalent Foundations and the U.pdf}
}

@inproceedings{vanderweegenMachineCheckedProofAverageCase2009,
  title = {A {{Machine-Checked Proof}} of the {{Average-Case Complexity}} of {{Quicksort}} in {{Coq}}},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  author = {{van der Weegen}, Eelis and McKinna, James},
  editor = {Berardi, Stefano and Damiani, Ferruccio and {de'Liguoro}, Ugo},
  year = {2009},
  pages = {256--271},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-02444-3_16},
  abstract = {As a case-study in machine-checked reasoning about the complexity of algorithms in type theory, we describe a proof of the average-case complexity of Quicksort in Coq. The proof attempts to follow a textbook development, at the heart of which lies a technical lemma about the behaviour of the algorithm for which the original proof only gives an intuitive justification.},
  isbn = {978-3-642-02444-3},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/7CPIQEIB/van der Weegen e McKinna - 2009 - A Machine-Checked Proof of the Average-Case Comple.pdf;/home/flaviomoura/Zotero/storage/LWDSUMVP/quicksort-coq-2008.pdf}
}

@article{vandoornHomotopyTypeTheory2017,
  title = {Homotopy {{Type Theory}} in {{Lean}}},
  author = {{van Doorn}, F. and {von Raumer}, J. and Buchholtz, U.},
  year = {2017},
  month = apr,
  journal = {ArXiv e-prints},
  keywords = {03B15,03B70,55U35,Computer Science - Logic in Computer Science,Mathematics - Logic}
}

@inproceedings{vanoostrom:LIPIcs.FSCD.2021.24,
  title = {Z; Syntax-Free Developments},
  booktitle = {6th International Conference on Formal Structures for Computation and Deduction ({{FSCD}} 2021)},
  author = {{van Oostrom}, Vincent},
  editor = {Kobayashi, Naoki},
  year = {2021},
  series = {Leibniz International Proceedings in Informatics ({{LIPIcs}})},
  volume = {195},
  pages = {24:1--24:22},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  issn = {1868-8969},
  doi = {10.4230/LIPIcs.FSCD.2021.24},
  isbn = {978-3-95977-191-7},
  urn = {urn:nbn:de:0030-drops-142620},
  file = {/home/flaviomoura/Zotero/storage/8V6HJMY8/2021 - Z; Syntax-Free Developments.pdf}
}

@article{vanoostromCausalEquivalenceTracing2023,
  title = {On {{Causal Equivalence}} by {{Tracing}} in {{String Rewriting}}},
  author = {{van Oostrom}, Vincent},
  year = {2023},
  month = apr,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {377},
  eprint = {2303.15783},
  primaryclass = {cs},
  pages = {27--43},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.377.2},
  urldate = {2024-07-21},
  abstract = {We introduce proof terms for string rewrite systems and, using these, show that various notions of equivalence on reductions known from the literature can be viewed as different perspectives on the notion of causal equivalence. In particular, we show that permutation equivalence classes (as known from the lambda-calculus and term rewriting) are uniquely represented both by trace graphs (known from physics as causal graphs) and by so-called greedy multistep reductions (as known from algebra). We present effective maps from the former to the latter, topological multi-sorting TM, and vice versa, the proof term algebra [[ ]].},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/KVVEVS2W/van Oostrom - 2023 - On Causal Equivalence by Tracing in String Rewriti.pdf;/home/flaviomoura/Zotero/storage/5BDBGHTI/2303.html}
}

@incollection{vanoostromConfluenceDecreasingDiagrams2008,
  title = {Confluence by {{Decreasing Diagrams}}: {{Converted}}},
  shorttitle = {Confluence by {{Decreasing Diagrams}}},
  booktitle = {Rewriting {{Techniques}} and {{Applications}}},
  author = {{van Oostrom}, Vincent},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Voronkov, Andrei},
  year = {2008},
  volume = {5117},
  pages = {306--320},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-70590-1_21},
  urldate = {2023-01-28},
  isbn = {978-3-540-70588-8 978-3-540-70590-1},
  langid = {english}
}

@article{vanoostromNaivelyImplementingCalculus,
  title = {On Na{\"i}vely Implementing the {$\lambda$} {$\beta$} -Calculus},
  author = {{van Oostrom}, Vincent},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IFITVWNI/van Oostrom - On naÃ¯vely implementing the Î» Î² -calculus.pdf}
}

@article{vanoostromZpropertyLeftlinearTerm,
  title = {The {{Z-property}} for Left-Linear Term Rewriting via Convective Context-Sensitive Completeness},
  author = {{van Oostrom}, Vincent},
  abstract = {We present a method to derive the Z-property, hence confluence, of a first-order term rewrite system T from completeness of an associated context-sensitive term rewrite system T , {\textmu} with replacement map {\textmu}. We generalise earlier such results by only requiring leftlinearity of T and that T -critical peaks be T , {\textmu}-critical peaks. We introduce convective replacement maps as a generalisation of canonical maps known from the literature.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/EEH3HWVC/van Oostrom - The Z-property for left-linear term rewriting via .pdf}
}

@incollection{vanraamsdonkHigherOrderRewriting1999,
  title = {Higher-{{Order Rewriting}}},
  booktitle = {Rewriting {{Techniques}} and {{Applications}}},
  author = {{van Raamsdonk}, Femke},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Narendran, Paliath and Rusinowitch, Michael},
  year = {1999},
  volume = {1631},
  pages = {220--239},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-48685-2_17},
  urldate = {2023-07-11},
  abstract = {Higher-order rewriting is a framework in which higher-order programs can be described by transformation rules on expressions. A computation occurs by transforming an expression into another using such rules. This step-by-step computation model induced by rewriting naturally gives rise to a notion of complexity as the number of steps needed to reduce expressions to a normal form, i.e., an expression that cannot be reduced further. The study of complexity analysis focuses on the development of automatable techniques to provide bounds to this number. In this paper, we consider a form of higher-order rewriting with a call-by-value evaluation strategy, so as to model call-by-value programs. We provide a cost--size semantics: a class of algebraic interpretations to map terms to tuples which bound both the reduction cost and the size of normal forms.},
  isbn = {978-3-540-66201-3 978-3-540-48685-5},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/NSHIS369/van Raamsdonk - 1999 - Higher-Order Rewriting.pdf}
}

@article{vaughanReviewThreeTechniques,
  title = {A {{Review}} of {{Three Techniques}} for {{Formally Representing Variable Binding}}},
  author = {Vaughan, Jeffrey A},
  abstract = {This paper compares three models for formal reasoning about programming languages with binding. Higher order abstract syntax (hoas) uses meta-level binding to represent object-level binding [PE88]. Nominal Logic couples a concrete representation of bound variables with a formal apparatus for safely manipulating bound variables [Pit03]. The locally named binding representation places bound and free variables in different syntactic sorts [MP99]. This paper surveys each binding model, and compares it to the others and to Gordon and Melham's axiomatization of the untyped lambda calculus [GM97]. Comparisons are made based on expressive power, transparency to human readers, and suitability for mechanized reasoning of each binding model. Each system excels in one area; hoas is most expressive, Nominal Logic most transparent, and locally named most mechanizable.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/JKU37CP7/Vaughan - A Review of Three Techniques for Formally Represen.pdf}
}

@article{veldmanIntuitionismInspiration2021,
  title = {Intuitionism: An Inspiration?},
  shorttitle = {Intuitionism},
  author = {Veldman, Wim},
  year = {2021},
  journal = {arXiv:2102.01561 [math]},
  eprint = {2102.01561},
  primaryclass = {math},
  doi = {10.13140/RG.2.2.12313.54881},
  urldate = {2021-02-03},
  abstract = {The paper is an introduction to intuitionistic mathematics.},
  archiveprefix = {arXiv},
  keywords = {03 F 55,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/9QM75K4I/Veldman - 2021 - Intuitionism an inspiration.pdf;/home/flaviomoura/Zotero/storage/5T94J9AS/2102.html}
}

@article{veldmanIntuitionisticCompletenessTheorem1976,
  title = {An {{Intuitionistic Completeness Theorem}} for {{Intuitionistic Predicate Logic}}},
  author = {Veldman, W.},
  year = {1976},
  journal = {The Journal of Symbolic Logic},
  volume = {41},
  number = {1},
  pages = {159},
  doi = {10.2307/2272955}
}

@mastersthesis{venturaCalculosSubstituicoesExplicitas2006,
  title = {C{\'a}lculos de {{Substitui{\c c}{\~o}es Expl{\'i}citas}} Que {{Preservam}} a {{Propriedade}} de {{Redu{\c c}{\~a}o}} Do {{Sujeito}}},
  author = {Ventura, D. L.},
  year = {2006},
  school = {Departamento de Matem{\'a}tica, Universidade de Bras{\'i}lia}
}

@article{venturaExplicitSubstitutionCalculi2015,
  title = {Explicit Substitution Calculi with de {{Bruijn}} Indices and Intersection Type Systems},
  author = {Ventura, D. Lima and Kamareddine, F. and {Ayala-Rinc{\'o}n}, M.},
  year = {2015},
  journal = {Logic Journal of the IGPL},
  volume = {23},
  number = {2},
  pages = {295--340}
}

@article{venturaExplicitSubstitutionsCalculi2009,
  title = {Explicit Substitutions Calculi with One Step {{Eta-reduction}} Decided Explicitly},
  author = {Ventura, D. and {Ayala-Rincon}, M. and Kamareddine, F.},
  year = {2009},
  journal = {Logic Journal of the IGPL},
  volume = {17},
  pages = {697--718}
}

@inproceedings{verasCalculationFundamentalGroups2021,
  title = {Calculation of {{Fundamental Groups}} via {{Computational Paths}}},
  booktitle = {Anais Do {{Encontro}} de {{Teoria}} Da {{Computa{\c c}{\~a}o}} ({{ETC}})},
  author = {de Veras, T. M. L. and Ramos, A. F. and de Queiroz, R. J. G. B. and de Oliveira, A. G.},
  year = {2021},
  month = jul,
  pages = {17--21},
  publisher = {SBC},
  issn = {2595-6116},
  doi = {10.5753/etc.2021.16370},
  urldate = {2021-07-20},
  abstract = {We address the question as to how to formalise the concept of computational paths (sequences of rewrites) as equalities between two terms of the same type. The intention is to demonstrate the use of a term rewriting system in performing computations with these computational paths, establishing equalities between equalities, and further higher equalities, in particular, in the calculation of fundamental groups of surfaces such as the circle, the torus and the real projective plane.},
  copyright = {Copyright (c)},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/IPMJECE2/Veras et al. - 2021 - Calculation of Fundamental Groups via Computationa.pdf}
}

@misc{verasComputationalPathsApproach2023,
  title = {Computational {{Paths}} -- {{An}} Approach in the \${{LND}}\_\{\vphantom\}{{EQ}}\vphantom\{\}-{{TRS}}\_\{2\}\$ System},
  author = {Veras, Tiago M. L. and Ramos, Arthur F. and {de Queiroz}, Ruy J. G. B. and {de Oliveira}, Anjolina G.},
  year = {2023},
  month = nov,
  number = {arXiv:2007.07769},
  eprint = {2007.07769},
  primaryclass = {cs},
  publisher = {arXiv},
  urldate = {2023-11-21},
  abstract = {We use a labelled deduction system ( LND\$\_\{ED-\}\$TRS ) based on the concept of computational paths (sequences of rewrites) as equalities between two terms of the same type, which allowed us to carry out in homotopic theory an approach using the concept of computational paths. From this, we show that the computational paths can be used to perform the proofs of the \$LND\_\{EQ\}-TRS\_\{2\}\$ rewriting system.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/VBN3J228/Veras et al. - 2023 - Computational Paths -- An approach in the $LND_ EQ.pdf;/home/flaviomoura/Zotero/storage/BI44C4VS/2007.html}
}

@article{verasTopologicalApplicationLabelled2020,
  title = {A {{Topological Application}} of {{Labelled Natural Deduction}}},
  author = {Veras, Tiago M. L. and Ramos, Arthur F. and {de Queiroz}, Ruy J. G. B. and {de Oliveira}, Anjolina G.},
  year = {2020},
  month = oct,
  journal = {arXiv:1906.09105 [cs, math]},
  eprint = {1906.09105},
  primaryclass = {cs, math},
  urldate = {2020-10-20},
  abstract = {We use a labelled deduction system based on the concept of computational paths (sequences of rewrites) as equalities between two terms of the same type. We also define a term rewriting system that is used to make computations between these computational paths, establishing equalities between equalities. We then proceed to show the main result here: using this system to obtain the calculation of the fundamental group of the circle, of the torus and the real projective plane.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Algebraic Topology},
  file = {/home/flaviomoura/Zotero/storage/W4J3EZ9A/Veras et al. - 2020 - A Topological Application of Labelled Natural Dedu.pdf;/home/flaviomoura/Zotero/storage/QTEEMGJ7/1906.html}
}

@article{vestergaardFormalisedFirstorderConfluence2003,
  title = {A Formalised First-Order Confluence Proof for the {\emph{{$\lambda$}}}-Calculus Using One-Sorted Variable Names},
  author = {Vestergaard, Ren{\'e} and Brotherston, James},
  year = {2003},
  month = jun,
  journal = {Information and Computation},
  series = {12th {{International Conference}} on {{Rewriting Techniques}} and {{Applications}} ({{RTA}} 2001)},
  volume = {183},
  number = {2},
  pages = {212--244},
  issn = {0890-5401},
  doi = {10.1016/S0890-5401(03)00023-3},
  urldate = {2024-10-08},
  abstract = {We present the titular proof development that has been verified in Isabelle/HOL. As a first, the proof is conducted exclusively by the primitive proof principles of the standard syntax and of the considered reduction relations: the naive way, so to speak. Curiously, the Barendregt Variable Convention takes on a central technical role in the proof. We also show: (i) that our presentation of the {$\lambda$}-calculus coincides with Curry's and Hindley's when terms are considered equal up to {$\alpha$}-equivalence and (ii) that the confluence properties of all considered systems are equivalent.},
  keywords = {-Calculus,Barendregt's Variable Convention,Confluence,Structural induction and recursion,Theorem proving},
  file = {/home/flaviomoura/Zotero/storage/Q3RJEPY3/S0890540103000233.html}
}

@article{vialSequenceTypesInfinitary2021,
  title = {Sequence {{Types}} and {{Infinitary Semantics}}},
  author = {Vial, Pierre},
  year = {2021},
  month = feb,
  journal = {arXiv:2102.07515 [cs]},
  eprint = {2102.07515},
  primaryclass = {cs},
  urldate = {2021-02-16},
  abstract = {We introduce a new representation of non-idempotent intersection types, using sequences (families indexed with natural numbers) instead of lists or multisets. This allows scaling up intersection type theory to the infinitary lambda-calculus. We thus characterize hereditary head normalization (Klop's Problem) and we give a unique type to all hereditary permutators (TLCA Problem \#20), which is not possible in a finite system. On our way, we use non-idempotent intersection to retrieve some well-known results on infinitary terms. This paper begins with a gentle, high-level introduction to intersection type theory and to the infinitary calculus.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages,cs-LO},
  file = {/home/flaviomoura/Zotero/storage/V66F3PSM/Vial - 2021 - Sequence Types and Infinitary Semantics.pdf;/home/flaviomoura/Zotero/storage/KAFIJKL3/2102.html}
}

@article{villadsenTeachingIntuitionisticClassical2022,
  title = {Teaching {{Intuitionistic}} and {{Classical Propositional Logic Using Isabelle}}},
  author = {Villadsen, J{\o}rgen and From, Asta Halkj{\ae}r and Blackburn, Patrick},
  year = {2022},
  month = feb,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {354},
  pages = {71--85},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.354.6},
  urldate = {2022-02-11},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ZLXHPNG7/Villadsen et al. - 2022 - Teaching Intuitionistic and Classical Propositiona.pdf}
}

@unpublished{vilmartMinimalityFiniteDimensionalZWCalculi2024,
  title = {Minimality in {{Finite-Dimensional ZW-Calculi}}},
  author = {Vilmart, Renaud and {de Visme}, Marc},
  year = {2024},
  month = mar,
  urldate = {2024-03-12},
  abstract = {The ZW-calculus is a graphical language capable of representing 2-dimensional quantum systems (qubit) through its diagrams, and manipulating them through its equational theory. We extend the formalism to accommodate finite dimensional Hilbert spaces beyond qubit systems. First we define a qudit version of the language, where all systems have the same arbitrary finite dimension d, and show that the provided equational theory is both complete -- i.e. semantical equivalence is entirely captured by the equations -- and minimal -- i.e. none of the equations are consequences of the others. We then extend the graphical language further to accommodate all finite dimensional Hilbert spaces at the same time. We again show the completeness of the provided equational theory.},
  keywords = {Completeness,Equational Theory,Finite Dimensional Hilbert Spaces,Normal Form,Qudit systems,Universality,ZW-calculus},
  file = {/home/flaviomoura/Zotero/storage/LXGHPBBN/Vilmart e de Visme - 2024 - Minimality in Finite-Dimensional ZW-Calculi.pdf}
}

@article{visoPowerTightnessCallByPushValue2021,
  title = {The {{Power}} of {{Tightness}} for {{Call-By-Push-Value}}},
  author = {Viso, Delia Kesner andres Andr{\'e}s},
  year = {2021},
  month = may,
  journal = {arXiv:2105.00564 [cs]},
  eprint = {2105.00564},
  primaryclass = {cs},
  urldate = {2021-05-04},
  abstract = {We propose tight type systems for Call-by-Name (CBN) and Call-by-Value (CBV) that can be both encoded in a tight type system for Call-by-Push-Value (CBPV). All such systems are quantitative, in the sense that they provide exact information about the length of normalization sequences to normal form (discriminated between multiplicative and exponential steps) as well as the size of these normal forms.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/P9HNKLTT/Viso - 2021 - The Power of Tightness for Call-By-Push-Value.pdf;/home/flaviomoura/Zotero/storage/DALC5LNP/2105.html}
}

@article{voisinHowMakePortrait2022,
  title = {1. {{How}} to {{Make}} a {{Portrait}} of a {{Bird}} by {{Claire Voisin}}},
  author = {Voisin, Claire},
  year = {2022},
  month = jun,
  journal = {Notices of the American Mathematical Society},
  volume = {69},
  number = {06},
  pages = {1},
  issn = {0002-9920, 1088-9477},
  doi = {10.1090/noti2500},
  urldate = {2024-03-17},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/3EN4EFHE/Voisin - 2022 - 1. How to Make a Portrait of a Bird by Claire Vois.pdf}
}

@article{vonplatoGentzenProofNormalization2008,
  title = {Gentzen's {{Proof}} of {{Normalization}} for {{Natural Deduction}}},
  author = {{von Plato}, Jan},
  year = {2008},
  month = jun,
  journal = {Bulletin of Symbolic Logic},
  volume = {14},
  number = {2},
  pages = {240--257},
  issn = {1079-8986, 1943-5894},
  doi = {10.2178/bsl/1208442829},
  urldate = {2020-07-02},
  abstract = {Abstract                            Gentzen writes in the published version of his doctoral thesis               Untersuchungen {\"u}ber das logische Schliessen               (Investigations into logical reasoning) that he was able to prove the normalization theorem only for intuitionistic natural deduction, but not for classical. To cover the latter, he developed classical sequent calculus and proved a corresponding theorem, the famous cut elimination result. Its proof was organized so that a cut elimination result for an intuitionistic sequent calculus came out as a special case, namely the one in which the sequents have at most one formula in the right, succedent part. Thus, there was no need for a direct proof of normalization for intuitionistic natural deduction. The only traces of such a proof in the published thesis are some convertibilities, such as when an implication introduction is followed by an implication elimination [1934--35, II.5.13]. It remained to Dag Prawitz in 1965 to work out a proof of normalization. Another, less known proof was given also in 1965 by Andres Raggio.                                         We found in February 2005 an early handwritten version of Gentzen's thesis, with exactly the above title, but with rather different contents: Most remarkably, it contains a detailed proof of normalization for what became the standard system of natural deduction. The manuscript is located in the Paul Bernays collection at the ETH-Zurichwith the signum               Hs               . 974: 271. Bernays must have gotten it well before the time of his being expelled from G{\"o}ttingen on the basis of the racial laws in April 1933.},
  langid = {english}
}

@book{voronkovLogicProgrammingAutomated1992,
  title = {Logic {{Programming}} and {{Automated Reasoning}},{{International Conference LPAR}}'92, {{St}}. {{Petersburg}}, {{Russia}}, {{July}} 15-20, 1992, {{Proceedings}}},
  editor = {Voronkov, Andrei},
  year = {1992},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {624},
  publisher = {Springer},
  doi = {10.1007/BFb0013043},
  isbn = {3-540-55727-X}
}

@article{vouillonSolutionPoplmarkChallenge2011,
  title = {A {{Solution To}} the {{Poplmark Challenge Based}} on {{De Bruijn Indices}}},
  author = {Vouillon, J{\'e}r{\^o}me},
  year = {2011},
  journal = {J Autom Reasoning},
  volume = {49},
  number = {3},
  pages = {327--362},
  doi = {10.1007/s10817-011-9230-5}
}

@article{vrijerDirectProofFinite1985,
  title = {A {{Direct Proof}} of the {{Finite Developments Theorem}}},
  author = {de Vrijer, R. C.},
  year = {1985},
  journal = {J. Symb. Log.},
  volume = {50},
  number = {2},
  pages = {339--343}
}

@inproceedings{wadlerCallbyvalueDualCallbyname2003,
  title = {Call-by-Value Is Dual to Call-by-Name},
  booktitle = {Proceedings of the {{Eighth ACM SIGPLAN International Conference}} on {{Functional Programming}}, {{ICFP}} 2003, {{Uppsala}}, {{Sweden}}, {{August}} 25-29, 2003},
  author = {Wadler, Philip},
  year = {2003},
  pages = {189--201},
  doi = {10.1145/944705.944723}
}

@inproceedings{wadlerCallbyValueDualCallbyName2005,
  title = {Call-by-{{Value Is Dual}} to {{Call-by-Name}} - {{Reloaded}}},
  booktitle = {Term {{Rewriting}} and {{Applications}}, 16th {{International Conference}}, {{RTA}} 2005, {{Nara}}, {{Japan}}, {{April}} 19-21, 2005, {{Proceedings}}},
  author = {Wadler, Philip},
  year = {2005},
  pages = {185--203},
  doi = {10.1007/978-3-540-32033-3_15}
}

@article{wadlerPropositionsTypes2015,
  title = {Propositions as Types},
  author = {Wadler, Philip},
  year = {2015},
  month = nov,
  journal = {Communications of the ACM},
  volume = {58},
  number = {12},
  pages = {75--84},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/2699407},
  urldate = {2024-03-19},
  abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/EA97S34A/Wadler - 2015 - Propositions as types.pdf}
}

@article{wagnerConstructionsCombinatoricsNeural2021,
  title = {Constructions in Combinatorics via Neural Networks},
  author = {Wagner, Adam Zsolt},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.14516 [cs, math]},
  eprint = {2104.14516},
  primaryclass = {cs, math},
  urldate = {2021-05-21},
  abstract = {We demonstrate how by using a reinforcement learning algorithm, the deep cross-entropy method, one can find explicit constructions and counterexamples to several open conjectures in extremal combinatorics and graph theory. Amongst the conjectures we refute are a question of Brualdi and Cao about maximizing permanents of pattern avoiding matrices, and several problems related to the adjacency and distance eigenvalues of graphs.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Machine Learning,Mathematics - Combinatorics},
  file = {/home/flaviomoura/Zotero/storage/ECII93YR/2104.html}
}

@book{wallworkEnglishAcademicResearch2013,
  title = {English for {{Academic Research}}: {{Vocabulary Exercises}}},
  author = {Wallwork, Adrian},
  year = {2013},
  series = {[]},
  publisher = {Springer US},
  doi = {10.1007/978-1-4614-4268-4}
}

@book{wallworkEnglishPresentationsInternational2016,
  title = {English for {{Presentations}} at {{International Conferences}}},
  author = {Wallwork, Adrian},
  year = {2016},
  series = {[]},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-26330-4}
}

@book{wallworkEnglishResearchGrammar2013,
  title = {English for {{Research}}: {{Grammar}}, {{Usage}} and {{Style}}},
  author = {Wallwork, Adrian},
  year = {2013},
  publisher = {Springer US},
  doi = {10.1007/978-1-4614-1593-0}
}

@book{wallworkEnglishWritingResearch2016,
  title = {English for {{Writing Research Papers}}},
  author = {Wallwork, Adrian},
  year = {2016},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-26094-5}
}

@article{waltherVerificationClassroom2004,
  title = {Verification in the {{Classroom}}},
  author = {Walther, Christoph and Schweitzer, Stephan},
  year = {2004},
  journal = {Journal of Automated Reasoning},
  volume = {32},
  number = {1},
  pages = {35--73},
  doi = {10.1023/b:jars.0000021872.64036.41}
}

@book{wansingDagPrawitzProofs2016,
  title = {Dag {{Prawitz}} on {{Proofs}} and {{Meaning}}},
  author = {Wansing, Heinrich},
  year = {2016},
  edition = {1st},
  publisher = {Springer Publishing Company, Incorporated},
  isbn = {3-319-36031-0 978-3-319-36031-7},
  file = {/home/flaviomoura/Zotero/storage/ZYBQZEEQ/Wansing - 2016 - Dag Prawitz on Proofs and Meaning.pdf}
}

@book{wapnerPeaSunMathematical2007,
  title = {The {{Pea}} and the {{Sun}}: {{A Mathematical Paradox}}},
  author = {Wapner, Leonard M.},
  year = {2007},
  publisher = {A K Peters},
  isbn = {978-1-56881-327-1 1-56881-327-9}
}

@article{warrenFirstorderNaturalDeduction2021,
  title = {First-Order Natural Deduction in {{Agda}}},
  author = {Warren, Louis},
  year = {2021},
  month = apr,
  journal = {arXiv:2104.04095 [cs, math]},
  eprint = {2104.04095},
  primaryclass = {cs, math},
  urldate = {2021-04-12},
  abstract = {Agda is a dependently-typed functional programming language, based on an extension of intuitionistic Martin-L{\textbackslash}"of type theory. We implement first order natural deduction in Agda. We use Agda's type checker to verify the correctness of natural deduction proofs, and also prove properties of natural deduction, using Agda's proof assistant functionality. This implementation corresponds to a formalisation of natural deduction in constructive type theory, and the proofs are verified by Agda to be correct (under the assumption that Agda itself is correct).},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/7GAM6NUK/Warren - 2021 - First-order natural deduction in Agda.pdf;/home/flaviomoura/Zotero/storage/K8YQFJIA/2104.html}
}

@book{warrenPrologNext502023,
  title = {Prolog: {{The Next}} 50 {{Years}}},
  shorttitle = {Prolog},
  editor = {Warren, David S. and Dahl, Veronica and Eiter, Thomas and Hermenegildo, Manuel V. and Kowalski, Robert and Rossi, Francesca},
  year = {2023},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {13900},
  publisher = {Springer Nature Switzerland},
  address = {Cham},
  doi = {10.1007/978-3-031-35254-6},
  urldate = {2024-04-08},
  copyright = {https://www.springernature.com/gp/researchers/text-and-data-mining},
  isbn = {978-3-031-35253-9 978-3-031-35254-6},
  langid = {english}
}

@misc{weirichCoqMetalibPackage,
  title = {Coq {{Metalib}} Package},
  author = {Weirich, S. and al. , {\relax et}.},
  urldate = {2023-08-30},
  abstract = {This library is automatically installed via Coq Platform (Coq version 8.15.2)},
  howpublished = {https://github.com/plclub/metalib}
}

@article{weirInformalProofFormal2015,
  title = {Informal {{Proof}}, {{Formal Proof}}, {{Formalism}}},
  author = {WEIR, A.},
  year = {2015},
  journal = {The Review of Symbolic Logic},
  volume = {9},
  number = {01},
  pages = {23--43},
  doi = {10.1017/s1755020315000234}
}

@book{weissDataStructuresAlgorithm2014,
  title = {Data {{Structures}} and {{Algorithm Analysis}} in {{C}}++ (4th {{Edition}})},
  author = {Weiss, Mark Allen},
  year = {2014},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  address = {Boston, MA, USA},
  isbn = {0-321-44146-X}
}

@inproceedings{wernerSetsTypesTypes1997,
  title = {Sets in {{Types}}, {{Types}} in {{Sets}}},
  booktitle = {Theoretical {{Aspects}} of {{Computer Software}}, {{Third International Symposium}}, {{TACS}} '97, {{Sendai}}, {{Japan}}, {{September}} 23-26, 1997, {{Proceedings}}},
  author = {Werner, B.},
  year = {1997},
  pages = {530--346},
  doi = {10.1007/BFb0014566}
}

@phdthesis{wernerTheorieConstructionsInductives1994,
  title = {Une {{Th{\'e}orie}} Des {{Constructions Inductives}}},
  author = {Werner, Benjamin},
  year = {1994},
  school = {Universit{\'e} Paris 7}
}

@inproceedings{wieczorekCoqFormalizationNormalization2018,
  title = {A {{Coq Formalization}} of {{Normalization}} by {{Evaluation}} for {{Martin-L{\"o}F Type Theory}}},
  booktitle = {Proceedings of the 7th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  author = {Wieczorek, P. and Biernacki, D.},
  year = {2018},
  series = {{{CPP}} 2018},
  pages = {266--279},
  publisher = {ACM},
  address = {New York, NY, USA},
  doi = {10.1145/3167091},
  isbn = {978-1-4503-5586-5},
  keywords = {Coq,normalization by evaluation,program certification,type theory}
}

@article{wiedijkEncodingHOLLight,
  title = {Encoding the {{HOL Light}} Logic in {{Coq}}},
  author = {Wiedijk, Freek},
  abstract = {We show how to encode the HOL Light logic in Coq. This makes an automatic translation of HOL proofs to Coq possible. The translated HOL proofs refer to translated HOL data types but those data types can be related to the standard Coq data types, making the HOL results useful for Coq. The translated proofs have a size linear in the time HOL takes to process the original proofs. However the constant of linearity is large. The approach described in this paper is similar to the method of Pavel Naumov, Mark-Oliver Stehr and Jos{\textasciiacute}e Mesequer for translating HOL98 proofs to Nuprl [10].},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/BEY4BI7K/Wiedijk - Encoding the HOL Light logic in Coq.pdf}
}

@article{wiedijkHandbookPracticalLogic2012,
  title = {"handbook of {{Practical Logic}} and {{Automated Reasoning}}," {{By John R}}. {{Harrison}}, {{Cambridge University Press}}, 2009},
  author = {Wiedijk, Freek},
  year = {2012},
  journal = {J Autom Reasoning},
  volume = {49},
  number = {1},
  pages = {107--109},
  doi = {10.1007/s10817-012-9251-8}
}

@book{wiedijkUsefulnessFormalMethods2006,
  title = {On the Usefulness of Formal Methods},
  author = {Wiedijk, F.},
  year = {2006},
  annotation = {Published: Nieuwsbrief van de NVTI}
}

@techreport{wiedijkUsefulnessFormalMethods2006a,
  type = {Technical {{Report}}},
  title = {On the Usefulness of Formal Methods},
  author = {Wiedijk, F.},
  year = {2006},
  institution = {Nieuwsbrief van de NVTI}
}

@article{williamsonDeepLearningUseful2024,
  title = {Is Deep Learning a Useful Tool for the Pure Mathematician?},
  author = {Williamson, Geordie},
  year = {2024},
  month = feb,
  journal = {Bulletin of the American Mathematical Society},
  volume = {61},
  number = {2},
  pages = {271--286},
  issn = {0273-0979, 1088-9485},
  doi = {10.1090/bull/1829},
  urldate = {2024-07-10},
  abstract = {A personal and informal account of what a pure mathematician might expect when using tools from deep learning in their research.},
  copyright = {https://www.ams.org/publications/copyright-and-permissions},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/5TNLZTVN/Williamson - 2024 - Is deep learning a useful tool for the pure mathem.pdf}
}

@book{willisonModelsEngagedLearning2020,
  title = {The {{Models}} of {{Engaged Learning}} and {{Teaching}}: {{Connecting Sophisticated Thinking}} from {{Early Childhood}} to {{PhD}}},
  shorttitle = {The {{Models}} of {{Engaged Learning}} and {{Teaching}}},
  author = {Willison, John},
  year = {2020},
  series = {{{SpringerBriefs}} in {{Education}}},
  publisher = {Springer Singapore},
  address = {Singapore},
  doi = {10.1007/978-981-15-2683-1},
  urldate = {2020-07-05},
  isbn = {9789811526824 9789811526831},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/AFIFAE2N/Willison - 2020 - The Models of Engaged Learning and Teaching Conne.pdf}
}

@incollection{winklerEquationalTheoremProving1989,
  title = {Equational {{Theorem Proving}} and {{Rewrite Rule Systems}}},
  booktitle = {Informatik-{{Fachberichte}}},
  author = {Winkler, Franz},
  year = {1989},
  series = {Informatik-{{Fachberichte}}},
  pages = {26--39},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-74688-8_3}
}

@book{winskelDiscreteMathematicsII2012,
  title = {Discrete {{Mathematics II}}: {{Set Theory}} for {{Computer Science}}},
  author = {Winskel, G.},
  year = {2012},
  annotation = {Published: Available at {\textbackslash}tt https://www.cl.cam.ac.uk/ gw104/DiscMath2012.pdf}
}

@book{winskelSetTheoryComputer2010,
  title = {Set {{Theory}} for {{Computer Science}}},
  author = {Winskel, G.},
  year = {2010},
  annotation = {Published: Available at {\textbackslash}tt https://www.cl.cam.ac.uk/ gw104/STfCS2010.pdf}
}

@article{wissmannSupportedSetsNew2022,
  title = {Supported {{Sets}} -- {{A New Foundation For Nominal Sets And Automata}}},
  author = {Wi{\ss}mann, Thorsten},
  year = {2022},
  pages = {22},
  abstract = {This proposes and discusses the category of supported sets which provides a uniform foundation for nominal sets of various kinds, such as those for equality symmetry, for the order symmetry, and renaming sets. We show that all these differently flavoured categories of nominal sets are monadic over supported sets. Thus, supported sets provide a canonical finite way to represent nominal sets and the automata therein, e.g. register automata. Name binding in supported sets is modelled by a functor following the idea of de Bruijn indices. This functor lifts to the well-known abstraction functor in nominal sets. Together with the monadicity result, this gives rise to a determinization process that takes the finite representation of a register automaton in supported sets and transforms it into its configuration automaton in nominal sets.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/CJGWIAKG/WiÃmann - 2022 - Supported Sets â A New Foundation For Nominal Sets.pdf}
}

@book{witelskiMethodsMathematicalModelling2015,
  title = {Methods of {{Mathematical Modelling}}},
  author = {Witelski, Thomas and Bowen, Mark},
  year = {2015},
  series = {Springer {{Undergraduate Mathematics Series}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-23042-9}
}

@book{wongSchoolLeadershipEducational2019,
  title = {School {{Leadership}} and {{Educational Change}} in {{Singapore}}},
  author = {Wong, Benjamin and Hairon, Salleh and Ng, Pak Tee},
  year = {2019},
  series = {Springer {{Texts}} in {{Education}}},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-74746-0}
}

@article{wuProofsTermsTerms,
  title = {Proofs as {{Terms}}, {{Terms}} as {{Graphs}}},
  author = {Wu, Jui-Hsuan},
  abstract = {Starting from an encoding of untyped {$\lambda$}-terms with sharing, defined using synthetic inference rules based on a focused proof system for Gentzen's LJ, we introduce the positive {$\lambda$}-calculus, a call-by-value calculus with explicit substitutions. This calculus is closely related to Accattoli and Paolini's value substitution calculus but has a different style of reduction rules that provides a good notion of sharing along the reduction. We also propose a graphical representation in order to capture the structural equivalence on terms that can be described using rule permutations. On one hand, this graphical representation provides a way to remove redundancy in the syntax, and on the other hand, it allows implementing basic operations such as substitution and reduction in a straightforward way.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/ABD8LHN9/Wu - Proofs as Terms, Terms as Graphs.pdf}
}

@article{xiaInteractionTreesRepresenting2019,
  title = {Interaction Trees: Representing Recursive and Impure Programs in {{Coq}}},
  shorttitle = {Interaction Trees},
  author = {Xia, Li-yao and Zakowski, Yannick and He, Paul and Hur, Chung-Kil and Malecha, Gregory and Pierce, Benjamin C. and Zdancewic, Steve},
  year = {2019},
  month = dec,
  journal = {Library presented in the paper: Interaction Trees},
  volume = {4},
  number = {POPL},
  pages = {51:1--51:32},
  doi = {10.1145/3371119},
  urldate = {2024-09-19},
  abstract = {Interaction trees (ITrees) are a general-purpose data structure for representing the behaviors of recursive programs that interact with their environments. A coinductive variant of ``free monads,'' ITrees are built out of uninterpreted events and their continuations. They support compositional construction of interpreters from event handlers, which give meaning to events by defining their semantics as monadic actions. ITrees are expressive enough to represent impure and potentially nonterminating, mutually recursive computations, while admitting a rich equational theory of equivalence up to weak bisimulation. In contrast to other approaches such as relationally specified operational semantics, ITrees are executable via code extraction, making them suitable for debugging, testing, and implementing software artifacts that are amenable to formal verification. We have implemented ITrees and their associated theory as a Coq library, mechanizing classic domain- and category-theoretic results about program semantics, iteration, monadic structures, and equational reasoning. Although the internals of the library rely heavily on coinductive proofs, the interface hides these details so that clients can use and reason about ITrees without explicit use of Coq's coinduction tactics. To showcase the utility of our theory, we prove the termination-sensitive correctness of a compiler from a simple imperative source language to an assembly-like target whose meanings are given in an ITree-based denotational semantics. Unlike previous results using operational techniques, our bisimulation proof follows straightforwardly by structural induction and elementary rewriting via an equational theory of combinators for control-flow graphs.},
  file = {/home/flaviomoura/Zotero/storage/XQ2UACJ9/Xia et al. - 2019 - Interaction trees representing recursive and impu.pdf}
}

@misc{xiuFormalVerificationParameterized2025,
  title = {Formal {{Verification}} of {{Parameterized Systems}} Based on {{Induction}}},
  author = {Xiu, Jiaqi and Li, Yongjian},
  year = {2025},
  month = mar,
  number = {arXiv:2503.18030},
  eprint = {2503.18030},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2503.18030},
  urldate = {2025-03-25},
  abstract = {Parameterized systems play a crucial role in the computer field, and their security is of great significance. Formal verification of parameterized protocols is especially challenging due to its "parameterized" feature, which brings complexity and undecidability. Existing automated parameterized verification methods have limitations, such as facing difficulties in automatically deriving parameterized invariants constrained by mixed Forall and Exists quantifiers, or having challenges in completing the parameterized verification of large and complex protocols. This paper proposes a formal verification framework for parameterized systems based on induction, named wiseParaverifier. It starts from small concretizations of protocols, analyzes inductive counterexamples, and constructs counterexample formulas to guide the entire process of parameterized verification. It also presents a heuristic Generalize method to quickly find auxiliary invariants, a method for promoting complex mixed quantifiers and merging parameterized invariants, and uses symmetric reduction ideas to accelerate the verification process. Experimental results show that wiseParaverifier can successfully complete automatic inductive verification on 7 cache coherence protocols and 10 distributed protocols. It has strong verification capabilities and migration capabilities, and can provide concise and readable verification results, which is helpful for learners to understand protocol behaviors.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Symbolic Computation},
  file = {/home/flaviomoura/Zotero/storage/FYVT5M7C/Xiu and Li - 2025 - Formal Verification of Parameterized Systems based on Induction.pdf;/home/flaviomoura/Zotero/storage/X4NE4APC/2503.html}
}

@misc{xuAutomatingEquationalProofs2024,
  title = {Automating {{Equational Proofs}} in {{Dirac Notation}}},
  author = {Xu, Yingte and Barthe, Gilles and Zhou, Li},
  year = {2024},
  month = nov,
  number = {arXiv:2411.11617},
  eprint = {2411.11617},
  publisher = {arXiv},
  doi = {10.48550/arXiv.2411.11617},
  urldate = {2024-11-25},
  abstract = {Dirac notation is widely used in quantum physics and quantum programming languages to define, compute and reason about quantum states. This paper considers Dirac notation from the perspective of automated reasoning. We prove two main results: first, the first-order theory of Dirac notation is decidable, by a reduction to the theory of real closed fields and Tarski's theorem. Then, we prove that validity of equations can be decided efficiently, using term-rewriting techniques. We implement our equivalence checking algorithm in Mathematica, and showcase its efficiency across more than 100 examples from the literature.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/home/flaviomoura/Zotero/storage/XLNVIKK7/Xu et al. - 2024 - Automating Equational Proofs in Dirac Notation.pdf;/home/flaviomoura/Zotero/storage/XSMLWAWW/2411.html}
}

@article{xueDependentlyTypedCalculus2021,
  title = {A Dependently Typed Calculus with Polymorphic Subtyping},
  author = {Xue, Mingqi and Oliveira, Bruno C.d.S.},
  year = {2021},
  month = aug,
  journal = {Science of Computer Programming},
  volume = {208},
  pages = {102655},
  issn = {01676423},
  doi = {10.1016/j.scico.2021.102655},
  urldate = {2021-04-19},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/DPC4AXY3/Xue e Oliveira - 2021 - A dependently typed calculus with polymorphic subt.pdf}
}

@article{yamadaCategoriesDependenceSemantics2019,
  title = {Categories with {{Dependence}} and {{Semantics}} of {{Dependent Types}}},
  author = {Yamada, Norihiro},
  year = {2019},
  month = feb,
  journal = {arXiv:1704.04747 [cs, math]},
  eprint = {1704.04747},
  primaryclass = {cs, math},
  urldate = {2020-07-17},
  abstract = {The present paper gives a generalization of cartesian closed categories, called cartesian closed categories with dependence, whose strict version induces categories with families that support 1-, Sigma- and Pi-types in the strict sense. Consequently, we have obtained a new semantics of dependent type theories that is both categorical and true-to-syntax.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory},
  file = {/home/flaviomoura/Zotero/storage/C9G8MI8S/Yamada - 2019 - Categories with Dependence and Semantics of Depend.pdf;/home/flaviomoura/Zotero/storage/XULB2I5R/1704.html}
}

@article{yamadaGameSemanticModelComputation2019,
  title = {A {{Game-Semantic Model}} of {{Computation}}, {{Revisited}}: An {{Automata-Theoretic Perspective}}},
  shorttitle = {A {{Game-Semantic Model}} of {{Computation}}, {{Revisited}}},
  author = {Yamada, Norihiro},
  year = {2019},
  month = dec,
  journal = {arXiv:1806.10435 [cs, math]},
  eprint = {1806.10435},
  primaryclass = {cs, math},
  urldate = {2020-07-17},
  abstract = {In the previous work, we have given a novel, game-semantic model of computation in an intrinsic, non-inductive and non-axiomatic manner, which is similar to Turing machines but beyond computation on natural numbers, e.g., higher-order computation. As the main theorem of the work, it has been shown that the game-semantic model may execute all the computation of the programming language PCF. The present paper revisits this result from an automata-theoretic perspective: It shows that deterministic non-erasing pushdown automata whose input tape is equipped with simple directed edges between cells can implement all the game-semantic PCF-computation, where the edges rather restrict the cells of the tape which the automata may read off. This is a mathematically highly-surprising phenomenon because it is well-known that the more powerful non-deterministic erasing pushdown automata are strictly weaker than Turing machines (in the Chomsky hierarchy), let alone than PCF.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/WDLXBFHU/Yamada - 2019 - A Game-Semantic Model of Computation, Revisited a.pdf;/home/flaviomoura/Zotero/storage/JPPH7ZER/1806.html}
}

@article{yamadaGameSemanticsMartinL2016,
  title = {Game {{Semantics}} for {{Martin-L}}\${\textbackslash}backslash\$''of {{Type Theory}}},
  author = {Yamada, N.},
  year = {2016},
  month = oct,
  journal = {ArXiv e-prints},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic}
}

@article{yamadaGameSemanticsMartinL2019,
  title = {Game {{Semantics}} of {{Martin-L}}{\textbackslash}"of {{Type Theory}}},
  author = {Yamada, Norihiro},
  year = {2019},
  month = oct,
  journal = {arXiv:1905.00993 [cs, math]},
  eprint = {1905.00993},
  primaryclass = {cs, math},
  urldate = {2020-07-17},
  abstract = {We present game semantics of Martin-L{\textbackslash}"of type theory (MLTT), which solves a long-standing problem open for more than twenty years. More specifically, we introduce a category with families (CwF) of a novel variant of games, which induces an interpretation of MLTT equipped with one-, zero-, N-, pi- and sigma-types as well as Id-types or a cumulative hierarchy of universes (n.b., the last two types are incompatible with each other in our semantics), and the interpretation is faithful for the (one, pi, sigma)-fragment. Notably, it generalizes conventional game semantics of simple type theories in a natural, canonical way in the sense that the category of conventional games and strategies forms a reflective subcategory of the CwF, and the latter inherits the game-semantic and the domain-theoretic structures of the former. Also, our semantics can be regarded as a mathematical formalization of the standard BHK-interpretation (or the meaning explanation) of MLTT, giving a mathematical, semantic, intensional foundation of constructive mathematics, comparable to the set-theoretic one for classical mathematics. By its conceptual naturality and mathematical precision, the semantics provides useful insights on the syntax as well.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/3G2FKQ6T/Yamada - 2019 - Game Semantics of Martin-Lof Type Theory.pdf;/home/flaviomoura/Zotero/storage/FBYSB9T3/1905.html}
}

@article{yamadaGameSemanticsMartinL2020,
  title = {Game Semantics of {{Martin-L}}{\textbackslash}"of Type Theory, Part {{III}}: Its Consistency with {{Church}}'s Thesis},
  shorttitle = {Game Semantics of {{Martin-L}}{\textbackslash}"of Type Theory, Part {{III}}},
  author = {Yamada, Norihiro},
  year = {2020},
  month = jul,
  journal = {arXiv:2007.08094 [cs, math]},
  eprint = {2007.08094},
  primaryclass = {cs, math},
  urldate = {2020-07-17},
  abstract = {We prove consistency of intensional Martin-L{\textbackslash}"of type theory (MLTT) with formal Church's thesis (CT), which was open for at least fifteen years. The difficulty in proving the consistency is that a standard method of realizability a la Kleene does not work for the consistency, though it validates CT, as it does not model MLTT; specifically, the realizability does not validate MLTT's congruence rule on pi-types (known as the \${\textbackslash}xi\$-rule). We overcome this point and prove the consistency by novel realizability a la game semantics, which is based on the author's previous work.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/AWZ7V9LW/Yamada - 2020 - Game semantics of Martin-Lof type theory, part I.pdf;/home/flaviomoura/Zotero/storage/BK379HZC/2007.html}
}

@article{yamadaGameSemanticsMartinL2021,
  title = {Game {{Semantics}} of {{Martin-L}}{\textbackslash}"of {{Type Theory}}},
  author = {Yamada, Norihiro},
  year = {2021},
  month = jun,
  journal = {arXiv:1905.00993 [cs, math]},
  eprint = {1905.00993},
  primaryclass = {cs, math},
  urldate = {2021-06-08},
  abstract = {We present new game semantics of Martin-L{\textbackslash}"of type theory (MLTT) equipped with One-, Zero-, N-, Pi-, Sigma- and Id-types. Our game semantics interprets MLTT more accurately than existing ones. Another advantage of our game semantics over existing ones is its interpretation of Sigma-types that is direct and compatible with the game semantics of product types . Besides, its mathematical structure is novel and useful; e.g., the category of our games has all finite limits, which is a key step to an extension of the present work to homotopy type theory, and our games interpret subtyping on dependent types for the first time as game semantics. Finally, we provide a new, game-semantic proof of the independence of Markov's principle from MLTT, which demonstrates an advantage of our game semantics over extensional models of MLTT such as the effective topos.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/B67IDX7U/1905.html}
}

@article{yamadaGameSemanticsMartinLof2019,
  title = {Game {{Semantics}} of {{Martin-L{\"o}f Type Theory}}},
  author = {Yamada, Norihiro},
  year = {2019},
  journal = {CoRR},
  abstract = {We present game semantics of Martin-L{\"o}f type theory (MLTT), which solves a long-standing problem open for more than twenty years. More specifically, we introduce a category with families of a novel variant of games, which induces an interpretation of MLTT equipped with one-, zero-, N-, pi- and sigma-types as well as Id-types or a cumulative hierarchy of universes (n.b., the last two types are incompatible with each other in our semantics), and the interpretation is faithful for the (one, pi, sigma)-fragment. Notably, it generalizes standard game semantics of simple type theories in a natural, canonical way in the sense that the CwF forms a reflective subcategory of the category of conventional games and strategies, and the former inherits the game-semantic and the domain-theoretic structures of the latter. Also, our semantics can be regarded naturally as a mathematical formalization of the standard BHK-interpretation (or the meaning explanation) of MLTT, giving a mathematical, semantic, intensional foundation of constructive mathematics, comparable to the set-theoretic one for classical mathematics. By its conceptual naturality and mathematical precision, the semantics provides useful insights on the syntax as well.}
}

@article{yamadaGametheoreticInterpretationType2016,
  title = {Game-Theoretic {{Interpretation}} of {{Type Theory Part II}}: {{Uniqueness}} of {{Identity Proofs}} and {{Univalence}}},
  shorttitle = {Game-Theoretic {{Interpretation}} of {{Type Theory Part II}}},
  author = {Yamada, Norihiro},
  year = {2016},
  month = apr,
  journal = {arXiv:1602.04123 [cs, math]},
  eprint = {1602.04123},
  primaryclass = {cs, math},
  urldate = {2020-07-17},
  abstract = {In the present paper, based on the previous work (Part I), we present a game semantics for the intensional variant of intuitionistic type theory that refutes the principle of uniqueness of identity proofs and validates the univalence axiom, though we do not interpret non-trivial higher propositional equalities. Specifically, following the historic groupoid interpretation by Hofmann and Streicher, we equip predicative games in Part I with a groupoid structure, which gives rise to the notion of (predicative) gamoids. Roughly, gamoids are "games with (computational) equalities specified", which interpret subtleties in Id-types. We then formulate a category with families of predicative gamoids, equipped with dependent product, dependent sum, and Id-types as well as universes, which forms a concrete instance of the groupoid model. We believe that this work is an important stepping-stone towards a complete interpretation of homotopy type theory.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory,Mathematics - Combinatorics,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/TDP658JT/Yamada - 2016 - Game-theoretic Interpretation of Type Theory Part .pdf;/home/flaviomoura/Zotero/storage/LMYYIYDC/1602.html}
}

@article{yamadaMultiDimensionalInterpretationsTermination,
  title = {Multi-{{Dimensional Interpretations}} for {{Termination}} of {{Term Rewriting}}},
  author = {Yamada, Akihisa},
  pages = {18},
  abstract = {Interpretation methods constitute a foundation of termination analysis for term rewriting. From time to time remarkable instances of interpretation methods appeared, such as polynomial interpretations, matrix interpretations, arctic interpretations, and their variants. In this paper we introduce a general framework, the multi-dimensional interpretation method, that subsumes these variants as well as many previously unknown interpretation methods as instances. Employing the notion of derivers, we prove the soundness of the proposed method in an elegant way. We implement the proposed method in the termination prover NaTT and verify its significance through experiments.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/XCVM5FJG/Yamada - Multi-Dimensional Interpretations for Termination .pdf}
}

@article{yamadaSequentCalculiPolarities2020,
  title = {Sequent {{Calculi}} without {{Polarities}} for the {{Unity}} of {{Logic}}},
  author = {Yamada, Norihiro},
  year = {2020},
  month = feb,
  journal = {arXiv:2001.06138 [math]},
  eprint = {2001.06138},
  primaryclass = {math},
  urldate = {2020-07-17},
  abstract = {The present work aims to establish the unity of logic in the same sense as Girard's well-known work yet without having recourse to polarities. Our motivations are to reduce various logics into a single one, clarify the dichotomy between linearity and non-linearity (resp. intuitionisity and classicality) in logic, and further prove that actually we do not need polarities for the unity of logic. Our starting conjecture is that there would be mathematically precise operations of unlinearization and classicalization on logic such that the unlinearization of classical linear logic (CLL) (resp. intuitionistic linear logic (ILL\vphantom\{\}) coincides with classical logic (CL) (resp. intuitionistic logic (IL)), and the classicalization of IL (resp. ILL) with CL (resp. CLL), where the two operations are compatible in the sense of the evident commutativity. Nevertheless, CLL, in contradiction to the name, is actually not the classicalization of ILL, and CL is not the unlinearization of CLL, both of which are obvious from a game-semantic analysis. The main contribution of the present work is then to prove the conjecture in terms of sequent calculi except that CLL is replaced with its negative fragment, which let us call classical linear logic negative (CLLN).},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/BFVNJP6H/Yamada - 2020 - Sequent Calculi without Polarities for the Unity o.pdf;/home/flaviomoura/Zotero/storage/L6I9WRNK/2001.html}
}

@book{yandellHonorsClassHilbert2002,
  title = {The Honors Class: {{Hilbert}}'s Problems and Their Solvers},
  author = {Yandell, Ben},
  year = {2002},
  edition = {1},
  publisher = {A.K. Peters},
  isbn = {1-56881-216-7 978-1-56881-216-8 1-56881-141-1}
}

@article{yokouchiChurchRosserTheoremRewriting1989,
  title = {Church-{{Rosser Theorem}} for a {{Rewriting System}} on {{Categorical Combinators}}},
  author = {Yokouchi, H.},
  year = {1989},
  journal = {Theoretical Computer Science},
  volume = {65},
  number = {3},
  pages = {271--290}
}

@article{yokoyama2004deterministic,
  title = {Deterministic Second-Order Patterns in Program Transformation},
  author = {Yokoyama, Tetsuo and Hu, Zhenjiang and Takeichi, Masato},
  year = {2004},
  journal = {Computer Software},
  volume = {21},
  number = {5},
  pages = {71--76}
}

@article{yokoyamaDeterministicSecondorderPatterns2004,
  title = {Deterministic Second-Order Patterns},
  author = {Yokoyama, Tetsuo and Hu, Zhenjiang and Takeichi, Masato},
  year = {2004},
  month = mar,
  journal = {Information Processing Letters},
  volume = {89},
  number = {6},
  pages = {309--314},
  issn = {00200190},
  doi = {10.1016/j.ipl.2003.12.008},
  urldate = {2021-02-20},
  langid = {english}
}

@article{zachCUTELIMINATIONNORMALIZATION2021,
  title = {{{CUT ELIMINATION AND NORMALIZATION FOR GENERALIZED SINGLE AND MULTI-CONCLUSION SEQUENT AND NATURAL DEDUCTION CALCULI}}},
  author = {Zach, Richard},
  year = {2021},
  month = sep,
  journal = {The Review of Symbolic Logic},
  volume = {14},
  number = {3},
  pages = {645--686},
  issn = {1755-0203, 1755-0211},
  doi = {10.1017/S1755020320000015},
  urldate = {2024-03-23},
  abstract = {Abstract             Any set of truth-functional connectives has sequent calculus rules that can be generated systematically from the truth tables of the connectives. Such a sequent calculus gives rise to a multi-conclusion natural deduction system and to a version of Parigot's free deduction. The elimination rules are ``general,'' but can be systematically simplified. Cut-elimination and normalization hold. Restriction to a single formula in the succedent yields intuitionistic versions of these systems. The rules also yield generalized lambda calculi providing proof terms for natural deduction proofs as in the Curry--Howard isomorphism. Addition of an indirect proof rule yields classical single-conclusion versions of these systems. Gentzen's standard systems arise as special cases.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/W4X4MV98/Zach - 2021 - CUT ELIMINATION AND NORMALIZATION FOR GENERALIZED .pdf}
}

@misc{zachLogicMathematicsComputer2024,
  title = {Logic in {{Mathematics}} and {{Computer Science}}},
  author = {Zach, Richard},
  year = {2024},
  month = apr,
  number = {arXiv:2404.09033},
  eprint = {2404.09033},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2024-04-16},
  abstract = {Logic has pride of place in mathematics and its 20th century offshoot, computer science. Modern symbolic logic was developed, in part, as a way to provide a formal framework for mathematics: Frege, Peano, Whitehead and Russell, as well as Hilbert developed systems of logic to formalize mathematics. These systems were meant to serve either as themselves foundational, or at least as formal analogs of mathematical reasoning amenable to mathematical study, e.g., in Hilbert's consistency program. Similar efforts continue, but have been expanded by the development of sophisticated methods to study the properties of such systems using proof and model theory. In parallel with this evolution of logical formalisms as tools for articulating mathematical theories (broadly speaking), much progress has been made in the quest for a mechanization of logical inference and the investigation of its theoretical limits, culminating recently in the development of new foundational frameworks for mathematics with sophisticated computer-assisted proof systems. In addition, logical formalisms developed by logicians in mathematical and philosophical contexts have proved immensely useful in describing theories and systems of interest to computer scientists, and to some degree, vice versa. Three examples of the influence of logic in computer science are automated reasoning, computer verification, and type systems for programming languages.},
  archiveprefix = {arXiv},
  keywords = {03-01,F.4.1,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/2EY7B4TU/Zach - 2024 - Logic in Mathematics and Computer Science.pdf;/home/flaviomoura/Zotero/storage/DBYKSFTX/2404.html}
}

@article{zamdzhievComputationalAdequacySubstructural2021,
  title = {Computational {{Adequacy}} for {{Substructural Lambda Calculi}}},
  author = {Zamdzhiev, Vladimir},
  year = {2021},
  month = jan,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {333},
  eprint = {2005.05433},
  pages = {322--334},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.333.22},
  urldate = {2021-01-27},
  abstract = {Substructural type systems, such as affine (and linear) type systems, are type systems which impose restrictions on copying (and discarding) of variables, and they have found many applications in computer science, including quantum programming. We describe one linear and one affine type systems and we formulate abstract categorical models for both of them which are sound and computationally adequate. We also show, under basic assumptions, that interpreting lambda abstractions via a monoidal closed structure (a popular method for linear type systems) necessarily leads to degenerate and inadequate models for call-by-value affine type systems with recursion. In our categorical treatment, a solution to this problem is clearly presented. Our categorical models are more general than linear/non-linear models used to study linear logic and we present a homogeneous categorical account of both linear and affine type systems in a call-by-value setting. We also give examples with many concrete models, including classical and quantum ones.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/LNEZWAAC/Zamdzhiev - 2021 - Computational Adequacy for Substructural Lambda Ca.pdf;/home/flaviomoura/Zotero/storage/FZCAIB2G/2005.html}
}

@article{zantemaCorrectionPaintPot2023,
  title = {Correction: {{The}} Paint Pot Problem and Common Multiples in Monoids},
  shorttitle = {Correction},
  author = {Zantema, Hans and {van Oostrom}, Vincent},
  year = {2023},
  month = jun,
  journal = {Applicable Algebra in Engineering, Communication and Computing},
  issn = {1432-0622},
  doi = {10.1007/s00200-023-00613-7},
  urldate = {2024-07-21},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/G9K2B66M/Zantema and van Oostrom - 2023 - Correction The paint pot problem and common multi.pdf}
}

@article{zantemaPaintPotProblem2023,
  title = {The Paint Pot Problem and Common Multiples in Monoids},
  author = {Zantema, Hans and {van Oostrom}, Vincent},
  year = {2023},
  month = may,
  journal = {Applicable Algebra in Engineering, Communication and Computing},
  issn = {1432-0622},
  doi = {10.1007/s00200-023-00606-6},
  urldate = {2024-07-21},
  abstract = {Illustrated by a problem on paint pots that is easy to understand but hard to solve, we investigate whether particular monoids have the property of common right multiples. As one result we characterize generalized braid monoids represented by undirected graphs, being a subclass of Artin--Tits monoids. Stated in other words, we investigate to which graphs the old Garside result stating that braid monoids have the property of common right multiples, generalizes. This characterization also follows from old results on Coxeter groups and the connection between finiteness of Coxeter groups and common right multiples in Artin--Tits monoids. However, our independent presentation is self-contained up to some basic knowledge of rewriting, and also applies to monoids beyond the Artin--Tits format. The main new contribution is a technique to prove that the property of common right multiples does not hold, by finding a particular model, in our examples all being finite.},
  langid = {english},
  keywords = {Artin-Tits monoids,Common multiples,Deneralized braids,Rewriting,Tiling},
  file = {/home/flaviomoura/Zotero/storage/N3T3RPPH/Zantema and van Oostrom - 2023 - The paint pot problem and common multiples in mono.pdf}
}

@misc{zeunerFunctorPointsApproach2024,
  title = {The {{Functor}} of {{Points Approach}} to {{Schemes}} in {{Cubical Agda}}},
  author = {Zeuner, Max and Hutzler, Matthias},
  year = {2024},
  month = mar,
  number = {arXiv:2403.13088},
  eprint = {2403.13088},
  primaryclass = {math},
  publisher = {arXiv},
  urldate = {2024-04-18},
  abstract = {We present a formalization of quasi-compact and quasi-separated schemes (qcqs-schemes) in the Cubical Agda proof assistant. We follow Grothendieck's functor of points approach, which defines schemes, the quintessential notion of modern algebraic geometry, as certain well-behaved functors from commutative rings to sets. This approach is often regarded as conceptually simpler than the standard approach of defining schemes as locally ringed spaces, but to our knowledge it has not yet been adopted in formalizations of algebraic geometry. We build upon a previous formalization of the so-called Zariski lattice associated to a commutative ring in order to define the notion of compact open subfunctor. This allows for a concise definition of qcqs-schemes, streamlining the usual presentation as e.g. given in the standard textbook of Demazure and Gabriel. It also lets us obtain a fully constructive proof that compact open subfunctors of affine schemes are qcqs-schemes.},
  archiveprefix = {arXiv},
  keywords = {Mathematics - Algebraic Geometry,Mathematics - Logic},
  file = {/home/flaviomoura/Zotero/storage/CYRSWWNI/Zeuner e Hutzler - 2024 - The Functor of Points Approach to Schemes in Cubic.pdf;/home/flaviomoura/Zotero/storage/TCEVZXPZ/2403.html}
}

@article{zhangEquivalenceCountableComputable,
  title = {Equivalence of {{Countable}} and {{Computable}}},
  author = {Zhang, Hantao},
  abstract = {The concept of ``countable set'' is attributed to Georg Cantor, who set the boundary between countable and uncountable sets in 1874. The concept of ``computable set'' arose in the study of computing models in the 1930s by the founders of computer science, including G{\textasciidieresis}odel, Church, and Turing. However, the connection between countability and computability was not thoroughly studied in the past eight decades. A counting bijection of a set S is a bijection from the set of natural numbers to S. We say S is enumerable if either S is finite or S has a computable counting bijection. S is countable if S is enumerable. We prove that S is enumerable if and only if S is computable. This equivalence provides insights to the study of set theory and computability theory and reveals that countability is related to space and time complexity. We show that the set of total computable functions (or deciders, algorithms) is unenumerable. We also provide a sufficient and necessary condition for a set to be enumerable and use the concept of counting order to explain why some sets are unenumerable. We show that some popular statements about countable sets, such as ``every subset of a countable set is countable'' or ``every formal language is countable,'' lack a valid proof. These unproven statements are widely taught in college courses on discrete mathematics, set theory, and computability theory.},
  langid = {english},
  file = {/home/flaviomoura/Zotero/storage/G4NCP696/Zhang - Equivalence of Countable and Computable.pdf}
}

@article{zhangSortingPermutationBest2021,
  title = {Sorting a {{Permutation}} by {{Best Short Swaps}}},
  author = {Zhang, Shu and Zhu, Daming and Jiang, Haitao and Guo, Jiong and Feng, Haodi and Liu, Xiaowen},
  year = {2021},
  month = mar,
  journal = {Algorithmica},
  issn = {0178-4617, 1432-0541},
  doi = {10.1007/s00453-021-00814-x},
  urldate = {2021-03-06},
  langid = {english}
}

@article{zhangTypeTheoriesCategory2021,
  title = {Type Theories in Category Theory},
  author = {Zhang, Tesla},
  year = {2021},
  month = jul,
  journal = {arXiv:2107.13242 [cs]},
  eprint = {2107.13242},
  primaryclass = {cs},
  urldate = {2021-07-29},
  abstract = {We introduce basic notions in category theory to type theorists, including comprehension categories, categories with attributes, contextual categories, type categories, and categories with families along with additional discussions that are not very closely related to type theories by listing definitions, lemmata, and remarks. By doing so, this introduction becomes more friendly as a referential material to be read in random order (instead of from the beginning to the end). In the end, we list some mistakes made in the early versions of this introduction. The interpretation of common type formers in dependent type theories are discussed based on existing categorical constructions instead of mechanically derived from their type theoretical definition. Non-dependent type formers include unit, products (as fiber products), and functions (as fiber exponents), and dependent ones include extensional equalities (as equalizers), dependent products, and the universe of (all) propositions (as the subobject classifier).},
  archiveprefix = {arXiv},
  keywords = {68Q55 18C50,Computer Science - Logic in Computer Science,Computer Science - Programming Languages,F.4.1,I.2.3},
  file = {/home/flaviomoura/Zotero/storage/IMENBNEU/Zhang - 2021 - Type theories in category theory.pdf;/home/flaviomoura/Zotero/storage/BSJRA9ZA/2107.html}
}

@article{zhanVerifyingAsymptoticTime2018,
  title = {Verifying {{Asymptotic Time Complexity}} of {{Imperative Programs}} in {{Isabelle}}},
  author = {Zhan, Bohua and Haslbeck, Maximilian P. L.},
  year = {2018},
  month = feb,
  journal = {arXiv:1802.01336 [cs]},
  eprint = {1802.01336},
  primaryclass = {cs},
  urldate = {2020-12-01},
  abstract = {We present a framework in Isabelle for verifying asymptotic time complexity of imperative programs. We build upon an extension of Imperative HOL and its separation logic to include running time. In addition to the basic arguments, our framework is able to handle advanced techniques for time complexity analysis, such as the use of the Akra-Bazzi theorem and amortized analysis. Various automation is built and incorporated into the auto2 prover to reason about separation logic with time credits, and to derive asymptotic behavior of functions. As case studies, we verify the asymptotic time complexity (in addition to functional correctness) of imperative algorithms and data structures such as median of medians selection, Karatsuba's algorithm, and splay trees.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Logic in Computer Science},
  file = {/home/flaviomoura/Zotero/storage/FLKZL8JD/Zhan e Haslbeck - 2018 - Verifying Asymptotic Time Complexity of Imperative.pdf;/home/flaviomoura/Zotero/storage/SWU7KP8W/1802.html}
}

@article{zhuProgramTransformationConstructive1995,
  title = {Program {{Transformation}} in {{Constructive Type Theory}}},
  author = {Zhu, M.-Y.},
  year = {1995},
  journal = {ACM SIGPLAN Notices},
  volume = {30},
  number = {1},
  pages = {11--19},
  doi = {10.1145/199818.199833}
}

@phdthesis{zinnclausUnderstandingInformalMathematical2004,
  title = {Understanding Informal Mathematical Discourse},
  author = {Zinn, Claus},
  year = {2004},
  address = {Institut fur Informatik},
  school = {Universitat Erlangen-Nurnberg}
}

@book{ziviani2004projeto,
  title = {Projeto de Algoritmos: Com Implementa{\c c}{\~o}es Em {{Pascal}} e {{C}}},
  author = {Ziviani, Nivio and others},
  year = {2004},
  volume = {2},
  publisher = {Thomson Luton}
}
