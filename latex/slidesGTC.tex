\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{pgfplots}
\usepgfplotslibrary{dateplot}

\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage[color]{coqdoc}
\usepackage[all]{xy}
\usepackage{pdfsync}

\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}
\newcommand{\term}{{\mathcal{T}}}
\newcommand{\fv}[1]{{\tt fv}(#1)}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\db}[1]{{\bf \underline{#1}}}

\title{A FORMALISATION THAT THE Z PROPERTY IMPLIES CONFLUENCE}
\date{\today}
\author{Flávio L. C. de Moura and Leandro Oliveira Rezende}
\institute{Seminário do GTC/UnB}
\titlegraphic{\hfill\includegraphics[height=1.5cm]{unb-logo.png}}

\begin{document}

\maketitle

\begin{frame}[fragile]{Motivation: Explicit Substitutions}
  \begin{itemize}
  \item Starting point: $\lambda$-calculus
    $$\term ::= x \mid \lambda x.\term \mid \term\term $$
    $$(\lambda x.t)\ u \to_\beta t\{x/u\}$$
    \pause
    \item Extending the $\lambda$-calculus with an explicit substitution operator: {\color{red} calculi with explicit substitutions} 
    $$\term ::= x \mid \lambda x.\term \mid \term\term\; {\color{red} \mid \term[x/\term]}$$ \pause
    $$\begin{array}{lll}
        (\lambda x.t)\ u &  \to &  {\color{red} t[x/u]} \\ \pause
        {\color{red} x[x/u]} & {\color{red}\to} & {\color{red}u} \\
        {\color{red} y[x/u]} & {\color{red}\to} & {\color{red}y} \\
        {\color{red}(\lambda y.t')[x/u]} &  {\color{red} \to} &  {\color{red} \lambda y. t'[x/u]} \\
        {\color{red} (t'\ t'')[x/u]} & {\color{red}\to} & {\color{red} t'[x/u]\ t''[x/u]} \\
      \end{array}$$
  \end{itemize}
\end{frame}

\begin{frame}{The $\lambda\sigma$-calculus}
  $\begin{array}{llcl}
      \mbox{\bf Terms} &  a,b & ::=  & \db{1} \mid \lambda a \mid a\ b \mid a[s]  \\ 
     \mbox{\bf Substitutions} & s,t & ::= & id \mid \uparrow \mid s.t \mid s \circ t \\[.5cm]
     \mbox{(Beta)} & (\lambda a)\ b & \to &  a[b.id] \\
     \mbox{(VarId)} & \db{1}[id] & \to & \db{1} \\
     \mbox{(VarCons)} & \db{1}[a.s] & \to & a \\
     \mbox{(App)} & (a\ b)[s] & \to &  a[s]\ b[s] \\
     \mbox{(Abs)} & (\lambda a)[s] & \to &  \lambda(a[\db{1}.(s \circ \uparrow)]) \\
     \mbox{(Clos)} & a[s][t] & \to &  a[s\circ t] \\     
     \mbox{(IdL)} & id\circ s & \to & s \\
     \mbox{(ShiftId)} & \uparrow \circ id & \to & \uparrow \\
     \mbox{(ShiftCons)} & \uparrow \circ (a.s) & \to & s \\
     \mbox{(Map)} & (a.s) \circ t & \to & a[t].(s \circ t) \\
     \mbox{(Ass)} & (s_1 \circ s_2) \circ s_3 & \to & s_1 \circ (s_2 \circ s_3)
    \end{array}$
  \end{frame}

\begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
  $$\term ::= x \mid \lambda x.\term \mid \term\term \mid \term[x/\term]$$

  $$\begin{array}{llll}
      t[x/u][y/v] & =_C & t[y/v][x/u], & \mbox{ if } y \notin\fv{u} \mbox{ and } x \notin \fv{v} \\[.3cm]
      (\lambda x. t)\ u & \to_{\tt B} & t[x/u] & \\      
      x[x/u] & \to_{\tt Var} & u & \\      
      t[x/u] & \to_{\tt Gc} & t, & \mbox{ if } x \notin\fv{t} \\      
      (t\ v)[x/u] & \to_{\tt App} & t[x/u]\ v[x/u] & \\
      (\lambda y. t)[x/u] & \to_{\tt Lamb} & \lambda y.t[x/u] & \\
      t[x/u][y/v] & \to_{\tt Comp} & t[y/v][x/u[y/v]], & \mbox{ if } y \in\fv{u} \\            
      \end{array}$$
\end{frame}

\begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
  \begin{itemize}
  \item {\bf Goal}: Formal proof of confluence (with code extraction).
    \begin{itemize}
    \item Proof assistant: Coq.
    \item Framework: Locally nameless representation (Arthur Charguéraud).
      \begin{itemize}
      \item[{\color{blue}+}] No need for $\alpha$-conversion (bound variables are De Bruijn indexes).
      \item[{\color{blue}+}] No need referential contexts (named free variables).
      \item[{\color{red}--}] The whole library is non-constructive.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
    $$\term ::= x \mid \term\term \mid \lambda x.\term \mid \term[x/\term]$$

  \begin{coqdoccode}
    \coqdocnoindent \coqdockw{Inductive} \coqdocvar{pterm} :
    \coqdockw{Set} :=\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_bvar} : \coqdocvar{nat} \ensuremath{\rightarrow}
    \coqdocvar{pterm}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_fvar} : \coqdocvar{var} \ensuremath{\rightarrow}
    \coqdocvar{pterm}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_app} : \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{pterm\_abs} :
    \coqdocvar{pterm} \ensuremath{\rightarrow}
    \coqdocvar{pterm}\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{pterm\_sub} : \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}
    \ensuremath{\rightarrow} \coqdocvar{pterm}.\coqdoceol
  \end{coqdoccode}

  \begin{coqdoccode}
    \coqdocemptyline \coqdocnoindent \coqdockw{Inductive}
    \coqdocvar{term} : \coqdocvar{pterm} \ensuremath{\rightarrow}
    \coqdockw{Prop} :=\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{term\_var} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{x}, \coqdocvar{term} (\coqdocvar{pterm\_fvar}
    \coqdocvar{x})\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{term\_app} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{t1} \coqdocvar{t2},\coqdocvar{term} \coqdocvar{t1}
    \ensuremath{\rightarrow} \coqdocvar{term} \coqdocvar{t2}
    \ensuremath{\rightarrow} \coqdoceol \coqdocindent{9.00em}
    \coqdocvar{term} (\coqdocvar{pterm\_app} \coqdocvar{t1}
    \coqdocvar{t2})\coqdoceol \coqdocindent{1.00em} \ensuremath{|}
    \coqdocvar{term\_abs} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{L} \coqdocvar{t1},(\coqdockw{\ensuremath{\forall}}
    \coqdocvar{x}, \coqdocvar{x} $\backslash$\coqdocvar{notin}
    \coqdocvar{L} \ensuremath{\rightarrow} \coqdocvar{term}
    (\coqdocvar{t1} \^{} \coqdocvar{x}))
    \ensuremath{\rightarrow}\coqdoceol \coqdocindent{18.00em}
    \coqdocvar{term} (\coqdocvar{pterm\_abs} \coqdocvar{t1})\coqdoceol
    \coqdocindent{1.00em} \ensuremath{|} \coqdocvar{term\_sub} :
    \coqdockw{\ensuremath{\forall}} \coqdocvar{L} \coqdocvar{t1}
    \coqdocvar{t2}, (\coqdockw{\ensuremath{\forall}} \coqdocvar{x},
    \coqdocvar{x} $\backslash$\coqdocvar{notin} \coqdocvar{L}
    \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{t1} \^{}
    \coqdocvar{x})) \ensuremath{\rightarrow}\coqdoceol
    \coqdocindent{12.00em} \coqdocvar{term} \coqdocvar{t2}
    \ensuremath{\rightarrow} \coqdocvar{term} (\coqdocvar{pterm\_sub}
    \coqdocvar{t1} \coqdocvar{t2}).\coqdoceol
  \end{coqdoccode}
\end{frame}

\begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
  \begin{center}
    $t[x/u][y/v] =_C t[y/v][x/u], \mbox{ if } y \notin\fv{u} \mbox{ and } x \notin \fv{v}$
    \end{center}
  
  \begin{coqdoccode}
    \coqdockw{Inductive} \coqdocvar{eqc} : \coqdocvar{Rel}
    \coqdocvar{pterm} :=\coqdoceol \coqdocnoindent \ensuremath{|}
    \coqdocvar{eqc\_def}: \coqdockw{\ensuremath{\forall}}
    \coqdocvar{t} \coqdocvar{u} \coqdocvar{v}, \coqdocvar{term}
    \coqdocvar{u} \ensuremath{\rightarrow} \coqdocvar{term}
    \coqdocvar{v} \ensuremath{\rightarrow} \coqdocvar{eqc}
    (\coqdocvar{t}[\coqdocvar{u}][\coqdocvar{v}]) ((\&
    \coqdocvar{t})[\coqdocvar{v}][\coqdocvar{u}]).\coqdoceol\coqdoceol
    \coqdocnoindent \coqdockw{Definition} \coqdocvar{eqc\_ctx}
    (\coqdocvar{t} \coqdocvar{u}: \coqdocvar{pterm}) :=
    \coqdocvar{ES\_contextual\_closure} \coqdocvar{eqc} \coqdocvar{t}
    \coqdocvar{u}.\coqdoceol \coqdoceol
    \coqdockw{Definition} \coqdocvar{eqC} (\coqdocvar{t} :
    \coqdocvar{pterm}) (\coqdocvar{u} : \coqdocvar{pterm}) :=
    \coqdocvar{refltrans} \coqdocvar{eqc\_ctx} \coqdocvar{t}
    \coqdocvar{u}.\coqdoceol \coqdocnoindent \coqdockw{Notation} "t $=_C$
    u" := (\coqdocvar{eqC} \coqdocvar{t} \coqdocvar{u})
    (\coqdoctac{at} \coqdockw{level} 66).\coqdoceol
\end{coqdoccode}
\end{frame}

\begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
  \begin{center}
    $(\lambda x. t)\ u \to_{\tt B}  t[x/u]$     
  \end{center}
  \begin{coqdoccode}
    \coqdockw{Inductive} \coqdocvar{rule\_b} : \coqdocvar{Rel}
    \coqdocvar{pterm} :=\coqdoceol \coqdocindent{1.50em}
    \coqdocvar{reg\_rule\_b} : \coqdockw{\ensuremath{\forall}}
    (\coqdocvar{t} \coqdocvar{u}:\coqdocvar{pterm}), \coqdoceol
    \coqdocindent{2.50em} \coqdocvar{rule\_b}
    (\coqdocvar{pterm\_app}(\coqdocvar{pterm\_abs} \coqdocvar{t})
    \coqdocvar{u}) (\coqdocvar{t}[\coqdocvar{u}]).\coqdoceol
    \coqdoceol \coqdockw{Definition} \coqdocvar{b\_ctx} \coqdocvar{t}
    \coqdocvar{u} := \coqdocvar{ES\_contextual\_closure}
    \coqdocvar{rule\_b} \coqdocvar{t} \coqdocvar{u}.\coqdoceol
    \coqdocnoindent \coqdockw{Notation} "t $\to_{\tt B}$ u" :=
    (\coqdocvar{b\_ctx} \coqdocvar{t} \coqdocvar{u}) (\coqdoctac{at}
    \coqdockw{level} 66).\coqdoceol
  \end{coqdoccode}
\end{frame}

  \begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
  $$\begin{array}{llll}
      x[x/u] & \to_{\tt Var} & u & \\      
      t[x/u] & \to_{\tt Gc} & t, & \mbox{ if } x \notin\fv{t} \\      
      (t\ v)[x/u] & \to_{\tt App} & t[x/u]\ v[x/u] & \\
      (\lambda y. t)[x/u] & \to_{\tt Lamb} & \lambda y.t[x/u] & \\
      t[x/u][y/v] & \to_{\tt Comp} & t[y/v][x/u[y/v]], & \mbox{ if } y \in\fv{u}            
      \end{array}$$
  \begin{coqdoccode}
    \coqdockw{Inductive} \coqdocvar{sys\_x} : \coqdocvar{Rel}
    \coqdocvar{pterm} :=\coqdoceol \coqdocnoindent \ensuremath{|}
    \coqdocvar{reg\_rule\_var} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{t}, \coqdocvar{sys\_x} (\coqdocvar{pterm\_bvar} 0
    [\coqdocvar{t}]) \coqdocvar{t}\coqdoceol \coqdocnoindent
    \ensuremath{|} \coqdocvar{reg\_rule\_gc} :
    \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u},
    \coqdocvar{sys\_x} (\coqdocvar{t}[\coqdocvar{u}])
    \coqdocvar{t}\coqdoceol \coqdocnoindent \ensuremath{|}
    \coqdocvar{reg\_rule\_app} : \coqdockw{\ensuremath{\forall}}
    \coqdocvar{t1} \coqdocvar{t2} \coqdocvar{u}, \coqdoceol
    \coqdocindent{1.00em} \coqdocvar{sys\_x} ((\coqdocvar{pterm\_app}
    \coqdocvar{t1} \coqdocvar{t2})[\coqdocvar{u}])
    (\coqdocvar{pterm\_app} (\coqdocvar{t1}[\coqdocvar{u}])
    (\coqdocvar{t2}[\coqdocvar{u}]))\coqdoceol \coqdocnoindent
    \ensuremath{|} \coqdocvar{reg\_rule\_lamb} :
    \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u},
    \coqdoceol \coqdocindent{1.00em} \coqdocvar{sys\_x}
    ((\coqdocvar{pterm\_abs} \coqdocvar{t})[\coqdocvar{u}])
    (\coqdocvar{pterm\_abs} ((\&
    \coqdocvar{t})[\coqdocvar{u}]))\coqdoceol \coqdocnoindent
    \ensuremath{|} \coqdocvar{reg\_rule\_comp} :
    \coqdockw{\ensuremath{\forall}} \coqdocvar{t} \coqdocvar{u}
    \coqdocvar{v}, \coqdocvar{has\_free\_index} 0 \coqdocvar{u}
    \ensuremath{\rightarrow}\coqdoceol \coqdocindent{1.00em}
    \coqdocvar{sys\_x} (\coqdocvar{t}[\coqdocvar{u}][\coqdocvar{v}])
    (((\& \coqdocvar{t})[\coqdocvar{v}])[ \coqdocvar{u}[ \coqdocvar{v}
    ] ]).\coqdoceol
  \end{coqdoccode}
\end{frame}

    \begin{frame}[fragile]{The $\lambda{\tt ex}$-calculus}
  \begin{coqdoccode}
\coqdockw{Corollary} \coqdocvar{lex\_is\_confluent}: \coqdocvar{Confl} \coqdocvar{lex}.\coqdoceol
\coqdocnoindent
\coqdockw{Proof}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Zprop\_implies\_Confl}.\coqdoceol
\coqdocindent{1.00em}
\coqdoctac{apply} \coqdocvar{Zlex}.\coqdoceol
\coqdocnoindent
\coqdockw{Qed}.\coqdoceol
\end{coqdoccode}
\end{frame}

\begin{frame}[fragile]{Confluence and the Z Property}  
  \begin{definition}[Z Property]
    Let $(A,\to)$ be an abstract rewriting system (ARS). The system
    $(A,\to)$ has the Z property, if there exists a map $f:A \to A$
    such that:
    
    \[
      \xymatrix{
        a \ar[r] &  b \ar@{.>>}[dl]\\
        f(a) \ar@{.>>}[r] & f(b) \\ 
      }
    \]
\end{definition}

  \begin{coqdoccode}
    \coqdocemptyline \coqdocnoindent \coqdockw{Definition}
    \coqdocvar{Zprop} \{\coqdocvar{A}:\coqdockw{Type}\}
    (\coqdocvar{R}: \coqdocvar{Rel} \coqdocvar{A}) :=
    \coqdoctac{\ensuremath{\exists}} \coqdocvar{f}:\coqdocvar{A}
    \ensuremath{\rightarrow} \coqdocvar{A},
    \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b},
    \coqdocvar{R} \coqdocvar{a} \coqdocvar{b} \ensuremath{\rightarrow}
    ((\coqdocvar{refltrans} \coqdocvar{R}) \coqdocvar{b}
    (\coqdocvar{f} \coqdocvar{a}) \ensuremath{\land}
    (\coqdocvar{refltrans} \coqdocvar{R}) (\coqdocvar{f}
    \coqdocvar{a}) (\coqdocvar{f} \coqdocvar{b})).\coqdoceol
  \end{coqdoccode}
\end{frame}

\begin{frame}[fragile]{Confluence and the Z Property}
  
  \begin{definition}[Confluence]
    An ARS $(A,\to)$ is confluent if
    
    \[
      \xymatrix{
        & a \ar@{->>}[dl] \ar@{->>}[dr] & \\
        b \ar@{.>>}[dr] &  & c \ar@{.>>}[dl] \\
        & d & 
      }
    \]
  \end{definition}
  
  \begin{coqdoccode}
    \coqdockw{Definition} \coqdocvar{Confl} \{\coqdocvar{A}:\coqdockw{Type}\} (\coqdocvar{R}: \coqdocvar{Rel} \coqdocvar{A}) := \coqdockw{\ensuremath{\forall}} \coqdocvar{a} \coqdocvar{b} \coqdocvar{c}, (\coqdocvar{refltrans} \coqdocvar{R}) \coqdocvar{a} \coqdocvar{b} \ensuremath{\rightarrow} (\coqdocvar{refltrans} \coqdocvar{R}) \coqdocvar{a} \coqdocvar{c} \ensuremath{\rightarrow} (\coqdoctac{\ensuremath{\exists}} \coqdocvar{d}, (\coqdocvar{refltrans} \coqdocvar{R}) \coqdocvar{b} \coqdocvar{d} \ensuremath{\land} (\coqdocvar{refltrans} \coqdocvar{R}) \coqdocvar{c} \coqdocvar{d}).\coqdoceol
  \end{coqdoccode}
\end{frame}

\begin{frame}[fragile]{Confluence and the Z Property}  
  \[
    \xymatrix{
      a \ar[r] &  b \ar@{.>>}[dl] & \ar@/^2.0pc/@{=>}@[red][rr] & &    & a \ar@{->>}[dl] \ar@{->>}[dr] & \\ 
      f(a) \ar@{.>>}[r] & f(b) & & &   b \ar@{.>>}[dr] &  & c \ar@{.>>}[dl] \\
      & & & &       & d & 
            }
  \]
  
  \begin{coqdoccode}
    \coqdockw{Theorem} \coqdocvar{Zprop\_implies\_Confl} \{\coqdocvar{A}:\coqdockw{Type}\}: \coqdockw{\ensuremath{\forall}} \coqdocvar{R}: \coqdocvar{Rel} \coqdocvar{A}, \coqdocvar{Zprop} \coqdocvar{R} \ensuremath{\rightarrow} \coqdocvar{Confl} \coqdocvar{R}.\coqdoceol
  \end{coqdoccode}
\end{frame}

\begin{frame}[fragile]{Future work}
  \begin{itemize}
  \item Complete the proof that the formalized calculus satisfies the
    Z property.
  \item Merge this formalization with the one that has the other properties (PSN and one-step $\beta$-simulation).
  \item Extract the code of the corresponding calculus with explicit substitutions.
  \end{itemize}
\end{frame}

% \bibliographystyle{plain}
% \bibliography{Zprop.bib}


\end{document}
